// This source is all automatically generated. Editing it may very
// well be an exercise in futility and frustration.
#include "Python.h"
#include "datetime.h"

// imports
#import "ArcGISVersion.dll" raw_interfaces_only, raw_native_types, no_namespace, named_guids, rename("esriProductCode", "esriVersionProductCode"), rename("VersionManager", "ArcGISVersionManager")
#import "esriSystem.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids, exclude("OLE_COLOR", "OLE_HANDLE", "VARTYPE")
#import "esriSystemUI.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriGeometry.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriGraphicsCore.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriGraphicsSymbols.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriDisplay.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriServer.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriOutput.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriGeoDatabase.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriGeoDatabaseDistributed.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriGeoDatabaseExtensions.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriGeoDatabasePS.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriGISClient.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriDataSourcesFile.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriDataSourcesGDB.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriDataSourcesOleDB.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriDataSourcesRaster.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriDataSourcesNetCDF.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriDataSourcesRasterUI.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "esriCarto.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids, exclude("UINT_PTR")


// Globals we need to keep around -- a reference to the UUID class for mapping
// GUIDs to Python-usable UUIDs and the IUnknown type we'll be using across the
// board.
static PyObject* g_pUUID_type = NULL;
static PyObject* g_pUnk_type = NULL;
static PyObject* g_pIIDMap = NULL;
static PyObject* g_pCLSIDMap = NULL;
static PyObject* g_pRecordMap = NULL;

// PyObject destructor for PyCObjects that hold IUnknown* in them
static void
destr_unknown(void* pvUnk)
{
    IUnknown* pUnk = (IUnknown*)pvUnk;
    if (pUnk)
        pUnk->Release();
}

// Checker/caster to see if we can get a GUID from a Python object, either
// by  checking if the object is an instance of the uuid.UUID type, or if
// it is a string, coercing it with the constructor and seeing if it accepts
// it.
//
// def GuidFromPyObject(potentialIID, GUID*):
//     if isinstance(potentialIID, basestring):
//         try:
//             potentialIID = uuid.UUID(potentialIID)
//         except:
//             return False
//     if isinstance(potentialIID, uuid.UUID):
//         if (<copy raw bytes of UUID data in object to out GUID*>):
//             return True
//     return False
//
static bool
GuidFromPyObject(PyObject* potentialIID, GUID* pOutGUID)
{
    if (!g_pUUID_type)
        return false;

    // See if we can cast a string into a UUID instance, if that's what we've got.
    if (PyString_Check(potentialIID) || PyUnicode_Check(potentialIID))
    {
        PyObject* piid_object = PyObject_CallFunction(g_pUUID_type, "O", potentialIID);
        bool retval = (piid_object)?GuidFromPyObject(piid_object, pOutGUID): false;
        Py_XDECREF(piid_object);
        if (!piid_object || PyErr_Occurred())
        {
            PyErr_Clear();
            PyObject* unicodearg = NULL;
            if (PyString_Check(potentialIID))
                unicodearg = PyUnicode_FromObject(potentialIID);
            else if (PyUnicode_Check(potentialIID))
            {
                unicodearg = potentialIID;
                Py_INCREF(unicodearg);
            }
            if (unicodearg)
            {
                BSTR classname = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodearg),
                                                     (UINT)PyUnicode_GET_SIZE(unicodearg));
                CLSID clsid;
                if (CLSIDFromProgID(classname, &clsid) == S_OK)
                {
                    retval = true;
                    if (memcpy_s((void *)pOutGUID, sizeof(GUID), (void *)&clsid, 16))
                        retval = false;
                }
                ::SysFreeString(classname);
            }
            Py_XDECREF(unicodearg);
        }
        return retval;
    }
    else if (PyObject_IsInstance(potentialIID, g_pUUID_type))
    {
        // Fetch raw bytes string -- need to fetch "bytes" on big-endian, 
        // "bytes_le" on little-endian architectures
        const int i = 1;
        PyObject* pBytes = NULL;
        if ( (*(char*)&i) == 0 )        
            pBytes = PyObject_GetAttrString(potentialIID, "bytes");
        else
            pBytes = PyObject_GetAttrString(potentialIID, "bytes_le");
        if (pBytes)
        {
            bool retval = true;
            // Pointer to raw data
            char* pRawBytes = PyString_AsString(pBytes);
            if (memcpy_s((void *)pOutGUID, sizeof(GUID), (void *)pRawBytes, 16))
                retval = false;
            Py_XDECREF(pBytes);
            return retval;
        }
        PyErr_Clear();
    }
    return false;
}

static PyObject*
GUIDToPythonUUID(const GUID* UUID)
{
    if (UUID)
    {
        // Lie to Python and tell it that our GUID is a 16-byte string
        PyObject* PyUUIDString = PyString_FromStringAndSize((char *)UUID, sizeof(GUID));
        if (!PyUUIDString)
            return NULL;
        // Args, varargs
        PyObject* PyArgs = PyTuple_New(0);
        PyObject* PyKWArgs = PyDict_New();
        PyObject* RetVal = NULL;
        // Dict with single value: the keyword argument bytes_le.
        const int i = 1;
        PyObject* pBytes = NULL;
        if ( (*(char*)&i) == 0 )
            PyDict_SetItemString(PyKWArgs, "bytes", PyUUIDString);
        else
            PyDict_SetItemString(PyKWArgs, "bytes_le", PyUUIDString);
        // New UUID with KW
        if (g_pUUID_type)
            RetVal = PyObject_Call(g_pUUID_type, PyArgs, PyKWArgs);
        else
            PyErr_SetString(PyExc_ImportError, "UUID module import failed");

        Py_DECREF(PyUUIDString);
        Py_DECREF(PyArgs);
        Py_DECREF(PyKWArgs);
        return RetVal;
    }
    else
    {
        PyErr_SetString(PyExc_ValueError, "Bad GUID");
        return NULL;
    }
}

static PyObject*
IUnknownToPythonIIDObject(IUnknown* pUnk, const GUID* IID)
{
    PyObject* RetVal = NULL;
    pUnk->AddRef();
    PyObject* PyUnk = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    //return PyUnk;

    PyObject* pCall = NULL;

    PyObject* pGuidObject = GUIDToPythonUUID(IID);
    if (!pGuidObject || !g_pIIDMap)
        return PyUnk;

    if (PyDict_Contains(g_pIIDMap, pGuidObject) == 1)
        pCall = PyDict_GetItem(g_pIIDMap, pGuidObject);
    if (!pCall)
        pCall = g_pUnk_type;
    if (pCall)
        RetVal = PyObject_CallFunction(pCall, "O", PyUnk);

    if (!RetVal)
        RetVal = PyUnk;
    else
        Py_DECREF(PyUnk);

    Py_XDECREF(pGuidObject);
    return RetVal;
}

static PyObject*
DATE_AsPyObject(DATE in_date)
{
  PyDateTime_IMPORT;
  // Round to even number of days
  int days = (int)in_date;
  // Convert what's left (after the decimal) to seconds; 86400 seconds per day.
  int seconds = (int)((in_date - (double)days) * 86400.0);
  if (in_date < 0)
    seconds *= -1;
  // TimeDelta to add to the date representing the start of all Variant VT_DATEs
  PyObject* pDelta = PyDelta_FromDSU(days, seconds, 0);
  // Midnight 30 December 1899
  PyObject* pStartOfVariantTime = PyDateTime_FromDateAndTime(1899, 12, 30, 0, 0, 0, 0);
  // Do addition of computed delta to 1899-12-30 00:00:00
  PyObject* pRetVal = PyObject_CallMethod(pStartOfVariantTime, "__add__", "O", pDelta);

  Py_XDECREF(pDelta);
  Py_XDECREF(pStartOfVariantTime);

  return pRetVal;
}

static DATE
PyObject_AsDATE(PyObject* in_date)
{
  PyDateTime_IMPORT;
  if (!PyDateTime_Check(in_date))
  {
    PyErr_SetString(PyExc_ValueError, "Cannot convert this Python object to a datetime");
    return (DATE)0.0;
  }

  double out_date;

  PyObject* pStartOfVariantTime = PyDateTime_FromDateAndTime(1899, 12, 30, 0, 0, 0, 0);
  PyDateTime_Delta* pDelta = (PyDateTime_Delta *)PyObject_CallMethod(in_date, "__sub__", "O", pStartOfVariantTime);
  Py_XDECREF(pStartOfVariantTime);
  
  if (pDelta && PyDelta_Check((PyObject *)pDelta))
  {
    out_date = (double)pDelta->days;
    out_date += (double)(pDelta->seconds) / 86400.0;
  }
  
  Py_XDECREF(pDelta);
  return (DATE)out_date;
}

static bool
PyObject_AsVariant(PyObject* in_object, VARIANT* out_variant)
{
  ::VariantClear(out_variant);
  PyDateTime_IMPORT;

  if (in_object == Py_None)
    return true;
  else if (PyUnicode_Check(in_object))
  {
    out_variant->vt = VT_BSTR;
    BSTR out_string = ::SysAllocStringLen(PyUnicode_AS_UNICODE(in_object), 
                                          (UINT)PyUnicode_GET_SIZE(in_object));
    out_variant->bstrVal = out_string;
    return true;
  }
  else if (PyString_Check(in_object))
  {
    PyObject* pUnicode = PyUnicode_FromObject(in_object);
    if (pUnicode)
    {
      out_variant->vt = VT_BSTR;
      BSTR out_string = ::SysAllocStringLen(PyUnicode_AS_UNICODE(pUnicode), 
                                            (UINT)PyUnicode_GET_SIZE(pUnicode));
      out_variant->bstrVal = out_string;
      Py_DECREF(pUnicode);
      return true;
    }
    return false;
  }
  else if (PyFloat_Check(in_object))
  {
    out_variant->vt = VT_R8;
    out_variant->dblVal = PyFloat_AsDouble(in_object);
    return true;
  }
  else if (PyInt_Check(in_object))
  {
    out_variant->vt = VT_I8;
    out_variant->llVal = PyInt_AsLong(in_object);
    return true;
  }
  else if (PyLong_Check(in_object))
  {
    out_variant->vt = VT_I8;
    out_variant->llVal = PyLong_AsLongLong(in_object);
    if (PyErr_Occurred())
    {
      PyErr_Clear();
      PyObject* strval = PyObject_Str(in_object);
      if (strval)
      {
        PyObject* unival = PyUnicode_FromObject(strval);
        out_variant->vt = VT_BSTR;
        BSTR out_string = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unival), 
                                              (UINT)PyUnicode_GET_SIZE(unival));
        out_variant->bstrVal = out_string;
        Py_DecRef(unival);
        Py_DecRef(strval);
        return true;
      }
      return false;
    }
    else
      return true;
  }
  else if (PyDateTime_Check(in_object))
  {
    out_variant->vt = VT_DATE;
    out_variant->date = PyObject_AsDATE(in_object);

    return true;
  }
  else if (PyObject_HasAttrString(in_object, "_pUnk"))
  {
    PyObject* pUnk = PyObject_GetAttrString(in_object, "_pUnk");
    if (pUnk && PyCObject_Check(pUnk))
    {
      IUnknown* pIUnknown = (IUnknown*)PyCObject_AsVoidPtr(pUnk);
      pIUnknown->AddRef();
      out_variant->vt = VT_UNKNOWN;
      out_variant->punkVal = pIUnknown;
      Py_DecRef(pUnk);
      return true;
    }
    Py_XDECREF(pUnk);
  }
  PyObject* repr = PyObject_Repr(in_object);
  PyErr_Format(PyExc_ValueError, "Can't convert %s to Variant.", repr?PyString_AsString(repr):"<Undef>", NULL);
  Py_XDECREF(repr);
  return false;
}

// Forward decl!
static PyObject* SAFEARRAYToPyObject(SAFEARRAY*, VARTYPE);

static PyObject*
Variant_AsPyObject(VARIANT* in_variant)
{
  if (in_variant->vt == VT_EMPTY)
    Py_RETURN_NONE;
  else if (in_variant->vt  == (VT_BYREF|VT_I1))
    return PyInt_FromLong(*(in_variant->pcVal)); //CHAR                *
  else if (in_variant->vt == (VT_BYREF|VT_UI2))
    return PyInt_FromLong(*(in_variant->puiVal)); //USHORT              *
  else if (in_variant->vt == (VT_BYREF|VT_UI4))
    return PyInt_FromLong(*(in_variant->pulVal)); //ULONG               *
  else if (in_variant->vt == (VT_BYREF|VT_UI8))
    return PyLong_FromUnsignedLongLong(*(in_variant->pullVal)); //ULONGLONG           *
  else if (in_variant->vt == (VT_BYREF|VT_INT))
    return PyInt_FromLong(*(in_variant->pintVal)); //INT                 *
  else if (in_variant->vt == (VT_BYREF|VT_UINT))
    return PyInt_FromLong(*(in_variant->puintVal)); //UINT                *
  else if (in_variant->vt == (VT_BYREF|VT_UI1))
    return PyInt_FromLong(*(in_variant->pbVal)); //BYTE                *
  else if (in_variant->vt == (VT_BYREF|VT_I2))
    return PyInt_FromLong(*(in_variant->piVal)); //SHORT               *
  else if (in_variant->vt == (VT_BYREF|VT_I4))
    return PyInt_FromLong(*(in_variant->plVal)); //LONG                *
  else if (in_variant->vt == (VT_BYREF|VT_I8))
    return PyLong_FromLongLong(*(in_variant->pllVal)); //LONGLONG            *
  else if (in_variant->vt == (VT_BYREF|VT_R4))
    return PyFloat_FromDouble((double)*(in_variant->pfltVal)); //FLOAT               *
  else if (in_variant->vt == (VT_BYREF|VT_R8))
    return PyFloat_FromDouble((double)*(in_variant->pdblVal)); //DOUBLE              *
  else if (in_variant->vt == (VT_BYREF|VT_BOOL))
    if ((*(in_variant->pboolVal)) == VARIANT_TRUE)
      Py_RETURN_TRUE;
    else
      Py_RETURN_FALSE;
  else if (in_variant->vt == (VT_BYREF|VT_BSTR))
    return PyUnicode_FromWideChar(*(in_variant->pbstrVal),::SysStringLen(*(in_variant->pbstrVal)));  //BSTR                *
  else if (in_variant->vt == (VT_BYREF|VT_UNKNOWN))
  {
    IUnknown* pUnk = *(in_variant->ppunkVal);
    return IUnknownToPythonIIDObject(pUnk, &IID_IUnknown);
  }
  else if (in_variant->vt == (VT_BYREF|VT_DISPATCH))
  {
    IDispatch* pDisp = *(in_variant->ppdispVal);
    return IUnknownToPythonIIDObject(pDisp, &IID_IUnknown);
  }
  else if (in_variant->vt == (VT_BYREF|VT_VARIANT))
    return Variant_AsPyObject(in_variant->pvarVal); //VARIANT             *
  else if (in_variant->vt  == VT_I8)
    return PyLong_FromLongLong(in_variant->llVal); //LONGLONG           
  else if (in_variant->vt == VT_I4)
    return PyInt_FromLong(in_variant->lVal); //LONG               
  else if (in_variant->vt == VT_UI1)
    return PyInt_FromLong((unsigned)in_variant->bVal); //BYTE               
  else if (in_variant->vt == VT_I2)
    return PyInt_FromLong(in_variant->iVal); //SHORT              
  else if (in_variant->vt == VT_R4)
    return PyFloat_FromDouble((double)(in_variant->fltVal)); //FLOAT              
  else if (in_variant->vt == VT_R8)
    return PyFloat_FromDouble((double)(in_variant->dblVal)); //DOUBLE             
  else if (in_variant->vt == VT_BOOL)
    if ((in_variant->boolVal) == VARIANT_TRUE)
      Py_RETURN_TRUE;
    else
      Py_RETURN_FALSE;              
  else if (in_variant->vt == VT_BSTR)
    return PyUnicode_FromWideChar(in_variant->bstrVal, ::SysStringLen(in_variant->bstrVal)); //BSTR               
  else if (in_variant->vt == VT_UNKNOWN)
  {
    IUnknown* pUnk = in_variant->punkVal;
    return IUnknownToPythonIIDObject(pUnk, &IID_IUnknown);
  }
  else if (in_variant->vt == VT_DISPATCH)
  {
    IDispatch* pDisp = in_variant->pdispVal;
    return IUnknownToPythonIIDObject(pDisp, &IID_IUnknown);
  }
  else if (in_variant->vt == VT_I1)
    return PyInt_FromLong(in_variant->cVal); //CHAR               
  else if (in_variant->vt == VT_UI2)
    return PyInt_FromLong(in_variant->uiVal); //USHORT             
  else if (in_variant->vt == VT_UI4)
    return PyInt_FromLong(in_variant->ulVal); //ULONG              
  else if (in_variant->vt == VT_UI8)
    return PyLong_FromUnsignedLongLong(in_variant->ullVal); //ULONGLONG          
  else if (in_variant->vt == VT_INT)
    return PyInt_FromLong(in_variant->intVal); //INT                
  else if (in_variant->vt == VT_UINT)
    return PyInt_FromLong(in_variant->uintVal); //UINT               
  else if ((in_variant->vt & VT_DATE) == VT_DATE)
  {
    DATE in_date = (in_variant->vt & VT_BYREF)?(*(in_variant->pdate)):in_variant->date;
    return DATE_AsPyObject(in_date);
  }
  else if (in_variant->vt & VT_ARRAY)
  {
    return SAFEARRAYToPyObject((in_variant->vt & VT_BYREF) ? 
                                        *(in_variant->pparray) : 
                                        in_variant->parray,
                                (in_variant->vt));
  }

  PyErr_SetString(PyExc_ValueError, "Cannot convert this variant to a Python object");
  return NULL;
}

static PyObject*
SAFEARRAYToPyObject(SAFEARRAY* pArray, VARTYPE vt)
{
  if (!pArray)
    Py_RETURN_NONE;
  PyObject* return_array(NULL);
  long entry_count(1);
  for (ssize_t dimension(0); dimension < pArray->cDims; ++dimension)
    entry_count *= (pArray->rgsabound[dimension]).cElements;
  if (pArray->fFeatures & FADF_BSTR)
  {
    return_array = PyList_New(0);
    BSTR* barray = (BSTR*)pArray->pvData;
    for (long string_index = 0; string_index < entry_count; ++string_index)
    {
      PyObject* new_string = PyUnicode_FromWideChar(barray[string_index], ::SysStringLen(barray[string_index]));
      PyList_Append(return_array, new_string);
      Py_DECREF(new_string);
    }
  }
  else if (pArray->fFeatures & FADF_VARIANT)
  {
    return_array = PyList_New(0);
    VARIANT* varray = (VARIANT*)pArray->pvData;
    for (long variant_index(0); variant_index < entry_count; ++variant_index)
    {
      PyObject* new_variant = Variant_AsPyObject(&varray[variant_index]);
      if (new_variant)
      {
        PyList_Append(return_array, new_variant);
        Py_DECREF(new_variant);
      }
      else
      {
        PyErr_Clear();
        PyList_Append(return_array, Py_None);
      }
    }
  }
  else if (pArray->fFeatures & FADF_UNKNOWN)
  {
    return_array = PyList_New(0);
    IUnknown** oarray = (IUnknown**)pArray->pvData;
    for (long object_index(0); object_index < entry_count; ++object_index)
    {
      PyObject* new_object = IUnknownToPythonIIDObject(oarray[object_index], &IID_IUnknown);
      PyList_Append(return_array, new_object);
      Py_DECREF(new_object);
    }
  }
  else if (vt == (VT_UI1 | VT_ARRAY))
  {
    return_array = PyByteArray_FromStringAndSize((char*)(pArray->pvData), entry_count);
  }

  if (!return_array)
  {
    if (PyErr_WarnEx(PyExc_Warning, "conversion for this error type not implemented", -1) != 0)
      return 0;

    return_array = Py_BuildValue("(HHNK)", (unsigned short)vt,
                                           (unsigned short)pArray->fFeatures,
                                           PyByteArray_FromStringAndSize((char*)(pArray->pvData), 
                                                                         sizeof(pArray->pvData)),
                                           (unsigned long long)pArray->pvData);
  }
  return return_array;
}

// Attempt to get an interface pointer from a Python object
static bool
IFaceFromPyObject(PyObject* pIn, const GUID* pOutGuid, void** pOutIFace)
{
    IUnknown* pUnk = NULL;

    if (pIn == Py_None)
    {
        *pOutIFace = NULL;
        return true;
    }
    else if (PyCObject_Check(pIn))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(pIn);
    }
    else
    {
        bool need_decref(false);
        if (PyObject_HasAttrString(pIn, "_arc_object"))
        {
          pIn = PyObject_GetAttrString(pIn, "_arc_object");
          if (pIn)
            need_decref = true;
        }
        PyObject* pObject = PyObject_GetAttrString(pIn, "_pUnk");
        if (!pObject)
            return false;
        if (!PyCObject_Check(pObject))
            return false;
        else
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(pObject);
        if (need_decref)
            Py_DECREF(pIn);
        Py_XDECREF(pObject);
    }
    if (pUnk && SUCCEEDED(pUnk->QueryInterface(*pOutGuid, pOutIFace)))
        return true;

    return false;
}



// Every module implements this IUnknown thing but only one reference to the 
// _Type struct will be used between them, so type checking will still work.
// This has the happy side effect of letting us pick and choose which of the
// OLBs that are offered as wrappers (and just plain remove them) without 
// needing to worry about it. Whichever of the C modules in the suite that gets
// imported first is fully capable and will do its best to bootstrap the system.

typedef struct IUnknownObject {
    PyObject_HEAD
    IUnknown* m_pUnk;
} IUnknownObject;

static PyObject*
IUnknownObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    IUnknownObject* self;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {        
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IUnknown with provided CLSID");
            return NULL;
        }
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        pUnk->AddRef();
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IUnknown");
            return NULL;
        }
        if (!PyCObject_Check(argument))
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IUnknown");
            return NULL;
        }
        else
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
            pUnk->AddRef();
        }
        if (argument)
            Py_DECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    if (!(self = ((IUnknownObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IUnknown");
        return NULL;
    }

    self->m_pUnk = pUnk;
    return (PyObject *)self;
}

static void
IUnknownObject_dealloc(IUnknownObject* self)
{
    if (self->m_pUnk)
        self->m_pUnk->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
IUnknown_GetpUnk(IUnknownObject* self)
{
    if (!self->m_pUnk)
        Py_RETURN_NONE;
    self->m_pUnk->AddRef();
    return PyCObject_FromVoidPtr((void*)self->m_pUnk, destr_unknown);
}

static PyObject*
IUnknown_GetPointer(IUnknownObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pUnk);
}

static PyObject*
IUnknown_GetIID(IUnknownObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "{00000000-0000-0000-C000-000000000046}");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
IUnknown_SupportsInterface(IUnknownObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pUnk->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}

PyMethodDef IUnknownMethods[] = {
    {"supports", (PyCFunction)IUnknown_SupportsInterface, METH_O, ""},
};

PyGetSetDef IUnknownGetSet[] = {
  {"_IID", (getter)IUnknown_GetIID, NULL, "Get IID for Unknown", NULL},
  {"_pUnk", (getter)IUnknown_GetpUnk, NULL, "Get opaque pointer to Unknown", NULL},
  {"_pointer", (getter)IUnknown_GetPointer, NULL, "Get long pointer to Unknown", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject IUnknownObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "cartocomutils.IUnknown",
                                              /* tp_name */
  sizeof(IUnknownObject),                     /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)IUnknownObject_dealloc,         /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "IUnknown",                                 /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  IUnknownMethods,                            /* tp_methods */
  0,                                          /* tp_members */
  IUnknownGetSet,                             /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  IUnknownObject_new,                         /* tp_new */
};




// Interface IDETerrain

typedef struct PyIDETerrainObject {
    PyObject_HEAD
    IDETerrain* m_pIDETerrain;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIDETerrainObject;

static PyObject*
PyIDETerrainObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIDETerrainObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IDETerrain* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IDETerrain, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IDETerrain with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIDETerrainObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IDETerrain");
            return NULL;
        }
        self->m_pIDETerrain = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IDETerrain");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IDETerrain");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IDETerrain* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IDETerrain, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IDETerrain");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIDETerrainObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IDETerrain");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIDETerrain = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIDETerrainObject_dealloc(PyIDETerrainObject* self)
{
    if (self->m_pIDETerrain)
        self->m_pIDETerrain->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIDETerrain_GetpUnk(PyIDETerrainObject* self)
{
    if (!self->m_pIDETerrain)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIDETerrain->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IDETerrain to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIDETerrain_GetPointer(PyIDETerrainObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIDETerrain);
}

static PyObject*
PyIDETerrain_GetIID(PyIDETerrainObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "0911f2fb-4b12-4012-ae6b-94fad2d2084d");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIDETerrain_GetHR(PyIDETerrainObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIDETerrain_GetIgnoreFailures(PyIDETerrainObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIDETerrain_SetIgnoreFailures(PyIDETerrainObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIDETerrain_SupportsInterface(PyIDETerrainObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIDETerrain->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IDETerrainMethod_put_Name(PyIDETerrainObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspName = 0;
    PyObject* pyvar_pName;
    PyObject* unicodepName = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pName))
      goto ideterrain_put_name_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_pName))
        unicodepName = PyUnicode_FromObject(pyvar_pName);
    else if (PyUnicode_Check(pyvar_pName))
    {
        unicodepName = pyvar_pName;
        Py_INCREF(unicodepName);
    }
    else if (pyvar_pName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter pName at index 0");
    if (unicodepName)
        bspName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodepName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodepName));
    
    if (PyErr_Occurred())
      goto ideterrain_put_name_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIDETerrain->put_Name(bspName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDETerrain->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDETerrain) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDETerrain.put_Name() returned %ld", (long)hr);
        goto ideterrain_put_name_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pName

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ideterrain_put_name_method_cleanup;

    ideterrain_put_name_method_cleanup:
    self->m_HR = hr;
    if (bspName)
        ::SysFreeString(bspName);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDETerrain.put_Name");
    return return_tuple;
}

static PyObject*
IDETerrainMethod_get_Name(PyIDETerrainObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspName;
    PyObject* pyvar_pName = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pName

    // Call method on actual COM interface
    hr = self->m_pIDETerrain->get_Name(&bspName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDETerrain->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDETerrain) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDETerrain.get_Name() returned %ld", (long)hr);
        goto ideterrain_get_name_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pName = PyUnicode_FromWideChar(bspName,::SysStringLen(bspName));
    ::SysFreeString(bspName);
    
    if (PyErr_Occurred())
      goto ideterrain_get_name_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pName);
    goto ideterrain_get_name_method_cleanup;

    ideterrain_get_name_method_cleanup:
    self->m_HR = hr;
    if (pyvar_pName != Py_None)
        Py_XDECREF(pyvar_pName);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDETerrain.get_Name");
    return return_tuple;
}

static PyObject*
IDETerrainMethod_put_TileSize(PyIDETerrainObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dpSize = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "d", &dpSize))
      goto ideterrain_put_tilesize_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pSize

    // Call method on actual COM interface
    hr = self->m_pIDETerrain->put_TileSize(dpSize);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDETerrain->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDETerrain) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDETerrain.put_TileSize() returned %ld", (long)hr);
        goto ideterrain_put_tilesize_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pSize

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ideterrain_put_tilesize_method_cleanup;

    ideterrain_put_tilesize_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pSize
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDETerrain.put_TileSize");
    return return_tuple;
}

static PyObject*
IDETerrainMethod_get_TileSize(PyIDETerrainObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dpSize = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pSize

    // Call method on actual COM interface
    hr = self->m_pIDETerrain->get_TileSize(&dpSize);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDETerrain->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDETerrain) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDETerrain.get_TileSize() returned %ld", (long)hr);
        goto ideterrain_get_tilesize_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pSize

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dpSize);
    goto ideterrain_get_tilesize_method_cleanup;

    ideterrain_get_tilesize_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pSize
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDETerrain.get_TileSize");
    return return_tuple;
}

static PyObject*
IDETerrainMethod_put_PyramidType(PyIDETerrainObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriTerrainPyramidType epType;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&epType))
      goto ideterrain_put_pyramidtype_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pType

    // Call method on actual COM interface
    hr = self->m_pIDETerrain->put_PyramidType(epType);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDETerrain->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDETerrain) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDETerrain.put_PyramidType() returned %ld", (long)hr);
        goto ideterrain_put_pyramidtype_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pType

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ideterrain_put_pyramidtype_method_cleanup;

    ideterrain_put_pyramidtype_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pType
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDETerrain.put_PyramidType");
    return return_tuple;
}

static PyObject*
IDETerrainMethod_get_PyramidType(PyIDETerrainObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriTerrainPyramidType epType;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pType

    // Call method on actual COM interface
    hr = self->m_pIDETerrain->get_PyramidType(&epType);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDETerrain->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDETerrain) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDETerrain.get_PyramidType() returned %ld", (long)hr);
        goto ideterrain_get_pyramidtype_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pType

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)epType);
    goto ideterrain_get_pyramidtype_method_cleanup;

    ideterrain_get_pyramidtype_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pType
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDETerrain.get_PyramidType");
    return return_tuple;
}

static PyObject*
IDETerrainMethod_put_MaxOverviewTerrainPoints(PyIDETerrainObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpcPoints = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lpcPoints))
      goto ideterrain_put_maxoverviewterrainpoints_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pcPoints

    // Call method on actual COM interface
    hr = self->m_pIDETerrain->put_MaxOverviewTerrainPoints(lpcPoints);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDETerrain->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDETerrain) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDETerrain.put_MaxOverviewTerrainPoints() returned %ld", (long)hr);
        goto ideterrain_put_maxoverviewterrainpoints_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pcPoints

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ideterrain_put_maxoverviewterrainpoints_method_cleanup;

    ideterrain_put_maxoverviewterrainpoints_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pcPoints
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDETerrain.put_MaxOverviewTerrainPoints");
    return return_tuple;
}

static PyObject*
IDETerrainMethod_get_MaxOverviewTerrainPoints(PyIDETerrainObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpcPoints = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pcPoints

    // Call method on actual COM interface
    hr = self->m_pIDETerrain->get_MaxOverviewTerrainPoints(&lpcPoints);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDETerrain->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDETerrain) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDETerrain.get_MaxOverviewTerrainPoints() returned %ld", (long)hr);
        goto ideterrain_get_maxoverviewterrainpoints_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pcPoints

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpcPoints);
    goto ideterrain_get_maxoverviewterrainpoints_method_cleanup;

    ideterrain_get_maxoverviewterrainpoints_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pcPoints
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDETerrain.get_MaxOverviewTerrainPoints");
    return return_tuple;
}

static PyObject*
IDETerrainMethod_put_MaxPointsPerShape(PyIDETerrainObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpcPoints = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lpcPoints))
      goto ideterrain_put_maxpointspershape_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pcPoints

    // Call method on actual COM interface
    hr = self->m_pIDETerrain->put_MaxPointsPerShape(lpcPoints);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDETerrain->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDETerrain) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDETerrain.put_MaxPointsPerShape() returned %ld", (long)hr);
        goto ideterrain_put_maxpointspershape_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pcPoints

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ideterrain_put_maxpointspershape_method_cleanup;

    ideterrain_put_maxpointspershape_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pcPoints
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDETerrain.put_MaxPointsPerShape");
    return return_tuple;
}

static PyObject*
IDETerrainMethod_get_MaxPointsPerShape(PyIDETerrainObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpcPoints = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pcPoints

    // Call method on actual COM interface
    hr = self->m_pIDETerrain->get_MaxPointsPerShape(&lpcPoints);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDETerrain->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDETerrain) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDETerrain.get_MaxPointsPerShape() returned %ld", (long)hr);
        goto ideterrain_get_maxpointspershape_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pcPoints

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpcPoints);
    goto ideterrain_get_maxpointspershape_method_cleanup;

    ideterrain_get_maxpointspershape_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pcPoints
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDETerrain.get_MaxPointsPerShape");
    return return_tuple;
}

static PyObject*
IDETerrainMethod_put_ConfigurationKeyword(PyIDETerrainObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspConfigKeyword = 0;
    PyObject* pyvar_pConfigKeyword;
    PyObject* unicodepConfigKeyword = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pConfigKeyword))
      goto ideterrain_put_configurationkeyword_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_pConfigKeyword))
        unicodepConfigKeyword = PyUnicode_FromObject(pyvar_pConfigKeyword);
    else if (PyUnicode_Check(pyvar_pConfigKeyword))
    {
        unicodepConfigKeyword = pyvar_pConfigKeyword;
        Py_INCREF(unicodepConfigKeyword);
    }
    else if (pyvar_pConfigKeyword != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter pConfigKeyword at index 0");
    if (unicodepConfigKeyword)
        bspConfigKeyword = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodepConfigKeyword), 
                                            (UINT)PyUnicode_GET_SIZE(unicodepConfigKeyword));
    
    if (PyErr_Occurred())
      goto ideterrain_put_configurationkeyword_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIDETerrain->put_ConfigurationKeyword(bspConfigKeyword);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDETerrain->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDETerrain) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDETerrain.put_ConfigurationKeyword() returned %ld", (long)hr);
        goto ideterrain_put_configurationkeyword_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pConfigKeyword

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ideterrain_put_configurationkeyword_method_cleanup;

    ideterrain_put_configurationkeyword_method_cleanup:
    self->m_HR = hr;
    if (bspConfigKeyword)
        ::SysFreeString(bspConfigKeyword);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDETerrain.put_ConfigurationKeyword");
    return return_tuple;
}

static PyObject*
IDETerrainMethod_get_ConfigurationKeyword(PyIDETerrainObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspConfigKeyword;
    PyObject* pyvar_pConfigKeyword = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pConfigKeyword

    // Call method on actual COM interface
    hr = self->m_pIDETerrain->get_ConfigurationKeyword(&bspConfigKeyword);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDETerrain->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDETerrain) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDETerrain.get_ConfigurationKeyword() returned %ld", (long)hr);
        goto ideterrain_get_configurationkeyword_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pConfigKeyword = PyUnicode_FromWideChar(bspConfigKeyword,::SysStringLen(bspConfigKeyword));
    ::SysFreeString(bspConfigKeyword);
    
    if (PyErr_Occurred())
      goto ideterrain_get_configurationkeyword_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pConfigKeyword);
    goto ideterrain_get_configurationkeyword_method_cleanup;

    ideterrain_get_configurationkeyword_method_cleanup:
    self->m_HR = hr;
    if (pyvar_pConfigKeyword != Py_None)
        Py_XDECREF(pyvar_pConfigKeyword);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDETerrain.get_ConfigurationKeyword");
    return return_tuple;
}


PyMethodDef PyIDETerrainMethods[] = {
    {"supports", (PyCFunction)PyIDETerrain_SupportsInterface, METH_O, ""},
    {"put_Name", (PyCFunction)IDETerrainMethod_put_Name, METH_VARARGS, ""},
    {"get_Name", (PyCFunction)IDETerrainMethod_get_Name, METH_VARARGS, ""},
    {"put_TileSize", (PyCFunction)IDETerrainMethod_put_TileSize, METH_VARARGS, ""},
    {"get_TileSize", (PyCFunction)IDETerrainMethod_get_TileSize, METH_VARARGS, ""},
    {"put_PyramidType", (PyCFunction)IDETerrainMethod_put_PyramidType, METH_VARARGS, ""},
    {"get_PyramidType", (PyCFunction)IDETerrainMethod_get_PyramidType, METH_VARARGS, ""},
    {"put_MaxOverviewTerrainPoints", (PyCFunction)IDETerrainMethod_put_MaxOverviewTerrainPoints, METH_VARARGS, ""},
    {"get_MaxOverviewTerrainPoints", (PyCFunction)IDETerrainMethod_get_MaxOverviewTerrainPoints, METH_VARARGS, ""},
    {"put_MaxPointsPerShape", (PyCFunction)IDETerrainMethod_put_MaxPointsPerShape, METH_VARARGS, ""},
    {"get_MaxPointsPerShape", (PyCFunction)IDETerrainMethod_get_MaxPointsPerShape, METH_VARARGS, ""},
    {"put_ConfigurationKeyword", (PyCFunction)IDETerrainMethod_put_ConfigurationKeyword, METH_VARARGS, ""},
    {"get_ConfigurationKeyword", (PyCFunction)IDETerrainMethod_get_ConfigurationKeyword, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIDETerrainGetSet[] = {
  {"_pUnk", (getter)PyIDETerrain_GetpUnk, NULL, "Get opaque pointer to an Unknown from IDETerrain", NULL},
  {"_pointer", (getter)PyIDETerrain_GetPointer, NULL, "Get memory address for IDETerrain", NULL},
  {"_IID", (getter)PyIDETerrain_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIDETerrain_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIDETerrain_GetIgnoreFailures, (setter)PyIDETerrain_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIDETerrainObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.IDETerrainObject",                          
                                              /* tp_name */
  sizeof(PyIDETerrainObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIDETerrainObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIDETerrainMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIDETerrainGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIDETerrainObject_new,                      
                                              /* tp_new */
};

// Interface IDETerrainWindowSize

typedef struct PyIDETerrainWindowSizeObject {
    PyObject_HEAD
    IDETerrainWindowSize* m_pIDETerrainWindowSize;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIDETerrainWindowSizeObject;

static PyObject*
PyIDETerrainWindowSizeObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIDETerrainWindowSizeObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IDETerrainWindowSize* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IDETerrainWindowSize, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IDETerrainWindowSize with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIDETerrainWindowSizeObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IDETerrainWindowSize");
            return NULL;
        }
        self->m_pIDETerrainWindowSize = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IDETerrainWindowSize");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IDETerrainWindowSize");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IDETerrainWindowSize* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IDETerrainWindowSize, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IDETerrainWindowSize");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIDETerrainWindowSizeObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IDETerrainWindowSize");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIDETerrainWindowSize = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIDETerrainWindowSizeObject_dealloc(PyIDETerrainWindowSizeObject* self)
{
    if (self->m_pIDETerrainWindowSize)
        self->m_pIDETerrainWindowSize->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIDETerrainWindowSize_GetpUnk(PyIDETerrainWindowSizeObject* self)
{
    if (!self->m_pIDETerrainWindowSize)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIDETerrainWindowSize->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IDETerrainWindowSize to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIDETerrainWindowSize_GetPointer(PyIDETerrainWindowSizeObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIDETerrainWindowSize);
}

static PyObject*
PyIDETerrainWindowSize_GetIID(PyIDETerrainWindowSizeObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "62b845f1-6b66-406d-870d-2afd3c00dc48");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIDETerrainWindowSize_GetHR(PyIDETerrainWindowSizeObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIDETerrainWindowSize_GetIgnoreFailures(PyIDETerrainWindowSizeObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIDETerrainWindowSize_SetIgnoreFailures(PyIDETerrainWindowSizeObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIDETerrainWindowSize_SupportsInterface(PyIDETerrainWindowSizeObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIDETerrainWindowSize->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IDETerrainWindowSizeMethod_put_Method(PyIDETerrainWindowSizeObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriTerrainWindowSizeMethod epMethod;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&epMethod))
      goto ideterrainwindowsize_put_method_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pMethod

    // Call method on actual COM interface
    hr = self->m_pIDETerrainWindowSize->put_Method(epMethod);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDETerrainWindowSize->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDETerrainWindowSize) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDETerrainWindowSize.put_Method() returned %ld", (long)hr);
        goto ideterrainwindowsize_put_method_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pMethod

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ideterrainwindowsize_put_method_method_cleanup;

    ideterrainwindowsize_put_method_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pMethod
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDETerrainWindowSize.put_Method");
    return return_tuple;
}

static PyObject*
IDETerrainWindowSizeMethod_get_Method(PyIDETerrainWindowSizeObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriTerrainWindowSizeMethod epMethod;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pMethod

    // Call method on actual COM interface
    hr = self->m_pIDETerrainWindowSize->get_Method(&epMethod);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDETerrainWindowSize->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDETerrainWindowSize) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDETerrainWindowSize.get_Method() returned %ld", (long)hr);
        goto ideterrainwindowsize_get_method_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pMethod

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)epMethod);
    goto ideterrainwindowsize_get_method_method_cleanup;

    ideterrainwindowsize_get_method_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pMethod
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDETerrainWindowSize.get_Method");
    return return_tuple;
}

static PyObject*
IDETerrainWindowSizeMethod_put_ZThreshold(PyIDETerrainWindowSizeObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dpThreshold = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "d", &dpThreshold))
      goto ideterrainwindowsize_put_zthreshold_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pThreshold

    // Call method on actual COM interface
    hr = self->m_pIDETerrainWindowSize->put_ZThreshold(dpThreshold);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDETerrainWindowSize->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDETerrainWindowSize) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDETerrainWindowSize.put_ZThreshold() returned %ld", (long)hr);
        goto ideterrainwindowsize_put_zthreshold_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pThreshold

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ideterrainwindowsize_put_zthreshold_method_cleanup;

    ideterrainwindowsize_put_zthreshold_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pThreshold
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDETerrainWindowSize.put_ZThreshold");
    return return_tuple;
}

static PyObject*
IDETerrainWindowSizeMethod_get_ZThreshold(PyIDETerrainWindowSizeObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dpThreshold = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pThreshold

    // Call method on actual COM interface
    hr = self->m_pIDETerrainWindowSize->get_ZThreshold(&dpThreshold);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDETerrainWindowSize->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDETerrainWindowSize) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDETerrainWindowSize.get_ZThreshold() returned %ld", (long)hr);
        goto ideterrainwindowsize_get_zthreshold_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pThreshold

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dpThreshold);
    goto ideterrainwindowsize_get_zthreshold_method_cleanup;

    ideterrainwindowsize_get_zthreshold_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pThreshold
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDETerrainWindowSize.get_ZThreshold");
    return return_tuple;
}

static PyObject*
IDETerrainWindowSizeMethod_put_ZThresholdStrategy(PyIDETerrainWindowSizeObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriTerrainZThresholdStrategy epStrategy;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&epStrategy))
      goto ideterrainwindowsize_put_zthresholdstrategy_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pStrategy

    // Call method on actual COM interface
    hr = self->m_pIDETerrainWindowSize->put_ZThresholdStrategy(epStrategy);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDETerrainWindowSize->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDETerrainWindowSize) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDETerrainWindowSize.put_ZThresholdStrategy() returned %ld", (long)hr);
        goto ideterrainwindowsize_put_zthresholdstrategy_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pStrategy

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ideterrainwindowsize_put_zthresholdstrategy_method_cleanup;

    ideterrainwindowsize_put_zthresholdstrategy_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pStrategy
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDETerrainWindowSize.put_ZThresholdStrategy");
    return return_tuple;
}

static PyObject*
IDETerrainWindowSizeMethod_get_ZThresholdStrategy(PyIDETerrainWindowSizeObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriTerrainZThresholdStrategy epStrategy;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pStrategy

    // Call method on actual COM interface
    hr = self->m_pIDETerrainWindowSize->get_ZThresholdStrategy(&epStrategy);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDETerrainWindowSize->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDETerrainWindowSize) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDETerrainWindowSize.get_ZThresholdStrategy() returned %ld", (long)hr);
        goto ideterrainwindowsize_get_zthresholdstrategy_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pStrategy

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)epStrategy);
    goto ideterrainwindowsize_get_zthresholdstrategy_method_cleanup;

    ideterrainwindowsize_get_zthresholdstrategy_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pStrategy
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDETerrainWindowSize.get_ZThresholdStrategy");
    return return_tuple;
}


PyMethodDef PyIDETerrainWindowSizeMethods[] = {
    {"supports", (PyCFunction)PyIDETerrainWindowSize_SupportsInterface, METH_O, ""},
    {"put_Method", (PyCFunction)IDETerrainWindowSizeMethod_put_Method, METH_VARARGS, ""},
    {"get_Method", (PyCFunction)IDETerrainWindowSizeMethod_get_Method, METH_VARARGS, ""},
    {"put_ZThreshold", (PyCFunction)IDETerrainWindowSizeMethod_put_ZThreshold, METH_VARARGS, ""},
    {"get_ZThreshold", (PyCFunction)IDETerrainWindowSizeMethod_get_ZThreshold, METH_VARARGS, ""},
    {"put_ZThresholdStrategy", (PyCFunction)IDETerrainWindowSizeMethod_put_ZThresholdStrategy, METH_VARARGS, ""},
    {"get_ZThresholdStrategy", (PyCFunction)IDETerrainWindowSizeMethod_get_ZThresholdStrategy, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIDETerrainWindowSizeGetSet[] = {
  {"_pUnk", (getter)PyIDETerrainWindowSize_GetpUnk, NULL, "Get opaque pointer to an Unknown from IDETerrainWindowSize", NULL},
  {"_pointer", (getter)PyIDETerrainWindowSize_GetPointer, NULL, "Get memory address for IDETerrainWindowSize", NULL},
  {"_IID", (getter)PyIDETerrainWindowSize_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIDETerrainWindowSize_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIDETerrainWindowSize_GetIgnoreFailures, (setter)PyIDETerrainWindowSize_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIDETerrainWindowSizeObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.IDETerrainWindowSizeObject",                          
                                              /* tp_name */
  sizeof(PyIDETerrainWindowSizeObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIDETerrainWindowSizeObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIDETerrainWindowSizeMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIDETerrainWindowSizeGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIDETerrainWindowSizeObject_new,                      
                                              /* tp_new */
};

// Interface ITerrainDataSource

typedef struct PyITerrainDataSourceObject {
    PyObject_HEAD
    ITerrainDataSource* m_pITerrainDataSource;
    HRESULT m_HR;
    int m_ignore_failures;
} PyITerrainDataSourceObject;

static PyObject*
PyITerrainDataSourceObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyITerrainDataSourceObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ITerrainDataSource* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ITerrainDataSource, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ITerrainDataSource with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyITerrainDataSourceObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ITerrainDataSource");
            return NULL;
        }
        self->m_pITerrainDataSource = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ITerrainDataSource");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ITerrainDataSource");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ITerrainDataSource* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ITerrainDataSource, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ITerrainDataSource");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyITerrainDataSourceObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ITerrainDataSource");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pITerrainDataSource = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyITerrainDataSourceObject_dealloc(PyITerrainDataSourceObject* self)
{
    if (self->m_pITerrainDataSource)
        self->m_pITerrainDataSource->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyITerrainDataSource_GetpUnk(PyITerrainDataSourceObject* self)
{
    if (!self->m_pITerrainDataSource)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pITerrainDataSource->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ITerrainDataSource to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyITerrainDataSource_GetPointer(PyITerrainDataSourceObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pITerrainDataSource);
}

static PyObject*
PyITerrainDataSource_GetIID(PyITerrainDataSourceObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "4d228018-1ec1-4fcc-9646-9c6a67f9ef3c");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyITerrainDataSource_GetHR(PyITerrainDataSourceObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyITerrainDataSource_GetIgnoreFailures(PyITerrainDataSourceObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyITerrainDataSource_SetIgnoreFailures(PyITerrainDataSourceObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyITerrainDataSource_SupportsInterface(PyITerrainDataSourceObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pITerrainDataSource->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ITerrainDataSourceMethod_put_FeatureClassID(PyITerrainDataSourceObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpClassID = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lpClassID))
      goto iterraindatasource_put_featureclassid_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pClassID

    // Call method on actual COM interface
    hr = self->m_pITerrainDataSource->put_FeatureClassID(lpClassID);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainDataSource->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainDataSource) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainDataSource.put_FeatureClassID() returned %ld", (long)hr);
        goto iterraindatasource_put_featureclassid_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pClassID

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterraindatasource_put_featureclassid_method_cleanup;

    iterraindatasource_put_featureclassid_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pClassID
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainDataSource.put_FeatureClassID");
    return return_tuple;
}

static PyObject*
ITerrainDataSourceMethod_get_FeatureClassID(PyITerrainDataSourceObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpClassID = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pClassID

    // Call method on actual COM interface
    hr = self->m_pITerrainDataSource->get_FeatureClassID(&lpClassID);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainDataSource->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainDataSource) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainDataSource.get_FeatureClassID() returned %ld", (long)hr);
        goto iterraindatasource_get_featureclassid_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pClassID

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpClassID);
    goto iterraindatasource_get_featureclassid_method_cleanup;

    iterraindatasource_get_featureclassid_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pClassID
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainDataSource.get_FeatureClassID");
    return return_tuple;
}

static PyObject*
ITerrainDataSourceMethod_put_GroupID(PyITerrainDataSourceObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpGroupID = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lpGroupID))
      goto iterraindatasource_put_groupid_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pGroupID

    // Call method on actual COM interface
    hr = self->m_pITerrainDataSource->put_GroupID(lpGroupID);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainDataSource->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainDataSource) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainDataSource.put_GroupID() returned %ld", (long)hr);
        goto iterraindatasource_put_groupid_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pGroupID

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterraindatasource_put_groupid_method_cleanup;

    iterraindatasource_put_groupid_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pGroupID
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainDataSource.put_GroupID");
    return return_tuple;
}

static PyObject*
ITerrainDataSourceMethod_get_GroupID(PyITerrainDataSourceObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpGroupID = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pGroupID

    // Call method on actual COM interface
    hr = self->m_pITerrainDataSource->get_GroupID(&lpGroupID);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainDataSource->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainDataSource) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainDataSource.get_GroupID() returned %ld", (long)hr);
        goto iterraindatasource_get_groupid_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pGroupID

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpGroupID);
    goto iterraindatasource_get_groupid_method_cleanup;

    iterraindatasource_get_groupid_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pGroupID
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainDataSource.get_GroupID");
    return return_tuple;
}

static PyObject*
ITerrainDataSourceMethod_put_HeightField(PyITerrainDataSourceObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspFieldName = 0;
    PyObject* pyvar_pFieldName;
    PyObject* unicodepFieldName = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pFieldName))
      goto iterraindatasource_put_heightfield_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_pFieldName))
        unicodepFieldName = PyUnicode_FromObject(pyvar_pFieldName);
    else if (PyUnicode_Check(pyvar_pFieldName))
    {
        unicodepFieldName = pyvar_pFieldName;
        Py_INCREF(unicodepFieldName);
    }
    else if (pyvar_pFieldName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter pFieldName at index 0");
    if (unicodepFieldName)
        bspFieldName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodepFieldName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodepFieldName));
    
    if (PyErr_Occurred())
      goto iterraindatasource_put_heightfield_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITerrainDataSource->put_HeightField(bspFieldName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainDataSource->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainDataSource) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainDataSource.put_HeightField() returned %ld", (long)hr);
        goto iterraindatasource_put_heightfield_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pFieldName

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterraindatasource_put_heightfield_method_cleanup;

    iterraindatasource_put_heightfield_method_cleanup:
    self->m_HR = hr;
    if (bspFieldName)
        ::SysFreeString(bspFieldName);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainDataSource.put_HeightField");
    return return_tuple;
}

static PyObject*
ITerrainDataSourceMethod_get_HeightField(PyITerrainDataSourceObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspFieldName;
    PyObject* pyvar_pFieldName = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pFieldName

    // Call method on actual COM interface
    hr = self->m_pITerrainDataSource->get_HeightField(&bspFieldName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainDataSource->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainDataSource) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainDataSource.get_HeightField() returned %ld", (long)hr);
        goto iterraindatasource_get_heightfield_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pFieldName = PyUnicode_FromWideChar(bspFieldName,::SysStringLen(bspFieldName));
    ::SysFreeString(bspFieldName);
    
    if (PyErr_Occurred())
      goto iterraindatasource_get_heightfield_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pFieldName);
    goto iterraindatasource_get_heightfield_method_cleanup;

    iterraindatasource_get_heightfield_method_cleanup:
    self->m_HR = hr;
    if (pyvar_pFieldName != Py_None)
        Py_XDECREF(pyvar_pFieldName);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainDataSource.get_HeightField");
    return return_tuple;
}

static PyObject*
ITerrainDataSourceMethod_put_TagValueField(PyITerrainDataSourceObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspFieldName = 0;
    PyObject* pyvar_pFieldName;
    PyObject* unicodepFieldName = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pFieldName))
      goto iterraindatasource_put_tagvaluefield_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_pFieldName))
        unicodepFieldName = PyUnicode_FromObject(pyvar_pFieldName);
    else if (PyUnicode_Check(pyvar_pFieldName))
    {
        unicodepFieldName = pyvar_pFieldName;
        Py_INCREF(unicodepFieldName);
    }
    else if (pyvar_pFieldName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter pFieldName at index 0");
    if (unicodepFieldName)
        bspFieldName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodepFieldName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodepFieldName));
    
    if (PyErr_Occurred())
      goto iterraindatasource_put_tagvaluefield_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITerrainDataSource->put_TagValueField(bspFieldName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainDataSource->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainDataSource) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainDataSource.put_TagValueField() returned %ld", (long)hr);
        goto iterraindatasource_put_tagvaluefield_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pFieldName

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterraindatasource_put_tagvaluefield_method_cleanup;

    iterraindatasource_put_tagvaluefield_method_cleanup:
    self->m_HR = hr;
    if (bspFieldName)
        ::SysFreeString(bspFieldName);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainDataSource.put_TagValueField");
    return return_tuple;
}

static PyObject*
ITerrainDataSourceMethod_get_TagValueField(PyITerrainDataSourceObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspFieldName;
    PyObject* pyvar_pFieldName = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pFieldName

    // Call method on actual COM interface
    hr = self->m_pITerrainDataSource->get_TagValueField(&bspFieldName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainDataSource->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainDataSource) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainDataSource.get_TagValueField() returned %ld", (long)hr);
        goto iterraindatasource_get_tagvaluefield_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pFieldName = PyUnicode_FromWideChar(bspFieldName,::SysStringLen(bspFieldName));
    ::SysFreeString(bspFieldName);
    
    if (PyErr_Occurred())
      goto iterraindatasource_get_tagvaluefield_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pFieldName);
    goto iterraindatasource_get_tagvaluefield_method_cleanup;

    iterraindatasource_get_tagvaluefield_method_cleanup:
    self->m_HR = hr;
    if (pyvar_pFieldName != Py_None)
        Py_XDECREF(pyvar_pFieldName);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainDataSource.get_TagValueField");
    return return_tuple;
}

static PyObject*
ITerrainDataSourceMethod_put_SurfaceFeatureType(PyITerrainDataSourceObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriTinSurfaceType epType;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&epType))
      goto iterraindatasource_put_surfacefeaturetype_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pType

    // Call method on actual COM interface
    hr = self->m_pITerrainDataSource->put_SurfaceFeatureType(epType);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainDataSource->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainDataSource) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainDataSource.put_SurfaceFeatureType() returned %ld", (long)hr);
        goto iterraindatasource_put_surfacefeaturetype_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pType

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterraindatasource_put_surfacefeaturetype_method_cleanup;

    iterraindatasource_put_surfacefeaturetype_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pType
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainDataSource.put_SurfaceFeatureType");
    return return_tuple;
}

static PyObject*
ITerrainDataSourceMethod_get_SurfaceFeatureType(PyITerrainDataSourceObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriTinSurfaceType epType;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pType

    // Call method on actual COM interface
    hr = self->m_pITerrainDataSource->get_SurfaceFeatureType(&epType);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainDataSource->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainDataSource) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainDataSource.get_SurfaceFeatureType() returned %ld", (long)hr);
        goto iterraindatasource_get_surfacefeaturetype_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pType

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)epType);
    goto iterraindatasource_get_surfacefeaturetype_method_cleanup;

    iterraindatasource_get_surfacefeaturetype_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pType
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainDataSource.get_SurfaceFeatureType");
    return return_tuple;
}

static PyObject*
ITerrainDataSourceMethod_put_ApplyToOverviewTerrain(PyITerrainDataSourceObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pbApply = VARIANT_FALSE;
    PyObject* pyvar_pbApply = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pbApply))
      goto iterraindatasource_put_applytooverviewterrain_method_cleanup;

    // Set up initial variable values as needed
    b_pbApply = ((PyObject_IsTrue(pyvar_pbApply) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iterraindatasource_put_applytooverviewterrain_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITerrainDataSource->put_ApplyToOverviewTerrain(b_pbApply);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainDataSource->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainDataSource) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainDataSource.put_ApplyToOverviewTerrain() returned %ld", (long)hr);
        goto iterraindatasource_put_applytooverviewterrain_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pbApply

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterraindatasource_put_applytooverviewterrain_method_cleanup;

    iterraindatasource_put_applytooverviewterrain_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pbApply
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainDataSource.put_ApplyToOverviewTerrain");
    return return_tuple;
}

static PyObject*
ITerrainDataSourceMethod_get_ApplyToOverviewTerrain(PyITerrainDataSourceObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pbApply = VARIANT_FALSE;
    PyObject* pyvar_pbApply = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pbApply

    // Call method on actual COM interface
    hr = self->m_pITerrainDataSource->get_ApplyToOverviewTerrain(&b_pbApply);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainDataSource->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainDataSource) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainDataSource.get_ApplyToOverviewTerrain() returned %ld", (long)hr);
        goto iterraindatasource_get_applytooverviewterrain_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pbApply = ((b_pbApply == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto iterraindatasource_get_applytooverviewterrain_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pbApply);
    goto iterraindatasource_get_applytooverviewterrain_method_cleanup;

    iterraindatasource_get_applytooverviewterrain_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pbApply
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainDataSource.get_ApplyToOverviewTerrain");
    return return_tuple;
}

static PyObject*
ITerrainDataSourceMethod_get_Embedded(PyITerrainDataSourceObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pbEmbedded = VARIANT_FALSE;
    PyObject* pyvar_pbEmbedded = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pbEmbedded

    // Call method on actual COM interface
    hr = self->m_pITerrainDataSource->get_Embedded(&b_pbEmbedded);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainDataSource->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainDataSource) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainDataSource.get_Embedded() returned %ld", (long)hr);
        goto iterraindatasource_get_embedded_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pbEmbedded = ((b_pbEmbedded == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto iterraindatasource_get_embedded_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pbEmbedded);
    goto iterraindatasource_get_embedded_method_cleanup;

    iterraindatasource_get_embedded_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pbEmbedded
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainDataSource.get_Embedded");
    return return_tuple;
}

static PyObject*
ITerrainDataSourceMethod_SetResolutionBounds(PyITerrainDataSourceObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dlowerBound = 0;
    double dupperBound = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "dd", &dlowerBound, &dupperBound))
      goto iterraindatasource_setresolutionbounds_method_cleanup;

    // Set up initial variable values as needed
    // No setup for lowerBound
    // No setup for upperBound

    // Call method on actual COM interface
    hr = self->m_pITerrainDataSource->SetResolutionBounds(dlowerBound, dupperBound);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainDataSource->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainDataSource) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainDataSource.SetResolutionBounds() returned %ld", (long)hr);
        goto iterraindatasource_setresolutionbounds_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for lowerBound
    // No teardown for upperBound

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterraindatasource_setresolutionbounds_method_cleanup;

    iterraindatasource_setresolutionbounds_method_cleanup:
    self->m_HR = hr;
    // No cleanup for lowerBound
    // No cleanup for upperBound
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainDataSource.SetResolutionBounds");
    return return_tuple;
}

static PyObject*
ITerrainDataSourceMethod_QueryResolutionBounds(PyITerrainDataSourceObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dpLowerBound = 0;
    double dpUpperBound = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pLowerBound
    // No setup for pUpperBound

    // Call method on actual COM interface
    hr = self->m_pITerrainDataSource->QueryResolutionBounds(&dpLowerBound, &dpUpperBound);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainDataSource->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainDataSource) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainDataSource.QueryResolutionBounds() returned %ld", (long)hr);
        goto iterraindatasource_queryresolutionbounds_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pLowerBound
    // No teardown for pUpperBound

    // Initialize output tuple
    return_tuple = Py_BuildValue("dd",
                                            dpLowerBound, dpUpperBound);
    goto iterraindatasource_queryresolutionbounds_method_cleanup;

    iterraindatasource_queryresolutionbounds_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pLowerBound
    // No cleanup for pUpperBound
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainDataSource.QueryResolutionBounds");
    return return_tuple;
}


PyMethodDef PyITerrainDataSourceMethods[] = {
    {"supports", (PyCFunction)PyITerrainDataSource_SupportsInterface, METH_O, ""},
    {"put_FeatureClassID", (PyCFunction)ITerrainDataSourceMethod_put_FeatureClassID, METH_VARARGS, ""},
    {"get_FeatureClassID", (PyCFunction)ITerrainDataSourceMethod_get_FeatureClassID, METH_VARARGS, ""},
    {"put_GroupID", (PyCFunction)ITerrainDataSourceMethod_put_GroupID, METH_VARARGS, ""},
    {"get_GroupID", (PyCFunction)ITerrainDataSourceMethod_get_GroupID, METH_VARARGS, ""},
    {"put_HeightField", (PyCFunction)ITerrainDataSourceMethod_put_HeightField, METH_VARARGS, ""},
    {"get_HeightField", (PyCFunction)ITerrainDataSourceMethod_get_HeightField, METH_VARARGS, ""},
    {"put_TagValueField", (PyCFunction)ITerrainDataSourceMethod_put_TagValueField, METH_VARARGS, ""},
    {"get_TagValueField", (PyCFunction)ITerrainDataSourceMethod_get_TagValueField, METH_VARARGS, ""},
    {"put_SurfaceFeatureType", (PyCFunction)ITerrainDataSourceMethod_put_SurfaceFeatureType, METH_VARARGS, ""},
    {"get_SurfaceFeatureType", (PyCFunction)ITerrainDataSourceMethod_get_SurfaceFeatureType, METH_VARARGS, ""},
    {"put_ApplyToOverviewTerrain", (PyCFunction)ITerrainDataSourceMethod_put_ApplyToOverviewTerrain, METH_VARARGS, ""},
    {"get_ApplyToOverviewTerrain", (PyCFunction)ITerrainDataSourceMethod_get_ApplyToOverviewTerrain, METH_VARARGS, ""},
    {"get_Embedded", (PyCFunction)ITerrainDataSourceMethod_get_Embedded, METH_VARARGS, ""},
    {"SetResolutionBounds", (PyCFunction)ITerrainDataSourceMethod_SetResolutionBounds, METH_VARARGS, ""},
    {"QueryResolutionBounds", (PyCFunction)ITerrainDataSourceMethod_QueryResolutionBounds, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyITerrainDataSourceGetSet[] = {
  {"_pUnk", (getter)PyITerrainDataSource_GetpUnk, NULL, "Get opaque pointer to an Unknown from ITerrainDataSource", NULL},
  {"_pointer", (getter)PyITerrainDataSource_GetPointer, NULL, "Get memory address for ITerrainDataSource", NULL},
  {"_IID", (getter)PyITerrainDataSource_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyITerrainDataSource_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyITerrainDataSource_GetIgnoreFailures, (setter)PyITerrainDataSource_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyITerrainDataSourceObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.ITerrainDataSourceObject",                          
                                              /* tp_name */
  sizeof(PyITerrainDataSourceObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyITerrainDataSourceObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyITerrainDataSourceMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyITerrainDataSourceGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyITerrainDataSourceObject_new,                      
                                              /* tp_new */
};

// Interface ITerrainPyramidLevel

typedef struct PyITerrainPyramidLevelObject {
    PyObject_HEAD
    ITerrainPyramidLevel* m_pITerrainPyramidLevel;
    HRESULT m_HR;
    int m_ignore_failures;
} PyITerrainPyramidLevelObject;

static PyObject*
PyITerrainPyramidLevelObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyITerrainPyramidLevelObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ITerrainPyramidLevel* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ITerrainPyramidLevel, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ITerrainPyramidLevel with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyITerrainPyramidLevelObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ITerrainPyramidLevel");
            return NULL;
        }
        self->m_pITerrainPyramidLevel = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ITerrainPyramidLevel");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ITerrainPyramidLevel");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ITerrainPyramidLevel* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ITerrainPyramidLevel, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ITerrainPyramidLevel");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyITerrainPyramidLevelObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ITerrainPyramidLevel");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pITerrainPyramidLevel = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyITerrainPyramidLevelObject_dealloc(PyITerrainPyramidLevelObject* self)
{
    if (self->m_pITerrainPyramidLevel)
        self->m_pITerrainPyramidLevel->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyITerrainPyramidLevel_GetpUnk(PyITerrainPyramidLevelObject* self)
{
    if (!self->m_pITerrainPyramidLevel)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pITerrainPyramidLevel->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ITerrainPyramidLevel to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyITerrainPyramidLevel_GetPointer(PyITerrainPyramidLevelObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pITerrainPyramidLevel);
}

static PyObject*
PyITerrainPyramidLevel_GetIID(PyITerrainPyramidLevelObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "9ff889cd-ee5d-4093-9bf2-8384002d01a4");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyITerrainPyramidLevel_GetHR(PyITerrainPyramidLevelObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyITerrainPyramidLevel_GetIgnoreFailures(PyITerrainPyramidLevelObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyITerrainPyramidLevel_SetIgnoreFailures(PyITerrainPyramidLevelObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyITerrainPyramidLevel_SupportsInterface(PyITerrainPyramidLevelObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pITerrainPyramidLevel->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ITerrainPyramidLevelMethod_get_PyramidType(PyITerrainPyramidLevelObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriTerrainPyramidType epType;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pType

    // Call method on actual COM interface
    hr = self->m_pITerrainPyramidLevel->get_PyramidType(&epType);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainPyramidLevel->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainPyramidLevel) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainPyramidLevel.get_PyramidType() returned %ld", (long)hr);
        goto iterrainpyramidlevel_get_pyramidtype_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pType

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)epType);
    goto iterrainpyramidlevel_get_pyramidtype_method_cleanup;

    iterrainpyramidlevel_get_pyramidtype_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pType
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainPyramidLevel.get_PyramidType");
    return return_tuple;
}

static PyObject*
ITerrainPyramidLevelMethod_put_Resolution(PyITerrainPyramidLevelObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dpResolution = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "d", &dpResolution))
      goto iterrainpyramidlevel_put_resolution_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pResolution

    // Call method on actual COM interface
    hr = self->m_pITerrainPyramidLevel->put_Resolution(dpResolution);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainPyramidLevel->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainPyramidLevel) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainPyramidLevel.put_Resolution() returned %ld", (long)hr);
        goto iterrainpyramidlevel_put_resolution_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pResolution

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterrainpyramidlevel_put_resolution_method_cleanup;

    iterrainpyramidlevel_put_resolution_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pResolution
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainPyramidLevel.put_Resolution");
    return return_tuple;
}

static PyObject*
ITerrainPyramidLevelMethod_get_Resolution(PyITerrainPyramidLevelObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dpResolution = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pResolution

    // Call method on actual COM interface
    hr = self->m_pITerrainPyramidLevel->get_Resolution(&dpResolution);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainPyramidLevel->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainPyramidLevel) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainPyramidLevel.get_Resolution() returned %ld", (long)hr);
        goto iterrainpyramidlevel_get_resolution_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pResolution

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dpResolution);
    goto iterrainpyramidlevel_get_resolution_method_cleanup;

    iterrainpyramidlevel_get_resolution_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pResolution
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainPyramidLevel.get_Resolution");
    return return_tuple;
}

static PyObject*
ITerrainPyramidLevelMethod_put_MaxScale(PyITerrainPyramidLevelObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpScale = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lpScale))
      goto iterrainpyramidlevel_put_maxscale_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pScale

    // Call method on actual COM interface
    hr = self->m_pITerrainPyramidLevel->put_MaxScale(lpScale);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainPyramidLevel->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainPyramidLevel) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainPyramidLevel.put_MaxScale() returned %ld", (long)hr);
        goto iterrainpyramidlevel_put_maxscale_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pScale

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterrainpyramidlevel_put_maxscale_method_cleanup;

    iterrainpyramidlevel_put_maxscale_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pScale
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainPyramidLevel.put_MaxScale");
    return return_tuple;
}

static PyObject*
ITerrainPyramidLevelMethod_get_MaxScale(PyITerrainPyramidLevelObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpScale = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pScale

    // Call method on actual COM interface
    hr = self->m_pITerrainPyramidLevel->get_MaxScale(&lpScale);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainPyramidLevel->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainPyramidLevel) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainPyramidLevel.get_MaxScale() returned %ld", (long)hr);
        goto iterrainpyramidlevel_get_maxscale_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pScale

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpScale);
    goto iterrainpyramidlevel_get_maxscale_method_cleanup;

    iterrainpyramidlevel_get_maxscale_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pScale
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainPyramidLevel.get_MaxScale");
    return return_tuple;
}


PyMethodDef PyITerrainPyramidLevelMethods[] = {
    {"supports", (PyCFunction)PyITerrainPyramidLevel_SupportsInterface, METH_O, ""},
    {"get_PyramidType", (PyCFunction)ITerrainPyramidLevelMethod_get_PyramidType, METH_VARARGS, ""},
    {"put_Resolution", (PyCFunction)ITerrainPyramidLevelMethod_put_Resolution, METH_VARARGS, ""},
    {"get_Resolution", (PyCFunction)ITerrainPyramidLevelMethod_get_Resolution, METH_VARARGS, ""},
    {"put_MaxScale", (PyCFunction)ITerrainPyramidLevelMethod_put_MaxScale, METH_VARARGS, ""},
    {"get_MaxScale", (PyCFunction)ITerrainPyramidLevelMethod_get_MaxScale, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyITerrainPyramidLevelGetSet[] = {
  {"_pUnk", (getter)PyITerrainPyramidLevel_GetpUnk, NULL, "Get opaque pointer to an Unknown from ITerrainPyramidLevel", NULL},
  {"_pointer", (getter)PyITerrainPyramidLevel_GetPointer, NULL, "Get memory address for ITerrainPyramidLevel", NULL},
  {"_IID", (getter)PyITerrainPyramidLevel_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyITerrainPyramidLevel_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyITerrainPyramidLevel_GetIgnoreFailures, (setter)PyITerrainPyramidLevel_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyITerrainPyramidLevelObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.ITerrainPyramidLevelObject",                          
                                              /* tp_name */
  sizeof(PyITerrainPyramidLevelObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyITerrainPyramidLevelObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyITerrainPyramidLevelMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyITerrainPyramidLevelGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyITerrainPyramidLevelObject_new,                      
                                              /* tp_new */
};

// Interface IEnumEnvelope

typedef struct PyIEnumEnvelopeObject {
    PyObject_HEAD
    IEnumEnvelope* m_pIEnumEnvelope;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIEnumEnvelopeObject;

static PyObject*
PyIEnumEnvelopeObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIEnumEnvelopeObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IEnumEnvelope* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IEnumEnvelope, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IEnumEnvelope with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIEnumEnvelopeObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IEnumEnvelope");
            return NULL;
        }
        self->m_pIEnumEnvelope = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IEnumEnvelope");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IEnumEnvelope");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IEnumEnvelope* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IEnumEnvelope, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IEnumEnvelope");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIEnumEnvelopeObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IEnumEnvelope");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIEnumEnvelope = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIEnumEnvelopeObject_dealloc(PyIEnumEnvelopeObject* self)
{
    if (self->m_pIEnumEnvelope)
        self->m_pIEnumEnvelope->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIEnumEnvelope_GetpUnk(PyIEnumEnvelopeObject* self)
{
    if (!self->m_pIEnumEnvelope)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIEnumEnvelope->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IEnumEnvelope to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIEnumEnvelope_GetPointer(PyIEnumEnvelopeObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIEnumEnvelope);
}

static PyObject*
PyIEnumEnvelope_GetIID(PyIEnumEnvelopeObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "dba7c9d4-ace6-4973-89aa-3313a7d5d853");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIEnumEnvelope_GetHR(PyIEnumEnvelopeObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIEnumEnvelope_GetIgnoreFailures(PyIEnumEnvelopeObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIEnumEnvelope_SetIgnoreFailures(PyIEnumEnvelopeObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIEnumEnvelope_SupportsInterface(PyIEnumEnvelopeObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIEnumEnvelope->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IEnumEnvelopeMethod_get_Count(PyIEnumEnvelopeObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pCount

    // Call method on actual COM interface
    hr = self->m_pIEnumEnvelope->get_Count(&lpCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIEnumEnvelope->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IEnumEnvelope) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IEnumEnvelope.get_Count() returned %ld", (long)hr);
        goto ienumenvelope_get_count_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pCount

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpCount);
    goto ienumenvelope_get_count_method_cleanup;

    ienumenvelope_get_count_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pCount
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IEnumEnvelope.get_Count");
    return return_tuple;
}

static PyObject*
IEnumEnvelopeMethod_Reset(PyIEnumEnvelopeObject* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pIEnumEnvelope->Reset();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIEnumEnvelope->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IEnumEnvelope) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IEnumEnvelope.Reset() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}

static PyObject*
IEnumEnvelopeMethod_Next(PyIEnumEnvelopeObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IEnvelope* ipppEnvelope = NULL;
    PyObject* py_ppEnvelope = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppEnvelope

    // Call method on actual COM interface
    hr = self->m_pIEnumEnvelope->Next(&ipppEnvelope);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIEnumEnvelope->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IEnumEnvelope) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IEnumEnvelope.Next() returned %ld", (long)hr);
        goto ienumenvelope_next_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppEnvelope);
    if (ipppEnvelope)
    {
        IUnknown* pUnk = NULL;
        ipppEnvelope->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppEnvelope = IUnknownToPythonIIDObject(pUnk, &IID_IEnvelope);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppEnvelope)
    {
        if (py_ppEnvelope)
           Py_DECREF(py_ppEnvelope);
        py_ppEnvelope = Py_None;
        Py_INCREF(py_ppEnvelope);
    }
    if (PyErr_Occurred())
      goto ienumenvelope_next_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppEnvelope);
    goto ienumenvelope_next_method_cleanup;

    ienumenvelope_next_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppEnvelope);
    if (ipppEnvelope)
      ipppEnvelope->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IEnumEnvelope.Next");
    return return_tuple;
}

static PyObject*
IEnumEnvelopeMethod_QueryNext(PyIEnumEnvelopeObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IEnvelope* ippEnvelope = NULL;
    PyObject* py_pEnvelope;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_pEnvelope))
      goto ienumenvelope_querynext_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pEnvelope, &IID_IEnvelope, (void**)&ippEnvelope))
        PyErr_SetString(PyExc_TypeError, "Argument pEnvelope (position 0) is not IEnvelope");
    
    if (PyErr_Occurred())
      goto ienumenvelope_querynext_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIEnumEnvelope->QueryNext(ippEnvelope);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIEnumEnvelope->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IEnumEnvelope) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IEnumEnvelope.QueryNext() returned %ld", (long)hr);
        goto ienumenvelope_querynext_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pEnvelope

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ienumenvelope_querynext_method_cleanup;

    ienumenvelope_querynext_method_cleanup:
    self->m_HR = hr;
    if (ippEnvelope)
      ippEnvelope->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IEnumEnvelope.QueryNext");
    return return_tuple;
}


PyMethodDef PyIEnumEnvelopeMethods[] = {
    {"supports", (PyCFunction)PyIEnumEnvelope_SupportsInterface, METH_O, ""},
    {"get_Count", (PyCFunction)IEnumEnvelopeMethod_get_Count, METH_VARARGS, ""},
    {"Reset", (PyCFunction)IEnumEnvelopeMethod_Reset, METH_NOARGS, ""},
    {"Next", (PyCFunction)IEnumEnvelopeMethod_Next, METH_VARARGS, ""},
    {"QueryNext", (PyCFunction)IEnumEnvelopeMethod_QueryNext, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIEnumEnvelopeGetSet[] = {
  {"_pUnk", (getter)PyIEnumEnvelope_GetpUnk, NULL, "Get opaque pointer to an Unknown from IEnumEnvelope", NULL},
  {"_pointer", (getter)PyIEnumEnvelope_GetPointer, NULL, "Get memory address for IEnumEnvelope", NULL},
  {"_IID", (getter)PyIEnumEnvelope_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIEnumEnvelope_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIEnumEnvelope_GetIgnoreFailures, (setter)PyIEnumEnvelope_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIEnumEnvelopeObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.IEnumEnvelopeObject",                          
                                              /* tp_name */
  sizeof(PyIEnumEnvelopeObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIEnumEnvelopeObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIEnumEnvelopeMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIEnumEnvelopeGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIEnumEnvelopeObject_new,                      
                                              /* tp_new */
};

// Interface ITerrainEdit

typedef struct PyITerrainEditObject {
    PyObject_HEAD
    ITerrainEdit* m_pITerrainEdit;
    HRESULT m_HR;
    int m_ignore_failures;
} PyITerrainEditObject;

static PyObject*
PyITerrainEditObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyITerrainEditObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ITerrainEdit* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ITerrainEdit, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ITerrainEdit with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyITerrainEditObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ITerrainEdit");
            return NULL;
        }
        self->m_pITerrainEdit = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ITerrainEdit");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ITerrainEdit");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ITerrainEdit* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ITerrainEdit, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ITerrainEdit");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyITerrainEditObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ITerrainEdit");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pITerrainEdit = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyITerrainEditObject_dealloc(PyITerrainEditObject* self)
{
    if (self->m_pITerrainEdit)
        self->m_pITerrainEdit->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyITerrainEdit_GetpUnk(PyITerrainEditObject* self)
{
    if (!self->m_pITerrainEdit)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pITerrainEdit->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ITerrainEdit to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyITerrainEdit_GetPointer(PyITerrainEditObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pITerrainEdit);
}

static PyObject*
PyITerrainEdit_GetIID(PyITerrainEditObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "8e9c9736-60b1-4db5-af18-ed40f41d4714");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyITerrainEdit_GetHR(PyITerrainEditObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyITerrainEdit_GetIgnoreFailures(PyITerrainEditObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyITerrainEdit_SetIgnoreFailures(PyITerrainEditObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyITerrainEdit_SupportsInterface(PyITerrainEditObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pITerrainEdit->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ITerrainEditMethod_AddDataSource(PyITerrainEditObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ITerrainDataSource* ippDataSource = NULL;
    PyObject* py_pDataSource;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_pDataSource))
      goto iterrainedit_adddatasource_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pDataSource, &IID_ITerrainDataSource, (void**)&ippDataSource))
        PyErr_SetString(PyExc_TypeError, "Argument pDataSource (position 0) is not ITerrainDataSource");
    
    if (PyErr_Occurred())
      goto iterrainedit_adddatasource_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITerrainEdit->AddDataSource(ippDataSource);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainEdit->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainEdit) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainEdit.AddDataSource() returned %ld", (long)hr);
        goto iterrainedit_adddatasource_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pDataSource

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterrainedit_adddatasource_method_cleanup;

    iterrainedit_adddatasource_method_cleanup:
    self->m_HR = hr;
    if (ippDataSource)
      ippDataSource->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainEdit.AddDataSource");
    return return_tuple;
}

static PyObject*
ITerrainEditMethod_RemoveDataSource(PyITerrainEditObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lindex))
      goto iterrainedit_removedatasource_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index

    // Call method on actual COM interface
    hr = self->m_pITerrainEdit->RemoveDataSource(lindex);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainEdit->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainEdit) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainEdit.RemoveDataSource() returned %ld", (long)hr);
        goto iterrainedit_removedatasource_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterrainedit_removedatasource_method_cleanup;

    iterrainedit_removedatasource_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainEdit.RemoveDataSource");
    return return_tuple;
}

static PyObject*
ITerrainEditMethod_AddPyramidLevel(PyITerrainEditObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ITerrainPyramidLevel* ippPyramidLevel = NULL;
    PyObject* py_pPyramidLevel;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_pPyramidLevel))
      goto iterrainedit_addpyramidlevel_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pPyramidLevel, &IID_ITerrainPyramidLevel, (void**)&ippPyramidLevel))
        PyErr_SetString(PyExc_TypeError, "Argument pPyramidLevel (position 0) is not ITerrainPyramidLevel");
    
    if (PyErr_Occurred())
      goto iterrainedit_addpyramidlevel_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITerrainEdit->AddPyramidLevel(ippPyramidLevel);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainEdit->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainEdit) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainEdit.AddPyramidLevel() returned %ld", (long)hr);
        goto iterrainedit_addpyramidlevel_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pPyramidLevel

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterrainedit_addpyramidlevel_method_cleanup;

    iterrainedit_addpyramidlevel_method_cleanup:
    self->m_HR = hr;
    if (ippPyramidLevel)
      ippPyramidLevel->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainEdit.AddPyramidLevel");
    return return_tuple;
}

static PyObject*
ITerrainEditMethod_RemovePyramidLevel(PyITerrainEditObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lindex))
      goto iterrainedit_removepyramidlevel_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index

    // Call method on actual COM interface
    hr = self->m_pITerrainEdit->RemovePyramidLevel(lindex);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainEdit->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainEdit) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainEdit.RemovePyramidLevel() returned %ld", (long)hr);
        goto iterrainedit_removepyramidlevel_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterrainedit_removepyramidlevel_method_cleanup;

    iterrainedit_removepyramidlevel_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainEdit.RemovePyramidLevel");
    return return_tuple;
}

static PyObject*
ITerrainEditMethod_ChangeMaxScale(PyITerrainEditObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;
    long lnewScale = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "ll", &lindex, &lnewScale))
      goto iterrainedit_changemaxscale_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index
    // No setup for newScale

    // Call method on actual COM interface
    hr = self->m_pITerrainEdit->ChangeMaxScale(lindex, lnewScale);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainEdit->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainEdit) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainEdit.ChangeMaxScale() returned %ld", (long)hr);
        goto iterrainedit_changemaxscale_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index
    // No teardown for newScale

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterrainedit_changemaxscale_method_cleanup;

    iterrainedit_changemaxscale_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    // No cleanup for newScale
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainEdit.ChangeMaxScale");
    return return_tuple;
}

static PyObject*
ITerrainEditMethod_ChangeResolutionBounds(PyITerrainEditObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;
    double dlowerBound = 0;
    double dupperBound = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "ldd", &lindex, &dlowerBound, &dupperBound))
      goto iterrainedit_changeresolutionbounds_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index
    // No setup for lowerBound
    // No setup for upperBound

    // Call method on actual COM interface
    hr = self->m_pITerrainEdit->ChangeResolutionBounds(lindex, dlowerBound, dupperBound);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainEdit->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainEdit) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainEdit.ChangeResolutionBounds() returned %ld", (long)hr);
        goto iterrainedit_changeresolutionbounds_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index
    // No teardown for lowerBound
    // No teardown for upperBound

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterrainedit_changeresolutionbounds_method_cleanup;

    iterrainedit_changeresolutionbounds_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    // No cleanup for lowerBound
    // No cleanup for upperBound
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainEdit.ChangeResolutionBounds");
    return return_tuple;
}

static PyObject*
ITerrainEditMethod_DeleteDataSourceData(PyITerrainEditObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;
    IEnvelope* ippAOI = NULL;
    PyObject* py_pAOI;
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;

    // Unpack values
    if (!PyArg_ParseTuple(args, "lOO", &lindex, &py_pAOI, &py_pTrackCancel))
      goto iterrainedit_deletedatasourcedata_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index
    if (!IFaceFromPyObject(py_pAOI, &IID_IEnvelope, (void**)&ippAOI))
        PyErr_SetString(PyExc_TypeError, "Argument pAOI (position 1) is not IEnvelope");
    
    if (PyErr_Occurred())
      goto iterrainedit_deletedatasourcedata_method_cleanup;
    
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 2) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto iterrainedit_deletedatasourcedata_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITerrainEdit->DeleteDataSourceData(lindex, ippAOI, ippTrackCancel);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainEdit->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainEdit) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainEdit.DeleteDataSourceData() returned %ld", (long)hr);
        goto iterrainedit_deletedatasourcedata_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index
    // No teardown for pAOI
    // No teardown for pTrackCancel

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterrainedit_deletedatasourcedata_method_cleanup;

    iterrainedit_deletedatasourcedata_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    if (ippAOI)
      ippAOI->Release();
    if (ippTrackCancel)
      ippTrackCancel->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainEdit.DeleteDataSourceData");
    return return_tuple;
}

static PyObject*
ITerrainEditMethod_AddDataSourceData(PyITerrainEditObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;
    IEnvelope* ippAOI = NULL;
    PyObject* py_pAOI;
    IFeatureClass* ippInFC = NULL;
    PyObject* py_pInFC;
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;

    // Unpack values
    if (!PyArg_ParseTuple(args, "lOOO", &lindex, &py_pAOI, &py_pInFC, &py_pTrackCancel))
      goto iterrainedit_adddatasourcedata_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index
    if (!IFaceFromPyObject(py_pAOI, &IID_IEnvelope, (void**)&ippAOI))
        PyErr_SetString(PyExc_TypeError, "Argument pAOI (position 1) is not IEnvelope");
    
    if (PyErr_Occurred())
      goto iterrainedit_adddatasourcedata_method_cleanup;
    
    if (!IFaceFromPyObject(py_pInFC, &IID_IFeatureClass, (void**)&ippInFC))
        PyErr_SetString(PyExc_TypeError, "Argument pInFC (position 2) is not IFeatureClass");
    
    if (PyErr_Occurred())
      goto iterrainedit_adddatasourcedata_method_cleanup;
    
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 3) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto iterrainedit_adddatasourcedata_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITerrainEdit->AddDataSourceData(lindex, ippAOI, ippInFC, ippTrackCancel);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainEdit->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainEdit) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainEdit.AddDataSourceData() returned %ld", (long)hr);
        goto iterrainedit_adddatasourcedata_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index
    // No teardown for pAOI
    // No teardown for pInFC
    // No teardown for pTrackCancel

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterrainedit_adddatasourcedata_method_cleanup;

    iterrainedit_adddatasourcedata_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    if (ippAOI)
      ippAOI->Release();
    if (ippInFC)
      ippInFC->Release();
    if (ippTrackCancel)
      ippTrackCancel->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainEdit.AddDataSourceData");
    return return_tuple;
}

static PyObject*
ITerrainEditMethod_ReplaceDataSourceData(PyITerrainEditObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;
    IEnvelope* ippAOI = NULL;
    PyObject* py_pAOI;
    IFeatureClass* ippInFC = NULL;
    PyObject* py_pInFC;
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;

    // Unpack values
    if (!PyArg_ParseTuple(args, "lOOO", &lindex, &py_pAOI, &py_pInFC, &py_pTrackCancel))
      goto iterrainedit_replacedatasourcedata_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index
    if (!IFaceFromPyObject(py_pAOI, &IID_IEnvelope, (void**)&ippAOI))
        PyErr_SetString(PyExc_TypeError, "Argument pAOI (position 1) is not IEnvelope");
    
    if (PyErr_Occurred())
      goto iterrainedit_replacedatasourcedata_method_cleanup;
    
    if (!IFaceFromPyObject(py_pInFC, &IID_IFeatureClass, (void**)&ippInFC))
        PyErr_SetString(PyExc_TypeError, "Argument pInFC (position 2) is not IFeatureClass");
    
    if (PyErr_Occurred())
      goto iterrainedit_replacedatasourcedata_method_cleanup;
    
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 3) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto iterrainedit_replacedatasourcedata_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITerrainEdit->ReplaceDataSourceData(lindex, ippAOI, ippInFC, ippTrackCancel);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainEdit->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainEdit) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainEdit.ReplaceDataSourceData() returned %ld", (long)hr);
        goto iterrainedit_replacedatasourcedata_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index
    // No teardown for pAOI
    // No teardown for pInFC
    // No teardown for pTrackCancel

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterrainedit_replacedatasourcedata_method_cleanup;

    iterrainedit_replacedatasourcedata_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    if (ippAOI)
      ippAOI->Release();
    if (ippInFC)
      ippInFC->Release();
    if (ippTrackCancel)
      ippTrackCancel->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainEdit.ReplaceDataSourceData");
    return return_tuple;
}

static PyObject*
ITerrainEditMethod_Build(PyITerrainEditObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_pTrackCancel))
      goto iterrainedit_build_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 0) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto iterrainedit_build_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITerrainEdit->Build(ippTrackCancel);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainEdit->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainEdit) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainEdit.Build() returned %ld", (long)hr);
        goto iterrainedit_build_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pTrackCancel

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterrainedit_build_method_cleanup;

    iterrainedit_build_method_cleanup:
    self->m_HR = hr;
    if (ippTrackCancel)
      ippTrackCancel->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainEdit.Build");
    return return_tuple;
}


PyMethodDef PyITerrainEditMethods[] = {
    {"supports", (PyCFunction)PyITerrainEdit_SupportsInterface, METH_O, ""},
    {"AddDataSource", (PyCFunction)ITerrainEditMethod_AddDataSource, METH_VARARGS, ""},
    {"RemoveDataSource", (PyCFunction)ITerrainEditMethod_RemoveDataSource, METH_VARARGS, ""},
    {"AddPyramidLevel", (PyCFunction)ITerrainEditMethod_AddPyramidLevel, METH_VARARGS, ""},
    {"RemovePyramidLevel", (PyCFunction)ITerrainEditMethod_RemovePyramidLevel, METH_VARARGS, ""},
    {"ChangeMaxScale", (PyCFunction)ITerrainEditMethod_ChangeMaxScale, METH_VARARGS, ""},
    {"ChangeResolutionBounds", (PyCFunction)ITerrainEditMethod_ChangeResolutionBounds, METH_VARARGS, ""},
    {"DeleteDataSourceData", (PyCFunction)ITerrainEditMethod_DeleteDataSourceData, METH_VARARGS, ""},
    {"AddDataSourceData", (PyCFunction)ITerrainEditMethod_AddDataSourceData, METH_VARARGS, ""},
    {"ReplaceDataSourceData", (PyCFunction)ITerrainEditMethod_ReplaceDataSourceData, METH_VARARGS, ""},
    {"Build", (PyCFunction)ITerrainEditMethod_Build, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyITerrainEditGetSet[] = {
  {"_pUnk", (getter)PyITerrainEdit_GetpUnk, NULL, "Get opaque pointer to an Unknown from ITerrainEdit", NULL},
  {"_pointer", (getter)PyITerrainEdit_GetPointer, NULL, "Get memory address for ITerrainEdit", NULL},
  {"_IID", (getter)PyITerrainEdit_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyITerrainEdit_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyITerrainEdit_GetIgnoreFailures, (setter)PyITerrainEdit_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyITerrainEditObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.ITerrainEditObject",                          
                                              /* tp_name */
  sizeof(PyITerrainEditObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyITerrainEditObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyITerrainEditMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyITerrainEditGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyITerrainEditObject_new,                      
                                              /* tp_new */
};

// Interface ITerrainEdit2

typedef struct PyITerrainEdit2Object {
    PyObject_HEAD
    ITerrainEdit2* m_pITerrainEdit2;
    HRESULT m_HR;
    int m_ignore_failures;
} PyITerrainEdit2Object;

static PyObject*
PyITerrainEdit2Object_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyITerrainEdit2Object* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ITerrainEdit2* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ITerrainEdit2, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ITerrainEdit2 with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyITerrainEdit2Object *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ITerrainEdit2");
            return NULL;
        }
        self->m_pITerrainEdit2 = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ITerrainEdit2");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ITerrainEdit2");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ITerrainEdit2* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ITerrainEdit2, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ITerrainEdit2");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyITerrainEdit2Object *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ITerrainEdit2");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pITerrainEdit2 = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyITerrainEdit2Object_dealloc(PyITerrainEdit2Object* self)
{
    if (self->m_pITerrainEdit2)
        self->m_pITerrainEdit2->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyITerrainEdit2_GetpUnk(PyITerrainEdit2Object* self)
{
    if (!self->m_pITerrainEdit2)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pITerrainEdit2->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ITerrainEdit2 to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyITerrainEdit2_GetPointer(PyITerrainEdit2Object* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pITerrainEdit2);
}

static PyObject*
PyITerrainEdit2_GetIID(PyITerrainEdit2Object* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "ed9009eb-18f0-436e-9385-0f0007dd1f90");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyITerrainEdit2_GetHR(PyITerrainEdit2Object* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyITerrainEdit2_GetIgnoreFailures(PyITerrainEdit2Object* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyITerrainEdit2_SetIgnoreFailures(PyITerrainEdit2Object* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyITerrainEdit2_SupportsInterface(PyITerrainEdit2Object* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pITerrainEdit2->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ITerrainEdit2Method_UpdateExtent(PyITerrainEdit2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_pTrackCancel))
      goto iterrainedit2_updateextent_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 0) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto iterrainedit2_updateextent_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITerrainEdit2->UpdateExtent(ippTrackCancel);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainEdit2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainEdit2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainEdit2.UpdateExtent() returned %ld", (long)hr);
        goto iterrainedit2_updateextent_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pTrackCancel

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterrainedit2_updateextent_method_cleanup;

    iterrainedit2_updateextent_method_cleanup:
    self->m_HR = hr;
    if (ippTrackCancel)
      ippTrackCancel->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainEdit2.UpdateExtent");
    return return_tuple;
}

static PyObject*
ITerrainEdit2Method_AddDataSource(PyITerrainEdit2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ITerrainDataSource* ippDataSource = NULL;
    PyObject* py_pDataSource;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_pDataSource))
      goto iterrainedit2_adddatasource_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pDataSource, &IID_ITerrainDataSource, (void**)&ippDataSource))
        PyErr_SetString(PyExc_TypeError, "Argument pDataSource (position 0) is not ITerrainDataSource");
    
    if (PyErr_Occurred())
      goto iterrainedit2_adddatasource_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITerrainEdit2->AddDataSource(ippDataSource);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainEdit2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainEdit2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainEdit2.AddDataSource() returned %ld", (long)hr);
        goto iterrainedit2_adddatasource_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pDataSource

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterrainedit2_adddatasource_method_cleanup;

    iterrainedit2_adddatasource_method_cleanup:
    self->m_HR = hr;
    if (ippDataSource)
      ippDataSource->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainEdit2.AddDataSource");
    return return_tuple;
}

static PyObject*
ITerrainEdit2Method_RemoveDataSource(PyITerrainEdit2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lindex))
      goto iterrainedit2_removedatasource_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index

    // Call method on actual COM interface
    hr = self->m_pITerrainEdit2->RemoveDataSource(lindex);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainEdit2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainEdit2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainEdit2.RemoveDataSource() returned %ld", (long)hr);
        goto iterrainedit2_removedatasource_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterrainedit2_removedatasource_method_cleanup;

    iterrainedit2_removedatasource_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainEdit2.RemoveDataSource");
    return return_tuple;
}

static PyObject*
ITerrainEdit2Method_AddPyramidLevel(PyITerrainEdit2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ITerrainPyramidLevel* ippPyramidLevel = NULL;
    PyObject* py_pPyramidLevel;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_pPyramidLevel))
      goto iterrainedit2_addpyramidlevel_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pPyramidLevel, &IID_ITerrainPyramidLevel, (void**)&ippPyramidLevel))
        PyErr_SetString(PyExc_TypeError, "Argument pPyramidLevel (position 0) is not ITerrainPyramidLevel");
    
    if (PyErr_Occurred())
      goto iterrainedit2_addpyramidlevel_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITerrainEdit2->AddPyramidLevel(ippPyramidLevel);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainEdit2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainEdit2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainEdit2.AddPyramidLevel() returned %ld", (long)hr);
        goto iterrainedit2_addpyramidlevel_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pPyramidLevel

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterrainedit2_addpyramidlevel_method_cleanup;

    iterrainedit2_addpyramidlevel_method_cleanup:
    self->m_HR = hr;
    if (ippPyramidLevel)
      ippPyramidLevel->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainEdit2.AddPyramidLevel");
    return return_tuple;
}

static PyObject*
ITerrainEdit2Method_RemovePyramidLevel(PyITerrainEdit2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lindex))
      goto iterrainedit2_removepyramidlevel_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index

    // Call method on actual COM interface
    hr = self->m_pITerrainEdit2->RemovePyramidLevel(lindex);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainEdit2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainEdit2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainEdit2.RemovePyramidLevel() returned %ld", (long)hr);
        goto iterrainedit2_removepyramidlevel_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterrainedit2_removepyramidlevel_method_cleanup;

    iterrainedit2_removepyramidlevel_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainEdit2.RemovePyramidLevel");
    return return_tuple;
}

static PyObject*
ITerrainEdit2Method_ChangeMaxScale(PyITerrainEdit2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;
    long lnewScale = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "ll", &lindex, &lnewScale))
      goto iterrainedit2_changemaxscale_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index
    // No setup for newScale

    // Call method on actual COM interface
    hr = self->m_pITerrainEdit2->ChangeMaxScale(lindex, lnewScale);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainEdit2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainEdit2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainEdit2.ChangeMaxScale() returned %ld", (long)hr);
        goto iterrainedit2_changemaxscale_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index
    // No teardown for newScale

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterrainedit2_changemaxscale_method_cleanup;

    iterrainedit2_changemaxscale_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    // No cleanup for newScale
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainEdit2.ChangeMaxScale");
    return return_tuple;
}

static PyObject*
ITerrainEdit2Method_ChangeResolutionBounds(PyITerrainEdit2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;
    double dlowerBound = 0;
    double dupperBound = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "ldd", &lindex, &dlowerBound, &dupperBound))
      goto iterrainedit2_changeresolutionbounds_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index
    // No setup for lowerBound
    // No setup for upperBound

    // Call method on actual COM interface
    hr = self->m_pITerrainEdit2->ChangeResolutionBounds(lindex, dlowerBound, dupperBound);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainEdit2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainEdit2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainEdit2.ChangeResolutionBounds() returned %ld", (long)hr);
        goto iterrainedit2_changeresolutionbounds_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index
    // No teardown for lowerBound
    // No teardown for upperBound

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterrainedit2_changeresolutionbounds_method_cleanup;

    iterrainedit2_changeresolutionbounds_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    // No cleanup for lowerBound
    // No cleanup for upperBound
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainEdit2.ChangeResolutionBounds");
    return return_tuple;
}

static PyObject*
ITerrainEdit2Method_DeleteDataSourceData(PyITerrainEdit2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;
    IEnvelope* ippAOI = NULL;
    PyObject* py_pAOI;
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;

    // Unpack values
    if (!PyArg_ParseTuple(args, "lOO", &lindex, &py_pAOI, &py_pTrackCancel))
      goto iterrainedit2_deletedatasourcedata_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index
    if (!IFaceFromPyObject(py_pAOI, &IID_IEnvelope, (void**)&ippAOI))
        PyErr_SetString(PyExc_TypeError, "Argument pAOI (position 1) is not IEnvelope");
    
    if (PyErr_Occurred())
      goto iterrainedit2_deletedatasourcedata_method_cleanup;
    
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 2) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto iterrainedit2_deletedatasourcedata_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITerrainEdit2->DeleteDataSourceData(lindex, ippAOI, ippTrackCancel);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainEdit2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainEdit2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainEdit2.DeleteDataSourceData() returned %ld", (long)hr);
        goto iterrainedit2_deletedatasourcedata_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index
    // No teardown for pAOI
    // No teardown for pTrackCancel

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterrainedit2_deletedatasourcedata_method_cleanup;

    iterrainedit2_deletedatasourcedata_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    if (ippAOI)
      ippAOI->Release();
    if (ippTrackCancel)
      ippTrackCancel->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainEdit2.DeleteDataSourceData");
    return return_tuple;
}

static PyObject*
ITerrainEdit2Method_AddDataSourceData(PyITerrainEdit2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;
    IEnvelope* ippAOI = NULL;
    PyObject* py_pAOI;
    IFeatureClass* ippInFC = NULL;
    PyObject* py_pInFC;
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;

    // Unpack values
    if (!PyArg_ParseTuple(args, "lOOO", &lindex, &py_pAOI, &py_pInFC, &py_pTrackCancel))
      goto iterrainedit2_adddatasourcedata_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index
    if (!IFaceFromPyObject(py_pAOI, &IID_IEnvelope, (void**)&ippAOI))
        PyErr_SetString(PyExc_TypeError, "Argument pAOI (position 1) is not IEnvelope");
    
    if (PyErr_Occurred())
      goto iterrainedit2_adddatasourcedata_method_cleanup;
    
    if (!IFaceFromPyObject(py_pInFC, &IID_IFeatureClass, (void**)&ippInFC))
        PyErr_SetString(PyExc_TypeError, "Argument pInFC (position 2) is not IFeatureClass");
    
    if (PyErr_Occurred())
      goto iterrainedit2_adddatasourcedata_method_cleanup;
    
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 3) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto iterrainedit2_adddatasourcedata_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITerrainEdit2->AddDataSourceData(lindex, ippAOI, ippInFC, ippTrackCancel);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainEdit2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainEdit2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainEdit2.AddDataSourceData() returned %ld", (long)hr);
        goto iterrainedit2_adddatasourcedata_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index
    // No teardown for pAOI
    // No teardown for pInFC
    // No teardown for pTrackCancel

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterrainedit2_adddatasourcedata_method_cleanup;

    iterrainedit2_adddatasourcedata_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    if (ippAOI)
      ippAOI->Release();
    if (ippInFC)
      ippInFC->Release();
    if (ippTrackCancel)
      ippTrackCancel->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainEdit2.AddDataSourceData");
    return return_tuple;
}

static PyObject*
ITerrainEdit2Method_ReplaceDataSourceData(PyITerrainEdit2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;
    IEnvelope* ippAOI = NULL;
    PyObject* py_pAOI;
    IFeatureClass* ippInFC = NULL;
    PyObject* py_pInFC;
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;

    // Unpack values
    if (!PyArg_ParseTuple(args, "lOOO", &lindex, &py_pAOI, &py_pInFC, &py_pTrackCancel))
      goto iterrainedit2_replacedatasourcedata_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index
    if (!IFaceFromPyObject(py_pAOI, &IID_IEnvelope, (void**)&ippAOI))
        PyErr_SetString(PyExc_TypeError, "Argument pAOI (position 1) is not IEnvelope");
    
    if (PyErr_Occurred())
      goto iterrainedit2_replacedatasourcedata_method_cleanup;
    
    if (!IFaceFromPyObject(py_pInFC, &IID_IFeatureClass, (void**)&ippInFC))
        PyErr_SetString(PyExc_TypeError, "Argument pInFC (position 2) is not IFeatureClass");
    
    if (PyErr_Occurred())
      goto iterrainedit2_replacedatasourcedata_method_cleanup;
    
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 3) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto iterrainedit2_replacedatasourcedata_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITerrainEdit2->ReplaceDataSourceData(lindex, ippAOI, ippInFC, ippTrackCancel);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainEdit2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainEdit2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainEdit2.ReplaceDataSourceData() returned %ld", (long)hr);
        goto iterrainedit2_replacedatasourcedata_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index
    // No teardown for pAOI
    // No teardown for pInFC
    // No teardown for pTrackCancel

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterrainedit2_replacedatasourcedata_method_cleanup;

    iterrainedit2_replacedatasourcedata_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    if (ippAOI)
      ippAOI->Release();
    if (ippInFC)
      ippInFC->Release();
    if (ippTrackCancel)
      ippTrackCancel->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainEdit2.ReplaceDataSourceData");
    return return_tuple;
}

static PyObject*
ITerrainEdit2Method_Build(PyITerrainEdit2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_pTrackCancel))
      goto iterrainedit2_build_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 0) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto iterrainedit2_build_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITerrainEdit2->Build(ippTrackCancel);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainEdit2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainEdit2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainEdit2.Build() returned %ld", (long)hr);
        goto iterrainedit2_build_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pTrackCancel

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterrainedit2_build_method_cleanup;

    iterrainedit2_build_method_cleanup:
    self->m_HR = hr;
    if (ippTrackCancel)
      ippTrackCancel->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainEdit2.Build");
    return return_tuple;
}


PyMethodDef PyITerrainEdit2Methods[] = {
    {"supports", (PyCFunction)PyITerrainEdit2_SupportsInterface, METH_O, ""},
    {"UpdateExtent", (PyCFunction)ITerrainEdit2Method_UpdateExtent, METH_VARARGS, ""},
    {"AddDataSource", (PyCFunction)ITerrainEdit2Method_AddDataSource, METH_VARARGS, ""},
    {"RemoveDataSource", (PyCFunction)ITerrainEdit2Method_RemoveDataSource, METH_VARARGS, ""},
    {"AddPyramidLevel", (PyCFunction)ITerrainEdit2Method_AddPyramidLevel, METH_VARARGS, ""},
    {"RemovePyramidLevel", (PyCFunction)ITerrainEdit2Method_RemovePyramidLevel, METH_VARARGS, ""},
    {"ChangeMaxScale", (PyCFunction)ITerrainEdit2Method_ChangeMaxScale, METH_VARARGS, ""},
    {"ChangeResolutionBounds", (PyCFunction)ITerrainEdit2Method_ChangeResolutionBounds, METH_VARARGS, ""},
    {"DeleteDataSourceData", (PyCFunction)ITerrainEdit2Method_DeleteDataSourceData, METH_VARARGS, ""},
    {"AddDataSourceData", (PyCFunction)ITerrainEdit2Method_AddDataSourceData, METH_VARARGS, ""},
    {"ReplaceDataSourceData", (PyCFunction)ITerrainEdit2Method_ReplaceDataSourceData, METH_VARARGS, ""},
    {"Build", (PyCFunction)ITerrainEdit2Method_Build, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyITerrainEdit2GetSet[] = {
  {"_pUnk", (getter)PyITerrainEdit2_GetpUnk, NULL, "Get opaque pointer to an Unknown from ITerrainEdit2", NULL},
  {"_pointer", (getter)PyITerrainEdit2_GetPointer, NULL, "Get memory address for ITerrainEdit2", NULL},
  {"_IID", (getter)PyITerrainEdit2_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyITerrainEdit2_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyITerrainEdit2_GetIgnoreFailures, (setter)PyITerrainEdit2_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyITerrainEdit2Object_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.ITerrainEdit2Object",                          
                                              /* tp_name */
  sizeof(PyITerrainEdit2Object),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyITerrainEdit2Object_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyITerrainEdit2Methods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyITerrainEdit2GetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyITerrainEdit2Object_new,                      
                                              /* tp_new */
};

// Interface ITerrainEdit3

typedef struct PyITerrainEdit3Object {
    PyObject_HEAD
    ITerrainEdit3* m_pITerrainEdit3;
    HRESULT m_HR;
    int m_ignore_failures;
} PyITerrainEdit3Object;

static PyObject*
PyITerrainEdit3Object_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyITerrainEdit3Object* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ITerrainEdit3* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ITerrainEdit3, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ITerrainEdit3 with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyITerrainEdit3Object *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ITerrainEdit3");
            return NULL;
        }
        self->m_pITerrainEdit3 = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ITerrainEdit3");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ITerrainEdit3");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ITerrainEdit3* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ITerrainEdit3, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ITerrainEdit3");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyITerrainEdit3Object *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ITerrainEdit3");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pITerrainEdit3 = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyITerrainEdit3Object_dealloc(PyITerrainEdit3Object* self)
{
    if (self->m_pITerrainEdit3)
        self->m_pITerrainEdit3->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyITerrainEdit3_GetpUnk(PyITerrainEdit3Object* self)
{
    if (!self->m_pITerrainEdit3)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pITerrainEdit3->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ITerrainEdit3 to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyITerrainEdit3_GetPointer(PyITerrainEdit3Object* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pITerrainEdit3);
}

static PyObject*
PyITerrainEdit3_GetIID(PyITerrainEdit3Object* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "a7e67808-29d5-4dd9-8696-06993fa838b4");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyITerrainEdit3_GetHR(PyITerrainEdit3Object* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyITerrainEdit3_GetIgnoreFailures(PyITerrainEdit3Object* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyITerrainEdit3_SetIgnoreFailures(PyITerrainEdit3Object* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyITerrainEdit3_SupportsInterface(PyITerrainEdit3Object* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pITerrainEdit3->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ITerrainEdit3Method_ChangeUsageInOverview(PyITerrainEdit3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;
    VARIANT_BOOL b_bApply = VARIANT_FALSE;
    PyObject* pyvar_bApply = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "lO", &lindex, &pyvar_bApply))
      goto iterrainedit3_changeusageinoverview_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index
    b_bApply = ((PyObject_IsTrue(pyvar_bApply) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iterrainedit3_changeusageinoverview_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITerrainEdit3->ChangeUsageInOverview(lindex, b_bApply);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainEdit3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainEdit3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainEdit3.ChangeUsageInOverview() returned %ld", (long)hr);
        goto iterrainedit3_changeusageinoverview_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index
    // No teardown for bApply

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterrainedit3_changeusageinoverview_method_cleanup;

    iterrainedit3_changeusageinoverview_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    // No cleanup for bApply
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainEdit3.ChangeUsageInOverview");
    return return_tuple;
}

static PyObject*
ITerrainEdit3Method_DeleteDataSourceDataByFC(PyITerrainEdit3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;
    BSTR bspointCountFieldName = 0;
    PyObject* pyvar_pointCountFieldName;
    PyObject* unicodepointCountFieldName = NULL;
    IFeatureClass* ippFC = NULL;
    PyObject* py_pFC;
    VARIANT_BOOL b_bSparseData = VARIANT_FALSE;
    PyObject* pyvar_bSparseData = NULL;
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;

    // Unpack values
    if (!PyArg_ParseTuple(args, "lOOOO", &lindex, &pyvar_pointCountFieldName, &py_pFC, &pyvar_bSparseData, &py_pTrackCancel))
      goto iterrainedit3_deletedatasourcedatabyfc_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index
    if (PyString_Check(pyvar_pointCountFieldName))
        unicodepointCountFieldName = PyUnicode_FromObject(pyvar_pointCountFieldName);
    else if (PyUnicode_Check(pyvar_pointCountFieldName))
    {
        unicodepointCountFieldName = pyvar_pointCountFieldName;
        Py_INCREF(unicodepointCountFieldName);
    }
    else if (pyvar_pointCountFieldName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter pointCountFieldName at index 1");
    if (unicodepointCountFieldName)
        bspointCountFieldName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodepointCountFieldName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodepointCountFieldName));
    
    if (PyErr_Occurred())
      goto iterrainedit3_deletedatasourcedatabyfc_method_cleanup;
    
    if (!IFaceFromPyObject(py_pFC, &IID_IFeatureClass, (void**)&ippFC))
        PyErr_SetString(PyExc_TypeError, "Argument pFC (position 2) is not IFeatureClass");
    
    if (PyErr_Occurred())
      goto iterrainedit3_deletedatasourcedatabyfc_method_cleanup;
    
    b_bSparseData = ((PyObject_IsTrue(pyvar_bSparseData) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iterrainedit3_deletedatasourcedatabyfc_method_cleanup;
    
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 4) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto iterrainedit3_deletedatasourcedatabyfc_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITerrainEdit3->DeleteDataSourceDataByFC(lindex, bspointCountFieldName, ippFC, b_bSparseData, ippTrackCancel);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainEdit3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainEdit3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainEdit3.DeleteDataSourceDataByFC() returned %ld", (long)hr);
        goto iterrainedit3_deletedatasourcedatabyfc_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index
    // No teardown for pointCountFieldName
    // No teardown for pFC
    // No teardown for bSparseData
    // No teardown for pTrackCancel

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterrainedit3_deletedatasourcedatabyfc_method_cleanup;

    iterrainedit3_deletedatasourcedatabyfc_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    if (bspointCountFieldName)
        ::SysFreeString(bspointCountFieldName);
    
    if (ippFC)
      ippFC->Release();
    // No cleanup for bSparseData
    if (ippTrackCancel)
      ippTrackCancel->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainEdit3.DeleteDataSourceDataByFC");
    return return_tuple;
}

static PyObject*
ITerrainEdit3Method_DeleteDataSourceData2(PyITerrainEdit3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;
    BSTR bspointCountFieldName = 0;
    PyObject* pyvar_pointCountFieldName;
    PyObject* unicodepointCountFieldName = NULL;
    IGeometry* ippAOI = NULL;
    PyObject* py_pAOI;
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;

    // Unpack values
    if (!PyArg_ParseTuple(args, "lOOO", &lindex, &pyvar_pointCountFieldName, &py_pAOI, &py_pTrackCancel))
      goto iterrainedit3_deletedatasourcedata2_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index
    if (PyString_Check(pyvar_pointCountFieldName))
        unicodepointCountFieldName = PyUnicode_FromObject(pyvar_pointCountFieldName);
    else if (PyUnicode_Check(pyvar_pointCountFieldName))
    {
        unicodepointCountFieldName = pyvar_pointCountFieldName;
        Py_INCREF(unicodepointCountFieldName);
    }
    else if (pyvar_pointCountFieldName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter pointCountFieldName at index 1");
    if (unicodepointCountFieldName)
        bspointCountFieldName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodepointCountFieldName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodepointCountFieldName));
    
    if (PyErr_Occurred())
      goto iterrainedit3_deletedatasourcedata2_method_cleanup;
    
    if (!IFaceFromPyObject(py_pAOI, &IID_IGeometry, (void**)&ippAOI))
        PyErr_SetString(PyExc_TypeError, "Argument pAOI (position 2) is not IGeometry");
    
    if (PyErr_Occurred())
      goto iterrainedit3_deletedatasourcedata2_method_cleanup;
    
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 3) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto iterrainedit3_deletedatasourcedata2_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITerrainEdit3->DeleteDataSourceData2(lindex, bspointCountFieldName, ippAOI, ippTrackCancel);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainEdit3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainEdit3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainEdit3.DeleteDataSourceData2() returned %ld", (long)hr);
        goto iterrainedit3_deletedatasourcedata2_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index
    // No teardown for pointCountFieldName
    // No teardown for pAOI
    // No teardown for pTrackCancel

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterrainedit3_deletedatasourcedata2_method_cleanup;

    iterrainedit3_deletedatasourcedata2_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    if (bspointCountFieldName)
        ::SysFreeString(bspointCountFieldName);
    
    if (ippAOI)
      ippAOI->Release();
    if (ippTrackCancel)
      ippTrackCancel->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainEdit3.DeleteDataSourceData2");
    return return_tuple;
}

static PyObject*
ITerrainEdit3Method_AddDataSourceData2(PyITerrainEdit3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;
    BSTR bspointCountFieldName = 0;
    PyObject* pyvar_pointCountFieldName;
    PyObject* unicodepointCountFieldName = NULL;
    IGeometry* ippAOI = NULL;
    PyObject* py_pAOI;
    IFeatureClass* ippInFC = NULL;
    PyObject* py_pInFC;
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;

    // Unpack values
    if (!PyArg_ParseTuple(args, "lOOOO", &lindex, &pyvar_pointCountFieldName, &py_pAOI, &py_pInFC, &py_pTrackCancel))
      goto iterrainedit3_adddatasourcedata2_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index
    if (PyString_Check(pyvar_pointCountFieldName))
        unicodepointCountFieldName = PyUnicode_FromObject(pyvar_pointCountFieldName);
    else if (PyUnicode_Check(pyvar_pointCountFieldName))
    {
        unicodepointCountFieldName = pyvar_pointCountFieldName;
        Py_INCREF(unicodepointCountFieldName);
    }
    else if (pyvar_pointCountFieldName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter pointCountFieldName at index 1");
    if (unicodepointCountFieldName)
        bspointCountFieldName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodepointCountFieldName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodepointCountFieldName));
    
    if (PyErr_Occurred())
      goto iterrainedit3_adddatasourcedata2_method_cleanup;
    
    if (!IFaceFromPyObject(py_pAOI, &IID_IGeometry, (void**)&ippAOI))
        PyErr_SetString(PyExc_TypeError, "Argument pAOI (position 2) is not IGeometry");
    
    if (PyErr_Occurred())
      goto iterrainedit3_adddatasourcedata2_method_cleanup;
    
    if (!IFaceFromPyObject(py_pInFC, &IID_IFeatureClass, (void**)&ippInFC))
        PyErr_SetString(PyExc_TypeError, "Argument pInFC (position 3) is not IFeatureClass");
    
    if (PyErr_Occurred())
      goto iterrainedit3_adddatasourcedata2_method_cleanup;
    
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 4) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto iterrainedit3_adddatasourcedata2_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITerrainEdit3->AddDataSourceData2(lindex, bspointCountFieldName, ippAOI, ippInFC, ippTrackCancel);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainEdit3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainEdit3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainEdit3.AddDataSourceData2() returned %ld", (long)hr);
        goto iterrainedit3_adddatasourcedata2_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index
    // No teardown for pointCountFieldName
    // No teardown for pAOI
    // No teardown for pInFC
    // No teardown for pTrackCancel

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterrainedit3_adddatasourcedata2_method_cleanup;

    iterrainedit3_adddatasourcedata2_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    if (bspointCountFieldName)
        ::SysFreeString(bspointCountFieldName);
    
    if (ippAOI)
      ippAOI->Release();
    if (ippInFC)
      ippInFC->Release();
    if (ippTrackCancel)
      ippTrackCancel->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainEdit3.AddDataSourceData2");
    return return_tuple;
}

static PyObject*
ITerrainEdit3Method_ReplaceDataSourceData2(PyITerrainEdit3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;
    BSTR bspointCountFieldName = 0;
    PyObject* pyvar_pointCountFieldName;
    PyObject* unicodepointCountFieldName = NULL;
    IGeometry* ippAOI = NULL;
    PyObject* py_pAOI;
    IFeatureClass* ippInFC = NULL;
    PyObject* py_pInFC;
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;

    // Unpack values
    if (!PyArg_ParseTuple(args, "lOOOO", &lindex, &pyvar_pointCountFieldName, &py_pAOI, &py_pInFC, &py_pTrackCancel))
      goto iterrainedit3_replacedatasourcedata2_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index
    if (PyString_Check(pyvar_pointCountFieldName))
        unicodepointCountFieldName = PyUnicode_FromObject(pyvar_pointCountFieldName);
    else if (PyUnicode_Check(pyvar_pointCountFieldName))
    {
        unicodepointCountFieldName = pyvar_pointCountFieldName;
        Py_INCREF(unicodepointCountFieldName);
    }
    else if (pyvar_pointCountFieldName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter pointCountFieldName at index 1");
    if (unicodepointCountFieldName)
        bspointCountFieldName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodepointCountFieldName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodepointCountFieldName));
    
    if (PyErr_Occurred())
      goto iterrainedit3_replacedatasourcedata2_method_cleanup;
    
    if (!IFaceFromPyObject(py_pAOI, &IID_IGeometry, (void**)&ippAOI))
        PyErr_SetString(PyExc_TypeError, "Argument pAOI (position 2) is not IGeometry");
    
    if (PyErr_Occurred())
      goto iterrainedit3_replacedatasourcedata2_method_cleanup;
    
    if (!IFaceFromPyObject(py_pInFC, &IID_IFeatureClass, (void**)&ippInFC))
        PyErr_SetString(PyExc_TypeError, "Argument pInFC (position 3) is not IFeatureClass");
    
    if (PyErr_Occurred())
      goto iterrainedit3_replacedatasourcedata2_method_cleanup;
    
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 4) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto iterrainedit3_replacedatasourcedata2_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITerrainEdit3->ReplaceDataSourceData2(lindex, bspointCountFieldName, ippAOI, ippInFC, ippTrackCancel);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainEdit3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainEdit3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainEdit3.ReplaceDataSourceData2() returned %ld", (long)hr);
        goto iterrainedit3_replacedatasourcedata2_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index
    // No teardown for pointCountFieldName
    // No teardown for pAOI
    // No teardown for pInFC
    // No teardown for pTrackCancel

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterrainedit3_replacedatasourcedata2_method_cleanup;

    iterrainedit3_replacedatasourcedata2_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    if (bspointCountFieldName)
        ::SysFreeString(bspointCountFieldName);
    
    if (ippAOI)
      ippAOI->Release();
    if (ippInFC)
      ippInFC->Release();
    if (ippTrackCancel)
      ippTrackCancel->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainEdit3.ReplaceDataSourceData2");
    return return_tuple;
}

static PyObject*
ITerrainEdit3Method_CalculateFieldStatistics(PyITerrainEdit3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;
    IStringArray* ippFieldNames = NULL;
    PyObject* py_pFieldNames;
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;

    // Unpack values
    if (!PyArg_ParseTuple(args, "lOO", &lindex, &py_pFieldNames, &py_pTrackCancel))
      goto iterrainedit3_calculatefieldstatistics_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index
    if (!IFaceFromPyObject(py_pFieldNames, &IID_IStringArray, (void**)&ippFieldNames))
        PyErr_SetString(PyExc_TypeError, "Argument pFieldNames (position 1) is not IStringArray");
    
    if (PyErr_Occurred())
      goto iterrainedit3_calculatefieldstatistics_method_cleanup;
    
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 2) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto iterrainedit3_calculatefieldstatistics_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITerrainEdit3->CalculateFieldStatistics(lindex, ippFieldNames, ippTrackCancel);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainEdit3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainEdit3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainEdit3.CalculateFieldStatistics() returned %ld", (long)hr);
        goto iterrainedit3_calculatefieldstatistics_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index
    // No teardown for pFieldNames
    // No teardown for pTrackCancel

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterrainedit3_calculatefieldstatistics_method_cleanup;

    iterrainedit3_calculatefieldstatistics_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    if (ippFieldNames)
      ippFieldNames->Release();
    if (ippTrackCancel)
      ippTrackCancel->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainEdit3.CalculateFieldStatistics");
    return return_tuple;
}

static PyObject*
ITerrainEdit3Method_UpdateExtent(PyITerrainEdit3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_pTrackCancel))
      goto iterrainedit3_updateextent_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 0) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto iterrainedit3_updateextent_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITerrainEdit3->UpdateExtent(ippTrackCancel);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainEdit3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainEdit3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainEdit3.UpdateExtent() returned %ld", (long)hr);
        goto iterrainedit3_updateextent_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pTrackCancel

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterrainedit3_updateextent_method_cleanup;

    iterrainedit3_updateextent_method_cleanup:
    self->m_HR = hr;
    if (ippTrackCancel)
      ippTrackCancel->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainEdit3.UpdateExtent");
    return return_tuple;
}

static PyObject*
ITerrainEdit3Method_AddDataSource(PyITerrainEdit3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ITerrainDataSource* ippDataSource = NULL;
    PyObject* py_pDataSource;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_pDataSource))
      goto iterrainedit3_adddatasource_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pDataSource, &IID_ITerrainDataSource, (void**)&ippDataSource))
        PyErr_SetString(PyExc_TypeError, "Argument pDataSource (position 0) is not ITerrainDataSource");
    
    if (PyErr_Occurred())
      goto iterrainedit3_adddatasource_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITerrainEdit3->AddDataSource(ippDataSource);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainEdit3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainEdit3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainEdit3.AddDataSource() returned %ld", (long)hr);
        goto iterrainedit3_adddatasource_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pDataSource

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterrainedit3_adddatasource_method_cleanup;

    iterrainedit3_adddatasource_method_cleanup:
    self->m_HR = hr;
    if (ippDataSource)
      ippDataSource->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainEdit3.AddDataSource");
    return return_tuple;
}

static PyObject*
ITerrainEdit3Method_RemoveDataSource(PyITerrainEdit3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lindex))
      goto iterrainedit3_removedatasource_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index

    // Call method on actual COM interface
    hr = self->m_pITerrainEdit3->RemoveDataSource(lindex);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainEdit3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainEdit3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainEdit3.RemoveDataSource() returned %ld", (long)hr);
        goto iterrainedit3_removedatasource_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterrainedit3_removedatasource_method_cleanup;

    iterrainedit3_removedatasource_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainEdit3.RemoveDataSource");
    return return_tuple;
}

static PyObject*
ITerrainEdit3Method_AddPyramidLevel(PyITerrainEdit3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ITerrainPyramidLevel* ippPyramidLevel = NULL;
    PyObject* py_pPyramidLevel;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_pPyramidLevel))
      goto iterrainedit3_addpyramidlevel_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pPyramidLevel, &IID_ITerrainPyramidLevel, (void**)&ippPyramidLevel))
        PyErr_SetString(PyExc_TypeError, "Argument pPyramidLevel (position 0) is not ITerrainPyramidLevel");
    
    if (PyErr_Occurred())
      goto iterrainedit3_addpyramidlevel_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITerrainEdit3->AddPyramidLevel(ippPyramidLevel);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainEdit3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainEdit3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainEdit3.AddPyramidLevel() returned %ld", (long)hr);
        goto iterrainedit3_addpyramidlevel_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pPyramidLevel

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterrainedit3_addpyramidlevel_method_cleanup;

    iterrainedit3_addpyramidlevel_method_cleanup:
    self->m_HR = hr;
    if (ippPyramidLevel)
      ippPyramidLevel->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainEdit3.AddPyramidLevel");
    return return_tuple;
}

static PyObject*
ITerrainEdit3Method_RemovePyramidLevel(PyITerrainEdit3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lindex))
      goto iterrainedit3_removepyramidlevel_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index

    // Call method on actual COM interface
    hr = self->m_pITerrainEdit3->RemovePyramidLevel(lindex);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainEdit3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainEdit3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainEdit3.RemovePyramidLevel() returned %ld", (long)hr);
        goto iterrainedit3_removepyramidlevel_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterrainedit3_removepyramidlevel_method_cleanup;

    iterrainedit3_removepyramidlevel_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainEdit3.RemovePyramidLevel");
    return return_tuple;
}

static PyObject*
ITerrainEdit3Method_ChangeMaxScale(PyITerrainEdit3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;
    long lnewScale = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "ll", &lindex, &lnewScale))
      goto iterrainedit3_changemaxscale_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index
    // No setup for newScale

    // Call method on actual COM interface
    hr = self->m_pITerrainEdit3->ChangeMaxScale(lindex, lnewScale);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainEdit3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainEdit3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainEdit3.ChangeMaxScale() returned %ld", (long)hr);
        goto iterrainedit3_changemaxscale_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index
    // No teardown for newScale

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterrainedit3_changemaxscale_method_cleanup;

    iterrainedit3_changemaxscale_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    // No cleanup for newScale
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainEdit3.ChangeMaxScale");
    return return_tuple;
}

static PyObject*
ITerrainEdit3Method_ChangeResolutionBounds(PyITerrainEdit3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;
    double dlowerBound = 0;
    double dupperBound = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "ldd", &lindex, &dlowerBound, &dupperBound))
      goto iterrainedit3_changeresolutionbounds_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index
    // No setup for lowerBound
    // No setup for upperBound

    // Call method on actual COM interface
    hr = self->m_pITerrainEdit3->ChangeResolutionBounds(lindex, dlowerBound, dupperBound);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainEdit3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainEdit3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainEdit3.ChangeResolutionBounds() returned %ld", (long)hr);
        goto iterrainedit3_changeresolutionbounds_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index
    // No teardown for lowerBound
    // No teardown for upperBound

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterrainedit3_changeresolutionbounds_method_cleanup;

    iterrainedit3_changeresolutionbounds_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    // No cleanup for lowerBound
    // No cleanup for upperBound
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainEdit3.ChangeResolutionBounds");
    return return_tuple;
}

static PyObject*
ITerrainEdit3Method_DeleteDataSourceData(PyITerrainEdit3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;
    IEnvelope* ippAOI = NULL;
    PyObject* py_pAOI;
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;

    // Unpack values
    if (!PyArg_ParseTuple(args, "lOO", &lindex, &py_pAOI, &py_pTrackCancel))
      goto iterrainedit3_deletedatasourcedata_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index
    if (!IFaceFromPyObject(py_pAOI, &IID_IEnvelope, (void**)&ippAOI))
        PyErr_SetString(PyExc_TypeError, "Argument pAOI (position 1) is not IEnvelope");
    
    if (PyErr_Occurred())
      goto iterrainedit3_deletedatasourcedata_method_cleanup;
    
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 2) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto iterrainedit3_deletedatasourcedata_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITerrainEdit3->DeleteDataSourceData(lindex, ippAOI, ippTrackCancel);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainEdit3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainEdit3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainEdit3.DeleteDataSourceData() returned %ld", (long)hr);
        goto iterrainedit3_deletedatasourcedata_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index
    // No teardown for pAOI
    // No teardown for pTrackCancel

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterrainedit3_deletedatasourcedata_method_cleanup;

    iterrainedit3_deletedatasourcedata_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    if (ippAOI)
      ippAOI->Release();
    if (ippTrackCancel)
      ippTrackCancel->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainEdit3.DeleteDataSourceData");
    return return_tuple;
}

static PyObject*
ITerrainEdit3Method_AddDataSourceData(PyITerrainEdit3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;
    IEnvelope* ippAOI = NULL;
    PyObject* py_pAOI;
    IFeatureClass* ippInFC = NULL;
    PyObject* py_pInFC;
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;

    // Unpack values
    if (!PyArg_ParseTuple(args, "lOOO", &lindex, &py_pAOI, &py_pInFC, &py_pTrackCancel))
      goto iterrainedit3_adddatasourcedata_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index
    if (!IFaceFromPyObject(py_pAOI, &IID_IEnvelope, (void**)&ippAOI))
        PyErr_SetString(PyExc_TypeError, "Argument pAOI (position 1) is not IEnvelope");
    
    if (PyErr_Occurred())
      goto iterrainedit3_adddatasourcedata_method_cleanup;
    
    if (!IFaceFromPyObject(py_pInFC, &IID_IFeatureClass, (void**)&ippInFC))
        PyErr_SetString(PyExc_TypeError, "Argument pInFC (position 2) is not IFeatureClass");
    
    if (PyErr_Occurred())
      goto iterrainedit3_adddatasourcedata_method_cleanup;
    
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 3) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto iterrainedit3_adddatasourcedata_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITerrainEdit3->AddDataSourceData(lindex, ippAOI, ippInFC, ippTrackCancel);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainEdit3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainEdit3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainEdit3.AddDataSourceData() returned %ld", (long)hr);
        goto iterrainedit3_adddatasourcedata_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index
    // No teardown for pAOI
    // No teardown for pInFC
    // No teardown for pTrackCancel

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterrainedit3_adddatasourcedata_method_cleanup;

    iterrainedit3_adddatasourcedata_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    if (ippAOI)
      ippAOI->Release();
    if (ippInFC)
      ippInFC->Release();
    if (ippTrackCancel)
      ippTrackCancel->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainEdit3.AddDataSourceData");
    return return_tuple;
}

static PyObject*
ITerrainEdit3Method_ReplaceDataSourceData(PyITerrainEdit3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;
    IEnvelope* ippAOI = NULL;
    PyObject* py_pAOI;
    IFeatureClass* ippInFC = NULL;
    PyObject* py_pInFC;
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;

    // Unpack values
    if (!PyArg_ParseTuple(args, "lOOO", &lindex, &py_pAOI, &py_pInFC, &py_pTrackCancel))
      goto iterrainedit3_replacedatasourcedata_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index
    if (!IFaceFromPyObject(py_pAOI, &IID_IEnvelope, (void**)&ippAOI))
        PyErr_SetString(PyExc_TypeError, "Argument pAOI (position 1) is not IEnvelope");
    
    if (PyErr_Occurred())
      goto iterrainedit3_replacedatasourcedata_method_cleanup;
    
    if (!IFaceFromPyObject(py_pInFC, &IID_IFeatureClass, (void**)&ippInFC))
        PyErr_SetString(PyExc_TypeError, "Argument pInFC (position 2) is not IFeatureClass");
    
    if (PyErr_Occurred())
      goto iterrainedit3_replacedatasourcedata_method_cleanup;
    
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 3) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto iterrainedit3_replacedatasourcedata_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITerrainEdit3->ReplaceDataSourceData(lindex, ippAOI, ippInFC, ippTrackCancel);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainEdit3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainEdit3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainEdit3.ReplaceDataSourceData() returned %ld", (long)hr);
        goto iterrainedit3_replacedatasourcedata_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index
    // No teardown for pAOI
    // No teardown for pInFC
    // No teardown for pTrackCancel

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterrainedit3_replacedatasourcedata_method_cleanup;

    iterrainedit3_replacedatasourcedata_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    if (ippAOI)
      ippAOI->Release();
    if (ippInFC)
      ippInFC->Release();
    if (ippTrackCancel)
      ippTrackCancel->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainEdit3.ReplaceDataSourceData");
    return return_tuple;
}

static PyObject*
ITerrainEdit3Method_Build(PyITerrainEdit3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_pTrackCancel))
      goto iterrainedit3_build_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 0) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto iterrainedit3_build_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITerrainEdit3->Build(ippTrackCancel);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainEdit3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainEdit3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainEdit3.Build() returned %ld", (long)hr);
        goto iterrainedit3_build_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pTrackCancel

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterrainedit3_build_method_cleanup;

    iterrainedit3_build_method_cleanup:
    self->m_HR = hr;
    if (ippTrackCancel)
      ippTrackCancel->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainEdit3.Build");
    return return_tuple;
}


PyMethodDef PyITerrainEdit3Methods[] = {
    {"supports", (PyCFunction)PyITerrainEdit3_SupportsInterface, METH_O, ""},
    {"ChangeUsageInOverview", (PyCFunction)ITerrainEdit3Method_ChangeUsageInOverview, METH_VARARGS, ""},
    {"DeleteDataSourceDataByFC", (PyCFunction)ITerrainEdit3Method_DeleteDataSourceDataByFC, METH_VARARGS, ""},
    {"DeleteDataSourceData2", (PyCFunction)ITerrainEdit3Method_DeleteDataSourceData2, METH_VARARGS, ""},
    {"AddDataSourceData2", (PyCFunction)ITerrainEdit3Method_AddDataSourceData2, METH_VARARGS, ""},
    {"ReplaceDataSourceData2", (PyCFunction)ITerrainEdit3Method_ReplaceDataSourceData2, METH_VARARGS, ""},
    {"CalculateFieldStatistics", (PyCFunction)ITerrainEdit3Method_CalculateFieldStatistics, METH_VARARGS, ""},
    {"UpdateExtent", (PyCFunction)ITerrainEdit3Method_UpdateExtent, METH_VARARGS, ""},
    {"AddDataSource", (PyCFunction)ITerrainEdit3Method_AddDataSource, METH_VARARGS, ""},
    {"RemoveDataSource", (PyCFunction)ITerrainEdit3Method_RemoveDataSource, METH_VARARGS, ""},
    {"AddPyramidLevel", (PyCFunction)ITerrainEdit3Method_AddPyramidLevel, METH_VARARGS, ""},
    {"RemovePyramidLevel", (PyCFunction)ITerrainEdit3Method_RemovePyramidLevel, METH_VARARGS, ""},
    {"ChangeMaxScale", (PyCFunction)ITerrainEdit3Method_ChangeMaxScale, METH_VARARGS, ""},
    {"ChangeResolutionBounds", (PyCFunction)ITerrainEdit3Method_ChangeResolutionBounds, METH_VARARGS, ""},
    {"DeleteDataSourceData", (PyCFunction)ITerrainEdit3Method_DeleteDataSourceData, METH_VARARGS, ""},
    {"AddDataSourceData", (PyCFunction)ITerrainEdit3Method_AddDataSourceData, METH_VARARGS, ""},
    {"ReplaceDataSourceData", (PyCFunction)ITerrainEdit3Method_ReplaceDataSourceData, METH_VARARGS, ""},
    {"Build", (PyCFunction)ITerrainEdit3Method_Build, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyITerrainEdit3GetSet[] = {
  {"_pUnk", (getter)PyITerrainEdit3_GetpUnk, NULL, "Get opaque pointer to an Unknown from ITerrainEdit3", NULL},
  {"_pointer", (getter)PyITerrainEdit3_GetPointer, NULL, "Get memory address for ITerrainEdit3", NULL},
  {"_IID", (getter)PyITerrainEdit3_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyITerrainEdit3_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyITerrainEdit3_GetIgnoreFailures, (setter)PyITerrainEdit3_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyITerrainEdit3Object_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.ITerrainEdit3Object",                          
                                              /* tp_name */
  sizeof(PyITerrainEdit3Object),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyITerrainEdit3Object_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyITerrainEdit3Methods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyITerrainEdit3GetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyITerrainEdit3Object_new,                      
                                              /* tp_new */
};

// Interface ITerrainName

typedef struct PyITerrainNameObject {
    PyObject_HEAD
    ITerrainName* m_pITerrainName;
    HRESULT m_HR;
    int m_ignore_failures;
} PyITerrainNameObject;

static PyObject*
PyITerrainNameObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyITerrainNameObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ITerrainName* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ITerrainName, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ITerrainName with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyITerrainNameObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ITerrainName");
            return NULL;
        }
        self->m_pITerrainName = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ITerrainName");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ITerrainName");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ITerrainName* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ITerrainName, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ITerrainName");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyITerrainNameObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ITerrainName");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pITerrainName = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyITerrainNameObject_dealloc(PyITerrainNameObject* self)
{
    if (self->m_pITerrainName)
        self->m_pITerrainName->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyITerrainName_GetpUnk(PyITerrainNameObject* self)
{
    if (!self->m_pITerrainName)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pITerrainName->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ITerrainName to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyITerrainName_GetPointer(PyITerrainNameObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pITerrainName);
}

static PyObject*
PyITerrainName_GetIID(PyITerrainNameObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "fa7b8f6e-c012-4e16-afb9-62b8ce0f9011");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyITerrainName_GetHR(PyITerrainNameObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyITerrainName_GetIgnoreFailures(PyITerrainNameObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyITerrainName_SetIgnoreFailures(PyITerrainNameObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyITerrainName_SupportsInterface(PyITerrainNameObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pITerrainName->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ITerrainNameMethod_putref_FeatureDatasetName(PyITerrainNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IDatasetName* ipppFeatureDatasetName = NULL;
    PyObject* py_ppFeatureDatasetName;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_ppFeatureDatasetName))
      goto iterrainname_putref_featuredatasetname_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_ppFeatureDatasetName, &IID_IDatasetName, (void**)&ipppFeatureDatasetName))
        PyErr_SetString(PyExc_TypeError, "Argument ppFeatureDatasetName (position 0) is not IDatasetName");
    
    if (PyErr_Occurred())
      goto iterrainname_putref_featuredatasetname_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITerrainName->putref_FeatureDatasetName(ipppFeatureDatasetName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainName.putref_FeatureDatasetName() returned %ld", (long)hr);
        goto iterrainname_putref_featuredatasetname_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ppFeatureDatasetName

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterrainname_putref_featuredatasetname_method_cleanup;

    iterrainname_putref_featuredatasetname_method_cleanup:
    self->m_HR = hr;
    if (ipppFeatureDatasetName)
      ipppFeatureDatasetName->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainName.putref_FeatureDatasetName");
    return return_tuple;
}

static PyObject*
ITerrainNameMethod_get_FeatureDatasetName(PyITerrainNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IDatasetName* ipppFeatureDatasetName = NULL;
    PyObject* py_ppFeatureDatasetName = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppFeatureDatasetName

    // Call method on actual COM interface
    hr = self->m_pITerrainName->get_FeatureDatasetName(&ipppFeatureDatasetName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainName.get_FeatureDatasetName() returned %ld", (long)hr);
        goto iterrainname_get_featuredatasetname_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppFeatureDatasetName);
    if (ipppFeatureDatasetName)
    {
        IUnknown* pUnk = NULL;
        ipppFeatureDatasetName->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppFeatureDatasetName = IUnknownToPythonIIDObject(pUnk, &IID_IDatasetName);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppFeatureDatasetName)
    {
        if (py_ppFeatureDatasetName)
           Py_DECREF(py_ppFeatureDatasetName);
        py_ppFeatureDatasetName = Py_None;
        Py_INCREF(py_ppFeatureDatasetName);
    }
    if (PyErr_Occurred())
      goto iterrainname_get_featuredatasetname_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppFeatureDatasetName);
    goto iterrainname_get_featuredatasetname_method_cleanup;

    iterrainname_get_featuredatasetname_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppFeatureDatasetName);
    if (ipppFeatureDatasetName)
      ipppFeatureDatasetName->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainName.get_FeatureDatasetName");
    return return_tuple;
}


PyMethodDef PyITerrainNameMethods[] = {
    {"supports", (PyCFunction)PyITerrainName_SupportsInterface, METH_O, ""},
    {"putref_FeatureDatasetName", (PyCFunction)ITerrainNameMethod_putref_FeatureDatasetName, METH_VARARGS, ""},
    {"get_FeatureDatasetName", (PyCFunction)ITerrainNameMethod_get_FeatureDatasetName, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyITerrainNameGetSet[] = {
  {"_pUnk", (getter)PyITerrainName_GetpUnk, NULL, "Get opaque pointer to an Unknown from ITerrainName", NULL},
  {"_pointer", (getter)PyITerrainName_GetPointer, NULL, "Get memory address for ITerrainName", NULL},
  {"_IID", (getter)PyITerrainName_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyITerrainName_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyITerrainName_GetIgnoreFailures, (setter)PyITerrainName_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyITerrainNameObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.ITerrainNameObject",                          
                                              /* tp_name */
  sizeof(PyITerrainNameObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyITerrainNameObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyITerrainNameMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyITerrainNameGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyITerrainNameObject_new,                      
                                              /* tp_new */
};

// Interface ITerrainDataSource2

typedef struct PyITerrainDataSource2Object {
    PyObject_HEAD
    ITerrainDataSource2* m_pITerrainDataSource2;
    HRESULT m_HR;
    int m_ignore_failures;
} PyITerrainDataSource2Object;

static PyObject*
PyITerrainDataSource2Object_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyITerrainDataSource2Object* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ITerrainDataSource2* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ITerrainDataSource2, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ITerrainDataSource2 with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyITerrainDataSource2Object *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ITerrainDataSource2");
            return NULL;
        }
        self->m_pITerrainDataSource2 = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ITerrainDataSource2");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ITerrainDataSource2");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ITerrainDataSource2* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ITerrainDataSource2, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ITerrainDataSource2");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyITerrainDataSource2Object *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ITerrainDataSource2");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pITerrainDataSource2 = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyITerrainDataSource2Object_dealloc(PyITerrainDataSource2Object* self)
{
    if (self->m_pITerrainDataSource2)
        self->m_pITerrainDataSource2->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyITerrainDataSource2_GetpUnk(PyITerrainDataSource2Object* self)
{
    if (!self->m_pITerrainDataSource2)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pITerrainDataSource2->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ITerrainDataSource2 to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyITerrainDataSource2_GetPointer(PyITerrainDataSource2Object* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pITerrainDataSource2);
}

static PyObject*
PyITerrainDataSource2_GetIID(PyITerrainDataSource2Object* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "17b45aaf-fdb2-4492-87c6-9578b20001bd");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyITerrainDataSource2_GetHR(PyITerrainDataSource2Object* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyITerrainDataSource2_GetIgnoreFailures(PyITerrainDataSource2Object* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyITerrainDataSource2_SetIgnoreFailures(PyITerrainDataSource2Object* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyITerrainDataSource2_SupportsInterface(PyITerrainDataSource2Object* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pITerrainDataSource2->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ITerrainDataSource2Method_put_Anchored(PyITerrainDataSource2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pbAnchored = VARIANT_FALSE;
    PyObject* pyvar_pbAnchored = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pbAnchored))
      goto iterraindatasource2_put_anchored_method_cleanup;

    // Set up initial variable values as needed
    b_pbAnchored = ((PyObject_IsTrue(pyvar_pbAnchored) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iterraindatasource2_put_anchored_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITerrainDataSource2->put_Anchored(b_pbAnchored);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainDataSource2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainDataSource2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainDataSource2.put_Anchored() returned %ld", (long)hr);
        goto iterraindatasource2_put_anchored_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pbAnchored

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterraindatasource2_put_anchored_method_cleanup;

    iterraindatasource2_put_anchored_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pbAnchored
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainDataSource2.put_Anchored");
    return return_tuple;
}

static PyObject*
ITerrainDataSource2Method_get_Anchored(PyITerrainDataSource2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pbAnchored = VARIANT_FALSE;
    PyObject* pyvar_pbAnchored = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pbAnchored

    // Call method on actual COM interface
    hr = self->m_pITerrainDataSource2->get_Anchored(&b_pbAnchored);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainDataSource2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainDataSource2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainDataSource2.get_Anchored() returned %ld", (long)hr);
        goto iterraindatasource2_get_anchored_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pbAnchored = ((b_pbAnchored == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto iterraindatasource2_get_anchored_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pbAnchored);
    goto iterraindatasource2_get_anchored_method_cleanup;

    iterraindatasource2_get_anchored_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pbAnchored
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainDataSource2.get_Anchored");
    return return_tuple;
}

static PyObject*
ITerrainDataSource2Method_put_FeatureClassID(PyITerrainDataSource2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpClassID = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lpClassID))
      goto iterraindatasource2_put_featureclassid_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pClassID

    // Call method on actual COM interface
    hr = self->m_pITerrainDataSource2->put_FeatureClassID(lpClassID);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainDataSource2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainDataSource2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainDataSource2.put_FeatureClassID() returned %ld", (long)hr);
        goto iterraindatasource2_put_featureclassid_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pClassID

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterraindatasource2_put_featureclassid_method_cleanup;

    iterraindatasource2_put_featureclassid_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pClassID
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainDataSource2.put_FeatureClassID");
    return return_tuple;
}

static PyObject*
ITerrainDataSource2Method_get_FeatureClassID(PyITerrainDataSource2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpClassID = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pClassID

    // Call method on actual COM interface
    hr = self->m_pITerrainDataSource2->get_FeatureClassID(&lpClassID);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainDataSource2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainDataSource2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainDataSource2.get_FeatureClassID() returned %ld", (long)hr);
        goto iterraindatasource2_get_featureclassid_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pClassID

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpClassID);
    goto iterraindatasource2_get_featureclassid_method_cleanup;

    iterraindatasource2_get_featureclassid_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pClassID
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainDataSource2.get_FeatureClassID");
    return return_tuple;
}

static PyObject*
ITerrainDataSource2Method_put_GroupID(PyITerrainDataSource2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpGroupID = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lpGroupID))
      goto iterraindatasource2_put_groupid_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pGroupID

    // Call method on actual COM interface
    hr = self->m_pITerrainDataSource2->put_GroupID(lpGroupID);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainDataSource2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainDataSource2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainDataSource2.put_GroupID() returned %ld", (long)hr);
        goto iterraindatasource2_put_groupid_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pGroupID

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterraindatasource2_put_groupid_method_cleanup;

    iterraindatasource2_put_groupid_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pGroupID
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainDataSource2.put_GroupID");
    return return_tuple;
}

static PyObject*
ITerrainDataSource2Method_get_GroupID(PyITerrainDataSource2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpGroupID = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pGroupID

    // Call method on actual COM interface
    hr = self->m_pITerrainDataSource2->get_GroupID(&lpGroupID);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainDataSource2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainDataSource2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainDataSource2.get_GroupID() returned %ld", (long)hr);
        goto iterraindatasource2_get_groupid_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pGroupID

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpGroupID);
    goto iterraindatasource2_get_groupid_method_cleanup;

    iterraindatasource2_get_groupid_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pGroupID
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainDataSource2.get_GroupID");
    return return_tuple;
}

static PyObject*
ITerrainDataSource2Method_put_HeightField(PyITerrainDataSource2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspFieldName = 0;
    PyObject* pyvar_pFieldName;
    PyObject* unicodepFieldName = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pFieldName))
      goto iterraindatasource2_put_heightfield_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_pFieldName))
        unicodepFieldName = PyUnicode_FromObject(pyvar_pFieldName);
    else if (PyUnicode_Check(pyvar_pFieldName))
    {
        unicodepFieldName = pyvar_pFieldName;
        Py_INCREF(unicodepFieldName);
    }
    else if (pyvar_pFieldName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter pFieldName at index 0");
    if (unicodepFieldName)
        bspFieldName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodepFieldName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodepFieldName));
    
    if (PyErr_Occurred())
      goto iterraindatasource2_put_heightfield_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITerrainDataSource2->put_HeightField(bspFieldName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainDataSource2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainDataSource2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainDataSource2.put_HeightField() returned %ld", (long)hr);
        goto iterraindatasource2_put_heightfield_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pFieldName

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterraindatasource2_put_heightfield_method_cleanup;

    iterraindatasource2_put_heightfield_method_cleanup:
    self->m_HR = hr;
    if (bspFieldName)
        ::SysFreeString(bspFieldName);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainDataSource2.put_HeightField");
    return return_tuple;
}

static PyObject*
ITerrainDataSource2Method_get_HeightField(PyITerrainDataSource2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspFieldName;
    PyObject* pyvar_pFieldName = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pFieldName

    // Call method on actual COM interface
    hr = self->m_pITerrainDataSource2->get_HeightField(&bspFieldName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainDataSource2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainDataSource2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainDataSource2.get_HeightField() returned %ld", (long)hr);
        goto iterraindatasource2_get_heightfield_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pFieldName = PyUnicode_FromWideChar(bspFieldName,::SysStringLen(bspFieldName));
    ::SysFreeString(bspFieldName);
    
    if (PyErr_Occurred())
      goto iterraindatasource2_get_heightfield_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pFieldName);
    goto iterraindatasource2_get_heightfield_method_cleanup;

    iterraindatasource2_get_heightfield_method_cleanup:
    self->m_HR = hr;
    if (pyvar_pFieldName != Py_None)
        Py_XDECREF(pyvar_pFieldName);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainDataSource2.get_HeightField");
    return return_tuple;
}

static PyObject*
ITerrainDataSource2Method_put_TagValueField(PyITerrainDataSource2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspFieldName = 0;
    PyObject* pyvar_pFieldName;
    PyObject* unicodepFieldName = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pFieldName))
      goto iterraindatasource2_put_tagvaluefield_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_pFieldName))
        unicodepFieldName = PyUnicode_FromObject(pyvar_pFieldName);
    else if (PyUnicode_Check(pyvar_pFieldName))
    {
        unicodepFieldName = pyvar_pFieldName;
        Py_INCREF(unicodepFieldName);
    }
    else if (pyvar_pFieldName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter pFieldName at index 0");
    if (unicodepFieldName)
        bspFieldName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodepFieldName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodepFieldName));
    
    if (PyErr_Occurred())
      goto iterraindatasource2_put_tagvaluefield_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITerrainDataSource2->put_TagValueField(bspFieldName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainDataSource2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainDataSource2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainDataSource2.put_TagValueField() returned %ld", (long)hr);
        goto iterraindatasource2_put_tagvaluefield_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pFieldName

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterraindatasource2_put_tagvaluefield_method_cleanup;

    iterraindatasource2_put_tagvaluefield_method_cleanup:
    self->m_HR = hr;
    if (bspFieldName)
        ::SysFreeString(bspFieldName);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainDataSource2.put_TagValueField");
    return return_tuple;
}

static PyObject*
ITerrainDataSource2Method_get_TagValueField(PyITerrainDataSource2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspFieldName;
    PyObject* pyvar_pFieldName = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pFieldName

    // Call method on actual COM interface
    hr = self->m_pITerrainDataSource2->get_TagValueField(&bspFieldName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainDataSource2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainDataSource2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainDataSource2.get_TagValueField() returned %ld", (long)hr);
        goto iterraindatasource2_get_tagvaluefield_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pFieldName = PyUnicode_FromWideChar(bspFieldName,::SysStringLen(bspFieldName));
    ::SysFreeString(bspFieldName);
    
    if (PyErr_Occurred())
      goto iterraindatasource2_get_tagvaluefield_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pFieldName);
    goto iterraindatasource2_get_tagvaluefield_method_cleanup;

    iterraindatasource2_get_tagvaluefield_method_cleanup:
    self->m_HR = hr;
    if (pyvar_pFieldName != Py_None)
        Py_XDECREF(pyvar_pFieldName);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainDataSource2.get_TagValueField");
    return return_tuple;
}

static PyObject*
ITerrainDataSource2Method_put_SurfaceFeatureType(PyITerrainDataSource2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriTinSurfaceType epType;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&epType))
      goto iterraindatasource2_put_surfacefeaturetype_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pType

    // Call method on actual COM interface
    hr = self->m_pITerrainDataSource2->put_SurfaceFeatureType(epType);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainDataSource2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainDataSource2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainDataSource2.put_SurfaceFeatureType() returned %ld", (long)hr);
        goto iterraindatasource2_put_surfacefeaturetype_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pType

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterraindatasource2_put_surfacefeaturetype_method_cleanup;

    iterraindatasource2_put_surfacefeaturetype_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pType
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainDataSource2.put_SurfaceFeatureType");
    return return_tuple;
}

static PyObject*
ITerrainDataSource2Method_get_SurfaceFeatureType(PyITerrainDataSource2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriTinSurfaceType epType;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pType

    // Call method on actual COM interface
    hr = self->m_pITerrainDataSource2->get_SurfaceFeatureType(&epType);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainDataSource2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainDataSource2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainDataSource2.get_SurfaceFeatureType() returned %ld", (long)hr);
        goto iterraindatasource2_get_surfacefeaturetype_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pType

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)epType);
    goto iterraindatasource2_get_surfacefeaturetype_method_cleanup;

    iterraindatasource2_get_surfacefeaturetype_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pType
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainDataSource2.get_SurfaceFeatureType");
    return return_tuple;
}

static PyObject*
ITerrainDataSource2Method_put_ApplyToOverviewTerrain(PyITerrainDataSource2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pbApply = VARIANT_FALSE;
    PyObject* pyvar_pbApply = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pbApply))
      goto iterraindatasource2_put_applytooverviewterrain_method_cleanup;

    // Set up initial variable values as needed
    b_pbApply = ((PyObject_IsTrue(pyvar_pbApply) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iterraindatasource2_put_applytooverviewterrain_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITerrainDataSource2->put_ApplyToOverviewTerrain(b_pbApply);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainDataSource2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainDataSource2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainDataSource2.put_ApplyToOverviewTerrain() returned %ld", (long)hr);
        goto iterraindatasource2_put_applytooverviewterrain_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pbApply

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterraindatasource2_put_applytooverviewterrain_method_cleanup;

    iterraindatasource2_put_applytooverviewterrain_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pbApply
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainDataSource2.put_ApplyToOverviewTerrain");
    return return_tuple;
}

static PyObject*
ITerrainDataSource2Method_get_ApplyToOverviewTerrain(PyITerrainDataSource2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pbApply = VARIANT_FALSE;
    PyObject* pyvar_pbApply = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pbApply

    // Call method on actual COM interface
    hr = self->m_pITerrainDataSource2->get_ApplyToOverviewTerrain(&b_pbApply);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainDataSource2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainDataSource2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainDataSource2.get_ApplyToOverviewTerrain() returned %ld", (long)hr);
        goto iterraindatasource2_get_applytooverviewterrain_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pbApply = ((b_pbApply == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto iterraindatasource2_get_applytooverviewterrain_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pbApply);
    goto iterraindatasource2_get_applytooverviewterrain_method_cleanup;

    iterraindatasource2_get_applytooverviewterrain_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pbApply
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainDataSource2.get_ApplyToOverviewTerrain");
    return return_tuple;
}

static PyObject*
ITerrainDataSource2Method_get_Embedded(PyITerrainDataSource2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pbEmbedded = VARIANT_FALSE;
    PyObject* pyvar_pbEmbedded = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pbEmbedded

    // Call method on actual COM interface
    hr = self->m_pITerrainDataSource2->get_Embedded(&b_pbEmbedded);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainDataSource2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainDataSource2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainDataSource2.get_Embedded() returned %ld", (long)hr);
        goto iterraindatasource2_get_embedded_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pbEmbedded = ((b_pbEmbedded == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto iterraindatasource2_get_embedded_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pbEmbedded);
    goto iterraindatasource2_get_embedded_method_cleanup;

    iterraindatasource2_get_embedded_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pbEmbedded
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainDataSource2.get_Embedded");
    return return_tuple;
}

static PyObject*
ITerrainDataSource2Method_SetResolutionBounds(PyITerrainDataSource2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dlowerBound = 0;
    double dupperBound = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "dd", &dlowerBound, &dupperBound))
      goto iterraindatasource2_setresolutionbounds_method_cleanup;

    // Set up initial variable values as needed
    // No setup for lowerBound
    // No setup for upperBound

    // Call method on actual COM interface
    hr = self->m_pITerrainDataSource2->SetResolutionBounds(dlowerBound, dupperBound);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainDataSource2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainDataSource2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainDataSource2.SetResolutionBounds() returned %ld", (long)hr);
        goto iterraindatasource2_setresolutionbounds_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for lowerBound
    // No teardown for upperBound

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterraindatasource2_setresolutionbounds_method_cleanup;

    iterraindatasource2_setresolutionbounds_method_cleanup:
    self->m_HR = hr;
    // No cleanup for lowerBound
    // No cleanup for upperBound
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainDataSource2.SetResolutionBounds");
    return return_tuple;
}

static PyObject*
ITerrainDataSource2Method_QueryResolutionBounds(PyITerrainDataSource2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dpLowerBound = 0;
    double dpUpperBound = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pLowerBound
    // No setup for pUpperBound

    // Call method on actual COM interface
    hr = self->m_pITerrainDataSource2->QueryResolutionBounds(&dpLowerBound, &dpUpperBound);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainDataSource2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainDataSource2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainDataSource2.QueryResolutionBounds() returned %ld", (long)hr);
        goto iterraindatasource2_queryresolutionbounds_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pLowerBound
    // No teardown for pUpperBound

    // Initialize output tuple
    return_tuple = Py_BuildValue("dd",
                                            dpLowerBound, dpUpperBound);
    goto iterraindatasource2_queryresolutionbounds_method_cleanup;

    iterraindatasource2_queryresolutionbounds_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pLowerBound
    // No cleanup for pUpperBound
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainDataSource2.QueryResolutionBounds");
    return return_tuple;
}


PyMethodDef PyITerrainDataSource2Methods[] = {
    {"supports", (PyCFunction)PyITerrainDataSource2_SupportsInterface, METH_O, ""},
    {"put_Anchored", (PyCFunction)ITerrainDataSource2Method_put_Anchored, METH_VARARGS, ""},
    {"get_Anchored", (PyCFunction)ITerrainDataSource2Method_get_Anchored, METH_VARARGS, ""},
    {"put_FeatureClassID", (PyCFunction)ITerrainDataSource2Method_put_FeatureClassID, METH_VARARGS, ""},
    {"get_FeatureClassID", (PyCFunction)ITerrainDataSource2Method_get_FeatureClassID, METH_VARARGS, ""},
    {"put_GroupID", (PyCFunction)ITerrainDataSource2Method_put_GroupID, METH_VARARGS, ""},
    {"get_GroupID", (PyCFunction)ITerrainDataSource2Method_get_GroupID, METH_VARARGS, ""},
    {"put_HeightField", (PyCFunction)ITerrainDataSource2Method_put_HeightField, METH_VARARGS, ""},
    {"get_HeightField", (PyCFunction)ITerrainDataSource2Method_get_HeightField, METH_VARARGS, ""},
    {"put_TagValueField", (PyCFunction)ITerrainDataSource2Method_put_TagValueField, METH_VARARGS, ""},
    {"get_TagValueField", (PyCFunction)ITerrainDataSource2Method_get_TagValueField, METH_VARARGS, ""},
    {"put_SurfaceFeatureType", (PyCFunction)ITerrainDataSource2Method_put_SurfaceFeatureType, METH_VARARGS, ""},
    {"get_SurfaceFeatureType", (PyCFunction)ITerrainDataSource2Method_get_SurfaceFeatureType, METH_VARARGS, ""},
    {"put_ApplyToOverviewTerrain", (PyCFunction)ITerrainDataSource2Method_put_ApplyToOverviewTerrain, METH_VARARGS, ""},
    {"get_ApplyToOverviewTerrain", (PyCFunction)ITerrainDataSource2Method_get_ApplyToOverviewTerrain, METH_VARARGS, ""},
    {"get_Embedded", (PyCFunction)ITerrainDataSource2Method_get_Embedded, METH_VARARGS, ""},
    {"SetResolutionBounds", (PyCFunction)ITerrainDataSource2Method_SetResolutionBounds, METH_VARARGS, ""},
    {"QueryResolutionBounds", (PyCFunction)ITerrainDataSource2Method_QueryResolutionBounds, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyITerrainDataSource2GetSet[] = {
  {"_pUnk", (getter)PyITerrainDataSource2_GetpUnk, NULL, "Get opaque pointer to an Unknown from ITerrainDataSource2", NULL},
  {"_pointer", (getter)PyITerrainDataSource2_GetPointer, NULL, "Get memory address for ITerrainDataSource2", NULL},
  {"_IID", (getter)PyITerrainDataSource2_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyITerrainDataSource2_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyITerrainDataSource2_GetIgnoreFailures, (setter)PyITerrainDataSource2_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyITerrainDataSource2Object_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.ITerrainDataSource2Object",                          
                                              /* tp_name */
  sizeof(PyITerrainDataSource2Object),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyITerrainDataSource2Object_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyITerrainDataSource2Methods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyITerrainDataSource2GetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyITerrainDataSource2Object_new,                      
                                              /* tp_new */
};

// Interface ITerrainEmbeddedDataSource

typedef struct PyITerrainEmbeddedDataSourceObject {
    PyObject_HEAD
    ITerrainEmbeddedDataSource* m_pITerrainEmbeddedDataSource;
    HRESULT m_HR;
    int m_ignore_failures;
} PyITerrainEmbeddedDataSourceObject;

static PyObject*
PyITerrainEmbeddedDataSourceObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyITerrainEmbeddedDataSourceObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ITerrainEmbeddedDataSource* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ITerrainEmbeddedDataSource, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ITerrainEmbeddedDataSource with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyITerrainEmbeddedDataSourceObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ITerrainEmbeddedDataSource");
            return NULL;
        }
        self->m_pITerrainEmbeddedDataSource = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ITerrainEmbeddedDataSource");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ITerrainEmbeddedDataSource");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ITerrainEmbeddedDataSource* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ITerrainEmbeddedDataSource, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ITerrainEmbeddedDataSource");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyITerrainEmbeddedDataSourceObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ITerrainEmbeddedDataSource");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pITerrainEmbeddedDataSource = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyITerrainEmbeddedDataSourceObject_dealloc(PyITerrainEmbeddedDataSourceObject* self)
{
    if (self->m_pITerrainEmbeddedDataSource)
        self->m_pITerrainEmbeddedDataSource->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyITerrainEmbeddedDataSource_GetpUnk(PyITerrainEmbeddedDataSourceObject* self)
{
    if (!self->m_pITerrainEmbeddedDataSource)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pITerrainEmbeddedDataSource->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ITerrainEmbeddedDataSource to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyITerrainEmbeddedDataSource_GetPointer(PyITerrainEmbeddedDataSourceObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pITerrainEmbeddedDataSource);
}

static PyObject*
PyITerrainEmbeddedDataSource_GetIID(PyITerrainEmbeddedDataSourceObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "36a1b4a5-d296-433d-ac4f-4da50d020812");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyITerrainEmbeddedDataSource_GetHR(PyITerrainEmbeddedDataSourceObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyITerrainEmbeddedDataSource_GetIgnoreFailures(PyITerrainEmbeddedDataSourceObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyITerrainEmbeddedDataSource_SetIgnoreFailures(PyITerrainEmbeddedDataSourceObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyITerrainEmbeddedDataSource_SupportsInterface(PyITerrainEmbeddedDataSourceObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pITerrainEmbeddedDataSource->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ITerrainEmbeddedDataSourceMethod_put_ToBeEmbedded(PyITerrainEmbeddedDataSourceObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pbToBeEmbedded = VARIANT_FALSE;
    PyObject* pyvar_pbToBeEmbedded = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pbToBeEmbedded))
      goto iterrainembeddeddatasource_put_tobeembedded_method_cleanup;

    // Set up initial variable values as needed
    b_pbToBeEmbedded = ((PyObject_IsTrue(pyvar_pbToBeEmbedded) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iterrainembeddeddatasource_put_tobeembedded_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITerrainEmbeddedDataSource->put_ToBeEmbedded(b_pbToBeEmbedded);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainEmbeddedDataSource->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainEmbeddedDataSource) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainEmbeddedDataSource.put_ToBeEmbedded() returned %ld", (long)hr);
        goto iterrainembeddeddatasource_put_tobeembedded_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pbToBeEmbedded

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterrainembeddeddatasource_put_tobeembedded_method_cleanup;

    iterrainembeddeddatasource_put_tobeembedded_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pbToBeEmbedded
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainEmbeddedDataSource.put_ToBeEmbedded");
    return return_tuple;
}

static PyObject*
ITerrainEmbeddedDataSourceMethod_get_ToBeEmbedded(PyITerrainEmbeddedDataSourceObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pbToBeEmbedded = VARIANT_FALSE;
    PyObject* pyvar_pbToBeEmbedded = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pbToBeEmbedded

    // Call method on actual COM interface
    hr = self->m_pITerrainEmbeddedDataSource->get_ToBeEmbedded(&b_pbToBeEmbedded);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainEmbeddedDataSource->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainEmbeddedDataSource) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainEmbeddedDataSource.get_ToBeEmbedded() returned %ld", (long)hr);
        goto iterrainembeddeddatasource_get_tobeembedded_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pbToBeEmbedded = ((b_pbToBeEmbedded == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto iterrainembeddeddatasource_get_tobeembedded_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pbToBeEmbedded);
    goto iterrainembeddeddatasource_get_tobeembedded_method_cleanup;

    iterrainembeddeddatasource_get_tobeembedded_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pbToBeEmbedded
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainEmbeddedDataSource.get_ToBeEmbedded");
    return return_tuple;
}

static PyObject*
ITerrainEmbeddedDataSourceMethod_put_Name(PyITerrainEmbeddedDataSourceObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspName = 0;
    PyObject* pyvar_pName;
    PyObject* unicodepName = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pName))
      goto iterrainembeddeddatasource_put_name_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_pName))
        unicodepName = PyUnicode_FromObject(pyvar_pName);
    else if (PyUnicode_Check(pyvar_pName))
    {
        unicodepName = pyvar_pName;
        Py_INCREF(unicodepName);
    }
    else if (pyvar_pName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter pName at index 0");
    if (unicodepName)
        bspName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodepName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodepName));
    
    if (PyErr_Occurred())
      goto iterrainembeddeddatasource_put_name_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITerrainEmbeddedDataSource->put_Name(bspName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainEmbeddedDataSource->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainEmbeddedDataSource) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainEmbeddedDataSource.put_Name() returned %ld", (long)hr);
        goto iterrainembeddeddatasource_put_name_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pName

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterrainembeddeddatasource_put_name_method_cleanup;

    iterrainembeddeddatasource_put_name_method_cleanup:
    self->m_HR = hr;
    if (bspName)
        ::SysFreeString(bspName);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainEmbeddedDataSource.put_Name");
    return return_tuple;
}

static PyObject*
ITerrainEmbeddedDataSourceMethod_get_Name(PyITerrainEmbeddedDataSourceObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspName;
    PyObject* pyvar_pName = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pName

    // Call method on actual COM interface
    hr = self->m_pITerrainEmbeddedDataSource->get_Name(&bspName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainEmbeddedDataSource->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainEmbeddedDataSource) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainEmbeddedDataSource.get_Name() returned %ld", (long)hr);
        goto iterrainembeddeddatasource_get_name_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pName = PyUnicode_FromWideChar(bspName,::SysStringLen(bspName));
    ::SysFreeString(bspName);
    
    if (PyErr_Occurred())
      goto iterrainembeddeddatasource_get_name_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pName);
    goto iterrainembeddeddatasource_get_name_method_cleanup;

    iterrainembeddeddatasource_get_name_method_cleanup:
    self->m_HR = hr;
    if (pyvar_pName != Py_None)
        Py_XDECREF(pyvar_pName);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainEmbeddedDataSource.get_Name");
    return return_tuple;
}

static PyObject*
ITerrainEmbeddedDataSourceMethod_SetReservedFields(PyITerrainEmbeddedDataSourceObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IStringArray* ippFields = NULL;
    PyObject* py_pFields;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_pFields))
      goto iterrainembeddeddatasource_setreservedfields_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pFields, &IID_IStringArray, (void**)&ippFields))
        PyErr_SetString(PyExc_TypeError, "Argument pFields (position 0) is not IStringArray");
    
    if (PyErr_Occurred())
      goto iterrainembeddeddatasource_setreservedfields_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITerrainEmbeddedDataSource->SetReservedFields(ippFields);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainEmbeddedDataSource->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainEmbeddedDataSource) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainEmbeddedDataSource.SetReservedFields() returned %ld", (long)hr);
        goto iterrainembeddeddatasource_setreservedfields_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pFields

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterrainembeddeddatasource_setreservedfields_method_cleanup;

    iterrainembeddeddatasource_setreservedfields_method_cleanup:
    self->m_HR = hr;
    if (ippFields)
      ippFields->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainEmbeddedDataSource.SetReservedFields");
    return return_tuple;
}

static PyObject*
ITerrainEmbeddedDataSourceMethod_GetReservedFields(PyITerrainEmbeddedDataSourceObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IStringArray* ipppFields = NULL;
    PyObject* py_ppFields = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppFields

    // Call method on actual COM interface
    hr = self->m_pITerrainEmbeddedDataSource->GetReservedFields(&ipppFields);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainEmbeddedDataSource->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainEmbeddedDataSource) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainEmbeddedDataSource.GetReservedFields() returned %ld", (long)hr);
        goto iterrainembeddeddatasource_getreservedfields_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppFields);
    if (ipppFields)
    {
        IUnknown* pUnk = NULL;
        ipppFields->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppFields = IUnknownToPythonIIDObject(pUnk, &IID_IStringArray);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppFields)
    {
        if (py_ppFields)
           Py_DECREF(py_ppFields);
        py_ppFields = Py_None;
        Py_INCREF(py_ppFields);
    }
    if (PyErr_Occurred())
      goto iterrainembeddeddatasource_getreservedfields_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppFields);
    goto iterrainembeddeddatasource_getreservedfields_method_cleanup;

    iterrainembeddeddatasource_getreservedfields_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppFields);
    if (ipppFields)
      ipppFields->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainEmbeddedDataSource.GetReservedFields");
    return return_tuple;
}


PyMethodDef PyITerrainEmbeddedDataSourceMethods[] = {
    {"supports", (PyCFunction)PyITerrainEmbeddedDataSource_SupportsInterface, METH_O, ""},
    {"put_ToBeEmbedded", (PyCFunction)ITerrainEmbeddedDataSourceMethod_put_ToBeEmbedded, METH_VARARGS, ""},
    {"get_ToBeEmbedded", (PyCFunction)ITerrainEmbeddedDataSourceMethod_get_ToBeEmbedded, METH_VARARGS, ""},
    {"put_Name", (PyCFunction)ITerrainEmbeddedDataSourceMethod_put_Name, METH_VARARGS, ""},
    {"get_Name", (PyCFunction)ITerrainEmbeddedDataSourceMethod_get_Name, METH_VARARGS, ""},
    {"SetReservedFields", (PyCFunction)ITerrainEmbeddedDataSourceMethod_SetReservedFields, METH_VARARGS, ""},
    {"GetReservedFields", (PyCFunction)ITerrainEmbeddedDataSourceMethod_GetReservedFields, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyITerrainEmbeddedDataSourceGetSet[] = {
  {"_pUnk", (getter)PyITerrainEmbeddedDataSource_GetpUnk, NULL, "Get opaque pointer to an Unknown from ITerrainEmbeddedDataSource", NULL},
  {"_pointer", (getter)PyITerrainEmbeddedDataSource_GetPointer, NULL, "Get memory address for ITerrainEmbeddedDataSource", NULL},
  {"_IID", (getter)PyITerrainEmbeddedDataSource_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyITerrainEmbeddedDataSource_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyITerrainEmbeddedDataSource_GetIgnoreFailures, (setter)PyITerrainEmbeddedDataSource_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyITerrainEmbeddedDataSourceObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.ITerrainEmbeddedDataSourceObject",                          
                                              /* tp_name */
  sizeof(PyITerrainEmbeddedDataSourceObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyITerrainEmbeddedDataSourceObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyITerrainEmbeddedDataSourceMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyITerrainEmbeddedDataSourceGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyITerrainEmbeddedDataSourceObject_new,                      
                                              /* tp_new */
};

// Interface ITerrainFieldStatistics

typedef struct PyITerrainFieldStatisticsObject {
    PyObject_HEAD
    ITerrainFieldStatistics* m_pITerrainFieldStatistics;
    HRESULT m_HR;
    int m_ignore_failures;
} PyITerrainFieldStatisticsObject;

static PyObject*
PyITerrainFieldStatisticsObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyITerrainFieldStatisticsObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ITerrainFieldStatistics* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ITerrainFieldStatistics, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ITerrainFieldStatistics with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyITerrainFieldStatisticsObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ITerrainFieldStatistics");
            return NULL;
        }
        self->m_pITerrainFieldStatistics = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ITerrainFieldStatistics");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ITerrainFieldStatistics");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ITerrainFieldStatistics* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ITerrainFieldStatistics, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ITerrainFieldStatistics");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyITerrainFieldStatisticsObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ITerrainFieldStatistics");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pITerrainFieldStatistics = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyITerrainFieldStatisticsObject_dealloc(PyITerrainFieldStatisticsObject* self)
{
    if (self->m_pITerrainFieldStatistics)
        self->m_pITerrainFieldStatistics->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyITerrainFieldStatistics_GetpUnk(PyITerrainFieldStatisticsObject* self)
{
    if (!self->m_pITerrainFieldStatistics)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pITerrainFieldStatistics->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ITerrainFieldStatistics to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyITerrainFieldStatistics_GetPointer(PyITerrainFieldStatisticsObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pITerrainFieldStatistics);
}

static PyObject*
PyITerrainFieldStatistics_GetIID(PyITerrainFieldStatisticsObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "3f30b349-518b-41fa-9f2e-e00d6f81af82");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyITerrainFieldStatistics_GetHR(PyITerrainFieldStatisticsObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyITerrainFieldStatistics_GetIgnoreFailures(PyITerrainFieldStatisticsObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyITerrainFieldStatistics_SetIgnoreFailures(PyITerrainFieldStatisticsObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyITerrainFieldStatistics_SupportsInterface(PyITerrainFieldStatisticsObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pITerrainFieldStatistics->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ITerrainFieldStatisticsMethod_get_IsEmpty(PyITerrainFieldStatisticsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pbIsEmpty = VARIANT_FALSE;
    PyObject* pyvar_pbIsEmpty = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pbIsEmpty

    // Call method on actual COM interface
    hr = self->m_pITerrainFieldStatistics->get_IsEmpty(&b_pbIsEmpty);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainFieldStatistics->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainFieldStatistics) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainFieldStatistics.get_IsEmpty() returned %ld", (long)hr);
        goto iterrainfieldstatistics_get_isempty_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pbIsEmpty = ((b_pbIsEmpty == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto iterrainfieldstatistics_get_isempty_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pbIsEmpty);
    goto iterrainfieldstatistics_get_isempty_method_cleanup;

    iterrainfieldstatistics_get_isempty_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pbIsEmpty
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainFieldStatistics.get_IsEmpty");
    return return_tuple;
}

static PyObject*
ITerrainFieldStatisticsMethod_get_NeedsUpdate(PyITerrainFieldStatisticsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pbNeedsUpdate = VARIANT_FALSE;
    PyObject* pyvar_pbNeedsUpdate = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pbNeedsUpdate

    // Call method on actual COM interface
    hr = self->m_pITerrainFieldStatistics->get_NeedsUpdate(&b_pbNeedsUpdate);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainFieldStatistics->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainFieldStatistics) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainFieldStatistics.get_NeedsUpdate() returned %ld", (long)hr);
        goto iterrainfieldstatistics_get_needsupdate_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pbNeedsUpdate = ((b_pbNeedsUpdate == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto iterrainfieldstatistics_get_needsupdate_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pbNeedsUpdate);
    goto iterrainfieldstatistics_get_needsupdate_method_cleanup;

    iterrainfieldstatistics_get_needsupdate_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pbNeedsUpdate
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainFieldStatistics.get_NeedsUpdate");
    return return_tuple;
}

static PyObject*
ITerrainFieldStatisticsMethod_get_FieldName(PyITerrainFieldStatisticsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspName;
    PyObject* pyvar_pName = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pName

    // Call method on actual COM interface
    hr = self->m_pITerrainFieldStatistics->get_FieldName(&bspName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainFieldStatistics->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainFieldStatistics) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainFieldStatistics.get_FieldName() returned %ld", (long)hr);
        goto iterrainfieldstatistics_get_fieldname_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pName = PyUnicode_FromWideChar(bspName,::SysStringLen(bspName));
    ::SysFreeString(bspName);
    
    if (PyErr_Occurred())
      goto iterrainfieldstatistics_get_fieldname_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pName);
    goto iterrainfieldstatistics_get_fieldname_method_cleanup;

    iterrainfieldstatistics_get_fieldname_method_cleanup:
    self->m_HR = hr;
    if (pyvar_pName != Py_None)
        Py_XDECREF(pyvar_pName);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainFieldStatistics.get_FieldName");
    return return_tuple;
}

static PyObject*
ITerrainFieldStatisticsMethod_get_Count(PyITerrainFieldStatisticsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dpCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pCount

    // Call method on actual COM interface
    hr = self->m_pITerrainFieldStatistics->get_Count(&dpCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainFieldStatistics->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainFieldStatistics) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainFieldStatistics.get_Count() returned %ld", (long)hr);
        goto iterrainfieldstatistics_get_count_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pCount

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dpCount);
    goto iterrainfieldstatistics_get_count_method_cleanup;

    iterrainfieldstatistics_get_count_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pCount
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainFieldStatistics.get_Count");
    return return_tuple;
}

static PyObject*
ITerrainFieldStatisticsMethod_get_Minimum(PyITerrainFieldStatisticsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dpMinimum = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pMinimum

    // Call method on actual COM interface
    hr = self->m_pITerrainFieldStatistics->get_Minimum(&dpMinimum);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainFieldStatistics->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainFieldStatistics) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainFieldStatistics.get_Minimum() returned %ld", (long)hr);
        goto iterrainfieldstatistics_get_minimum_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pMinimum

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dpMinimum);
    goto iterrainfieldstatistics_get_minimum_method_cleanup;

    iterrainfieldstatistics_get_minimum_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pMinimum
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainFieldStatistics.get_Minimum");
    return return_tuple;
}

static PyObject*
ITerrainFieldStatisticsMethod_get_Maximum(PyITerrainFieldStatisticsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dpMaximum = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pMaximum

    // Call method on actual COM interface
    hr = self->m_pITerrainFieldStatistics->get_Maximum(&dpMaximum);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainFieldStatistics->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainFieldStatistics) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainFieldStatistics.get_Maximum() returned %ld", (long)hr);
        goto iterrainfieldstatistics_get_maximum_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pMaximum

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dpMaximum);
    goto iterrainfieldstatistics_get_maximum_method_cleanup;

    iterrainfieldstatistics_get_maximum_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pMaximum
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainFieldStatistics.get_Maximum");
    return return_tuple;
}

static PyObject*
ITerrainFieldStatisticsMethod_get_Mean(PyITerrainFieldStatisticsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dpMean = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pMean

    // Call method on actual COM interface
    hr = self->m_pITerrainFieldStatistics->get_Mean(&dpMean);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainFieldStatistics->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainFieldStatistics) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainFieldStatistics.get_Mean() returned %ld", (long)hr);
        goto iterrainfieldstatistics_get_mean_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pMean

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dpMean);
    goto iterrainfieldstatistics_get_mean_method_cleanup;

    iterrainfieldstatistics_get_mean_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pMean
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainFieldStatistics.get_Mean");
    return return_tuple;
}

static PyObject*
ITerrainFieldStatisticsMethod_get_StandardDeviation(PyITerrainFieldStatisticsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dpStandardDeviation = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pStandardDeviation

    // Call method on actual COM interface
    hr = self->m_pITerrainFieldStatistics->get_StandardDeviation(&dpStandardDeviation);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainFieldStatistics->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainFieldStatistics) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainFieldStatistics.get_StandardDeviation() returned %ld", (long)hr);
        goto iterrainfieldstatistics_get_standarddeviation_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pStandardDeviation

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dpStandardDeviation);
    goto iterrainfieldstatistics_get_standarddeviation_method_cleanup;

    iterrainfieldstatistics_get_standarddeviation_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pStandardDeviation
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainFieldStatistics.get_StandardDeviation");
    return return_tuple;
}

static PyObject*
ITerrainFieldStatisticsMethod_get_UniqueValueType(PyITerrainFieldStatisticsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriTerrainBlobDataType epType;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pType

    // Call method on actual COM interface
    hr = self->m_pITerrainFieldStatistics->get_UniqueValueType(&epType);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainFieldStatistics->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainFieldStatistics) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainFieldStatistics.get_UniqueValueType() returned %ld", (long)hr);
        goto iterrainfieldstatistics_get_uniquevaluetype_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pType

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)epType);
    goto iterrainfieldstatistics_get_uniquevaluetype_method_cleanup;

    iterrainfieldstatistics_get_uniquevaluetype_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pType
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainFieldStatistics.get_UniqueValueType");
    return return_tuple;
}

static PyObject*
ITerrainFieldStatisticsMethod_GetUniqueValuesAsLong(PyITerrainFieldStatisticsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ILongArray* ipppValues = NULL;
    PyObject* py_ppValues = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppValues

    // Call method on actual COM interface
    hr = self->m_pITerrainFieldStatistics->GetUniqueValuesAsLong(&ipppValues);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainFieldStatistics->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainFieldStatistics) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainFieldStatistics.GetUniqueValuesAsLong() returned %ld", (long)hr);
        goto iterrainfieldstatistics_getuniquevaluesaslong_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppValues);
    if (ipppValues)
    {
        IUnknown* pUnk = NULL;
        ipppValues->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppValues = IUnknownToPythonIIDObject(pUnk, &IID_ILongArray);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppValues)
    {
        if (py_ppValues)
           Py_DECREF(py_ppValues);
        py_ppValues = Py_None;
        Py_INCREF(py_ppValues);
    }
    if (PyErr_Occurred())
      goto iterrainfieldstatistics_getuniquevaluesaslong_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppValues);
    goto iterrainfieldstatistics_getuniquevaluesaslong_method_cleanup;

    iterrainfieldstatistics_getuniquevaluesaslong_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppValues);
    if (ipppValues)
      ipppValues->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainFieldStatistics.GetUniqueValuesAsLong");
    return return_tuple;
}

static PyObject*
ITerrainFieldStatisticsMethod_GetUniqueValuesAsDouble(PyITerrainFieldStatisticsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IDoubleArray* ipppValues = NULL;
    PyObject* py_ppValues = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppValues

    // Call method on actual COM interface
    hr = self->m_pITerrainFieldStatistics->GetUniqueValuesAsDouble(&ipppValues);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainFieldStatistics->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainFieldStatistics) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainFieldStatistics.GetUniqueValuesAsDouble() returned %ld", (long)hr);
        goto iterrainfieldstatistics_getuniquevaluesasdouble_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppValues);
    if (ipppValues)
    {
        IUnknown* pUnk = NULL;
        ipppValues->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppValues = IUnknownToPythonIIDObject(pUnk, &IID_IDoubleArray);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppValues)
    {
        if (py_ppValues)
           Py_DECREF(py_ppValues);
        py_ppValues = Py_None;
        Py_INCREF(py_ppValues);
    }
    if (PyErr_Occurred())
      goto iterrainfieldstatistics_getuniquevaluesasdouble_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppValues);
    goto iterrainfieldstatistics_getuniquevaluesasdouble_method_cleanup;

    iterrainfieldstatistics_getuniquevaluesasdouble_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppValues);
    if (ipppValues)
      ipppValues->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainFieldStatistics.GetUniqueValuesAsDouble");
    return return_tuple;
}

static PyObject*
ITerrainFieldStatisticsMethod_GetUniqueValueCounts(PyITerrainFieldStatisticsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IDoubleArray* ipppCounts = NULL;
    PyObject* py_ppCounts = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppCounts

    // Call method on actual COM interface
    hr = self->m_pITerrainFieldStatistics->GetUniqueValueCounts(&ipppCounts);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainFieldStatistics->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainFieldStatistics) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainFieldStatistics.GetUniqueValueCounts() returned %ld", (long)hr);
        goto iterrainfieldstatistics_getuniquevaluecounts_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppCounts);
    if (ipppCounts)
    {
        IUnknown* pUnk = NULL;
        ipppCounts->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppCounts = IUnknownToPythonIIDObject(pUnk, &IID_IDoubleArray);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppCounts)
    {
        if (py_ppCounts)
           Py_DECREF(py_ppCounts);
        py_ppCounts = Py_None;
        Py_INCREF(py_ppCounts);
    }
    if (PyErr_Occurred())
      goto iterrainfieldstatistics_getuniquevaluecounts_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppCounts);
    goto iterrainfieldstatistics_getuniquevaluecounts_method_cleanup;

    iterrainfieldstatistics_getuniquevaluecounts_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppCounts);
    if (ipppCounts)
      ipppCounts->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainFieldStatistics.GetUniqueValueCounts");
    return return_tuple;
}


PyMethodDef PyITerrainFieldStatisticsMethods[] = {
    {"supports", (PyCFunction)PyITerrainFieldStatistics_SupportsInterface, METH_O, ""},
    {"get_IsEmpty", (PyCFunction)ITerrainFieldStatisticsMethod_get_IsEmpty, METH_VARARGS, ""},
    {"get_NeedsUpdate", (PyCFunction)ITerrainFieldStatisticsMethod_get_NeedsUpdate, METH_VARARGS, ""},
    {"get_FieldName", (PyCFunction)ITerrainFieldStatisticsMethod_get_FieldName, METH_VARARGS, ""},
    {"get_Count", (PyCFunction)ITerrainFieldStatisticsMethod_get_Count, METH_VARARGS, ""},
    {"get_Minimum", (PyCFunction)ITerrainFieldStatisticsMethod_get_Minimum, METH_VARARGS, ""},
    {"get_Maximum", (PyCFunction)ITerrainFieldStatisticsMethod_get_Maximum, METH_VARARGS, ""},
    {"get_Mean", (PyCFunction)ITerrainFieldStatisticsMethod_get_Mean, METH_VARARGS, ""},
    {"get_StandardDeviation", (PyCFunction)ITerrainFieldStatisticsMethod_get_StandardDeviation, METH_VARARGS, ""},
    {"get_UniqueValueType", (PyCFunction)ITerrainFieldStatisticsMethod_get_UniqueValueType, METH_VARARGS, ""},
    {"GetUniqueValuesAsLong", (PyCFunction)ITerrainFieldStatisticsMethod_GetUniqueValuesAsLong, METH_VARARGS, ""},
    {"GetUniqueValuesAsDouble", (PyCFunction)ITerrainFieldStatisticsMethod_GetUniqueValuesAsDouble, METH_VARARGS, ""},
    {"GetUniqueValueCounts", (PyCFunction)ITerrainFieldStatisticsMethod_GetUniqueValueCounts, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyITerrainFieldStatisticsGetSet[] = {
  {"_pUnk", (getter)PyITerrainFieldStatistics_GetpUnk, NULL, "Get opaque pointer to an Unknown from ITerrainFieldStatistics", NULL},
  {"_pointer", (getter)PyITerrainFieldStatistics_GetPointer, NULL, "Get memory address for ITerrainFieldStatistics", NULL},
  {"_IID", (getter)PyITerrainFieldStatistics_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyITerrainFieldStatistics_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyITerrainFieldStatistics_GetIgnoreFailures, (setter)PyITerrainFieldStatistics_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyITerrainFieldStatisticsObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.ITerrainFieldStatisticsObject",                          
                                              /* tp_name */
  sizeof(PyITerrainFieldStatisticsObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyITerrainFieldStatisticsObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyITerrainFieldStatisticsMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyITerrainFieldStatisticsGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyITerrainFieldStatisticsObject_new,                      
                                              /* tp_new */
};

// Interface ITerrainEmbeddedDataSource2

typedef struct PyITerrainEmbeddedDataSource2Object {
    PyObject_HEAD
    ITerrainEmbeddedDataSource2* m_pITerrainEmbeddedDataSource2;
    HRESULT m_HR;
    int m_ignore_failures;
} PyITerrainEmbeddedDataSource2Object;

static PyObject*
PyITerrainEmbeddedDataSource2Object_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyITerrainEmbeddedDataSource2Object* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ITerrainEmbeddedDataSource2* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ITerrainEmbeddedDataSource2, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ITerrainEmbeddedDataSource2 with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyITerrainEmbeddedDataSource2Object *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ITerrainEmbeddedDataSource2");
            return NULL;
        }
        self->m_pITerrainEmbeddedDataSource2 = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ITerrainEmbeddedDataSource2");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ITerrainEmbeddedDataSource2");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ITerrainEmbeddedDataSource2* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ITerrainEmbeddedDataSource2, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ITerrainEmbeddedDataSource2");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyITerrainEmbeddedDataSource2Object *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ITerrainEmbeddedDataSource2");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pITerrainEmbeddedDataSource2 = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyITerrainEmbeddedDataSource2Object_dealloc(PyITerrainEmbeddedDataSource2Object* self)
{
    if (self->m_pITerrainEmbeddedDataSource2)
        self->m_pITerrainEmbeddedDataSource2->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyITerrainEmbeddedDataSource2_GetpUnk(PyITerrainEmbeddedDataSource2Object* self)
{
    if (!self->m_pITerrainEmbeddedDataSource2)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pITerrainEmbeddedDataSource2->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ITerrainEmbeddedDataSource2 to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyITerrainEmbeddedDataSource2_GetPointer(PyITerrainEmbeddedDataSource2Object* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pITerrainEmbeddedDataSource2);
}

static PyObject*
PyITerrainEmbeddedDataSource2_GetIID(PyITerrainEmbeddedDataSource2Object* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "7a0bb0b6-b097-4fbf-be95-d32473b75ab1");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyITerrainEmbeddedDataSource2_GetHR(PyITerrainEmbeddedDataSource2Object* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyITerrainEmbeddedDataSource2_GetIgnoreFailures(PyITerrainEmbeddedDataSource2Object* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyITerrainEmbeddedDataSource2_SetIgnoreFailures(PyITerrainEmbeddedDataSource2Object* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyITerrainEmbeddedDataSource2_SupportsInterface(PyITerrainEmbeddedDataSource2Object* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pITerrainEmbeddedDataSource2->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ITerrainEmbeddedDataSource2Method_GetFieldStatistics(PyITerrainEmbeddedDataSource2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsFieldName = 0;
    PyObject* pyvar_FieldName;
    PyObject* unicodeFieldName = NULL;
    ITerrainFieldStatistics* ipppStatistics = NULL;
    PyObject* py_ppStatistics = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_FieldName))
      goto iterrainembeddeddatasource2_getfieldstatistics_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_FieldName))
        unicodeFieldName = PyUnicode_FromObject(pyvar_FieldName);
    else if (PyUnicode_Check(pyvar_FieldName))
    {
        unicodeFieldName = pyvar_FieldName;
        Py_INCREF(unicodeFieldName);
    }
    else if (pyvar_FieldName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter FieldName at index 0");
    if (unicodeFieldName)
        bsFieldName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeFieldName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeFieldName));
    
    if (PyErr_Occurred())
      goto iterrainembeddeddatasource2_getfieldstatistics_method_cleanup;
    
    // No setup for ppStatistics

    // Call method on actual COM interface
    hr = self->m_pITerrainEmbeddedDataSource2->GetFieldStatistics(bsFieldName, &ipppStatistics);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainEmbeddedDataSource2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainEmbeddedDataSource2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainEmbeddedDataSource2.GetFieldStatistics() returned %ld", (long)hr);
        goto iterrainembeddeddatasource2_getfieldstatistics_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for FieldName
    Py_XDECREF(py_ppStatistics);
    if (ipppStatistics)
    {
        IUnknown* pUnk = NULL;
        ipppStatistics->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppStatistics = IUnknownToPythonIIDObject(pUnk, &IID_ITerrainFieldStatistics);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppStatistics)
    {
        if (py_ppStatistics)
           Py_DECREF(py_ppStatistics);
        py_ppStatistics = Py_None;
        Py_INCREF(py_ppStatistics);
    }
    if (PyErr_Occurred())
      goto iterrainembeddeddatasource2_getfieldstatistics_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppStatistics);
    goto iterrainembeddeddatasource2_getfieldstatistics_method_cleanup;

    iterrainembeddeddatasource2_getfieldstatistics_method_cleanup:
    self->m_HR = hr;
    if (bsFieldName)
        ::SysFreeString(bsFieldName);
    
    Py_XDECREF(py_ppStatistics);
    if (ipppStatistics)
      ipppStatistics->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainEmbeddedDataSource2.GetFieldStatistics");
    return return_tuple;
}

static PyObject*
ITerrainEmbeddedDataSource2Method_GetReservedFieldStatistics(PyITerrainEmbeddedDataSource2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IArray* ipppStatistics = NULL;
    PyObject* py_ppStatistics = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppStatistics

    // Call method on actual COM interface
    hr = self->m_pITerrainEmbeddedDataSource2->GetReservedFieldStatistics(&ipppStatistics);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainEmbeddedDataSource2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainEmbeddedDataSource2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainEmbeddedDataSource2.GetReservedFieldStatistics() returned %ld", (long)hr);
        goto iterrainembeddeddatasource2_getreservedfieldstatistics_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppStatistics);
    if (ipppStatistics)
    {
        IUnknown* pUnk = NULL;
        ipppStatistics->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppStatistics = IUnknownToPythonIIDObject(pUnk, &IID_IArray);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppStatistics)
    {
        if (py_ppStatistics)
           Py_DECREF(py_ppStatistics);
        py_ppStatistics = Py_None;
        Py_INCREF(py_ppStatistics);
    }
    if (PyErr_Occurred())
      goto iterrainembeddeddatasource2_getreservedfieldstatistics_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppStatistics);
    goto iterrainembeddeddatasource2_getreservedfieldstatistics_method_cleanup;

    iterrainembeddeddatasource2_getreservedfieldstatistics_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppStatistics);
    if (ipppStatistics)
      ipppStatistics->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainEmbeddedDataSource2.GetReservedFieldStatistics");
    return return_tuple;
}

static PyObject*
ITerrainEmbeddedDataSource2Method_put_ToBeEmbedded(PyITerrainEmbeddedDataSource2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pbToBeEmbedded = VARIANT_FALSE;
    PyObject* pyvar_pbToBeEmbedded = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pbToBeEmbedded))
      goto iterrainembeddeddatasource2_put_tobeembedded_method_cleanup;

    // Set up initial variable values as needed
    b_pbToBeEmbedded = ((PyObject_IsTrue(pyvar_pbToBeEmbedded) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iterrainembeddeddatasource2_put_tobeembedded_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITerrainEmbeddedDataSource2->put_ToBeEmbedded(b_pbToBeEmbedded);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainEmbeddedDataSource2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainEmbeddedDataSource2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainEmbeddedDataSource2.put_ToBeEmbedded() returned %ld", (long)hr);
        goto iterrainembeddeddatasource2_put_tobeembedded_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pbToBeEmbedded

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterrainembeddeddatasource2_put_tobeembedded_method_cleanup;

    iterrainembeddeddatasource2_put_tobeembedded_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pbToBeEmbedded
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainEmbeddedDataSource2.put_ToBeEmbedded");
    return return_tuple;
}

static PyObject*
ITerrainEmbeddedDataSource2Method_get_ToBeEmbedded(PyITerrainEmbeddedDataSource2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pbToBeEmbedded = VARIANT_FALSE;
    PyObject* pyvar_pbToBeEmbedded = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pbToBeEmbedded

    // Call method on actual COM interface
    hr = self->m_pITerrainEmbeddedDataSource2->get_ToBeEmbedded(&b_pbToBeEmbedded);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainEmbeddedDataSource2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainEmbeddedDataSource2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainEmbeddedDataSource2.get_ToBeEmbedded() returned %ld", (long)hr);
        goto iterrainembeddeddatasource2_get_tobeembedded_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pbToBeEmbedded = ((b_pbToBeEmbedded == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto iterrainembeddeddatasource2_get_tobeembedded_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pbToBeEmbedded);
    goto iterrainembeddeddatasource2_get_tobeembedded_method_cleanup;

    iterrainembeddeddatasource2_get_tobeembedded_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pbToBeEmbedded
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainEmbeddedDataSource2.get_ToBeEmbedded");
    return return_tuple;
}

static PyObject*
ITerrainEmbeddedDataSource2Method_put_Name(PyITerrainEmbeddedDataSource2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspName = 0;
    PyObject* pyvar_pName;
    PyObject* unicodepName = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pName))
      goto iterrainembeddeddatasource2_put_name_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_pName))
        unicodepName = PyUnicode_FromObject(pyvar_pName);
    else if (PyUnicode_Check(pyvar_pName))
    {
        unicodepName = pyvar_pName;
        Py_INCREF(unicodepName);
    }
    else if (pyvar_pName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter pName at index 0");
    if (unicodepName)
        bspName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodepName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodepName));
    
    if (PyErr_Occurred())
      goto iterrainembeddeddatasource2_put_name_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITerrainEmbeddedDataSource2->put_Name(bspName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainEmbeddedDataSource2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainEmbeddedDataSource2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainEmbeddedDataSource2.put_Name() returned %ld", (long)hr);
        goto iterrainembeddeddatasource2_put_name_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pName

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterrainembeddeddatasource2_put_name_method_cleanup;

    iterrainembeddeddatasource2_put_name_method_cleanup:
    self->m_HR = hr;
    if (bspName)
        ::SysFreeString(bspName);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainEmbeddedDataSource2.put_Name");
    return return_tuple;
}

static PyObject*
ITerrainEmbeddedDataSource2Method_get_Name(PyITerrainEmbeddedDataSource2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspName;
    PyObject* pyvar_pName = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pName

    // Call method on actual COM interface
    hr = self->m_pITerrainEmbeddedDataSource2->get_Name(&bspName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainEmbeddedDataSource2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainEmbeddedDataSource2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainEmbeddedDataSource2.get_Name() returned %ld", (long)hr);
        goto iterrainembeddeddatasource2_get_name_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pName = PyUnicode_FromWideChar(bspName,::SysStringLen(bspName));
    ::SysFreeString(bspName);
    
    if (PyErr_Occurred())
      goto iterrainembeddeddatasource2_get_name_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pName);
    goto iterrainembeddeddatasource2_get_name_method_cleanup;

    iterrainembeddeddatasource2_get_name_method_cleanup:
    self->m_HR = hr;
    if (pyvar_pName != Py_None)
        Py_XDECREF(pyvar_pName);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainEmbeddedDataSource2.get_Name");
    return return_tuple;
}

static PyObject*
ITerrainEmbeddedDataSource2Method_SetReservedFields(PyITerrainEmbeddedDataSource2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IStringArray* ippFields = NULL;
    PyObject* py_pFields;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_pFields))
      goto iterrainembeddeddatasource2_setreservedfields_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pFields, &IID_IStringArray, (void**)&ippFields))
        PyErr_SetString(PyExc_TypeError, "Argument pFields (position 0) is not IStringArray");
    
    if (PyErr_Occurred())
      goto iterrainembeddeddatasource2_setreservedfields_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITerrainEmbeddedDataSource2->SetReservedFields(ippFields);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainEmbeddedDataSource2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainEmbeddedDataSource2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainEmbeddedDataSource2.SetReservedFields() returned %ld", (long)hr);
        goto iterrainembeddeddatasource2_setreservedfields_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pFields

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterrainembeddeddatasource2_setreservedfields_method_cleanup;

    iterrainembeddeddatasource2_setreservedfields_method_cleanup:
    self->m_HR = hr;
    if (ippFields)
      ippFields->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainEmbeddedDataSource2.SetReservedFields");
    return return_tuple;
}

static PyObject*
ITerrainEmbeddedDataSource2Method_GetReservedFields(PyITerrainEmbeddedDataSource2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IStringArray* ipppFields = NULL;
    PyObject* py_ppFields = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppFields

    // Call method on actual COM interface
    hr = self->m_pITerrainEmbeddedDataSource2->GetReservedFields(&ipppFields);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainEmbeddedDataSource2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainEmbeddedDataSource2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainEmbeddedDataSource2.GetReservedFields() returned %ld", (long)hr);
        goto iterrainembeddeddatasource2_getreservedfields_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppFields);
    if (ipppFields)
    {
        IUnknown* pUnk = NULL;
        ipppFields->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppFields = IUnknownToPythonIIDObject(pUnk, &IID_IStringArray);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppFields)
    {
        if (py_ppFields)
           Py_DECREF(py_ppFields);
        py_ppFields = Py_None;
        Py_INCREF(py_ppFields);
    }
    if (PyErr_Occurred())
      goto iterrainembeddeddatasource2_getreservedfields_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppFields);
    goto iterrainembeddeddatasource2_getreservedfields_method_cleanup;

    iterrainembeddeddatasource2_getreservedfields_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppFields);
    if (ipppFields)
      ipppFields->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainEmbeddedDataSource2.GetReservedFields");
    return return_tuple;
}


PyMethodDef PyITerrainEmbeddedDataSource2Methods[] = {
    {"supports", (PyCFunction)PyITerrainEmbeddedDataSource2_SupportsInterface, METH_O, ""},
    {"GetFieldStatistics", (PyCFunction)ITerrainEmbeddedDataSource2Method_GetFieldStatistics, METH_VARARGS, ""},
    {"GetReservedFieldStatistics", (PyCFunction)ITerrainEmbeddedDataSource2Method_GetReservedFieldStatistics, METH_VARARGS, ""},
    {"put_ToBeEmbedded", (PyCFunction)ITerrainEmbeddedDataSource2Method_put_ToBeEmbedded, METH_VARARGS, ""},
    {"get_ToBeEmbedded", (PyCFunction)ITerrainEmbeddedDataSource2Method_get_ToBeEmbedded, METH_VARARGS, ""},
    {"put_Name", (PyCFunction)ITerrainEmbeddedDataSource2Method_put_Name, METH_VARARGS, ""},
    {"get_Name", (PyCFunction)ITerrainEmbeddedDataSource2Method_get_Name, METH_VARARGS, ""},
    {"SetReservedFields", (PyCFunction)ITerrainEmbeddedDataSource2Method_SetReservedFields, METH_VARARGS, ""},
    {"GetReservedFields", (PyCFunction)ITerrainEmbeddedDataSource2Method_GetReservedFields, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyITerrainEmbeddedDataSource2GetSet[] = {
  {"_pUnk", (getter)PyITerrainEmbeddedDataSource2_GetpUnk, NULL, "Get opaque pointer to an Unknown from ITerrainEmbeddedDataSource2", NULL},
  {"_pointer", (getter)PyITerrainEmbeddedDataSource2_GetPointer, NULL, "Get memory address for ITerrainEmbeddedDataSource2", NULL},
  {"_IID", (getter)PyITerrainEmbeddedDataSource2_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyITerrainEmbeddedDataSource2_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyITerrainEmbeddedDataSource2_GetIgnoreFailures, (setter)PyITerrainEmbeddedDataSource2_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyITerrainEmbeddedDataSource2Object_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.ITerrainEmbeddedDataSource2Object",                          
                                              /* tp_name */
  sizeof(PyITerrainEmbeddedDataSource2Object),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyITerrainEmbeddedDataSource2Object_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyITerrainEmbeddedDataSource2Methods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyITerrainEmbeddedDataSource2GetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyITerrainEmbeddedDataSource2Object_new,                      
                                              /* tp_new */
};

// Interface ITerrainBlockCursor

typedef struct PyITerrainBlockCursorObject {
    PyObject_HEAD
    ITerrainBlockCursor* m_pITerrainBlockCursor;
    HRESULT m_HR;
    int m_ignore_failures;
} PyITerrainBlockCursorObject;

static PyObject*
PyITerrainBlockCursorObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyITerrainBlockCursorObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ITerrainBlockCursor* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ITerrainBlockCursor, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ITerrainBlockCursor with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyITerrainBlockCursorObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ITerrainBlockCursor");
            return NULL;
        }
        self->m_pITerrainBlockCursor = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ITerrainBlockCursor");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ITerrainBlockCursor");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ITerrainBlockCursor* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ITerrainBlockCursor, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ITerrainBlockCursor");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyITerrainBlockCursorObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ITerrainBlockCursor");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pITerrainBlockCursor = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyITerrainBlockCursorObject_dealloc(PyITerrainBlockCursorObject* self)
{
    if (self->m_pITerrainBlockCursor)
        self->m_pITerrainBlockCursor->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyITerrainBlockCursor_GetpUnk(PyITerrainBlockCursorObject* self)
{
    if (!self->m_pITerrainBlockCursor)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pITerrainBlockCursor->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ITerrainBlockCursor to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyITerrainBlockCursor_GetPointer(PyITerrainBlockCursorObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pITerrainBlockCursor);
}

static PyObject*
PyITerrainBlockCursor_GetIID(PyITerrainBlockCursorObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "3f4fe9ad-471b-4d67-8f8f-930a23a60305");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyITerrainBlockCursor_GetHR(PyITerrainBlockCursorObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyITerrainBlockCursor_GetIgnoreFailures(PyITerrainBlockCursorObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyITerrainBlockCursor_SetIgnoreFailures(PyITerrainBlockCursorObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyITerrainBlockCursor_SupportsInterface(PyITerrainBlockCursorObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pITerrainBlockCursor->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ITerrainBlockCursorMethod_get_BlockCount(PyITerrainBlockCursorObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpcBlocks = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pcBlocks

    // Call method on actual COM interface
    hr = self->m_pITerrainBlockCursor->get_BlockCount(&lpcBlocks);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainBlockCursor->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainBlockCursor) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainBlockCursor.get_BlockCount() returned %ld", (long)hr);
        goto iterrainblockcursor_get_blockcount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pcBlocks

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpcBlocks);
    goto iterrainblockcursor_get_blockcount_method_cleanup;

    iterrainblockcursor_get_blockcount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pcBlocks
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainBlockCursor.get_BlockCount");
    return return_tuple;
}

static PyObject*
ITerrainBlockCursorMethod_Next(PyITerrainBlockCursorObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpRowBegin = 0;
    long lpRowEnd = 0;
    long lpColBegin = 0;
    long lpColEnd = 0;
    VARIANT_BOOL b_pbIsEnd = VARIANT_FALSE;
    PyObject* pyvar_pbIsEnd = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pRowBegin
    // No setup for pRowEnd
    // No setup for pColBegin
    // No setup for pColEnd
    // No setup for pbIsEnd

    // Call method on actual COM interface
    hr = self->m_pITerrainBlockCursor->Next(&lpRowBegin, &lpRowEnd, &lpColBegin, &lpColEnd, &b_pbIsEnd);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainBlockCursor->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainBlockCursor) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainBlockCursor.Next() returned %ld", (long)hr);
        goto iterrainblockcursor_next_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pRowBegin
    // No teardown for pRowEnd
    // No teardown for pColBegin
    // No teardown for pColEnd
    pyvar_pbIsEnd = ((b_pbIsEnd == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto iterrainblockcursor_next_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("llllO",
                                            lpRowBegin, lpRowEnd, lpColBegin, lpColEnd, pyvar_pbIsEnd);
    goto iterrainblockcursor_next_method_cleanup;

    iterrainblockcursor_next_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pRowBegin
    // No cleanup for pRowEnd
    // No cleanup for pColBegin
    // No cleanup for pColEnd
    // No cleanup for pbIsEnd
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainBlockCursor.Next");
    return return_tuple;
}

static PyObject*
ITerrainBlockCursorMethod_NextAsTin(PyITerrainBlockCursorObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ITin* ipppTin = NULL;
    PyObject* py_ppTin = NULL;
    IEnvelope* ipppExtent = NULL;
    PyObject* py_ppExtent = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppTin
    // No setup for ppExtent

    // Call method on actual COM interface
    hr = self->m_pITerrainBlockCursor->NextAsTin(&ipppTin, &ipppExtent);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainBlockCursor->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainBlockCursor) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainBlockCursor.NextAsTin() returned %ld", (long)hr);
        goto iterrainblockcursor_nextastin_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppTin);
    if (ipppTin)
    {
        IUnknown* pUnk = NULL;
        ipppTin->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppTin = IUnknownToPythonIIDObject(pUnk, &IID_ITin);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppTin)
    {
        if (py_ppTin)
           Py_DECREF(py_ppTin);
        py_ppTin = Py_None;
        Py_INCREF(py_ppTin);
    }
    if (PyErr_Occurred())
      goto iterrainblockcursor_nextastin_method_cleanup;
    
    Py_XDECREF(py_ppExtent);
    if (ipppExtent)
    {
        IUnknown* pUnk = NULL;
        ipppExtent->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppExtent = IUnknownToPythonIIDObject(pUnk, &IID_IEnvelope);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppExtent)
    {
        if (py_ppExtent)
           Py_DECREF(py_ppExtent);
        py_ppExtent = Py_None;
        Py_INCREF(py_ppExtent);
    }
    if (PyErr_Occurred())
      goto iterrainblockcursor_nextastin_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("OO",
                                            py_ppTin, py_ppExtent);
    goto iterrainblockcursor_nextastin_method_cleanup;

    iterrainblockcursor_nextastin_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppTin);
    if (ipppTin)
      ipppTin->Release();
    Py_XDECREF(py_ppExtent);
    if (ipppExtent)
      ipppExtent->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainBlockCursor.NextAsTin");
    return return_tuple;
}

static PyObject*
ITerrainBlockCursorMethod_Reset(PyITerrainBlockCursorObject* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pITerrainBlockCursor->Reset();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainBlockCursor->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainBlockCursor) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainBlockCursor.Reset() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}


PyMethodDef PyITerrainBlockCursorMethods[] = {
    {"supports", (PyCFunction)PyITerrainBlockCursor_SupportsInterface, METH_O, ""},
    {"get_BlockCount", (PyCFunction)ITerrainBlockCursorMethod_get_BlockCount, METH_VARARGS, ""},
    {"Next", (PyCFunction)ITerrainBlockCursorMethod_Next, METH_VARARGS, ""},
    {"NextAsTin", (PyCFunction)ITerrainBlockCursorMethod_NextAsTin, METH_VARARGS, ""},
    {"Reset", (PyCFunction)ITerrainBlockCursorMethod_Reset, METH_NOARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyITerrainBlockCursorGetSet[] = {
  {"_pUnk", (getter)PyITerrainBlockCursor_GetpUnk, NULL, "Get opaque pointer to an Unknown from ITerrainBlockCursor", NULL},
  {"_pointer", (getter)PyITerrainBlockCursor_GetPointer, NULL, "Get memory address for ITerrainBlockCursor", NULL},
  {"_IID", (getter)PyITerrainBlockCursor_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyITerrainBlockCursor_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyITerrainBlockCursor_GetIgnoreFailures, (setter)PyITerrainBlockCursor_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyITerrainBlockCursorObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.ITerrainBlockCursorObject",                          
                                              /* tp_name */
  sizeof(PyITerrainBlockCursorObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyITerrainBlockCursorObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyITerrainBlockCursorMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyITerrainBlockCursorGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyITerrainBlockCursorObject_new,                      
                                              /* tp_new */
};

// Interface ITerrainDataImporter

typedef struct PyITerrainDataImporterObject {
    PyObject_HEAD
    ITerrainDataImporter* m_pITerrainDataImporter;
    HRESULT m_HR;
    int m_ignore_failures;
} PyITerrainDataImporterObject;

static PyObject*
PyITerrainDataImporterObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyITerrainDataImporterObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ITerrainDataImporter* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ITerrainDataImporter, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ITerrainDataImporter with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyITerrainDataImporterObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ITerrainDataImporter");
            return NULL;
        }
        self->m_pITerrainDataImporter = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ITerrainDataImporter");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ITerrainDataImporter");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ITerrainDataImporter* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ITerrainDataImporter, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ITerrainDataImporter");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyITerrainDataImporterObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ITerrainDataImporter");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pITerrainDataImporter = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyITerrainDataImporterObject_dealloc(PyITerrainDataImporterObject* self)
{
    if (self->m_pITerrainDataImporter)
        self->m_pITerrainDataImporter->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyITerrainDataImporter_GetpUnk(PyITerrainDataImporterObject* self)
{
    if (!self->m_pITerrainDataImporter)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pITerrainDataImporter->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ITerrainDataImporter to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyITerrainDataImporter_GetPointer(PyITerrainDataImporterObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pITerrainDataImporter);
}

static PyObject*
PyITerrainDataImporter_GetIID(PyITerrainDataImporterObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "36b3f42a-abe0-440e-a266-8b8592c74c82");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyITerrainDataImporter_GetHR(PyITerrainDataImporterObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyITerrainDataImporter_GetIgnoreFailures(PyITerrainDataImporterObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyITerrainDataImporter_SetIgnoreFailures(PyITerrainDataImporterObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyITerrainDataImporter_SupportsInterface(PyITerrainDataImporterObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pITerrainDataImporter->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ITerrainDataImporterMethod_SetSourceDataSpatialReference(PyITerrainDataImporterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ISpatialReference* ippSpatialRef = NULL;
    PyObject* py_pSpatialRef;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_pSpatialRef))
      goto iterraindataimporter_setsourcedataspatialreference_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pSpatialRef, &IID_ISpatialReference, (void**)&ippSpatialRef))
        PyErr_SetString(PyExc_TypeError, "Argument pSpatialRef (position 0) is not ISpatialReference");
    
    if (PyErr_Occurred())
      goto iterraindataimporter_setsourcedataspatialreference_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITerrainDataImporter->SetSourceDataSpatialReference(ippSpatialRef);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainDataImporter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainDataImporter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainDataImporter.SetSourceDataSpatialReference() returned %ld", (long)hr);
        goto iterraindataimporter_setsourcedataspatialreference_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pSpatialRef

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterraindataimporter_setsourcedataspatialreference_method_cleanup;

    iterraindataimporter_setsourcedataspatialreference_method_cleanup:
    self->m_HR = hr;
    if (ippSpatialRef)
      ippSpatialRef->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainDataImporter.SetSourceDataSpatialReference");
    return return_tuple;
}

static PyObject*
ITerrainDataImporterMethod_SetEmpty(PyITerrainDataImporterObject* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pITerrainDataImporter->SetEmpty();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainDataImporter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainDataImporter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainDataImporter.SetEmpty() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}

static PyObject*
ITerrainDataImporterMethod_get_MaxShapePointCount(PyITerrainDataImporterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pCount

    // Call method on actual COM interface
    hr = self->m_pITerrainDataImporter->get_MaxShapePointCount(&lpCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainDataImporter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainDataImporter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainDataImporter.get_MaxShapePointCount() returned %ld", (long)hr);
        goto iterraindataimporter_get_maxshapepointcount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pCount

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpCount);
    goto iterraindataimporter_get_maxshapepointcount_method_cleanup;

    iterraindataimporter_get_maxshapepointcount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pCount
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainDataImporter.get_MaxShapePointCount");
    return return_tuple;
}

static PyObject*
ITerrainDataImporterMethod_OverwriteMaxShapePointCount(PyITerrainDataImporterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lnewCount = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lnewCount))
      goto iterraindataimporter_overwritemaxshapepointcount_method_cleanup;

    // Set up initial variable values as needed
    // No setup for newCount

    // Call method on actual COM interface
    hr = self->m_pITerrainDataImporter->OverwriteMaxShapePointCount(lnewCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainDataImporter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainDataImporter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainDataImporter.OverwriteMaxShapePointCount() returned %ld", (long)hr);
        goto iterraindataimporter_overwritemaxshapepointcount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for newCount

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterraindataimporter_overwritemaxshapepointcount_method_cleanup;

    iterraindataimporter_overwritemaxshapepointcount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for newCount
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainDataImporter.OverwriteMaxShapePointCount");
    return return_tuple;
}

static PyObject*
ITerrainDataImporterMethod_AddFile(PyITerrainDataImporterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsfileName = 0;
    PyObject* pyvar_fileName;
    PyObject* unicodefileName = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_fileName))
      goto iterraindataimporter_addfile_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_fileName))
        unicodefileName = PyUnicode_FromObject(pyvar_fileName);
    else if (PyUnicode_Check(pyvar_fileName))
    {
        unicodefileName = pyvar_fileName;
        Py_INCREF(unicodefileName);
    }
    else if (pyvar_fileName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter fileName at index 0");
    if (unicodefileName)
        bsfileName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodefileName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodefileName));
    
    if (PyErr_Occurred())
      goto iterraindataimporter_addfile_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITerrainDataImporter->AddFile(bsfileName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainDataImporter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainDataImporter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainDataImporter.AddFile() returned %ld", (long)hr);
        goto iterraindataimporter_addfile_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for fileName

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterraindataimporter_addfile_method_cleanup;

    iterraindataimporter_addfile_method_cleanup:
    self->m_HR = hr;
    if (bsfileName)
        ::SysFreeString(bsfileName);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainDataImporter.AddFile");
    return return_tuple;
}

static PyObject*
ITerrainDataImporterMethod_AddFolder(PyITerrainDataImporterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsfolderName = 0;
    PyObject* pyvar_folderName;
    PyObject* unicodefolderName = NULL;
    BSTR bsfileExtension = 0;
    PyObject* pyvar_fileExtension;
    PyObject* unicodefileExtension = NULL;
    VARIANT_BOOL b_bRecursive = VARIANT_FALSE;
    PyObject* pyvar_bRecursive = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOO", &pyvar_folderName, &pyvar_fileExtension, &pyvar_bRecursive))
      goto iterraindataimporter_addfolder_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_folderName))
        unicodefolderName = PyUnicode_FromObject(pyvar_folderName);
    else if (PyUnicode_Check(pyvar_folderName))
    {
        unicodefolderName = pyvar_folderName;
        Py_INCREF(unicodefolderName);
    }
    else if (pyvar_folderName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter folderName at index 0");
    if (unicodefolderName)
        bsfolderName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodefolderName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodefolderName));
    
    if (PyErr_Occurred())
      goto iterraindataimporter_addfolder_method_cleanup;
    
    if (PyString_Check(pyvar_fileExtension))
        unicodefileExtension = PyUnicode_FromObject(pyvar_fileExtension);
    else if (PyUnicode_Check(pyvar_fileExtension))
    {
        unicodefileExtension = pyvar_fileExtension;
        Py_INCREF(unicodefileExtension);
    }
    else if (pyvar_fileExtension != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter fileExtension at index 1");
    if (unicodefileExtension)
        bsfileExtension = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodefileExtension), 
                                            (UINT)PyUnicode_GET_SIZE(unicodefileExtension));
    
    if (PyErr_Occurred())
      goto iterraindataimporter_addfolder_method_cleanup;
    
    b_bRecursive = ((PyObject_IsTrue(pyvar_bRecursive) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iterraindataimporter_addfolder_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITerrainDataImporter->AddFolder(bsfolderName, bsfileExtension, b_bRecursive);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainDataImporter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainDataImporter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainDataImporter.AddFolder() returned %ld", (long)hr);
        goto iterraindataimporter_addfolder_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for folderName
    // No teardown for fileExtension
    // No teardown for bRecursive

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterraindataimporter_addfolder_method_cleanup;

    iterraindataimporter_addfolder_method_cleanup:
    self->m_HR = hr;
    if (bsfolderName)
        ::SysFreeString(bsfolderName);
    
    if (bsfileExtension)
        ::SysFreeString(bsfileExtension);
    
    // No cleanup for bRecursive
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainDataImporter.AddFolder");
    return return_tuple;
}

static PyObject*
ITerrainDataImporterMethod_GetDataExtent(PyITerrainDataImporterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ISpatialReference* ippTargetSpatialReference = NULL;
    PyObject* py_pTargetSpatialReference;
    IEnvelope* ipppExt = NULL;
    PyObject* py_ppExt = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_pTargetSpatialReference))
      goto iterraindataimporter_getdataextent_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pTargetSpatialReference, &IID_ISpatialReference, (void**)&ippTargetSpatialReference))
        PyErr_SetString(PyExc_TypeError, "Argument pTargetSpatialReference (position 0) is not ISpatialReference");
    
    if (PyErr_Occurred())
      goto iterraindataimporter_getdataextent_method_cleanup;
    
    // No setup for ppExt

    // Call method on actual COM interface
    hr = self->m_pITerrainDataImporter->GetDataExtent(ippTargetSpatialReference, &ipppExt);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainDataImporter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainDataImporter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainDataImporter.GetDataExtent() returned %ld", (long)hr);
        goto iterraindataimporter_getdataextent_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pTargetSpatialReference
    Py_XDECREF(py_ppExt);
    if (ipppExt)
    {
        IUnknown* pUnk = NULL;
        ipppExt->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppExt = IUnknownToPythonIIDObject(pUnk, &IID_IEnvelope);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppExt)
    {
        if (py_ppExt)
           Py_DECREF(py_ppExt);
        py_ppExt = Py_None;
        Py_INCREF(py_ppExt);
    }
    if (PyErr_Occurred())
      goto iterraindataimporter_getdataextent_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppExt);
    goto iterraindataimporter_getdataextent_method_cleanup;

    iterraindataimporter_getdataextent_method_cleanup:
    self->m_HR = hr;
    if (ippTargetSpatialReference)
      ippTargetSpatialReference->Release();
    Py_XDECREF(py_ppExt);
    if (ipppExt)
      ipppExt->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainDataImporter.GetDataExtent");
    return return_tuple;
}

static PyObject*
ITerrainDataImporterMethod_GetPointCount(PyITerrainDataImporterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dpCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pCount

    // Call method on actual COM interface
    hr = self->m_pITerrainDataImporter->GetPointCount(&dpCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainDataImporter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainDataImporter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainDataImporter.GetPointCount() returned %ld", (long)hr);
        goto iterraindataimporter_getpointcount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pCount

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dpCount);
    goto iterraindataimporter_getpointcount_method_cleanup;

    iterraindataimporter_getpointcount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pCount
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainDataImporter.GetPointCount");
    return return_tuple;
}

static PyObject*
ITerrainDataImporterMethod_Import(PyITerrainDataImporterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IFeatureClass* ippOutputFeatureClass = NULL;
    PyObject* py_pOutputFeatureClass;
    double dTileSize = 0;
    double dZFactor = 0;
    IEnvelope* ippAOI = NULL;
    PyObject* py_pAOI;
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;
    long lpcOutsidePoints = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OddOO", &py_pOutputFeatureClass, &dTileSize, &dZFactor, &py_pAOI, &py_pTrackCancel))
      goto iterraindataimporter_import_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pOutputFeatureClass, &IID_IFeatureClass, (void**)&ippOutputFeatureClass))
        PyErr_SetString(PyExc_TypeError, "Argument pOutputFeatureClass (position 0) is not IFeatureClass");
    
    if (PyErr_Occurred())
      goto iterraindataimporter_import_method_cleanup;
    
    // No setup for TileSize
    // No setup for ZFactor
    if (!IFaceFromPyObject(py_pAOI, &IID_IEnvelope, (void**)&ippAOI))
        PyErr_SetString(PyExc_TypeError, "Argument pAOI (position 3) is not IEnvelope");
    
    if (PyErr_Occurred())
      goto iterraindataimporter_import_method_cleanup;
    
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 4) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto iterraindataimporter_import_method_cleanup;
    
    // No setup for pcOutsidePoints

    // Call method on actual COM interface
    hr = self->m_pITerrainDataImporter->Import(ippOutputFeatureClass, dTileSize, dZFactor, ippAOI, ippTrackCancel, &lpcOutsidePoints);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainDataImporter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainDataImporter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainDataImporter.Import() returned %ld", (long)hr);
        goto iterraindataimporter_import_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pOutputFeatureClass
    // No teardown for TileSize
    // No teardown for ZFactor
    // No teardown for pAOI
    // No teardown for pTrackCancel
    // No teardown for pcOutsidePoints

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpcOutsidePoints);
    goto iterraindataimporter_import_method_cleanup;

    iterraindataimporter_import_method_cleanup:
    self->m_HR = hr;
    if (ippOutputFeatureClass)
      ippOutputFeatureClass->Release();
    // No cleanup for TileSize
    // No cleanup for ZFactor
    if (ippAOI)
      ippAOI->Release();
    if (ippTrackCancel)
      ippTrackCancel->Release();
    // No cleanup for pcOutsidePoints
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainDataImporter.Import");
    return return_tuple;
}


PyMethodDef PyITerrainDataImporterMethods[] = {
    {"supports", (PyCFunction)PyITerrainDataImporter_SupportsInterface, METH_O, ""},
    {"SetSourceDataSpatialReference", (PyCFunction)ITerrainDataImporterMethod_SetSourceDataSpatialReference, METH_VARARGS, ""},
    {"SetEmpty", (PyCFunction)ITerrainDataImporterMethod_SetEmpty, METH_NOARGS, ""},
    {"get_MaxShapePointCount", (PyCFunction)ITerrainDataImporterMethod_get_MaxShapePointCount, METH_VARARGS, ""},
    {"OverwriteMaxShapePointCount", (PyCFunction)ITerrainDataImporterMethod_OverwriteMaxShapePointCount, METH_VARARGS, ""},
    {"AddFile", (PyCFunction)ITerrainDataImporterMethod_AddFile, METH_VARARGS, ""},
    {"AddFolder", (PyCFunction)ITerrainDataImporterMethod_AddFolder, METH_VARARGS, ""},
    {"GetDataExtent", (PyCFunction)ITerrainDataImporterMethod_GetDataExtent, METH_VARARGS, ""},
    {"GetPointCount", (PyCFunction)ITerrainDataImporterMethod_GetPointCount, METH_VARARGS, ""},
    {"Import", (PyCFunction)ITerrainDataImporterMethod_Import, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyITerrainDataImporterGetSet[] = {
  {"_pUnk", (getter)PyITerrainDataImporter_GetpUnk, NULL, "Get opaque pointer to an Unknown from ITerrainDataImporter", NULL},
  {"_pointer", (getter)PyITerrainDataImporter_GetPointer, NULL, "Get memory address for ITerrainDataImporter", NULL},
  {"_IID", (getter)PyITerrainDataImporter_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyITerrainDataImporter_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyITerrainDataImporter_GetIgnoreFailures, (setter)PyITerrainDataImporter_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyITerrainDataImporterObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.ITerrainDataImporterObject",                          
                                              /* tp_name */
  sizeof(PyITerrainDataImporterObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyITerrainDataImporterObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyITerrainDataImporterMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyITerrainDataImporterGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyITerrainDataImporterObject_new,                      
                                              /* tp_new */
};

// Interface ITerrainLasDataImporter

typedef struct PyITerrainLasDataImporterObject {
    PyObject_HEAD
    ITerrainLasDataImporter* m_pITerrainLasDataImporter;
    HRESULT m_HR;
    int m_ignore_failures;
} PyITerrainLasDataImporterObject;

static PyObject*
PyITerrainLasDataImporterObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyITerrainLasDataImporterObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ITerrainLasDataImporter* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ITerrainLasDataImporter, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ITerrainLasDataImporter with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyITerrainLasDataImporterObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ITerrainLasDataImporter");
            return NULL;
        }
        self->m_pITerrainLasDataImporter = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ITerrainLasDataImporter");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ITerrainLasDataImporter");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ITerrainLasDataImporter* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ITerrainLasDataImporter, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ITerrainLasDataImporter");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyITerrainLasDataImporterObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ITerrainLasDataImporter");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pITerrainLasDataImporter = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyITerrainLasDataImporterObject_dealloc(PyITerrainLasDataImporterObject* self)
{
    if (self->m_pITerrainLasDataImporter)
        self->m_pITerrainLasDataImporter->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyITerrainLasDataImporter_GetpUnk(PyITerrainLasDataImporterObject* self)
{
    if (!self->m_pITerrainLasDataImporter)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pITerrainLasDataImporter->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ITerrainLasDataImporter to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyITerrainLasDataImporter_GetPointer(PyITerrainLasDataImporterObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pITerrainLasDataImporter);
}

static PyObject*
PyITerrainLasDataImporter_GetIID(PyITerrainLasDataImporterObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "80e83e8c-2ec1-4090-b399-411fa593b25b");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyITerrainLasDataImporter_GetHR(PyITerrainLasDataImporterObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyITerrainLasDataImporter_GetIgnoreFailures(PyITerrainLasDataImporterObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyITerrainLasDataImporter_SetIgnoreFailures(PyITerrainLasDataImporterObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyITerrainLasDataImporter_SupportsInterface(PyITerrainLasDataImporterObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pITerrainLasDataImporter->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ITerrainLasDataImporterMethod_AddProperty(PyITerrainLasDataImporterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriTerrainLasDataPropertyType eproperty;
    BSTR bsFieldName = 0;
    PyObject* pyvar_FieldName;
    PyObject* unicodeFieldName = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "iO", (int *)&eproperty, &pyvar_FieldName))
      goto iterrainlasdataimporter_addproperty_method_cleanup;

    // Set up initial variable values as needed
    // No setup for property
    if (PyString_Check(pyvar_FieldName))
        unicodeFieldName = PyUnicode_FromObject(pyvar_FieldName);
    else if (PyUnicode_Check(pyvar_FieldName))
    {
        unicodeFieldName = pyvar_FieldName;
        Py_INCREF(unicodeFieldName);
    }
    else if (pyvar_FieldName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter FieldName at index 1");
    if (unicodeFieldName)
        bsFieldName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeFieldName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeFieldName));
    
    if (PyErr_Occurred())
      goto iterrainlasdataimporter_addproperty_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITerrainLasDataImporter->AddProperty(eproperty, bsFieldName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainLasDataImporter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainLasDataImporter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainLasDataImporter.AddProperty() returned %ld", (long)hr);
        goto iterrainlasdataimporter_addproperty_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for property
    // No teardown for FieldName

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterrainlasdataimporter_addproperty_method_cleanup;

    iterrainlasdataimporter_addproperty_method_cleanup:
    self->m_HR = hr;
    // No cleanup for property
    if (bsFieldName)
        ::SysFreeString(bsFieldName);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainLasDataImporter.AddProperty");
    return return_tuple;
}

static PyObject*
ITerrainLasDataImporterMethod_AddReturnNumber(PyITerrainLasDataImporterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriTerrainLasReturnType eReturnNumber;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&eReturnNumber))
      goto iterrainlasdataimporter_addreturnnumber_method_cleanup;

    // Set up initial variable values as needed
    // No setup for ReturnNumber

    // Call method on actual COM interface
    hr = self->m_pITerrainLasDataImporter->AddReturnNumber(eReturnNumber);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainLasDataImporter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainLasDataImporter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainLasDataImporter.AddReturnNumber() returned %ld", (long)hr);
        goto iterrainlasdataimporter_addreturnnumber_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ReturnNumber

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterrainlasdataimporter_addreturnnumber_method_cleanup;

    iterrainlasdataimporter_addreturnnumber_method_cleanup:
    self->m_HR = hr;
    // No cleanup for ReturnNumber
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainLasDataImporter.AddReturnNumber");
    return return_tuple;
}

static PyObject*
ITerrainLasDataImporterMethod_SetClassCodes(PyITerrainLasDataImporterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ILongArray* ippCodes = NULL;
    PyObject* py_pCodes;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_pCodes))
      goto iterrainlasdataimporter_setclasscodes_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pCodes, &IID_ILongArray, (void**)&ippCodes))
        PyErr_SetString(PyExc_TypeError, "Argument pCodes (position 0) is not ILongArray");
    
    if (PyErr_Occurred())
      goto iterrainlasdataimporter_setclasscodes_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITerrainLasDataImporter->SetClassCodes(ippCodes);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainLasDataImporter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainLasDataImporter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainLasDataImporter.SetClassCodes() returned %ld", (long)hr);
        goto iterrainlasdataimporter_setclasscodes_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pCodes

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterrainlasdataimporter_setclasscodes_method_cleanup;

    iterrainlasdataimporter_setclasscodes_method_cleanup:
    self->m_HR = hr;
    if (ippCodes)
      ippCodes->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainLasDataImporter.SetClassCodes");
    return return_tuple;
}

static PyObject*
ITerrainLasDataImporterMethod_SetSourceDataSpatialReference(PyITerrainLasDataImporterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ISpatialReference* ippSpatialRef = NULL;
    PyObject* py_pSpatialRef;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_pSpatialRef))
      goto iterrainlasdataimporter_setsourcedataspatialreference_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pSpatialRef, &IID_ISpatialReference, (void**)&ippSpatialRef))
        PyErr_SetString(PyExc_TypeError, "Argument pSpatialRef (position 0) is not ISpatialReference");
    
    if (PyErr_Occurred())
      goto iterrainlasdataimporter_setsourcedataspatialreference_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITerrainLasDataImporter->SetSourceDataSpatialReference(ippSpatialRef);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainLasDataImporter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainLasDataImporter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainLasDataImporter.SetSourceDataSpatialReference() returned %ld", (long)hr);
        goto iterrainlasdataimporter_setsourcedataspatialreference_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pSpatialRef

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterrainlasdataimporter_setsourcedataspatialreference_method_cleanup;

    iterrainlasdataimporter_setsourcedataspatialreference_method_cleanup:
    self->m_HR = hr;
    if (ippSpatialRef)
      ippSpatialRef->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainLasDataImporter.SetSourceDataSpatialReference");
    return return_tuple;
}

static PyObject*
ITerrainLasDataImporterMethod_SetEmpty(PyITerrainLasDataImporterObject* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pITerrainLasDataImporter->SetEmpty();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainLasDataImporter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainLasDataImporter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainLasDataImporter.SetEmpty() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}

static PyObject*
ITerrainLasDataImporterMethod_get_MaxShapePointCount(PyITerrainLasDataImporterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pCount

    // Call method on actual COM interface
    hr = self->m_pITerrainLasDataImporter->get_MaxShapePointCount(&lpCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainLasDataImporter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainLasDataImporter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainLasDataImporter.get_MaxShapePointCount() returned %ld", (long)hr);
        goto iterrainlasdataimporter_get_maxshapepointcount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pCount

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpCount);
    goto iterrainlasdataimporter_get_maxshapepointcount_method_cleanup;

    iterrainlasdataimporter_get_maxshapepointcount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pCount
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainLasDataImporter.get_MaxShapePointCount");
    return return_tuple;
}

static PyObject*
ITerrainLasDataImporterMethod_OverwriteMaxShapePointCount(PyITerrainLasDataImporterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lnewCount = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lnewCount))
      goto iterrainlasdataimporter_overwritemaxshapepointcount_method_cleanup;

    // Set up initial variable values as needed
    // No setup for newCount

    // Call method on actual COM interface
    hr = self->m_pITerrainLasDataImporter->OverwriteMaxShapePointCount(lnewCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainLasDataImporter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainLasDataImporter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainLasDataImporter.OverwriteMaxShapePointCount() returned %ld", (long)hr);
        goto iterrainlasdataimporter_overwritemaxshapepointcount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for newCount

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterrainlasdataimporter_overwritemaxshapepointcount_method_cleanup;

    iterrainlasdataimporter_overwritemaxshapepointcount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for newCount
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainLasDataImporter.OverwriteMaxShapePointCount");
    return return_tuple;
}

static PyObject*
ITerrainLasDataImporterMethod_AddFile(PyITerrainLasDataImporterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsfileName = 0;
    PyObject* pyvar_fileName;
    PyObject* unicodefileName = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_fileName))
      goto iterrainlasdataimporter_addfile_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_fileName))
        unicodefileName = PyUnicode_FromObject(pyvar_fileName);
    else if (PyUnicode_Check(pyvar_fileName))
    {
        unicodefileName = pyvar_fileName;
        Py_INCREF(unicodefileName);
    }
    else if (pyvar_fileName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter fileName at index 0");
    if (unicodefileName)
        bsfileName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodefileName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodefileName));
    
    if (PyErr_Occurred())
      goto iterrainlasdataimporter_addfile_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITerrainLasDataImporter->AddFile(bsfileName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainLasDataImporter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainLasDataImporter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainLasDataImporter.AddFile() returned %ld", (long)hr);
        goto iterrainlasdataimporter_addfile_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for fileName

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterrainlasdataimporter_addfile_method_cleanup;

    iterrainlasdataimporter_addfile_method_cleanup:
    self->m_HR = hr;
    if (bsfileName)
        ::SysFreeString(bsfileName);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainLasDataImporter.AddFile");
    return return_tuple;
}

static PyObject*
ITerrainLasDataImporterMethod_AddFolder(PyITerrainLasDataImporterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsfolderName = 0;
    PyObject* pyvar_folderName;
    PyObject* unicodefolderName = NULL;
    BSTR bsfileExtension = 0;
    PyObject* pyvar_fileExtension;
    PyObject* unicodefileExtension = NULL;
    VARIANT_BOOL b_bRecursive = VARIANT_FALSE;
    PyObject* pyvar_bRecursive = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOO", &pyvar_folderName, &pyvar_fileExtension, &pyvar_bRecursive))
      goto iterrainlasdataimporter_addfolder_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_folderName))
        unicodefolderName = PyUnicode_FromObject(pyvar_folderName);
    else if (PyUnicode_Check(pyvar_folderName))
    {
        unicodefolderName = pyvar_folderName;
        Py_INCREF(unicodefolderName);
    }
    else if (pyvar_folderName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter folderName at index 0");
    if (unicodefolderName)
        bsfolderName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodefolderName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodefolderName));
    
    if (PyErr_Occurred())
      goto iterrainlasdataimporter_addfolder_method_cleanup;
    
    if (PyString_Check(pyvar_fileExtension))
        unicodefileExtension = PyUnicode_FromObject(pyvar_fileExtension);
    else if (PyUnicode_Check(pyvar_fileExtension))
    {
        unicodefileExtension = pyvar_fileExtension;
        Py_INCREF(unicodefileExtension);
    }
    else if (pyvar_fileExtension != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter fileExtension at index 1");
    if (unicodefileExtension)
        bsfileExtension = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodefileExtension), 
                                            (UINT)PyUnicode_GET_SIZE(unicodefileExtension));
    
    if (PyErr_Occurred())
      goto iterrainlasdataimporter_addfolder_method_cleanup;
    
    b_bRecursive = ((PyObject_IsTrue(pyvar_bRecursive) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iterrainlasdataimporter_addfolder_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITerrainLasDataImporter->AddFolder(bsfolderName, bsfileExtension, b_bRecursive);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainLasDataImporter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainLasDataImporter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainLasDataImporter.AddFolder() returned %ld", (long)hr);
        goto iterrainlasdataimporter_addfolder_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for folderName
    // No teardown for fileExtension
    // No teardown for bRecursive

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterrainlasdataimporter_addfolder_method_cleanup;

    iterrainlasdataimporter_addfolder_method_cleanup:
    self->m_HR = hr;
    if (bsfolderName)
        ::SysFreeString(bsfolderName);
    
    if (bsfileExtension)
        ::SysFreeString(bsfileExtension);
    
    // No cleanup for bRecursive
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainLasDataImporter.AddFolder");
    return return_tuple;
}

static PyObject*
ITerrainLasDataImporterMethod_GetDataExtent(PyITerrainLasDataImporterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ISpatialReference* ippTargetSpatialReference = NULL;
    PyObject* py_pTargetSpatialReference;
    IEnvelope* ipppExt = NULL;
    PyObject* py_ppExt = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_pTargetSpatialReference))
      goto iterrainlasdataimporter_getdataextent_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pTargetSpatialReference, &IID_ISpatialReference, (void**)&ippTargetSpatialReference))
        PyErr_SetString(PyExc_TypeError, "Argument pTargetSpatialReference (position 0) is not ISpatialReference");
    
    if (PyErr_Occurred())
      goto iterrainlasdataimporter_getdataextent_method_cleanup;
    
    // No setup for ppExt

    // Call method on actual COM interface
    hr = self->m_pITerrainLasDataImporter->GetDataExtent(ippTargetSpatialReference, &ipppExt);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainLasDataImporter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainLasDataImporter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainLasDataImporter.GetDataExtent() returned %ld", (long)hr);
        goto iterrainlasdataimporter_getdataextent_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pTargetSpatialReference
    Py_XDECREF(py_ppExt);
    if (ipppExt)
    {
        IUnknown* pUnk = NULL;
        ipppExt->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppExt = IUnknownToPythonIIDObject(pUnk, &IID_IEnvelope);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppExt)
    {
        if (py_ppExt)
           Py_DECREF(py_ppExt);
        py_ppExt = Py_None;
        Py_INCREF(py_ppExt);
    }
    if (PyErr_Occurred())
      goto iterrainlasdataimporter_getdataextent_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppExt);
    goto iterrainlasdataimporter_getdataextent_method_cleanup;

    iterrainlasdataimporter_getdataextent_method_cleanup:
    self->m_HR = hr;
    if (ippTargetSpatialReference)
      ippTargetSpatialReference->Release();
    Py_XDECREF(py_ppExt);
    if (ipppExt)
      ipppExt->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainLasDataImporter.GetDataExtent");
    return return_tuple;
}

static PyObject*
ITerrainLasDataImporterMethod_GetPointCount(PyITerrainLasDataImporterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dpCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pCount

    // Call method on actual COM interface
    hr = self->m_pITerrainLasDataImporter->GetPointCount(&dpCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainLasDataImporter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainLasDataImporter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainLasDataImporter.GetPointCount() returned %ld", (long)hr);
        goto iterrainlasdataimporter_getpointcount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pCount

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dpCount);
    goto iterrainlasdataimporter_getpointcount_method_cleanup;

    iterrainlasdataimporter_getpointcount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pCount
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainLasDataImporter.GetPointCount");
    return return_tuple;
}

static PyObject*
ITerrainLasDataImporterMethod_Import(PyITerrainLasDataImporterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IFeatureClass* ippOutputFeatureClass = NULL;
    PyObject* py_pOutputFeatureClass;
    double dTileSize = 0;
    double dZFactor = 0;
    IEnvelope* ippAOI = NULL;
    PyObject* py_pAOI;
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;
    long lpcOutsidePoints = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OddOO", &py_pOutputFeatureClass, &dTileSize, &dZFactor, &py_pAOI, &py_pTrackCancel))
      goto iterrainlasdataimporter_import_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pOutputFeatureClass, &IID_IFeatureClass, (void**)&ippOutputFeatureClass))
        PyErr_SetString(PyExc_TypeError, "Argument pOutputFeatureClass (position 0) is not IFeatureClass");
    
    if (PyErr_Occurred())
      goto iterrainlasdataimporter_import_method_cleanup;
    
    // No setup for TileSize
    // No setup for ZFactor
    if (!IFaceFromPyObject(py_pAOI, &IID_IEnvelope, (void**)&ippAOI))
        PyErr_SetString(PyExc_TypeError, "Argument pAOI (position 3) is not IEnvelope");
    
    if (PyErr_Occurred())
      goto iterrainlasdataimporter_import_method_cleanup;
    
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 4) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto iterrainlasdataimporter_import_method_cleanup;
    
    // No setup for pcOutsidePoints

    // Call method on actual COM interface
    hr = self->m_pITerrainLasDataImporter->Import(ippOutputFeatureClass, dTileSize, dZFactor, ippAOI, ippTrackCancel, &lpcOutsidePoints);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainLasDataImporter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainLasDataImporter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainLasDataImporter.Import() returned %ld", (long)hr);
        goto iterrainlasdataimporter_import_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pOutputFeatureClass
    // No teardown for TileSize
    // No teardown for ZFactor
    // No teardown for pAOI
    // No teardown for pTrackCancel
    // No teardown for pcOutsidePoints

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpcOutsidePoints);
    goto iterrainlasdataimporter_import_method_cleanup;

    iterrainlasdataimporter_import_method_cleanup:
    self->m_HR = hr;
    if (ippOutputFeatureClass)
      ippOutputFeatureClass->Release();
    // No cleanup for TileSize
    // No cleanup for ZFactor
    if (ippAOI)
      ippAOI->Release();
    if (ippTrackCancel)
      ippTrackCancel->Release();
    // No cleanup for pcOutsidePoints
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainLasDataImporter.Import");
    return return_tuple;
}


PyMethodDef PyITerrainLasDataImporterMethods[] = {
    {"supports", (PyCFunction)PyITerrainLasDataImporter_SupportsInterface, METH_O, ""},
    {"AddProperty", (PyCFunction)ITerrainLasDataImporterMethod_AddProperty, METH_VARARGS, ""},
    {"AddReturnNumber", (PyCFunction)ITerrainLasDataImporterMethod_AddReturnNumber, METH_VARARGS, ""},
    {"SetClassCodes", (PyCFunction)ITerrainLasDataImporterMethod_SetClassCodes, METH_VARARGS, ""},
    {"SetSourceDataSpatialReference", (PyCFunction)ITerrainLasDataImporterMethod_SetSourceDataSpatialReference, METH_VARARGS, ""},
    {"SetEmpty", (PyCFunction)ITerrainLasDataImporterMethod_SetEmpty, METH_NOARGS, ""},
    {"get_MaxShapePointCount", (PyCFunction)ITerrainLasDataImporterMethod_get_MaxShapePointCount, METH_VARARGS, ""},
    {"OverwriteMaxShapePointCount", (PyCFunction)ITerrainLasDataImporterMethod_OverwriteMaxShapePointCount, METH_VARARGS, ""},
    {"AddFile", (PyCFunction)ITerrainLasDataImporterMethod_AddFile, METH_VARARGS, ""},
    {"AddFolder", (PyCFunction)ITerrainLasDataImporterMethod_AddFolder, METH_VARARGS, ""},
    {"GetDataExtent", (PyCFunction)ITerrainLasDataImporterMethod_GetDataExtent, METH_VARARGS, ""},
    {"GetPointCount", (PyCFunction)ITerrainLasDataImporterMethod_GetPointCount, METH_VARARGS, ""},
    {"Import", (PyCFunction)ITerrainLasDataImporterMethod_Import, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyITerrainLasDataImporterGetSet[] = {
  {"_pUnk", (getter)PyITerrainLasDataImporter_GetpUnk, NULL, "Get opaque pointer to an Unknown from ITerrainLasDataImporter", NULL},
  {"_pointer", (getter)PyITerrainLasDataImporter_GetPointer, NULL, "Get memory address for ITerrainLasDataImporter", NULL},
  {"_IID", (getter)PyITerrainLasDataImporter_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyITerrainLasDataImporter_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyITerrainLasDataImporter_GetIgnoreFailures, (setter)PyITerrainLasDataImporter_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyITerrainLasDataImporterObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.ITerrainLasDataImporterObject",                          
                                              /* tp_name */
  sizeof(PyITerrainLasDataImporterObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyITerrainLasDataImporterObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyITerrainLasDataImporterMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyITerrainLasDataImporterGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyITerrainLasDataImporterObject_new,                      
                                              /* tp_new */
};

// Interface ITerrainAsciiDataImporter

typedef struct PyITerrainAsciiDataImporterObject {
    PyObject_HEAD
    ITerrainAsciiDataImporter* m_pITerrainAsciiDataImporter;
    HRESULT m_HR;
    int m_ignore_failures;
} PyITerrainAsciiDataImporterObject;

static PyObject*
PyITerrainAsciiDataImporterObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyITerrainAsciiDataImporterObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ITerrainAsciiDataImporter* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ITerrainAsciiDataImporter, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ITerrainAsciiDataImporter with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyITerrainAsciiDataImporterObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ITerrainAsciiDataImporter");
            return NULL;
        }
        self->m_pITerrainAsciiDataImporter = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ITerrainAsciiDataImporter");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ITerrainAsciiDataImporter");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ITerrainAsciiDataImporter* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ITerrainAsciiDataImporter, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ITerrainAsciiDataImporter");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyITerrainAsciiDataImporterObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ITerrainAsciiDataImporter");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pITerrainAsciiDataImporter = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyITerrainAsciiDataImporterObject_dealloc(PyITerrainAsciiDataImporterObject* self)
{
    if (self->m_pITerrainAsciiDataImporter)
        self->m_pITerrainAsciiDataImporter->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyITerrainAsciiDataImporter_GetpUnk(PyITerrainAsciiDataImporterObject* self)
{
    if (!self->m_pITerrainAsciiDataImporter)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pITerrainAsciiDataImporter->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ITerrainAsciiDataImporter to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyITerrainAsciiDataImporter_GetPointer(PyITerrainAsciiDataImporterObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pITerrainAsciiDataImporter);
}

static PyObject*
PyITerrainAsciiDataImporter_GetIID(PyITerrainAsciiDataImporterObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "8d2d47f1-75bb-4346-b245-4178e9eb9b38");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyITerrainAsciiDataImporter_GetHR(PyITerrainAsciiDataImporterObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyITerrainAsciiDataImporter_GetIgnoreFailures(PyITerrainAsciiDataImporterObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyITerrainAsciiDataImporter_SetIgnoreFailures(PyITerrainAsciiDataImporterObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyITerrainAsciiDataImporter_SupportsInterface(PyITerrainAsciiDataImporterObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pITerrainAsciiDataImporter->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ITerrainAsciiDataImporterMethod_put_FileFormat(PyITerrainAsciiDataImporterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriTerrainAsciiDataFormatType epFormat;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&epFormat))
      goto iterrainasciidataimporter_put_fileformat_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pFormat

    // Call method on actual COM interface
    hr = self->m_pITerrainAsciiDataImporter->put_FileFormat(epFormat);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainAsciiDataImporter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainAsciiDataImporter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainAsciiDataImporter.put_FileFormat() returned %ld", (long)hr);
        goto iterrainasciidataimporter_put_fileformat_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pFormat

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterrainasciidataimporter_put_fileformat_method_cleanup;

    iterrainasciidataimporter_put_fileformat_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pFormat
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainAsciiDataImporter.put_FileFormat");
    return return_tuple;
}

static PyObject*
ITerrainAsciiDataImporterMethod_get_FileFormat(PyITerrainAsciiDataImporterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriTerrainAsciiDataFormatType epFormat;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pFormat

    // Call method on actual COM interface
    hr = self->m_pITerrainAsciiDataImporter->get_FileFormat(&epFormat);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainAsciiDataImporter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainAsciiDataImporter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainAsciiDataImporter.get_FileFormat() returned %ld", (long)hr);
        goto iterrainasciidataimporter_get_fileformat_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pFormat

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)epFormat);
    goto iterrainasciidataimporter_get_fileformat_method_cleanup;

    iterrainasciidataimporter_get_fileformat_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pFormat
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainAsciiDataImporter.get_FileFormat");
    return return_tuple;
}

static PyObject*
ITerrainAsciiDataImporterMethod_SetSourceDataSpatialReference(PyITerrainAsciiDataImporterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ISpatialReference* ippSpatialRef = NULL;
    PyObject* py_pSpatialRef;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_pSpatialRef))
      goto iterrainasciidataimporter_setsourcedataspatialreference_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pSpatialRef, &IID_ISpatialReference, (void**)&ippSpatialRef))
        PyErr_SetString(PyExc_TypeError, "Argument pSpatialRef (position 0) is not ISpatialReference");
    
    if (PyErr_Occurred())
      goto iterrainasciidataimporter_setsourcedataspatialreference_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITerrainAsciiDataImporter->SetSourceDataSpatialReference(ippSpatialRef);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainAsciiDataImporter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainAsciiDataImporter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainAsciiDataImporter.SetSourceDataSpatialReference() returned %ld", (long)hr);
        goto iterrainasciidataimporter_setsourcedataspatialreference_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pSpatialRef

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterrainasciidataimporter_setsourcedataspatialreference_method_cleanup;

    iterrainasciidataimporter_setsourcedataspatialreference_method_cleanup:
    self->m_HR = hr;
    if (ippSpatialRef)
      ippSpatialRef->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainAsciiDataImporter.SetSourceDataSpatialReference");
    return return_tuple;
}

static PyObject*
ITerrainAsciiDataImporterMethod_SetEmpty(PyITerrainAsciiDataImporterObject* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pITerrainAsciiDataImporter->SetEmpty();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainAsciiDataImporter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainAsciiDataImporter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainAsciiDataImporter.SetEmpty() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}

static PyObject*
ITerrainAsciiDataImporterMethod_get_MaxShapePointCount(PyITerrainAsciiDataImporterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pCount

    // Call method on actual COM interface
    hr = self->m_pITerrainAsciiDataImporter->get_MaxShapePointCount(&lpCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainAsciiDataImporter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainAsciiDataImporter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainAsciiDataImporter.get_MaxShapePointCount() returned %ld", (long)hr);
        goto iterrainasciidataimporter_get_maxshapepointcount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pCount

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpCount);
    goto iterrainasciidataimporter_get_maxshapepointcount_method_cleanup;

    iterrainasciidataimporter_get_maxshapepointcount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pCount
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainAsciiDataImporter.get_MaxShapePointCount");
    return return_tuple;
}

static PyObject*
ITerrainAsciiDataImporterMethod_OverwriteMaxShapePointCount(PyITerrainAsciiDataImporterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lnewCount = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lnewCount))
      goto iterrainasciidataimporter_overwritemaxshapepointcount_method_cleanup;

    // Set up initial variable values as needed
    // No setup for newCount

    // Call method on actual COM interface
    hr = self->m_pITerrainAsciiDataImporter->OverwriteMaxShapePointCount(lnewCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainAsciiDataImporter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainAsciiDataImporter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainAsciiDataImporter.OverwriteMaxShapePointCount() returned %ld", (long)hr);
        goto iterrainasciidataimporter_overwritemaxshapepointcount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for newCount

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterrainasciidataimporter_overwritemaxshapepointcount_method_cleanup;

    iterrainasciidataimporter_overwritemaxshapepointcount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for newCount
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainAsciiDataImporter.OverwriteMaxShapePointCount");
    return return_tuple;
}

static PyObject*
ITerrainAsciiDataImporterMethod_AddFile(PyITerrainAsciiDataImporterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsfileName = 0;
    PyObject* pyvar_fileName;
    PyObject* unicodefileName = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_fileName))
      goto iterrainasciidataimporter_addfile_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_fileName))
        unicodefileName = PyUnicode_FromObject(pyvar_fileName);
    else if (PyUnicode_Check(pyvar_fileName))
    {
        unicodefileName = pyvar_fileName;
        Py_INCREF(unicodefileName);
    }
    else if (pyvar_fileName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter fileName at index 0");
    if (unicodefileName)
        bsfileName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodefileName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodefileName));
    
    if (PyErr_Occurred())
      goto iterrainasciidataimporter_addfile_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITerrainAsciiDataImporter->AddFile(bsfileName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainAsciiDataImporter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainAsciiDataImporter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainAsciiDataImporter.AddFile() returned %ld", (long)hr);
        goto iterrainasciidataimporter_addfile_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for fileName

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterrainasciidataimporter_addfile_method_cleanup;

    iterrainasciidataimporter_addfile_method_cleanup:
    self->m_HR = hr;
    if (bsfileName)
        ::SysFreeString(bsfileName);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainAsciiDataImporter.AddFile");
    return return_tuple;
}

static PyObject*
ITerrainAsciiDataImporterMethod_AddFolder(PyITerrainAsciiDataImporterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsfolderName = 0;
    PyObject* pyvar_folderName;
    PyObject* unicodefolderName = NULL;
    BSTR bsfileExtension = 0;
    PyObject* pyvar_fileExtension;
    PyObject* unicodefileExtension = NULL;
    VARIANT_BOOL b_bRecursive = VARIANT_FALSE;
    PyObject* pyvar_bRecursive = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOO", &pyvar_folderName, &pyvar_fileExtension, &pyvar_bRecursive))
      goto iterrainasciidataimporter_addfolder_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_folderName))
        unicodefolderName = PyUnicode_FromObject(pyvar_folderName);
    else if (PyUnicode_Check(pyvar_folderName))
    {
        unicodefolderName = pyvar_folderName;
        Py_INCREF(unicodefolderName);
    }
    else if (pyvar_folderName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter folderName at index 0");
    if (unicodefolderName)
        bsfolderName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodefolderName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodefolderName));
    
    if (PyErr_Occurred())
      goto iterrainasciidataimporter_addfolder_method_cleanup;
    
    if (PyString_Check(pyvar_fileExtension))
        unicodefileExtension = PyUnicode_FromObject(pyvar_fileExtension);
    else if (PyUnicode_Check(pyvar_fileExtension))
    {
        unicodefileExtension = pyvar_fileExtension;
        Py_INCREF(unicodefileExtension);
    }
    else if (pyvar_fileExtension != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter fileExtension at index 1");
    if (unicodefileExtension)
        bsfileExtension = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodefileExtension), 
                                            (UINT)PyUnicode_GET_SIZE(unicodefileExtension));
    
    if (PyErr_Occurred())
      goto iterrainasciidataimporter_addfolder_method_cleanup;
    
    b_bRecursive = ((PyObject_IsTrue(pyvar_bRecursive) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iterrainasciidataimporter_addfolder_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITerrainAsciiDataImporter->AddFolder(bsfolderName, bsfileExtension, b_bRecursive);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainAsciiDataImporter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainAsciiDataImporter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainAsciiDataImporter.AddFolder() returned %ld", (long)hr);
        goto iterrainasciidataimporter_addfolder_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for folderName
    // No teardown for fileExtension
    // No teardown for bRecursive

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterrainasciidataimporter_addfolder_method_cleanup;

    iterrainasciidataimporter_addfolder_method_cleanup:
    self->m_HR = hr;
    if (bsfolderName)
        ::SysFreeString(bsfolderName);
    
    if (bsfileExtension)
        ::SysFreeString(bsfileExtension);
    
    // No cleanup for bRecursive
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainAsciiDataImporter.AddFolder");
    return return_tuple;
}

static PyObject*
ITerrainAsciiDataImporterMethod_GetDataExtent(PyITerrainAsciiDataImporterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ISpatialReference* ippTargetSpatialReference = NULL;
    PyObject* py_pTargetSpatialReference;
    IEnvelope* ipppExt = NULL;
    PyObject* py_ppExt = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_pTargetSpatialReference))
      goto iterrainasciidataimporter_getdataextent_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pTargetSpatialReference, &IID_ISpatialReference, (void**)&ippTargetSpatialReference))
        PyErr_SetString(PyExc_TypeError, "Argument pTargetSpatialReference (position 0) is not ISpatialReference");
    
    if (PyErr_Occurred())
      goto iterrainasciidataimporter_getdataextent_method_cleanup;
    
    // No setup for ppExt

    // Call method on actual COM interface
    hr = self->m_pITerrainAsciiDataImporter->GetDataExtent(ippTargetSpatialReference, &ipppExt);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainAsciiDataImporter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainAsciiDataImporter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainAsciiDataImporter.GetDataExtent() returned %ld", (long)hr);
        goto iterrainasciidataimporter_getdataextent_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pTargetSpatialReference
    Py_XDECREF(py_ppExt);
    if (ipppExt)
    {
        IUnknown* pUnk = NULL;
        ipppExt->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppExt = IUnknownToPythonIIDObject(pUnk, &IID_IEnvelope);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppExt)
    {
        if (py_ppExt)
           Py_DECREF(py_ppExt);
        py_ppExt = Py_None;
        Py_INCREF(py_ppExt);
    }
    if (PyErr_Occurred())
      goto iterrainasciidataimporter_getdataextent_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppExt);
    goto iterrainasciidataimporter_getdataextent_method_cleanup;

    iterrainasciidataimporter_getdataextent_method_cleanup:
    self->m_HR = hr;
    if (ippTargetSpatialReference)
      ippTargetSpatialReference->Release();
    Py_XDECREF(py_ppExt);
    if (ipppExt)
      ipppExt->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainAsciiDataImporter.GetDataExtent");
    return return_tuple;
}

static PyObject*
ITerrainAsciiDataImporterMethod_GetPointCount(PyITerrainAsciiDataImporterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dpCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pCount

    // Call method on actual COM interface
    hr = self->m_pITerrainAsciiDataImporter->GetPointCount(&dpCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainAsciiDataImporter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainAsciiDataImporter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainAsciiDataImporter.GetPointCount() returned %ld", (long)hr);
        goto iterrainasciidataimporter_getpointcount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pCount

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dpCount);
    goto iterrainasciidataimporter_getpointcount_method_cleanup;

    iterrainasciidataimporter_getpointcount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pCount
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainAsciiDataImporter.GetPointCount");
    return return_tuple;
}

static PyObject*
ITerrainAsciiDataImporterMethod_Import(PyITerrainAsciiDataImporterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IFeatureClass* ippOutputFeatureClass = NULL;
    PyObject* py_pOutputFeatureClass;
    double dTileSize = 0;
    double dZFactor = 0;
    IEnvelope* ippAOI = NULL;
    PyObject* py_pAOI;
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;
    long lpcOutsidePoints = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OddOO", &py_pOutputFeatureClass, &dTileSize, &dZFactor, &py_pAOI, &py_pTrackCancel))
      goto iterrainasciidataimporter_import_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pOutputFeatureClass, &IID_IFeatureClass, (void**)&ippOutputFeatureClass))
        PyErr_SetString(PyExc_TypeError, "Argument pOutputFeatureClass (position 0) is not IFeatureClass");
    
    if (PyErr_Occurred())
      goto iterrainasciidataimporter_import_method_cleanup;
    
    // No setup for TileSize
    // No setup for ZFactor
    if (!IFaceFromPyObject(py_pAOI, &IID_IEnvelope, (void**)&ippAOI))
        PyErr_SetString(PyExc_TypeError, "Argument pAOI (position 3) is not IEnvelope");
    
    if (PyErr_Occurred())
      goto iterrainasciidataimporter_import_method_cleanup;
    
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 4) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto iterrainasciidataimporter_import_method_cleanup;
    
    // No setup for pcOutsidePoints

    // Call method on actual COM interface
    hr = self->m_pITerrainAsciiDataImporter->Import(ippOutputFeatureClass, dTileSize, dZFactor, ippAOI, ippTrackCancel, &lpcOutsidePoints);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainAsciiDataImporter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainAsciiDataImporter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainAsciiDataImporter.Import() returned %ld", (long)hr);
        goto iterrainasciidataimporter_import_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pOutputFeatureClass
    // No teardown for TileSize
    // No teardown for ZFactor
    // No teardown for pAOI
    // No teardown for pTrackCancel
    // No teardown for pcOutsidePoints

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpcOutsidePoints);
    goto iterrainasciidataimporter_import_method_cleanup;

    iterrainasciidataimporter_import_method_cleanup:
    self->m_HR = hr;
    if (ippOutputFeatureClass)
      ippOutputFeatureClass->Release();
    // No cleanup for TileSize
    // No cleanup for ZFactor
    if (ippAOI)
      ippAOI->Release();
    if (ippTrackCancel)
      ippTrackCancel->Release();
    // No cleanup for pcOutsidePoints
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainAsciiDataImporter.Import");
    return return_tuple;
}


PyMethodDef PyITerrainAsciiDataImporterMethods[] = {
    {"supports", (PyCFunction)PyITerrainAsciiDataImporter_SupportsInterface, METH_O, ""},
    {"put_FileFormat", (PyCFunction)ITerrainAsciiDataImporterMethod_put_FileFormat, METH_VARARGS, ""},
    {"get_FileFormat", (PyCFunction)ITerrainAsciiDataImporterMethod_get_FileFormat, METH_VARARGS, ""},
    {"SetSourceDataSpatialReference", (PyCFunction)ITerrainAsciiDataImporterMethod_SetSourceDataSpatialReference, METH_VARARGS, ""},
    {"SetEmpty", (PyCFunction)ITerrainAsciiDataImporterMethod_SetEmpty, METH_NOARGS, ""},
    {"get_MaxShapePointCount", (PyCFunction)ITerrainAsciiDataImporterMethod_get_MaxShapePointCount, METH_VARARGS, ""},
    {"OverwriteMaxShapePointCount", (PyCFunction)ITerrainAsciiDataImporterMethod_OverwriteMaxShapePointCount, METH_VARARGS, ""},
    {"AddFile", (PyCFunction)ITerrainAsciiDataImporterMethod_AddFile, METH_VARARGS, ""},
    {"AddFolder", (PyCFunction)ITerrainAsciiDataImporterMethod_AddFolder, METH_VARARGS, ""},
    {"GetDataExtent", (PyCFunction)ITerrainAsciiDataImporterMethod_GetDataExtent, METH_VARARGS, ""},
    {"GetPointCount", (PyCFunction)ITerrainAsciiDataImporterMethod_GetPointCount, METH_VARARGS, ""},
    {"Import", (PyCFunction)ITerrainAsciiDataImporterMethod_Import, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyITerrainAsciiDataImporterGetSet[] = {
  {"_pUnk", (getter)PyITerrainAsciiDataImporter_GetpUnk, NULL, "Get opaque pointer to an Unknown from ITerrainAsciiDataImporter", NULL},
  {"_pointer", (getter)PyITerrainAsciiDataImporter_GetPointer, NULL, "Get memory address for ITerrainAsciiDataImporter", NULL},
  {"_IID", (getter)PyITerrainAsciiDataImporter_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyITerrainAsciiDataImporter_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyITerrainAsciiDataImporter_GetIgnoreFailures, (setter)PyITerrainAsciiDataImporter_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyITerrainAsciiDataImporterObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.ITerrainAsciiDataImporterObject",                          
                                              /* tp_name */
  sizeof(PyITerrainAsciiDataImporterObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyITerrainAsciiDataImporterObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyITerrainAsciiDataImporterMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyITerrainAsciiDataImporterGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyITerrainAsciiDataImporterObject_new,                      
                                              /* tp_new */
};

// Interface ITerrainAsciiDataImporter2

typedef struct PyITerrainAsciiDataImporter2Object {
    PyObject_HEAD
    ITerrainAsciiDataImporter2* m_pITerrainAsciiDataImporter2;
    HRESULT m_HR;
    int m_ignore_failures;
} PyITerrainAsciiDataImporter2Object;

static PyObject*
PyITerrainAsciiDataImporter2Object_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyITerrainAsciiDataImporter2Object* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ITerrainAsciiDataImporter2* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ITerrainAsciiDataImporter2, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ITerrainAsciiDataImporter2 with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyITerrainAsciiDataImporter2Object *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ITerrainAsciiDataImporter2");
            return NULL;
        }
        self->m_pITerrainAsciiDataImporter2 = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ITerrainAsciiDataImporter2");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ITerrainAsciiDataImporter2");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ITerrainAsciiDataImporter2* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ITerrainAsciiDataImporter2, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ITerrainAsciiDataImporter2");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyITerrainAsciiDataImporter2Object *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ITerrainAsciiDataImporter2");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pITerrainAsciiDataImporter2 = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyITerrainAsciiDataImporter2Object_dealloc(PyITerrainAsciiDataImporter2Object* self)
{
    if (self->m_pITerrainAsciiDataImporter2)
        self->m_pITerrainAsciiDataImporter2->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyITerrainAsciiDataImporter2_GetpUnk(PyITerrainAsciiDataImporter2Object* self)
{
    if (!self->m_pITerrainAsciiDataImporter2)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pITerrainAsciiDataImporter2->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ITerrainAsciiDataImporter2 to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyITerrainAsciiDataImporter2_GetPointer(PyITerrainAsciiDataImporter2Object* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pITerrainAsciiDataImporter2);
}

static PyObject*
PyITerrainAsciiDataImporter2_GetIID(PyITerrainAsciiDataImporter2Object* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "33f2e5c8-8e0e-4fc2-8b7b-d901c6e90ed8");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyITerrainAsciiDataImporter2_GetHR(PyITerrainAsciiDataImporter2Object* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyITerrainAsciiDataImporter2_GetIgnoreFailures(PyITerrainAsciiDataImporter2Object* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyITerrainAsciiDataImporter2_SetIgnoreFailures(PyITerrainAsciiDataImporter2Object* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyITerrainAsciiDataImporter2_SupportsInterface(PyITerrainAsciiDataImporter2Object* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pITerrainAsciiDataImporter2->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ITerrainAsciiDataImporter2Method_put_DecimalPointType(PyITerrainAsciiDataImporter2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriTerrainDecimalSeparatorType epType;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&epType))
      goto iterrainasciidataimporter2_put_decimalpointtype_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pType

    // Call method on actual COM interface
    hr = self->m_pITerrainAsciiDataImporter2->put_DecimalPointType(epType);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainAsciiDataImporter2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainAsciiDataImporter2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainAsciiDataImporter2.put_DecimalPointType() returned %ld", (long)hr);
        goto iterrainasciidataimporter2_put_decimalpointtype_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pType

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterrainasciidataimporter2_put_decimalpointtype_method_cleanup;

    iterrainasciidataimporter2_put_decimalpointtype_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pType
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainAsciiDataImporter2.put_DecimalPointType");
    return return_tuple;
}

static PyObject*
ITerrainAsciiDataImporter2Method_get_DecimalPointType(PyITerrainAsciiDataImporter2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriTerrainDecimalSeparatorType epType;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pType

    // Call method on actual COM interface
    hr = self->m_pITerrainAsciiDataImporter2->get_DecimalPointType(&epType);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainAsciiDataImporter2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainAsciiDataImporter2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainAsciiDataImporter2.get_DecimalPointType() returned %ld", (long)hr);
        goto iterrainasciidataimporter2_get_decimalpointtype_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pType

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)epType);
    goto iterrainasciidataimporter2_get_decimalpointtype_method_cleanup;

    iterrainasciidataimporter2_get_decimalpointtype_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pType
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainAsciiDataImporter2.get_DecimalPointType");
    return return_tuple;
}

static PyObject*
ITerrainAsciiDataImporter2Method_put_FileFormat(PyITerrainAsciiDataImporter2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriTerrainAsciiDataFormatType epFormat;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&epFormat))
      goto iterrainasciidataimporter2_put_fileformat_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pFormat

    // Call method on actual COM interface
    hr = self->m_pITerrainAsciiDataImporter2->put_FileFormat(epFormat);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainAsciiDataImporter2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainAsciiDataImporter2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainAsciiDataImporter2.put_FileFormat() returned %ld", (long)hr);
        goto iterrainasciidataimporter2_put_fileformat_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pFormat

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterrainasciidataimporter2_put_fileformat_method_cleanup;

    iterrainasciidataimporter2_put_fileformat_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pFormat
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainAsciiDataImporter2.put_FileFormat");
    return return_tuple;
}

static PyObject*
ITerrainAsciiDataImporter2Method_get_FileFormat(PyITerrainAsciiDataImporter2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriTerrainAsciiDataFormatType epFormat;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pFormat

    // Call method on actual COM interface
    hr = self->m_pITerrainAsciiDataImporter2->get_FileFormat(&epFormat);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainAsciiDataImporter2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainAsciiDataImporter2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainAsciiDataImporter2.get_FileFormat() returned %ld", (long)hr);
        goto iterrainasciidataimporter2_get_fileformat_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pFormat

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)epFormat);
    goto iterrainasciidataimporter2_get_fileformat_method_cleanup;

    iterrainasciidataimporter2_get_fileformat_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pFormat
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainAsciiDataImporter2.get_FileFormat");
    return return_tuple;
}

static PyObject*
ITerrainAsciiDataImporter2Method_SetSourceDataSpatialReference(PyITerrainAsciiDataImporter2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ISpatialReference* ippSpatialRef = NULL;
    PyObject* py_pSpatialRef;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_pSpatialRef))
      goto iterrainasciidataimporter2_setsourcedataspatialreference_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pSpatialRef, &IID_ISpatialReference, (void**)&ippSpatialRef))
        PyErr_SetString(PyExc_TypeError, "Argument pSpatialRef (position 0) is not ISpatialReference");
    
    if (PyErr_Occurred())
      goto iterrainasciidataimporter2_setsourcedataspatialreference_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITerrainAsciiDataImporter2->SetSourceDataSpatialReference(ippSpatialRef);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainAsciiDataImporter2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainAsciiDataImporter2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainAsciiDataImporter2.SetSourceDataSpatialReference() returned %ld", (long)hr);
        goto iterrainasciidataimporter2_setsourcedataspatialreference_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pSpatialRef

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterrainasciidataimporter2_setsourcedataspatialreference_method_cleanup;

    iterrainasciidataimporter2_setsourcedataspatialreference_method_cleanup:
    self->m_HR = hr;
    if (ippSpatialRef)
      ippSpatialRef->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainAsciiDataImporter2.SetSourceDataSpatialReference");
    return return_tuple;
}

static PyObject*
ITerrainAsciiDataImporter2Method_SetEmpty(PyITerrainAsciiDataImporter2Object* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pITerrainAsciiDataImporter2->SetEmpty();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainAsciiDataImporter2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainAsciiDataImporter2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainAsciiDataImporter2.SetEmpty() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}

static PyObject*
ITerrainAsciiDataImporter2Method_get_MaxShapePointCount(PyITerrainAsciiDataImporter2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pCount

    // Call method on actual COM interface
    hr = self->m_pITerrainAsciiDataImporter2->get_MaxShapePointCount(&lpCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainAsciiDataImporter2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainAsciiDataImporter2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainAsciiDataImporter2.get_MaxShapePointCount() returned %ld", (long)hr);
        goto iterrainasciidataimporter2_get_maxshapepointcount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pCount

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpCount);
    goto iterrainasciidataimporter2_get_maxshapepointcount_method_cleanup;

    iterrainasciidataimporter2_get_maxshapepointcount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pCount
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainAsciiDataImporter2.get_MaxShapePointCount");
    return return_tuple;
}

static PyObject*
ITerrainAsciiDataImporter2Method_OverwriteMaxShapePointCount(PyITerrainAsciiDataImporter2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lnewCount = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lnewCount))
      goto iterrainasciidataimporter2_overwritemaxshapepointcount_method_cleanup;

    // Set up initial variable values as needed
    // No setup for newCount

    // Call method on actual COM interface
    hr = self->m_pITerrainAsciiDataImporter2->OverwriteMaxShapePointCount(lnewCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainAsciiDataImporter2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainAsciiDataImporter2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainAsciiDataImporter2.OverwriteMaxShapePointCount() returned %ld", (long)hr);
        goto iterrainasciidataimporter2_overwritemaxshapepointcount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for newCount

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterrainasciidataimporter2_overwritemaxshapepointcount_method_cleanup;

    iterrainasciidataimporter2_overwritemaxshapepointcount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for newCount
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainAsciiDataImporter2.OverwriteMaxShapePointCount");
    return return_tuple;
}

static PyObject*
ITerrainAsciiDataImporter2Method_AddFile(PyITerrainAsciiDataImporter2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsfileName = 0;
    PyObject* pyvar_fileName;
    PyObject* unicodefileName = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_fileName))
      goto iterrainasciidataimporter2_addfile_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_fileName))
        unicodefileName = PyUnicode_FromObject(pyvar_fileName);
    else if (PyUnicode_Check(pyvar_fileName))
    {
        unicodefileName = pyvar_fileName;
        Py_INCREF(unicodefileName);
    }
    else if (pyvar_fileName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter fileName at index 0");
    if (unicodefileName)
        bsfileName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodefileName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodefileName));
    
    if (PyErr_Occurred())
      goto iterrainasciidataimporter2_addfile_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITerrainAsciiDataImporter2->AddFile(bsfileName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainAsciiDataImporter2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainAsciiDataImporter2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainAsciiDataImporter2.AddFile() returned %ld", (long)hr);
        goto iterrainasciidataimporter2_addfile_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for fileName

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterrainasciidataimporter2_addfile_method_cleanup;

    iterrainasciidataimporter2_addfile_method_cleanup:
    self->m_HR = hr;
    if (bsfileName)
        ::SysFreeString(bsfileName);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainAsciiDataImporter2.AddFile");
    return return_tuple;
}

static PyObject*
ITerrainAsciiDataImporter2Method_AddFolder(PyITerrainAsciiDataImporter2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsfolderName = 0;
    PyObject* pyvar_folderName;
    PyObject* unicodefolderName = NULL;
    BSTR bsfileExtension = 0;
    PyObject* pyvar_fileExtension;
    PyObject* unicodefileExtension = NULL;
    VARIANT_BOOL b_bRecursive = VARIANT_FALSE;
    PyObject* pyvar_bRecursive = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOO", &pyvar_folderName, &pyvar_fileExtension, &pyvar_bRecursive))
      goto iterrainasciidataimporter2_addfolder_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_folderName))
        unicodefolderName = PyUnicode_FromObject(pyvar_folderName);
    else if (PyUnicode_Check(pyvar_folderName))
    {
        unicodefolderName = pyvar_folderName;
        Py_INCREF(unicodefolderName);
    }
    else if (pyvar_folderName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter folderName at index 0");
    if (unicodefolderName)
        bsfolderName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodefolderName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodefolderName));
    
    if (PyErr_Occurred())
      goto iterrainasciidataimporter2_addfolder_method_cleanup;
    
    if (PyString_Check(pyvar_fileExtension))
        unicodefileExtension = PyUnicode_FromObject(pyvar_fileExtension);
    else if (PyUnicode_Check(pyvar_fileExtension))
    {
        unicodefileExtension = pyvar_fileExtension;
        Py_INCREF(unicodefileExtension);
    }
    else if (pyvar_fileExtension != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter fileExtension at index 1");
    if (unicodefileExtension)
        bsfileExtension = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodefileExtension), 
                                            (UINT)PyUnicode_GET_SIZE(unicodefileExtension));
    
    if (PyErr_Occurred())
      goto iterrainasciidataimporter2_addfolder_method_cleanup;
    
    b_bRecursive = ((PyObject_IsTrue(pyvar_bRecursive) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iterrainasciidataimporter2_addfolder_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITerrainAsciiDataImporter2->AddFolder(bsfolderName, bsfileExtension, b_bRecursive);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainAsciiDataImporter2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainAsciiDataImporter2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainAsciiDataImporter2.AddFolder() returned %ld", (long)hr);
        goto iterrainasciidataimporter2_addfolder_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for folderName
    // No teardown for fileExtension
    // No teardown for bRecursive

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterrainasciidataimporter2_addfolder_method_cleanup;

    iterrainasciidataimporter2_addfolder_method_cleanup:
    self->m_HR = hr;
    if (bsfolderName)
        ::SysFreeString(bsfolderName);
    
    if (bsfileExtension)
        ::SysFreeString(bsfileExtension);
    
    // No cleanup for bRecursive
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainAsciiDataImporter2.AddFolder");
    return return_tuple;
}

static PyObject*
ITerrainAsciiDataImporter2Method_GetDataExtent(PyITerrainAsciiDataImporter2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ISpatialReference* ippTargetSpatialReference = NULL;
    PyObject* py_pTargetSpatialReference;
    IEnvelope* ipppExt = NULL;
    PyObject* py_ppExt = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_pTargetSpatialReference))
      goto iterrainasciidataimporter2_getdataextent_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pTargetSpatialReference, &IID_ISpatialReference, (void**)&ippTargetSpatialReference))
        PyErr_SetString(PyExc_TypeError, "Argument pTargetSpatialReference (position 0) is not ISpatialReference");
    
    if (PyErr_Occurred())
      goto iterrainasciidataimporter2_getdataextent_method_cleanup;
    
    // No setup for ppExt

    // Call method on actual COM interface
    hr = self->m_pITerrainAsciiDataImporter2->GetDataExtent(ippTargetSpatialReference, &ipppExt);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainAsciiDataImporter2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainAsciiDataImporter2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainAsciiDataImporter2.GetDataExtent() returned %ld", (long)hr);
        goto iterrainasciidataimporter2_getdataextent_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pTargetSpatialReference
    Py_XDECREF(py_ppExt);
    if (ipppExt)
    {
        IUnknown* pUnk = NULL;
        ipppExt->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppExt = IUnknownToPythonIIDObject(pUnk, &IID_IEnvelope);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppExt)
    {
        if (py_ppExt)
           Py_DECREF(py_ppExt);
        py_ppExt = Py_None;
        Py_INCREF(py_ppExt);
    }
    if (PyErr_Occurred())
      goto iterrainasciidataimporter2_getdataextent_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppExt);
    goto iterrainasciidataimporter2_getdataextent_method_cleanup;

    iterrainasciidataimporter2_getdataextent_method_cleanup:
    self->m_HR = hr;
    if (ippTargetSpatialReference)
      ippTargetSpatialReference->Release();
    Py_XDECREF(py_ppExt);
    if (ipppExt)
      ipppExt->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainAsciiDataImporter2.GetDataExtent");
    return return_tuple;
}

static PyObject*
ITerrainAsciiDataImporter2Method_GetPointCount(PyITerrainAsciiDataImporter2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dpCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pCount

    // Call method on actual COM interface
    hr = self->m_pITerrainAsciiDataImporter2->GetPointCount(&dpCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainAsciiDataImporter2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainAsciiDataImporter2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainAsciiDataImporter2.GetPointCount() returned %ld", (long)hr);
        goto iterrainasciidataimporter2_getpointcount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pCount

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dpCount);
    goto iterrainasciidataimporter2_getpointcount_method_cleanup;

    iterrainasciidataimporter2_getpointcount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pCount
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainAsciiDataImporter2.GetPointCount");
    return return_tuple;
}

static PyObject*
ITerrainAsciiDataImporter2Method_Import(PyITerrainAsciiDataImporter2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IFeatureClass* ippOutputFeatureClass = NULL;
    PyObject* py_pOutputFeatureClass;
    double dTileSize = 0;
    double dZFactor = 0;
    IEnvelope* ippAOI = NULL;
    PyObject* py_pAOI;
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;
    long lpcOutsidePoints = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OddOO", &py_pOutputFeatureClass, &dTileSize, &dZFactor, &py_pAOI, &py_pTrackCancel))
      goto iterrainasciidataimporter2_import_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pOutputFeatureClass, &IID_IFeatureClass, (void**)&ippOutputFeatureClass))
        PyErr_SetString(PyExc_TypeError, "Argument pOutputFeatureClass (position 0) is not IFeatureClass");
    
    if (PyErr_Occurred())
      goto iterrainasciidataimporter2_import_method_cleanup;
    
    // No setup for TileSize
    // No setup for ZFactor
    if (!IFaceFromPyObject(py_pAOI, &IID_IEnvelope, (void**)&ippAOI))
        PyErr_SetString(PyExc_TypeError, "Argument pAOI (position 3) is not IEnvelope");
    
    if (PyErr_Occurred())
      goto iterrainasciidataimporter2_import_method_cleanup;
    
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 4) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto iterrainasciidataimporter2_import_method_cleanup;
    
    // No setup for pcOutsidePoints

    // Call method on actual COM interface
    hr = self->m_pITerrainAsciiDataImporter2->Import(ippOutputFeatureClass, dTileSize, dZFactor, ippAOI, ippTrackCancel, &lpcOutsidePoints);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainAsciiDataImporter2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainAsciiDataImporter2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainAsciiDataImporter2.Import() returned %ld", (long)hr);
        goto iterrainasciidataimporter2_import_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pOutputFeatureClass
    // No teardown for TileSize
    // No teardown for ZFactor
    // No teardown for pAOI
    // No teardown for pTrackCancel
    // No teardown for pcOutsidePoints

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpcOutsidePoints);
    goto iterrainasciidataimporter2_import_method_cleanup;

    iterrainasciidataimporter2_import_method_cleanup:
    self->m_HR = hr;
    if (ippOutputFeatureClass)
      ippOutputFeatureClass->Release();
    // No cleanup for TileSize
    // No cleanup for ZFactor
    if (ippAOI)
      ippAOI->Release();
    if (ippTrackCancel)
      ippTrackCancel->Release();
    // No cleanup for pcOutsidePoints
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainAsciiDataImporter2.Import");
    return return_tuple;
}


PyMethodDef PyITerrainAsciiDataImporter2Methods[] = {
    {"supports", (PyCFunction)PyITerrainAsciiDataImporter2_SupportsInterface, METH_O, ""},
    {"put_DecimalPointType", (PyCFunction)ITerrainAsciiDataImporter2Method_put_DecimalPointType, METH_VARARGS, ""},
    {"get_DecimalPointType", (PyCFunction)ITerrainAsciiDataImporter2Method_get_DecimalPointType, METH_VARARGS, ""},
    {"put_FileFormat", (PyCFunction)ITerrainAsciiDataImporter2Method_put_FileFormat, METH_VARARGS, ""},
    {"get_FileFormat", (PyCFunction)ITerrainAsciiDataImporter2Method_get_FileFormat, METH_VARARGS, ""},
    {"SetSourceDataSpatialReference", (PyCFunction)ITerrainAsciiDataImporter2Method_SetSourceDataSpatialReference, METH_VARARGS, ""},
    {"SetEmpty", (PyCFunction)ITerrainAsciiDataImporter2Method_SetEmpty, METH_NOARGS, ""},
    {"get_MaxShapePointCount", (PyCFunction)ITerrainAsciiDataImporter2Method_get_MaxShapePointCount, METH_VARARGS, ""},
    {"OverwriteMaxShapePointCount", (PyCFunction)ITerrainAsciiDataImporter2Method_OverwriteMaxShapePointCount, METH_VARARGS, ""},
    {"AddFile", (PyCFunction)ITerrainAsciiDataImporter2Method_AddFile, METH_VARARGS, ""},
    {"AddFolder", (PyCFunction)ITerrainAsciiDataImporter2Method_AddFolder, METH_VARARGS, ""},
    {"GetDataExtent", (PyCFunction)ITerrainAsciiDataImporter2Method_GetDataExtent, METH_VARARGS, ""},
    {"GetPointCount", (PyCFunction)ITerrainAsciiDataImporter2Method_GetPointCount, METH_VARARGS, ""},
    {"Import", (PyCFunction)ITerrainAsciiDataImporter2Method_Import, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyITerrainAsciiDataImporter2GetSet[] = {
  {"_pUnk", (getter)PyITerrainAsciiDataImporter2_GetpUnk, NULL, "Get opaque pointer to an Unknown from ITerrainAsciiDataImporter2", NULL},
  {"_pointer", (getter)PyITerrainAsciiDataImporter2_GetPointer, NULL, "Get memory address for ITerrainAsciiDataImporter2", NULL},
  {"_IID", (getter)PyITerrainAsciiDataImporter2_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyITerrainAsciiDataImporter2_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyITerrainAsciiDataImporter2_GetIgnoreFailures, (setter)PyITerrainAsciiDataImporter2_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyITerrainAsciiDataImporter2Object_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.ITerrainAsciiDataImporter2Object",                          
                                              /* tp_name */
  sizeof(PyITerrainAsciiDataImporter2Object),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyITerrainAsciiDataImporter2Object_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyITerrainAsciiDataImporter2Methods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyITerrainAsciiDataImporter2GetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyITerrainAsciiDataImporter2Object_new,                      
                                              /* tp_new */
};

// Interface ITerrainLasDataInfo

typedef struct PyITerrainLasDataInfoObject {
    PyObject_HEAD
    ITerrainLasDataInfo* m_pITerrainLasDataInfo;
    HRESULT m_HR;
    int m_ignore_failures;
} PyITerrainLasDataInfoObject;

static PyObject*
PyITerrainLasDataInfoObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyITerrainLasDataInfoObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ITerrainLasDataInfo* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ITerrainLasDataInfo, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ITerrainLasDataInfo with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyITerrainLasDataInfoObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ITerrainLasDataInfo");
            return NULL;
        }
        self->m_pITerrainLasDataInfo = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ITerrainLasDataInfo");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ITerrainLasDataInfo");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ITerrainLasDataInfo* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ITerrainLasDataInfo, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ITerrainLasDataInfo");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyITerrainLasDataInfoObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ITerrainLasDataInfo");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pITerrainLasDataInfo = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyITerrainLasDataInfoObject_dealloc(PyITerrainLasDataInfoObject* self)
{
    if (self->m_pITerrainLasDataInfo)
        self->m_pITerrainLasDataInfo->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyITerrainLasDataInfo_GetpUnk(PyITerrainLasDataInfoObject* self)
{
    if (!self->m_pITerrainLasDataInfo)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pITerrainLasDataInfo->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ITerrainLasDataInfo to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyITerrainLasDataInfo_GetPointer(PyITerrainLasDataInfoObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pITerrainLasDataInfo);
}

static PyObject*
PyITerrainLasDataInfo_GetIID(PyITerrainLasDataInfoObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "c1b7f6d6-4f81-4f5b-9922-5f74d3eb1e94");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyITerrainLasDataInfo_GetHR(PyITerrainLasDataInfoObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyITerrainLasDataInfo_GetIgnoreFailures(PyITerrainLasDataInfoObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyITerrainLasDataInfo_SetIgnoreFailures(PyITerrainLasDataInfoObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyITerrainLasDataInfo_SupportsInterface(PyITerrainLasDataInfoObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pITerrainLasDataInfo->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ITerrainLasDataInfoMethod_Init(PyITerrainLasDataInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bslasFileName = 0;
    PyObject* pyvar_lasFileName;
    PyObject* unicodelasFileName = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_lasFileName))
      goto iterrainlasdatainfo_init_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_lasFileName))
        unicodelasFileName = PyUnicode_FromObject(pyvar_lasFileName);
    else if (PyUnicode_Check(pyvar_lasFileName))
    {
        unicodelasFileName = pyvar_lasFileName;
        Py_INCREF(unicodelasFileName);
    }
    else if (pyvar_lasFileName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter lasFileName at index 0");
    if (unicodelasFileName)
        bslasFileName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodelasFileName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodelasFileName));
    
    if (PyErr_Occurred())
      goto iterrainlasdatainfo_init_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITerrainLasDataInfo->Init(bslasFileName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainLasDataInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainLasDataInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainLasDataInfo.Init() returned %ld", (long)hr);
        goto iterrainlasdatainfo_init_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for lasFileName

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterrainlasdatainfo_init_method_cleanup;

    iterrainlasdatainfo_init_method_cleanup:
    self->m_HR = hr;
    if (bslasFileName)
        ::SysFreeString(bslasFileName);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainLasDataInfo.Init");
    return return_tuple;
}

static PyObject*
ITerrainLasDataInfoMethod_GetVersion(PyITerrainLasDataInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpMajor = 0;
    long lpMinor = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pMajor
    // No setup for pMinor

    // Call method on actual COM interface
    hr = self->m_pITerrainLasDataInfo->GetVersion(&lpMajor, &lpMinor);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainLasDataInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainLasDataInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainLasDataInfo.GetVersion() returned %ld", (long)hr);
        goto iterrainlasdatainfo_getversion_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pMajor
    // No teardown for pMinor

    // Initialize output tuple
    return_tuple = Py_BuildValue("ll",
                                            lpMajor, lpMinor);
    goto iterrainlasdatainfo_getversion_method_cleanup;

    iterrainlasdatainfo_getversion_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pMajor
    // No cleanup for pMinor
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainLasDataInfo.GetVersion");
    return return_tuple;
}

static PyObject*
ITerrainLasDataInfoMethod_GetSystemID(PyITerrainLasDataInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspID;
    PyObject* pyvar_pID = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pID

    // Call method on actual COM interface
    hr = self->m_pITerrainLasDataInfo->GetSystemID(&bspID);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainLasDataInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainLasDataInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainLasDataInfo.GetSystemID() returned %ld", (long)hr);
        goto iterrainlasdatainfo_getsystemid_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pID = PyUnicode_FromWideChar(bspID,::SysStringLen(bspID));
    ::SysFreeString(bspID);
    
    if (PyErr_Occurred())
      goto iterrainlasdatainfo_getsystemid_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pID);
    goto iterrainlasdatainfo_getsystemid_method_cleanup;

    iterrainlasdatainfo_getsystemid_method_cleanup:
    self->m_HR = hr;
    if (pyvar_pID != Py_None)
        Py_XDECREF(pyvar_pID);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainLasDataInfo.GetSystemID");
    return return_tuple;
}

static PyObject*
ITerrainLasDataInfoMethod_GetGeneratingSoftware(PyITerrainLasDataInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspName;
    PyObject* pyvar_pName = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pName

    // Call method on actual COM interface
    hr = self->m_pITerrainLasDataInfo->GetGeneratingSoftware(&bspName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainLasDataInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainLasDataInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainLasDataInfo.GetGeneratingSoftware() returned %ld", (long)hr);
        goto iterrainlasdatainfo_getgeneratingsoftware_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pName = PyUnicode_FromWideChar(bspName,::SysStringLen(bspName));
    ::SysFreeString(bspName);
    
    if (PyErr_Occurred())
      goto iterrainlasdatainfo_getgeneratingsoftware_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pName);
    goto iterrainlasdatainfo_getgeneratingsoftware_method_cleanup;

    iterrainlasdatainfo_getgeneratingsoftware_method_cleanup:
    self->m_HR = hr;
    if (pyvar_pName != Py_None)
        Py_XDECREF(pyvar_pName);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainLasDataInfo.GetGeneratingSoftware");
    return return_tuple;
}

static PyObject*
ITerrainLasDataInfoMethod_GetFlightDateJulian(PyITerrainLasDataInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpDate = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pDate

    // Call method on actual COM interface
    hr = self->m_pITerrainLasDataInfo->GetFlightDateJulian(&lpDate);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainLasDataInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainLasDataInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainLasDataInfo.GetFlightDateJulian() returned %ld", (long)hr);
        goto iterrainlasdatainfo_getflightdatejulian_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pDate

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpDate);
    goto iterrainlasdatainfo_getflightdatejulian_method_cleanup;

    iterrainlasdatainfo_getflightdatejulian_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pDate
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainLasDataInfo.GetFlightDateJulian");
    return return_tuple;
}

static PyObject*
ITerrainLasDataInfoMethod_GetYear(PyITerrainLasDataInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpYear = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pYear

    // Call method on actual COM interface
    hr = self->m_pITerrainLasDataInfo->GetYear(&lpYear);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainLasDataInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainLasDataInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainLasDataInfo.GetYear() returned %ld", (long)hr);
        goto iterrainlasdatainfo_getyear_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pYear

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpYear);
    goto iterrainlasdatainfo_getyear_method_cleanup;

    iterrainlasdatainfo_getyear_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pYear
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainLasDataInfo.GetYear");
    return return_tuple;
}

static PyObject*
ITerrainLasDataInfoMethod_GetPointDataFormat(PyITerrainLasDataInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpFormat = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pFormat

    // Call method on actual COM interface
    hr = self->m_pITerrainLasDataInfo->GetPointDataFormat(&lpFormat);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainLasDataInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainLasDataInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainLasDataInfo.GetPointDataFormat() returned %ld", (long)hr);
        goto iterrainlasdatainfo_getpointdataformat_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pFormat

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpFormat);
    goto iterrainlasdatainfo_getpointdataformat_method_cleanup;

    iterrainlasdatainfo_getpointdataformat_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pFormat
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainLasDataInfo.GetPointDataFormat");
    return return_tuple;
}

static PyObject*
ITerrainLasDataInfoMethod_GetNumberOfPointRecords(PyITerrainLasDataInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpcRecords = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pcRecords

    // Call method on actual COM interface
    hr = self->m_pITerrainLasDataInfo->GetNumberOfPointRecords(&lpcRecords);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainLasDataInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainLasDataInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainLasDataInfo.GetNumberOfPointRecords() returned %ld", (long)hr);
        goto iterrainlasdatainfo_getnumberofpointrecords_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pcRecords

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpcRecords);
    goto iterrainlasdatainfo_getnumberofpointrecords_method_cleanup;

    iterrainlasdatainfo_getnumberofpointrecords_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pcRecords
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainLasDataInfo.GetNumberOfPointRecords");
    return return_tuple;
}

static PyObject*
ITerrainLasDataInfoMethod_GetNumberOfPointsByReturn(PyITerrainLasDataInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lReturnNumber = 0;
    long lpcPoints = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lReturnNumber))
      goto iterrainlasdatainfo_getnumberofpointsbyreturn_method_cleanup;

    // Set up initial variable values as needed
    // No setup for ReturnNumber
    // No setup for pcPoints

    // Call method on actual COM interface
    hr = self->m_pITerrainLasDataInfo->GetNumberOfPointsByReturn(lReturnNumber, &lpcPoints);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainLasDataInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainLasDataInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainLasDataInfo.GetNumberOfPointsByReturn() returned %ld", (long)hr);
        goto iterrainlasdatainfo_getnumberofpointsbyreturn_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ReturnNumber
    // No teardown for pcPoints

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpcPoints);
    goto iterrainlasdatainfo_getnumberofpointsbyreturn_method_cleanup;

    iterrainlasdatainfo_getnumberofpointsbyreturn_method_cleanup:
    self->m_HR = hr;
    // No cleanup for ReturnNumber
    // No cleanup for pcPoints
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainLasDataInfo.GetNumberOfPointsByReturn");
    return return_tuple;
}

static PyObject*
ITerrainLasDataInfoMethod_GetDataExtent(PyITerrainLasDataInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IEnvelope* ipppExt = NULL;
    PyObject* py_ppExt = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppExt

    // Call method on actual COM interface
    hr = self->m_pITerrainLasDataInfo->GetDataExtent(&ipppExt);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainLasDataInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainLasDataInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainLasDataInfo.GetDataExtent() returned %ld", (long)hr);
        goto iterrainlasdatainfo_getdataextent_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppExt);
    if (ipppExt)
    {
        IUnknown* pUnk = NULL;
        ipppExt->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppExt = IUnknownToPythonIIDObject(pUnk, &IID_IEnvelope);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppExt)
    {
        if (py_ppExt)
           Py_DECREF(py_ppExt);
        py_ppExt = Py_None;
        Py_INCREF(py_ppExt);
    }
    if (PyErr_Occurred())
      goto iterrainlasdatainfo_getdataextent_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppExt);
    goto iterrainlasdatainfo_getdataextent_method_cleanup;

    iterrainlasdatainfo_getdataextent_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppExt);
    if (ipppExt)
      ipppExt->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainLasDataInfo.GetDataExtent");
    return return_tuple;
}

static PyObject*
ITerrainLasDataInfoMethod_GetSpatialReference(PyITerrainLasDataInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ISpatialReference* ipppSpatialReference = NULL;
    PyObject* py_ppSpatialReference = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppSpatialReference

    // Call method on actual COM interface
    hr = self->m_pITerrainLasDataInfo->GetSpatialReference(&ipppSpatialReference);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainLasDataInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainLasDataInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainLasDataInfo.GetSpatialReference() returned %ld", (long)hr);
        goto iterrainlasdatainfo_getspatialreference_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppSpatialReference);
    if (ipppSpatialReference)
    {
        IUnknown* pUnk = NULL;
        ipppSpatialReference->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppSpatialReference = IUnknownToPythonIIDObject(pUnk, &IID_ISpatialReference);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppSpatialReference)
    {
        if (py_ppSpatialReference)
           Py_DECREF(py_ppSpatialReference);
        py_ppSpatialReference = Py_None;
        Py_INCREF(py_ppSpatialReference);
    }
    if (PyErr_Occurred())
      goto iterrainlasdatainfo_getspatialreference_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppSpatialReference);
    goto iterrainlasdatainfo_getspatialreference_method_cleanup;

    iterrainlasdatainfo_getspatialreference_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppSpatialReference);
    if (ipppSpatialReference)
      ipppSpatialReference->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainLasDataInfo.GetSpatialReference");
    return return_tuple;
}


PyMethodDef PyITerrainLasDataInfoMethods[] = {
    {"supports", (PyCFunction)PyITerrainLasDataInfo_SupportsInterface, METH_O, ""},
    {"Init", (PyCFunction)ITerrainLasDataInfoMethod_Init, METH_VARARGS, ""},
    {"GetVersion", (PyCFunction)ITerrainLasDataInfoMethod_GetVersion, METH_VARARGS, ""},
    {"GetSystemID", (PyCFunction)ITerrainLasDataInfoMethod_GetSystemID, METH_VARARGS, ""},
    {"GetGeneratingSoftware", (PyCFunction)ITerrainLasDataInfoMethod_GetGeneratingSoftware, METH_VARARGS, ""},
    {"GetFlightDateJulian", (PyCFunction)ITerrainLasDataInfoMethod_GetFlightDateJulian, METH_VARARGS, ""},
    {"GetYear", (PyCFunction)ITerrainLasDataInfoMethod_GetYear, METH_VARARGS, ""},
    {"GetPointDataFormat", (PyCFunction)ITerrainLasDataInfoMethod_GetPointDataFormat, METH_VARARGS, ""},
    {"GetNumberOfPointRecords", (PyCFunction)ITerrainLasDataInfoMethod_GetNumberOfPointRecords, METH_VARARGS, ""},
    {"GetNumberOfPointsByReturn", (PyCFunction)ITerrainLasDataInfoMethod_GetNumberOfPointsByReturn, METH_VARARGS, ""},
    {"GetDataExtent", (PyCFunction)ITerrainLasDataInfoMethod_GetDataExtent, METH_VARARGS, ""},
    {"GetSpatialReference", (PyCFunction)ITerrainLasDataInfoMethod_GetSpatialReference, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyITerrainLasDataInfoGetSet[] = {
  {"_pUnk", (getter)PyITerrainLasDataInfo_GetpUnk, NULL, "Get opaque pointer to an Unknown from ITerrainLasDataInfo", NULL},
  {"_pointer", (getter)PyITerrainLasDataInfo_GetPointer, NULL, "Get memory address for ITerrainLasDataInfo", NULL},
  {"_IID", (getter)PyITerrainLasDataInfo_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyITerrainLasDataInfo_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyITerrainLasDataInfo_GetIgnoreFailures, (setter)PyITerrainLasDataInfo_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyITerrainLasDataInfoObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.ITerrainLasDataInfoObject",                          
                                              /* tp_name */
  sizeof(PyITerrainLasDataInfoObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyITerrainLasDataInfoObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyITerrainLasDataInfoMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyITerrainLasDataInfoGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyITerrainLasDataInfoObject_new,                      
                                              /* tp_new */
};

// Interface ITerrainBlobReader

typedef struct PyITerrainBlobReaderObject {
    PyObject_HEAD
    ITerrainBlobReader* m_pITerrainBlobReader;
    HRESULT m_HR;
    int m_ignore_failures;
} PyITerrainBlobReaderObject;

static PyObject*
PyITerrainBlobReaderObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyITerrainBlobReaderObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ITerrainBlobReader* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ITerrainBlobReader, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ITerrainBlobReader with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyITerrainBlobReaderObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ITerrainBlobReader");
            return NULL;
        }
        self->m_pITerrainBlobReader = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ITerrainBlobReader");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ITerrainBlobReader");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ITerrainBlobReader* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ITerrainBlobReader, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ITerrainBlobReader");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyITerrainBlobReaderObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ITerrainBlobReader");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pITerrainBlobReader = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyITerrainBlobReaderObject_dealloc(PyITerrainBlobReaderObject* self)
{
    if (self->m_pITerrainBlobReader)
        self->m_pITerrainBlobReader->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyITerrainBlobReader_GetpUnk(PyITerrainBlobReaderObject* self)
{
    if (!self->m_pITerrainBlobReader)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pITerrainBlobReader->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ITerrainBlobReader to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyITerrainBlobReader_GetPointer(PyITerrainBlobReaderObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pITerrainBlobReader);
}

static PyObject*
PyITerrainBlobReader_GetIID(PyITerrainBlobReaderObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "58ce4421-8073-464b-bf90-2ef70384c82e");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyITerrainBlobReader_GetHR(PyITerrainBlobReaderObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyITerrainBlobReader_GetIgnoreFailures(PyITerrainBlobReaderObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyITerrainBlobReader_SetIgnoreFailures(PyITerrainBlobReaderObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyITerrainBlobReader_SupportsInterface(PyITerrainBlobReaderObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pITerrainBlobReader->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ITerrainBlobReaderMethod_SetEmpty(PyITerrainBlobReaderObject* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pITerrainBlobReader->SetEmpty();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainBlobReader->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainBlobReader) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainBlobReader.SetEmpty() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}

static PyObject*
ITerrainBlobReaderMethod_IsKnownBlob(PyITerrainBlobReaderObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IMemoryBlobStream* ippBlob = NULL;
    PyObject* py_pBlob;
    VARIANT_BOOL b_pbIsKnown = VARIANT_FALSE;
    PyObject* pyvar_pbIsKnown = Py_False;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_pBlob))
      goto iterrainblobreader_isknownblob_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pBlob, &IID_IMemoryBlobStream, (void**)&ippBlob))
        PyErr_SetString(PyExc_TypeError, "Argument pBlob (position 0) is not IMemoryBlobStream");
    
    if (PyErr_Occurred())
      goto iterrainblobreader_isknownblob_method_cleanup;
    
    // No setup for pbIsKnown

    // Call method on actual COM interface
    hr = self->m_pITerrainBlobReader->IsKnownBlob(ippBlob, &b_pbIsKnown);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainBlobReader->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainBlobReader) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainBlobReader.IsKnownBlob() returned %ld", (long)hr);
        goto iterrainblobreader_isknownblob_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pBlob
    pyvar_pbIsKnown = ((b_pbIsKnown == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto iterrainblobreader_isknownblob_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pbIsKnown);
    goto iterrainblobreader_isknownblob_method_cleanup;

    iterrainblobreader_isknownblob_method_cleanup:
    self->m_HR = hr;
    if (ippBlob)
      ippBlob->Release();
    // No cleanup for pbIsKnown
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainBlobReader.IsKnownBlob");
    return return_tuple;
}

static PyObject*
ITerrainBlobReaderMethod_SetBlob(PyITerrainBlobReaderObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IMemoryBlobStream* ippBlob = NULL;
    PyObject* py_pBlob;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_pBlob))
      goto iterrainblobreader_setblob_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pBlob, &IID_IMemoryBlobStream, (void**)&ippBlob))
        PyErr_SetString(PyExc_TypeError, "Argument pBlob (position 0) is not IMemoryBlobStream");
    
    if (PyErr_Occurred())
      goto iterrainblobreader_setblob_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITerrainBlobReader->SetBlob(ippBlob);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainBlobReader->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainBlobReader) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainBlobReader.SetBlob() returned %ld", (long)hr);
        goto iterrainblobreader_setblob_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pBlob

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterrainblobreader_setblob_method_cleanup;

    iterrainblobreader_setblob_method_cleanup:
    self->m_HR = hr;
    if (ippBlob)
      ippBlob->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainBlobReader.SetBlob");
    return return_tuple;
}

static PyObject*
ITerrainBlobReaderMethod_GetDataType(PyITerrainBlobReaderObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriTerrainBlobDataType epType;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pType

    // Call method on actual COM interface
    hr = self->m_pITerrainBlobReader->GetDataType(&epType);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainBlobReader->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainBlobReader) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainBlobReader.GetDataType() returned %ld", (long)hr);
        goto iterrainblobreader_getdatatype_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pType

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)epType);
    goto iterrainblobreader_getdatatype_method_cleanup;

    iterrainblobreader_getdatatype_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pType
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainBlobReader.GetDataType");
    return return_tuple;
}

static PyObject*
ITerrainBlobReaderMethod_GetItemCount(PyITerrainBlobReaderObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpcItems = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pcItems

    // Call method on actual COM interface
    hr = self->m_pITerrainBlobReader->GetItemCount(&lpcItems);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainBlobReader->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainBlobReader) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainBlobReader.GetItemCount() returned %ld", (long)hr);
        goto iterrainblobreader_getitemcount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pcItems

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpcItems);
    goto iterrainblobreader_getitemcount_method_cleanup;

    iterrainblobreader_getitemcount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pcItems
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainBlobReader.GetItemCount");
    return return_tuple;
}

static PyObject*
ITerrainBlobReaderMethod_GetValue(PyITerrainBlobReaderObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;
    VARIANT vpValue;
    ::VariantInit(&vpValue);
    PyObject* pyvar_pValue = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lindex))
      goto iterrainblobreader_getvalue_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index
    // No setup for pValue

    // Call method on actual COM interface
    hr = self->m_pITerrainBlobReader->GetValue(lindex, &vpValue);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainBlobReader->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainBlobReader) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainBlobReader.GetValue() returned %ld", (long)hr);
        goto iterrainblobreader_getvalue_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index
    pyvar_pValue = Variant_AsPyObject(&vpValue);
    if (PyErr_Occurred())
      goto iterrainblobreader_getvalue_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pValue);
    goto iterrainblobreader_getvalue_method_cleanup;

    iterrainblobreader_getvalue_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    ::VariantClear(&vpValue);
    Py_XDECREF(pyvar_pValue);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainBlobReader.GetValue");
    return return_tuple;
}


PyMethodDef PyITerrainBlobReaderMethods[] = {
    {"supports", (PyCFunction)PyITerrainBlobReader_SupportsInterface, METH_O, ""},
    {"SetEmpty", (PyCFunction)ITerrainBlobReaderMethod_SetEmpty, METH_NOARGS, ""},
    {"IsKnownBlob", (PyCFunction)ITerrainBlobReaderMethod_IsKnownBlob, METH_VARARGS, ""},
    {"SetBlob", (PyCFunction)ITerrainBlobReaderMethod_SetBlob, METH_VARARGS, ""},
    {"GetDataType", (PyCFunction)ITerrainBlobReaderMethod_GetDataType, METH_VARARGS, ""},
    {"GetItemCount", (PyCFunction)ITerrainBlobReaderMethod_GetItemCount, METH_VARARGS, ""},
    {"GetValue", (PyCFunction)ITerrainBlobReaderMethod_GetValue, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyITerrainBlobReaderGetSet[] = {
  {"_pUnk", (getter)PyITerrainBlobReader_GetpUnk, NULL, "Get opaque pointer to an Unknown from ITerrainBlobReader", NULL},
  {"_pointer", (getter)PyITerrainBlobReader_GetPointer, NULL, "Get memory address for ITerrainBlobReader", NULL},
  {"_IID", (getter)PyITerrainBlobReader_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyITerrainBlobReader_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyITerrainBlobReader_GetIgnoreFailures, (setter)PyITerrainBlobReader_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyITerrainBlobReaderObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.ITerrainBlobReaderObject",                          
                                              /* tp_name */
  sizeof(PyITerrainBlobReaderObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyITerrainBlobReaderObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyITerrainBlobReaderMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyITerrainBlobReaderGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyITerrainBlobReaderObject_new,                      
                                              /* tp_new */
};

// Interface ITerrainBlobWriter

typedef struct PyITerrainBlobWriterObject {
    PyObject_HEAD
    ITerrainBlobWriter* m_pITerrainBlobWriter;
    HRESULT m_HR;
    int m_ignore_failures;
} PyITerrainBlobWriterObject;

static PyObject*
PyITerrainBlobWriterObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyITerrainBlobWriterObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ITerrainBlobWriter* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ITerrainBlobWriter, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ITerrainBlobWriter with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyITerrainBlobWriterObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ITerrainBlobWriter");
            return NULL;
        }
        self->m_pITerrainBlobWriter = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ITerrainBlobWriter");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ITerrainBlobWriter");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ITerrainBlobWriter* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ITerrainBlobWriter, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ITerrainBlobWriter");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyITerrainBlobWriterObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ITerrainBlobWriter");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pITerrainBlobWriter = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyITerrainBlobWriterObject_dealloc(PyITerrainBlobWriterObject* self)
{
    if (self->m_pITerrainBlobWriter)
        self->m_pITerrainBlobWriter->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyITerrainBlobWriter_GetpUnk(PyITerrainBlobWriterObject* self)
{
    if (!self->m_pITerrainBlobWriter)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pITerrainBlobWriter->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ITerrainBlobWriter to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyITerrainBlobWriter_GetPointer(PyITerrainBlobWriterObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pITerrainBlobWriter);
}

static PyObject*
PyITerrainBlobWriter_GetIID(PyITerrainBlobWriterObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "6ed22878-8391-4ee1-999f-a9b6be197bd9");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyITerrainBlobWriter_GetHR(PyITerrainBlobWriterObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyITerrainBlobWriter_GetIgnoreFailures(PyITerrainBlobWriterObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyITerrainBlobWriter_SetIgnoreFailures(PyITerrainBlobWriterObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyITerrainBlobWriter_SupportsInterface(PyITerrainBlobWriterObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pITerrainBlobWriter->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ITerrainBlobWriterMethod_BeginAddingValue(PyITerrainBlobWriterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriTerrainBlobDataType eType;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&eType))
      goto iterrainblobwriter_beginaddingvalue_method_cleanup;

    // Set up initial variable values as needed
    // No setup for Type

    // Call method on actual COM interface
    hr = self->m_pITerrainBlobWriter->BeginAddingValue(eType);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainBlobWriter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainBlobWriter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainBlobWriter.BeginAddingValue() returned %ld", (long)hr);
        goto iterrainblobwriter_beginaddingvalue_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Type

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterrainblobwriter_beginaddingvalue_method_cleanup;

    iterrainblobwriter_beginaddingvalue_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Type
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainBlobWriter.BeginAddingValue");
    return return_tuple;
}

static PyObject*
ITerrainBlobWriterMethod_AddValue(PyITerrainBlobWriterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT vValue;
    ::VariantInit(&vValue);
    PyObject* pyvar_Value = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_Value))
      goto iterrainblobwriter_addvalue_method_cleanup;

    // Set up initial variable values as needed
    PyObject_AsVariant(pyvar_Value, &vValue);
    
    if (PyErr_Occurred())
      goto iterrainblobwriter_addvalue_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITerrainBlobWriter->AddValue(vValue);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainBlobWriter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainBlobWriter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainBlobWriter.AddValue() returned %ld", (long)hr);
        goto iterrainblobwriter_addvalue_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Value

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterrainblobwriter_addvalue_method_cleanup;

    iterrainblobwriter_addvalue_method_cleanup:
    self->m_HR = hr;
    ::VariantClear(&vValue);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainBlobWriter.AddValue");
    return return_tuple;
}

static PyObject*
ITerrainBlobWriterMethod_GetItemCount(PyITerrainBlobWriterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpcItems = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pcItems

    // Call method on actual COM interface
    hr = self->m_pITerrainBlobWriter->GetItemCount(&lpcItems);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainBlobWriter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainBlobWriter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainBlobWriter.GetItemCount() returned %ld", (long)hr);
        goto iterrainblobwriter_getitemcount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pcItems

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpcItems);
    goto iterrainblobwriter_getitemcount_method_cleanup;

    iterrainblobwriter_getitemcount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pcItems
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainBlobWriter.GetItemCount");
    return return_tuple;
}

static PyObject*
ITerrainBlobWriterMethod_EndAddingValue(PyITerrainBlobWriterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IMemoryBlobStream* ipppBlob = NULL;
    PyObject* py_ppBlob = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppBlob

    // Call method on actual COM interface
    hr = self->m_pITerrainBlobWriter->EndAddingValue(&ipppBlob);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainBlobWriter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainBlobWriter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainBlobWriter.EndAddingValue() returned %ld", (long)hr);
        goto iterrainblobwriter_endaddingvalue_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppBlob);
    if (ipppBlob)
    {
        IUnknown* pUnk = NULL;
        ipppBlob->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppBlob = IUnknownToPythonIIDObject(pUnk, &IID_IMemoryBlobStream);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppBlob)
    {
        if (py_ppBlob)
           Py_DECREF(py_ppBlob);
        py_ppBlob = Py_None;
        Py_INCREF(py_ppBlob);
    }
    if (PyErr_Occurred())
      goto iterrainblobwriter_endaddingvalue_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppBlob);
    goto iterrainblobwriter_endaddingvalue_method_cleanup;

    iterrainblobwriter_endaddingvalue_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppBlob);
    if (ipppBlob)
      ipppBlob->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainBlobWriter.EndAddingValue");
    return return_tuple;
}


PyMethodDef PyITerrainBlobWriterMethods[] = {
    {"supports", (PyCFunction)PyITerrainBlobWriter_SupportsInterface, METH_O, ""},
    {"BeginAddingValue", (PyCFunction)ITerrainBlobWriterMethod_BeginAddingValue, METH_VARARGS, ""},
    {"AddValue", (PyCFunction)ITerrainBlobWriterMethod_AddValue, METH_VARARGS, ""},
    {"GetItemCount", (PyCFunction)ITerrainBlobWriterMethod_GetItemCount, METH_VARARGS, ""},
    {"EndAddingValue", (PyCFunction)ITerrainBlobWriterMethod_EndAddingValue, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyITerrainBlobWriterGetSet[] = {
  {"_pUnk", (getter)PyITerrainBlobWriter_GetpUnk, NULL, "Get opaque pointer to an Unknown from ITerrainBlobWriter", NULL},
  {"_pointer", (getter)PyITerrainBlobWriter_GetPointer, NULL, "Get memory address for ITerrainBlobWriter", NULL},
  {"_IID", (getter)PyITerrainBlobWriter_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyITerrainBlobWriter_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyITerrainBlobWriter_GetIgnoreFailures, (setter)PyITerrainBlobWriter_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyITerrainBlobWriterObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.ITerrainBlobWriterObject",                          
                                              /* tp_name */
  sizeof(PyITerrainBlobWriterObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyITerrainBlobWriterObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyITerrainBlobWriterMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyITerrainBlobWriterGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyITerrainBlobWriterObject_new,                      
                                              /* tp_new */
};

// Interface ITerrainEditEvents

typedef struct PyITerrainEditEventsObject {
    PyObject_HEAD
    ITerrainEditEvents* m_pITerrainEditEvents;
    HRESULT m_HR;
    int m_ignore_failures;
} PyITerrainEditEventsObject;

static PyObject*
PyITerrainEditEventsObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyITerrainEditEventsObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ITerrainEditEvents* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ITerrainEditEvents, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ITerrainEditEvents with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyITerrainEditEventsObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ITerrainEditEvents");
            return NULL;
        }
        self->m_pITerrainEditEvents = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ITerrainEditEvents");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ITerrainEditEvents");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ITerrainEditEvents* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ITerrainEditEvents, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ITerrainEditEvents");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyITerrainEditEventsObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ITerrainEditEvents");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pITerrainEditEvents = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyITerrainEditEventsObject_dealloc(PyITerrainEditEventsObject* self)
{
    if (self->m_pITerrainEditEvents)
        self->m_pITerrainEditEvents->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyITerrainEditEvents_GetpUnk(PyITerrainEditEventsObject* self)
{
    if (!self->m_pITerrainEditEvents)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pITerrainEditEvents->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ITerrainEditEvents to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyITerrainEditEvents_GetPointer(PyITerrainEditEventsObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pITerrainEditEvents);
}

static PyObject*
PyITerrainEditEvents_GetIID(PyITerrainEditEventsObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "f008ba42-5126-4daf-88ec-005af3a60083");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyITerrainEditEvents_GetHR(PyITerrainEditEventsObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyITerrainEditEvents_GetIgnoreFailures(PyITerrainEditEventsObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyITerrainEditEvents_SetIgnoreFailures(PyITerrainEditEventsObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyITerrainEditEvents_SupportsInterface(PyITerrainEditEventsObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pITerrainEditEvents->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ITerrainEditEventsMethod_OnBuild(PyITerrainEditEventsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IEnvelope* ippExtent = NULL;
    PyObject* py_pExtent;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_pExtent))
      goto iterraineditevents_onbuild_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pExtent, &IID_IEnvelope, (void**)&ippExtent))
        PyErr_SetString(PyExc_TypeError, "Argument pExtent (position 0) is not IEnvelope");
    
    if (PyErr_Occurred())
      goto iterraineditevents_onbuild_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITerrainEditEvents->OnBuild(ippExtent);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainEditEvents->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainEditEvents) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainEditEvents.OnBuild() returned %ld", (long)hr);
        goto iterraineditevents_onbuild_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pExtent

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterraineditevents_onbuild_method_cleanup;

    iterraineditevents_onbuild_method_cleanup:
    self->m_HR = hr;
    if (ippExtent)
      ippExtent->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainEditEvents.OnBuild");
    return return_tuple;
}

static PyObject*
ITerrainEditEventsMethod_OnUndoBuild(PyITerrainEditEventsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IEnvelope* ippExtent = NULL;
    PyObject* py_pExtent;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_pExtent))
      goto iterraineditevents_onundobuild_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pExtent, &IID_IEnvelope, (void**)&ippExtent))
        PyErr_SetString(PyExc_TypeError, "Argument pExtent (position 0) is not IEnvelope");
    
    if (PyErr_Occurred())
      goto iterraineditevents_onundobuild_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITerrainEditEvents->OnUndoBuild(ippExtent);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainEditEvents->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainEditEvents) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainEditEvents.OnUndoBuild() returned %ld", (long)hr);
        goto iterraineditevents_onundobuild_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pExtent

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterraineditevents_onundobuild_method_cleanup;

    iterraineditevents_onundobuild_method_cleanup:
    self->m_HR = hr;
    if (ippExtent)
      ippExtent->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainEditEvents.OnUndoBuild");
    return return_tuple;
}

static PyObject*
ITerrainEditEventsMethod_OnRedoBuild(PyITerrainEditEventsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IEnvelope* ippExtent = NULL;
    PyObject* py_pExtent;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_pExtent))
      goto iterraineditevents_onredobuild_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pExtent, &IID_IEnvelope, (void**)&ippExtent))
        PyErr_SetString(PyExc_TypeError, "Argument pExtent (position 0) is not IEnvelope");
    
    if (PyErr_Occurred())
      goto iterraineditevents_onredobuild_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITerrainEditEvents->OnRedoBuild(ippExtent);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainEditEvents->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainEditEvents) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainEditEvents.OnRedoBuild() returned %ld", (long)hr);
        goto iterraineditevents_onredobuild_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pExtent

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterraineditevents_onredobuild_method_cleanup;

    iterraineditevents_onredobuild_method_cleanup:
    self->m_HR = hr;
    if (ippExtent)
      ippExtent->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainEditEvents.OnRedoBuild");
    return return_tuple;
}

static PyObject*
ITerrainEditEventsMethod_OnReconcile(PyITerrainEditEventsObject* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pITerrainEditEvents->OnReconcile();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainEditEvents->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainEditEvents) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainEditEvents.OnReconcile() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}

static PyObject*
ITerrainEditEventsMethod_OnUndoReconcile(PyITerrainEditEventsObject* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pITerrainEditEvents->OnUndoReconcile();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainEditEvents->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainEditEvents) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainEditEvents.OnUndoReconcile() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}

static PyObject*
ITerrainEditEventsMethod_OnRedoReconcile(PyITerrainEditEventsObject* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pITerrainEditEvents->OnRedoReconcile();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainEditEvents->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainEditEvents) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainEditEvents.OnRedoReconcile() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}


PyMethodDef PyITerrainEditEventsMethods[] = {
    {"supports", (PyCFunction)PyITerrainEditEvents_SupportsInterface, METH_O, ""},
    {"OnBuild", (PyCFunction)ITerrainEditEventsMethod_OnBuild, METH_VARARGS, ""},
    {"OnUndoBuild", (PyCFunction)ITerrainEditEventsMethod_OnUndoBuild, METH_VARARGS, ""},
    {"OnRedoBuild", (PyCFunction)ITerrainEditEventsMethod_OnRedoBuild, METH_VARARGS, ""},
    {"OnReconcile", (PyCFunction)ITerrainEditEventsMethod_OnReconcile, METH_NOARGS, ""},
    {"OnUndoReconcile", (PyCFunction)ITerrainEditEventsMethod_OnUndoReconcile, METH_NOARGS, ""},
    {"OnRedoReconcile", (PyCFunction)ITerrainEditEventsMethod_OnRedoReconcile, METH_NOARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyITerrainEditEventsGetSet[] = {
  {"_pUnk", (getter)PyITerrainEditEvents_GetpUnk, NULL, "Get opaque pointer to an Unknown from ITerrainEditEvents", NULL},
  {"_pointer", (getter)PyITerrainEditEvents_GetPointer, NULL, "Get memory address for ITerrainEditEvents", NULL},
  {"_IID", (getter)PyITerrainEditEvents_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyITerrainEditEvents_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyITerrainEditEvents_GetIgnoreFailures, (setter)PyITerrainEditEvents_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyITerrainEditEventsObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.ITerrainEditEventsObject",                          
                                              /* tp_name */
  sizeof(PyITerrainEditEventsObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyITerrainEditEventsObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyITerrainEditEventsMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyITerrainEditEventsGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyITerrainEditEventsObject_new,                      
                                              /* tp_new */
};

// Interface ITerrainLasDataInfo2

typedef struct PyITerrainLasDataInfo2Object {
    PyObject_HEAD
    ITerrainLasDataInfo2* m_pITerrainLasDataInfo2;
    HRESULT m_HR;
    int m_ignore_failures;
} PyITerrainLasDataInfo2Object;

static PyObject*
PyITerrainLasDataInfo2Object_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyITerrainLasDataInfo2Object* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ITerrainLasDataInfo2* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ITerrainLasDataInfo2, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ITerrainLasDataInfo2 with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyITerrainLasDataInfo2Object *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ITerrainLasDataInfo2");
            return NULL;
        }
        self->m_pITerrainLasDataInfo2 = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ITerrainLasDataInfo2");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ITerrainLasDataInfo2");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ITerrainLasDataInfo2* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ITerrainLasDataInfo2, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ITerrainLasDataInfo2");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyITerrainLasDataInfo2Object *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ITerrainLasDataInfo2");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pITerrainLasDataInfo2 = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyITerrainLasDataInfo2Object_dealloc(PyITerrainLasDataInfo2Object* self)
{
    if (self->m_pITerrainLasDataInfo2)
        self->m_pITerrainLasDataInfo2->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyITerrainLasDataInfo2_GetpUnk(PyITerrainLasDataInfo2Object* self)
{
    if (!self->m_pITerrainLasDataInfo2)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pITerrainLasDataInfo2->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ITerrainLasDataInfo2 to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyITerrainLasDataInfo2_GetPointer(PyITerrainLasDataInfo2Object* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pITerrainLasDataInfo2);
}

static PyObject*
PyITerrainLasDataInfo2_GetIID(PyITerrainLasDataInfo2Object* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "08ac58e1-f142-45db-9847-0d28f6d7d241");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyITerrainLasDataInfo2_GetHR(PyITerrainLasDataInfo2Object* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyITerrainLasDataInfo2_GetIgnoreFailures(PyITerrainLasDataInfo2Object* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyITerrainLasDataInfo2_SetIgnoreFailures(PyITerrainLasDataInfo2Object* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyITerrainLasDataInfo2_SupportsInterface(PyITerrainLasDataInfo2Object* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pITerrainLasDataInfo2->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ITerrainLasDataInfo2Method_GetFileSourceID(PyITerrainLasDataInfo2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpID = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pID

    // Call method on actual COM interface
    hr = self->m_pITerrainLasDataInfo2->GetFileSourceID(&lpID);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainLasDataInfo2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainLasDataInfo2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainLasDataInfo2.GetFileSourceID() returned %ld", (long)hr);
        goto iterrainlasdatainfo2_getfilesourceid_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pID

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpID);
    goto iterrainlasdatainfo2_getfilesourceid_method_cleanup;

    iterrainlasdatainfo2_getfilesourceid_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pID
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainLasDataInfo2.GetFileSourceID");
    return return_tuple;
}

static PyObject*
ITerrainLasDataInfo2Method_get_IsStandardGpsTime(PyITerrainLasDataInfo2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pbIsAStandard = VARIANT_FALSE;
    PyObject* pyvar_pbIsAStandard = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pbIsAStandard

    // Call method on actual COM interface
    hr = self->m_pITerrainLasDataInfo2->get_IsStandardGpsTime(&b_pbIsAStandard);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainLasDataInfo2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainLasDataInfo2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainLasDataInfo2.get_IsStandardGpsTime() returned %ld", (long)hr);
        goto iterrainlasdatainfo2_get_isstandardgpstime_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pbIsAStandard = ((b_pbIsAStandard == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto iterrainlasdatainfo2_get_isstandardgpstime_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pbIsAStandard);
    goto iterrainlasdatainfo2_get_isstandardgpstime_method_cleanup;

    iterrainlasdatainfo2_get_isstandardgpstime_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pbIsAStandard
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainLasDataInfo2.get_IsStandardGpsTime");
    return return_tuple;
}

static PyObject*
ITerrainLasDataInfo2Method_GetPointInfoByClassCode(PyITerrainLasDataInfo2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;
    ILongArray* ippCodes = NULL;
    PyObject* py_pCodes;
    IDoubleArray* ipppCounts = NULL;
    PyObject* py_ppCounts = NULL;
    IArray* ipppExtents = NULL;
    PyObject* py_ppExtents = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OO", &py_pTrackCancel, &py_pCodes))
      goto iterrainlasdatainfo2_getpointinfobyclasscode_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 0) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto iterrainlasdatainfo2_getpointinfobyclasscode_method_cleanup;
    
    if (!IFaceFromPyObject(py_pCodes, &IID_ILongArray, (void**)&ippCodes))
        PyErr_SetString(PyExc_TypeError, "Argument pCodes (position 1) is not ILongArray");
    
    if (PyErr_Occurred())
      goto iterrainlasdatainfo2_getpointinfobyclasscode_method_cleanup;
    
    // No setup for ppCounts
    // No setup for ppExtents

    // Call method on actual COM interface
    hr = self->m_pITerrainLasDataInfo2->GetPointInfoByClassCode(ippTrackCancel, ippCodes, &ipppCounts, &ipppExtents);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainLasDataInfo2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainLasDataInfo2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainLasDataInfo2.GetPointInfoByClassCode() returned %ld", (long)hr);
        goto iterrainlasdatainfo2_getpointinfobyclasscode_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pTrackCancel
    // No teardown for pCodes
    Py_XDECREF(py_ppCounts);
    if (ipppCounts)
    {
        IUnknown* pUnk = NULL;
        ipppCounts->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppCounts = IUnknownToPythonIIDObject(pUnk, &IID_IDoubleArray);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppCounts)
    {
        if (py_ppCounts)
           Py_DECREF(py_ppCounts);
        py_ppCounts = Py_None;
        Py_INCREF(py_ppCounts);
    }
    if (PyErr_Occurred())
      goto iterrainlasdatainfo2_getpointinfobyclasscode_method_cleanup;
    
    Py_XDECREF(py_ppExtents);
    if (ipppExtents)
    {
        IUnknown* pUnk = NULL;
        ipppExtents->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppExtents = IUnknownToPythonIIDObject(pUnk, &IID_IArray);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppExtents)
    {
        if (py_ppExtents)
           Py_DECREF(py_ppExtents);
        py_ppExtents = Py_None;
        Py_INCREF(py_ppExtents);
    }
    if (PyErr_Occurred())
      goto iterrainlasdatainfo2_getpointinfobyclasscode_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("OO",
                                            py_ppCounts, py_ppExtents);
    goto iterrainlasdatainfo2_getpointinfobyclasscode_method_cleanup;

    iterrainlasdatainfo2_getpointinfobyclasscode_method_cleanup:
    self->m_HR = hr;
    if (ippTrackCancel)
      ippTrackCancel->Release();
    if (ippCodes)
      ippCodes->Release();
    Py_XDECREF(py_ppCounts);
    if (ipppCounts)
      ipppCounts->Release();
    Py_XDECREF(py_ppExtents);
    if (ipppExtents)
      ipppExtents->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainLasDataInfo2.GetPointInfoByClassCode");
    return return_tuple;
}

static PyObject*
ITerrainLasDataInfo2Method_Init(PyITerrainLasDataInfo2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bslasFileName = 0;
    PyObject* pyvar_lasFileName;
    PyObject* unicodelasFileName = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_lasFileName))
      goto iterrainlasdatainfo2_init_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_lasFileName))
        unicodelasFileName = PyUnicode_FromObject(pyvar_lasFileName);
    else if (PyUnicode_Check(pyvar_lasFileName))
    {
        unicodelasFileName = pyvar_lasFileName;
        Py_INCREF(unicodelasFileName);
    }
    else if (pyvar_lasFileName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter lasFileName at index 0");
    if (unicodelasFileName)
        bslasFileName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodelasFileName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodelasFileName));
    
    if (PyErr_Occurred())
      goto iterrainlasdatainfo2_init_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITerrainLasDataInfo2->Init(bslasFileName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainLasDataInfo2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainLasDataInfo2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainLasDataInfo2.Init() returned %ld", (long)hr);
        goto iterrainlasdatainfo2_init_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for lasFileName

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterrainlasdatainfo2_init_method_cleanup;

    iterrainlasdatainfo2_init_method_cleanup:
    self->m_HR = hr;
    if (bslasFileName)
        ::SysFreeString(bslasFileName);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainLasDataInfo2.Init");
    return return_tuple;
}

static PyObject*
ITerrainLasDataInfo2Method_GetVersion(PyITerrainLasDataInfo2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpMajor = 0;
    long lpMinor = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pMajor
    // No setup for pMinor

    // Call method on actual COM interface
    hr = self->m_pITerrainLasDataInfo2->GetVersion(&lpMajor, &lpMinor);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainLasDataInfo2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainLasDataInfo2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainLasDataInfo2.GetVersion() returned %ld", (long)hr);
        goto iterrainlasdatainfo2_getversion_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pMajor
    // No teardown for pMinor

    // Initialize output tuple
    return_tuple = Py_BuildValue("ll",
                                            lpMajor, lpMinor);
    goto iterrainlasdatainfo2_getversion_method_cleanup;

    iterrainlasdatainfo2_getversion_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pMajor
    // No cleanup for pMinor
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainLasDataInfo2.GetVersion");
    return return_tuple;
}

static PyObject*
ITerrainLasDataInfo2Method_GetSystemID(PyITerrainLasDataInfo2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspID;
    PyObject* pyvar_pID = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pID

    // Call method on actual COM interface
    hr = self->m_pITerrainLasDataInfo2->GetSystemID(&bspID);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainLasDataInfo2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainLasDataInfo2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainLasDataInfo2.GetSystemID() returned %ld", (long)hr);
        goto iterrainlasdatainfo2_getsystemid_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pID = PyUnicode_FromWideChar(bspID,::SysStringLen(bspID));
    ::SysFreeString(bspID);
    
    if (PyErr_Occurred())
      goto iterrainlasdatainfo2_getsystemid_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pID);
    goto iterrainlasdatainfo2_getsystemid_method_cleanup;

    iterrainlasdatainfo2_getsystemid_method_cleanup:
    self->m_HR = hr;
    if (pyvar_pID != Py_None)
        Py_XDECREF(pyvar_pID);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainLasDataInfo2.GetSystemID");
    return return_tuple;
}

static PyObject*
ITerrainLasDataInfo2Method_GetGeneratingSoftware(PyITerrainLasDataInfo2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspName;
    PyObject* pyvar_pName = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pName

    // Call method on actual COM interface
    hr = self->m_pITerrainLasDataInfo2->GetGeneratingSoftware(&bspName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainLasDataInfo2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainLasDataInfo2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainLasDataInfo2.GetGeneratingSoftware() returned %ld", (long)hr);
        goto iterrainlasdatainfo2_getgeneratingsoftware_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pName = PyUnicode_FromWideChar(bspName,::SysStringLen(bspName));
    ::SysFreeString(bspName);
    
    if (PyErr_Occurred())
      goto iterrainlasdatainfo2_getgeneratingsoftware_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pName);
    goto iterrainlasdatainfo2_getgeneratingsoftware_method_cleanup;

    iterrainlasdatainfo2_getgeneratingsoftware_method_cleanup:
    self->m_HR = hr;
    if (pyvar_pName != Py_None)
        Py_XDECREF(pyvar_pName);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainLasDataInfo2.GetGeneratingSoftware");
    return return_tuple;
}

static PyObject*
ITerrainLasDataInfo2Method_GetFlightDateJulian(PyITerrainLasDataInfo2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpDate = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pDate

    // Call method on actual COM interface
    hr = self->m_pITerrainLasDataInfo2->GetFlightDateJulian(&lpDate);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainLasDataInfo2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainLasDataInfo2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainLasDataInfo2.GetFlightDateJulian() returned %ld", (long)hr);
        goto iterrainlasdatainfo2_getflightdatejulian_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pDate

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpDate);
    goto iterrainlasdatainfo2_getflightdatejulian_method_cleanup;

    iterrainlasdatainfo2_getflightdatejulian_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pDate
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainLasDataInfo2.GetFlightDateJulian");
    return return_tuple;
}

static PyObject*
ITerrainLasDataInfo2Method_GetYear(PyITerrainLasDataInfo2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpYear = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pYear

    // Call method on actual COM interface
    hr = self->m_pITerrainLasDataInfo2->GetYear(&lpYear);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainLasDataInfo2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainLasDataInfo2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainLasDataInfo2.GetYear() returned %ld", (long)hr);
        goto iterrainlasdatainfo2_getyear_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pYear

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpYear);
    goto iterrainlasdatainfo2_getyear_method_cleanup;

    iterrainlasdatainfo2_getyear_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pYear
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainLasDataInfo2.GetYear");
    return return_tuple;
}

static PyObject*
ITerrainLasDataInfo2Method_GetPointDataFormat(PyITerrainLasDataInfo2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpFormat = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pFormat

    // Call method on actual COM interface
    hr = self->m_pITerrainLasDataInfo2->GetPointDataFormat(&lpFormat);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainLasDataInfo2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainLasDataInfo2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainLasDataInfo2.GetPointDataFormat() returned %ld", (long)hr);
        goto iterrainlasdatainfo2_getpointdataformat_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pFormat

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpFormat);
    goto iterrainlasdatainfo2_getpointdataformat_method_cleanup;

    iterrainlasdatainfo2_getpointdataformat_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pFormat
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainLasDataInfo2.GetPointDataFormat");
    return return_tuple;
}

static PyObject*
ITerrainLasDataInfo2Method_GetNumberOfPointRecords(PyITerrainLasDataInfo2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpcRecords = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pcRecords

    // Call method on actual COM interface
    hr = self->m_pITerrainLasDataInfo2->GetNumberOfPointRecords(&lpcRecords);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainLasDataInfo2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainLasDataInfo2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainLasDataInfo2.GetNumberOfPointRecords() returned %ld", (long)hr);
        goto iterrainlasdatainfo2_getnumberofpointrecords_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pcRecords

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpcRecords);
    goto iterrainlasdatainfo2_getnumberofpointrecords_method_cleanup;

    iterrainlasdatainfo2_getnumberofpointrecords_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pcRecords
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainLasDataInfo2.GetNumberOfPointRecords");
    return return_tuple;
}

static PyObject*
ITerrainLasDataInfo2Method_GetNumberOfPointsByReturn(PyITerrainLasDataInfo2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lReturnNumber = 0;
    long lpcPoints = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lReturnNumber))
      goto iterrainlasdatainfo2_getnumberofpointsbyreturn_method_cleanup;

    // Set up initial variable values as needed
    // No setup for ReturnNumber
    // No setup for pcPoints

    // Call method on actual COM interface
    hr = self->m_pITerrainLasDataInfo2->GetNumberOfPointsByReturn(lReturnNumber, &lpcPoints);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainLasDataInfo2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainLasDataInfo2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainLasDataInfo2.GetNumberOfPointsByReturn() returned %ld", (long)hr);
        goto iterrainlasdatainfo2_getnumberofpointsbyreturn_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ReturnNumber
    // No teardown for pcPoints

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpcPoints);
    goto iterrainlasdatainfo2_getnumberofpointsbyreturn_method_cleanup;

    iterrainlasdatainfo2_getnumberofpointsbyreturn_method_cleanup:
    self->m_HR = hr;
    // No cleanup for ReturnNumber
    // No cleanup for pcPoints
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainLasDataInfo2.GetNumberOfPointsByReturn");
    return return_tuple;
}

static PyObject*
ITerrainLasDataInfo2Method_GetDataExtent(PyITerrainLasDataInfo2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IEnvelope* ipppExt = NULL;
    PyObject* py_ppExt = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppExt

    // Call method on actual COM interface
    hr = self->m_pITerrainLasDataInfo2->GetDataExtent(&ipppExt);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainLasDataInfo2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainLasDataInfo2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainLasDataInfo2.GetDataExtent() returned %ld", (long)hr);
        goto iterrainlasdatainfo2_getdataextent_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppExt);
    if (ipppExt)
    {
        IUnknown* pUnk = NULL;
        ipppExt->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppExt = IUnknownToPythonIIDObject(pUnk, &IID_IEnvelope);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppExt)
    {
        if (py_ppExt)
           Py_DECREF(py_ppExt);
        py_ppExt = Py_None;
        Py_INCREF(py_ppExt);
    }
    if (PyErr_Occurred())
      goto iterrainlasdatainfo2_getdataextent_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppExt);
    goto iterrainlasdatainfo2_getdataextent_method_cleanup;

    iterrainlasdatainfo2_getdataextent_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppExt);
    if (ipppExt)
      ipppExt->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainLasDataInfo2.GetDataExtent");
    return return_tuple;
}

static PyObject*
ITerrainLasDataInfo2Method_GetSpatialReference(PyITerrainLasDataInfo2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ISpatialReference* ipppSpatialReference = NULL;
    PyObject* py_ppSpatialReference = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppSpatialReference

    // Call method on actual COM interface
    hr = self->m_pITerrainLasDataInfo2->GetSpatialReference(&ipppSpatialReference);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrainLasDataInfo2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrainLasDataInfo2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrainLasDataInfo2.GetSpatialReference() returned %ld", (long)hr);
        goto iterrainlasdatainfo2_getspatialreference_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppSpatialReference);
    if (ipppSpatialReference)
    {
        IUnknown* pUnk = NULL;
        ipppSpatialReference->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppSpatialReference = IUnknownToPythonIIDObject(pUnk, &IID_ISpatialReference);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppSpatialReference)
    {
        if (py_ppSpatialReference)
           Py_DECREF(py_ppSpatialReference);
        py_ppSpatialReference = Py_None;
        Py_INCREF(py_ppSpatialReference);
    }
    if (PyErr_Occurred())
      goto iterrainlasdatainfo2_getspatialreference_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppSpatialReference);
    goto iterrainlasdatainfo2_getspatialreference_method_cleanup;

    iterrainlasdatainfo2_getspatialreference_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppSpatialReference);
    if (ipppSpatialReference)
      ipppSpatialReference->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrainLasDataInfo2.GetSpatialReference");
    return return_tuple;
}


PyMethodDef PyITerrainLasDataInfo2Methods[] = {
    {"supports", (PyCFunction)PyITerrainLasDataInfo2_SupportsInterface, METH_O, ""},
    {"GetFileSourceID", (PyCFunction)ITerrainLasDataInfo2Method_GetFileSourceID, METH_VARARGS, ""},
    {"get_IsStandardGpsTime", (PyCFunction)ITerrainLasDataInfo2Method_get_IsStandardGpsTime, METH_VARARGS, ""},
    {"GetPointInfoByClassCode", (PyCFunction)ITerrainLasDataInfo2Method_GetPointInfoByClassCode, METH_VARARGS, ""},
    {"Init", (PyCFunction)ITerrainLasDataInfo2Method_Init, METH_VARARGS, ""},
    {"GetVersion", (PyCFunction)ITerrainLasDataInfo2Method_GetVersion, METH_VARARGS, ""},
    {"GetSystemID", (PyCFunction)ITerrainLasDataInfo2Method_GetSystemID, METH_VARARGS, ""},
    {"GetGeneratingSoftware", (PyCFunction)ITerrainLasDataInfo2Method_GetGeneratingSoftware, METH_VARARGS, ""},
    {"GetFlightDateJulian", (PyCFunction)ITerrainLasDataInfo2Method_GetFlightDateJulian, METH_VARARGS, ""},
    {"GetYear", (PyCFunction)ITerrainLasDataInfo2Method_GetYear, METH_VARARGS, ""},
    {"GetPointDataFormat", (PyCFunction)ITerrainLasDataInfo2Method_GetPointDataFormat, METH_VARARGS, ""},
    {"GetNumberOfPointRecords", (PyCFunction)ITerrainLasDataInfo2Method_GetNumberOfPointRecords, METH_VARARGS, ""},
    {"GetNumberOfPointsByReturn", (PyCFunction)ITerrainLasDataInfo2Method_GetNumberOfPointsByReturn, METH_VARARGS, ""},
    {"GetDataExtent", (PyCFunction)ITerrainLasDataInfo2Method_GetDataExtent, METH_VARARGS, ""},
    {"GetSpatialReference", (PyCFunction)ITerrainLasDataInfo2Method_GetSpatialReference, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyITerrainLasDataInfo2GetSet[] = {
  {"_pUnk", (getter)PyITerrainLasDataInfo2_GetpUnk, NULL, "Get opaque pointer to an Unknown from ITerrainLasDataInfo2", NULL},
  {"_pointer", (getter)PyITerrainLasDataInfo2_GetPointer, NULL, "Get memory address for ITerrainLasDataInfo2", NULL},
  {"_IID", (getter)PyITerrainLasDataInfo2_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyITerrainLasDataInfo2_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyITerrainLasDataInfo2_GetIgnoreFailures, (setter)PyITerrainLasDataInfo2_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyITerrainLasDataInfo2Object_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.ITerrainLasDataInfo2Object",                          
                                              /* tp_name */
  sizeof(PyITerrainLasDataInfo2Object),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyITerrainLasDataInfo2Object_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyITerrainLasDataInfo2Methods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyITerrainLasDataInfo2GetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyITerrainLasDataInfo2Object_new,                      
                                              /* tp_new */
};

// Interface IGPTerrainMembership

typedef struct PyIGPTerrainMembershipObject {
    PyObject_HEAD
    IGPTerrainMembership* m_pIGPTerrainMembership;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIGPTerrainMembershipObject;

static PyObject*
PyIGPTerrainMembershipObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIGPTerrainMembershipObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IGPTerrainMembership* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IGPTerrainMembership, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IGPTerrainMembership with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIGPTerrainMembershipObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IGPTerrainMembership");
            return NULL;
        }
        self->m_pIGPTerrainMembership = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IGPTerrainMembership");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IGPTerrainMembership");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IGPTerrainMembership* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IGPTerrainMembership, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IGPTerrainMembership");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIGPTerrainMembershipObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IGPTerrainMembership");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIGPTerrainMembership = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIGPTerrainMembershipObject_dealloc(PyIGPTerrainMembershipObject* self)
{
    if (self->m_pIGPTerrainMembership)
        self->m_pIGPTerrainMembership->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIGPTerrainMembership_GetpUnk(PyIGPTerrainMembershipObject* self)
{
    if (!self->m_pIGPTerrainMembership)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIGPTerrainMembership->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IGPTerrainMembership to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIGPTerrainMembership_GetPointer(PyIGPTerrainMembershipObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIGPTerrainMembership);
}

static PyObject*
PyIGPTerrainMembership_GetIID(PyIGPTerrainMembershipObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "718ad44a-b78f-43e3-8087-ee37cb18ac80");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIGPTerrainMembership_GetHR(PyIGPTerrainMembershipObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIGPTerrainMembership_GetIgnoreFailures(PyIGPTerrainMembershipObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIGPTerrainMembership_SetIgnoreFailures(PyIGPTerrainMembershipObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIGPTerrainMembership_SupportsInterface(PyIGPTerrainMembershipObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIGPTerrainMembership->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IGPTerrainMembershipMethod_get_TerrainName(PyIGPTerrainMembershipObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName;
    PyObject* pyvar_Name = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Name

    // Call method on actual COM interface
    hr = self->m_pIGPTerrainMembership->get_TerrainName(&bsName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGPTerrainMembership->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGPTerrainMembership) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGPTerrainMembership.get_TerrainName() returned %ld", (long)hr);
        goto igpterrainmembership_get_terrainname_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Name = PyUnicode_FromWideChar(bsName,::SysStringLen(bsName));
    ::SysFreeString(bsName);
    
    if (PyErr_Occurred())
      goto igpterrainmembership_get_terrainname_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Name);
    goto igpterrainmembership_get_terrainname_method_cleanup;

    igpterrainmembership_get_terrainname_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Name != Py_None)
        Py_XDECREF(pyvar_Name);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGPTerrainMembership.get_TerrainName");
    return return_tuple;
}

static PyObject*
IGPTerrainMembershipMethod_put_TerrainName(PyIGPTerrainMembershipObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName = 0;
    PyObject* pyvar_Name;
    PyObject* unicodeName = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_Name))
      goto igpterrainmembership_put_terrainname_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_Name))
        unicodeName = PyUnicode_FromObject(pyvar_Name);
    else if (PyUnicode_Check(pyvar_Name))
    {
        unicodeName = pyvar_Name;
        Py_INCREF(unicodeName);
    }
    else if (pyvar_Name != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Name at index 0");
    if (unicodeName)
        bsName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeName));
    
    if (PyErr_Occurred())
      goto igpterrainmembership_put_terrainname_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIGPTerrainMembership->put_TerrainName(bsName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGPTerrainMembership->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGPTerrainMembership) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGPTerrainMembership.put_TerrainName() returned %ld", (long)hr);
        goto igpterrainmembership_put_terrainname_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Name

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto igpterrainmembership_put_terrainname_method_cleanup;

    igpterrainmembership_put_terrainname_method_cleanup:
    self->m_HR = hr;
    if (bsName)
        ::SysFreeString(bsName);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGPTerrainMembership.put_TerrainName");
    return return_tuple;
}


PyMethodDef PyIGPTerrainMembershipMethods[] = {
    {"supports", (PyCFunction)PyIGPTerrainMembership_SupportsInterface, METH_O, ""},
    {"get_TerrainName", (PyCFunction)IGPTerrainMembershipMethod_get_TerrainName, METH_VARARGS, ""},
    {"put_TerrainName", (PyCFunction)IGPTerrainMembershipMethod_put_TerrainName, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIGPTerrainMembershipGetSet[] = {
  {"_pUnk", (getter)PyIGPTerrainMembership_GetpUnk, NULL, "Get opaque pointer to an Unknown from IGPTerrainMembership", NULL},
  {"_pointer", (getter)PyIGPTerrainMembership_GetPointer, NULL, "Get memory address for IGPTerrainMembership", NULL},
  {"_IID", (getter)PyIGPTerrainMembership_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIGPTerrainMembership_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIGPTerrainMembership_GetIgnoreFailures, (setter)PyIGPTerrainMembership_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIGPTerrainMembershipObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.IGPTerrainMembershipObject",                          
                                              /* tp_name */
  sizeof(PyIGPTerrainMembershipObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIGPTerrainMembershipObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIGPTerrainMembershipMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIGPTerrainMembershipGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIGPTerrainMembershipObject_new,                      
                                              /* tp_new */
};

// Interface ISimpleStatistics

typedef struct PyISimpleStatisticsObject {
    PyObject_HEAD
    ISimpleStatistics* m_pISimpleStatistics;
    HRESULT m_HR;
    int m_ignore_failures;
} PyISimpleStatisticsObject;

static PyObject*
PyISimpleStatisticsObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyISimpleStatisticsObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ISimpleStatistics* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ISimpleStatistics, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ISimpleStatistics with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyISimpleStatisticsObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ISimpleStatistics");
            return NULL;
        }
        self->m_pISimpleStatistics = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ISimpleStatistics");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ISimpleStatistics");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ISimpleStatistics* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ISimpleStatistics, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ISimpleStatistics");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyISimpleStatisticsObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ISimpleStatistics");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pISimpleStatistics = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyISimpleStatisticsObject_dealloc(PyISimpleStatisticsObject* self)
{
    if (self->m_pISimpleStatistics)
        self->m_pISimpleStatistics->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyISimpleStatistics_GetpUnk(PyISimpleStatisticsObject* self)
{
    if (!self->m_pISimpleStatistics)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pISimpleStatistics->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ISimpleStatistics to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyISimpleStatistics_GetPointer(PyISimpleStatisticsObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pISimpleStatistics);
}

static PyObject*
PyISimpleStatistics_GetIID(PyISimpleStatisticsObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "cf4000ec-9418-4da3-9c2d-931ace25889c");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyISimpleStatistics_GetHR(PyISimpleStatisticsObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyISimpleStatistics_GetIgnoreFailures(PyISimpleStatisticsObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyISimpleStatistics_SetIgnoreFailures(PyISimpleStatisticsObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyISimpleStatistics_SupportsInterface(PyISimpleStatisticsObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pISimpleStatistics->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ISimpleStatisticsMethod_get_DataType(PyISimpleStatisticsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT vpType;
    ::VariantInit(&vpType);
    PyObject* pyvar_pType = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pType

    // Call method on actual COM interface
    hr = self->m_pISimpleStatistics->get_DataType(&vpType);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISimpleStatistics->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISimpleStatistics) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISimpleStatistics.get_DataType() returned %ld", (long)hr);
        goto isimplestatistics_get_datatype_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pType = Variant_AsPyObject(&vpType);
    if (PyErr_Occurred())
      goto isimplestatistics_get_datatype_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pType);
    goto isimplestatistics_get_datatype_method_cleanup;

    isimplestatistics_get_datatype_method_cleanup:
    self->m_HR = hr;
    ::VariantClear(&vpType);
    Py_XDECREF(pyvar_pType);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISimpleStatistics.get_DataType");
    return return_tuple;
}

static PyObject*
ISimpleStatisticsMethod_get_Count(PyISimpleStatisticsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dpCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pCount

    // Call method on actual COM interface
    hr = self->m_pISimpleStatistics->get_Count(&dpCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISimpleStatistics->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISimpleStatistics) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISimpleStatistics.get_Count() returned %ld", (long)hr);
        goto isimplestatistics_get_count_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pCount

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dpCount);
    goto isimplestatistics_get_count_method_cleanup;

    isimplestatistics_get_count_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pCount
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISimpleStatistics.get_Count");
    return return_tuple;
}

static PyObject*
ISimpleStatisticsMethod_get_Minimum(PyISimpleStatisticsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dpMinimum = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pMinimum

    // Call method on actual COM interface
    hr = self->m_pISimpleStatistics->get_Minimum(&dpMinimum);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISimpleStatistics->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISimpleStatistics) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISimpleStatistics.get_Minimum() returned %ld", (long)hr);
        goto isimplestatistics_get_minimum_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pMinimum

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dpMinimum);
    goto isimplestatistics_get_minimum_method_cleanup;

    isimplestatistics_get_minimum_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pMinimum
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISimpleStatistics.get_Minimum");
    return return_tuple;
}

static PyObject*
ISimpleStatisticsMethod_get_Maximum(PyISimpleStatisticsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dpMaximum = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pMaximum

    // Call method on actual COM interface
    hr = self->m_pISimpleStatistics->get_Maximum(&dpMaximum);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISimpleStatistics->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISimpleStatistics) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISimpleStatistics.get_Maximum() returned %ld", (long)hr);
        goto isimplestatistics_get_maximum_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pMaximum

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dpMaximum);
    goto isimplestatistics_get_maximum_method_cleanup;

    isimplestatistics_get_maximum_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pMaximum
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISimpleStatistics.get_Maximum");
    return return_tuple;
}

static PyObject*
ISimpleStatisticsMethod_get_Mean(PyISimpleStatisticsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dpMean = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pMean

    // Call method on actual COM interface
    hr = self->m_pISimpleStatistics->get_Mean(&dpMean);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISimpleStatistics->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISimpleStatistics) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISimpleStatistics.get_Mean() returned %ld", (long)hr);
        goto isimplestatistics_get_mean_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pMean

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dpMean);
    goto isimplestatistics_get_mean_method_cleanup;

    isimplestatistics_get_mean_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pMean
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISimpleStatistics.get_Mean");
    return return_tuple;
}

static PyObject*
ISimpleStatisticsMethod_get_StandardDeviation(PyISimpleStatisticsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dpStandardDeviation = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pStandardDeviation

    // Call method on actual COM interface
    hr = self->m_pISimpleStatistics->get_StandardDeviation(&dpStandardDeviation);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISimpleStatistics->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISimpleStatistics) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISimpleStatistics.get_StandardDeviation() returned %ld", (long)hr);
        goto isimplestatistics_get_standarddeviation_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pStandardDeviation

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dpStandardDeviation);
    goto isimplestatistics_get_standarddeviation_method_cleanup;

    isimplestatistics_get_standarddeviation_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pStandardDeviation
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISimpleStatistics.get_StandardDeviation");
    return return_tuple;
}


PyMethodDef PyISimpleStatisticsMethods[] = {
    {"supports", (PyCFunction)PyISimpleStatistics_SupportsInterface, METH_O, ""},
    {"get_DataType", (PyCFunction)ISimpleStatisticsMethod_get_DataType, METH_VARARGS, ""},
    {"get_Count", (PyCFunction)ISimpleStatisticsMethod_get_Count, METH_VARARGS, ""},
    {"get_Minimum", (PyCFunction)ISimpleStatisticsMethod_get_Minimum, METH_VARARGS, ""},
    {"get_Maximum", (PyCFunction)ISimpleStatisticsMethod_get_Maximum, METH_VARARGS, ""},
    {"get_Mean", (PyCFunction)ISimpleStatisticsMethod_get_Mean, METH_VARARGS, ""},
    {"get_StandardDeviation", (PyCFunction)ISimpleStatisticsMethod_get_StandardDeviation, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyISimpleStatisticsGetSet[] = {
  {"_pUnk", (getter)PyISimpleStatistics_GetpUnk, NULL, "Get opaque pointer to an Unknown from ISimpleStatistics", NULL},
  {"_pointer", (getter)PyISimpleStatistics_GetPointer, NULL, "Get memory address for ISimpleStatistics", NULL},
  {"_IID", (getter)PyISimpleStatistics_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyISimpleStatistics_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyISimpleStatistics_GetIgnoreFailures, (setter)PyISimpleStatistics_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyISimpleStatisticsObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.ISimpleStatisticsObject",                          
                                              /* tp_name */
  sizeof(PyISimpleStatisticsObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyISimpleStatisticsObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyISimpleStatisticsMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyISimpleStatisticsGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyISimpleStatisticsObject_new,                      
                                              /* tp_new */
};

// Interface ILasReturnStatistics

typedef struct PyILasReturnStatisticsObject {
    PyObject_HEAD
    ILasReturnStatistics* m_pILasReturnStatistics;
    HRESULT m_HR;
    int m_ignore_failures;
} PyILasReturnStatisticsObject;

static PyObject*
PyILasReturnStatisticsObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyILasReturnStatisticsObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ILasReturnStatistics* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ILasReturnStatistics, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ILasReturnStatistics with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyILasReturnStatisticsObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ILasReturnStatistics");
            return NULL;
        }
        self->m_pILasReturnStatistics = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ILasReturnStatistics");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ILasReturnStatistics");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ILasReturnStatistics* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ILasReturnStatistics, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ILasReturnStatistics");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyILasReturnStatisticsObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ILasReturnStatistics");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pILasReturnStatistics = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyILasReturnStatisticsObject_dealloc(PyILasReturnStatisticsObject* self)
{
    if (self->m_pILasReturnStatistics)
        self->m_pILasReturnStatistics->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyILasReturnStatistics_GetpUnk(PyILasReturnStatisticsObject* self)
{
    if (!self->m_pILasReturnStatistics)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pILasReturnStatistics->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ILasReturnStatistics to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyILasReturnStatistics_GetPointer(PyILasReturnStatisticsObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pILasReturnStatistics);
}

static PyObject*
PyILasReturnStatistics_GetIID(PyILasReturnStatisticsObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "15080791-5b91-4f28-9931-1ffe7e7db33e");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyILasReturnStatistics_GetHR(PyILasReturnStatisticsObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyILasReturnStatistics_GetIgnoreFailures(PyILasReturnStatisticsObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyILasReturnStatistics_SetIgnoreFailures(PyILasReturnStatisticsObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyILasReturnStatistics_SupportsInterface(PyILasReturnStatisticsObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pILasReturnStatistics->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ILasReturnStatisticsMethod_get_ReturnType(PyILasReturnStatisticsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriTerrainLasReturnType epType;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pType

    // Call method on actual COM interface
    hr = self->m_pILasReturnStatistics->get_ReturnType(&epType);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasReturnStatistics->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasReturnStatistics) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasReturnStatistics.get_ReturnType() returned %ld", (long)hr);
        goto ilasreturnstatistics_get_returntype_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pType

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)epType);
    goto ilasreturnstatistics_get_returntype_method_cleanup;

    ilasreturnstatistics_get_returntype_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pType
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasReturnStatistics.get_ReturnType");
    return return_tuple;
}

static PyObject*
ILasReturnStatisticsMethod_get_PointCount(PyILasReturnStatisticsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dpCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pCount

    // Call method on actual COM interface
    hr = self->m_pILasReturnStatistics->get_PointCount(&dpCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasReturnStatistics->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasReturnStatistics) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasReturnStatistics.get_PointCount() returned %ld", (long)hr);
        goto ilasreturnstatistics_get_pointcount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pCount

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dpCount);
    goto ilasreturnstatistics_get_pointcount_method_cleanup;

    ilasreturnstatistics_get_pointcount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pCount
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasReturnStatistics.get_PointCount");
    return return_tuple;
}

static PyObject*
ILasReturnStatisticsMethod_get_SyntheticPointCount(PyILasReturnStatisticsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dpCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pCount

    // Call method on actual COM interface
    hr = self->m_pILasReturnStatistics->get_SyntheticPointCount(&dpCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasReturnStatistics->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasReturnStatistics) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasReturnStatistics.get_SyntheticPointCount() returned %ld", (long)hr);
        goto ilasreturnstatistics_get_syntheticpointcount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pCount

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dpCount);
    goto ilasreturnstatistics_get_syntheticpointcount_method_cleanup;

    ilasreturnstatistics_get_syntheticpointcount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pCount
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasReturnStatistics.get_SyntheticPointCount");
    return return_tuple;
}

static PyObject*
ILasReturnStatisticsMethod_get_KeyPointCount(PyILasReturnStatisticsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dpCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pCount

    // Call method on actual COM interface
    hr = self->m_pILasReturnStatistics->get_KeyPointCount(&dpCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasReturnStatistics->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasReturnStatistics) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasReturnStatistics.get_KeyPointCount() returned %ld", (long)hr);
        goto ilasreturnstatistics_get_keypointcount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pCount

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dpCount);
    goto ilasreturnstatistics_get_keypointcount_method_cleanup;

    ilasreturnstatistics_get_keypointcount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pCount
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasReturnStatistics.get_KeyPointCount");
    return return_tuple;
}

static PyObject*
ILasReturnStatisticsMethod_get_Extent(PyILasReturnStatisticsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IEnvelope* ipppExt = NULL;
    PyObject* py_ppExt = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppExt

    // Call method on actual COM interface
    hr = self->m_pILasReturnStatistics->get_Extent(&ipppExt);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasReturnStatistics->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasReturnStatistics) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasReturnStatistics.get_Extent() returned %ld", (long)hr);
        goto ilasreturnstatistics_get_extent_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppExt);
    if (ipppExt)
    {
        IUnknown* pUnk = NULL;
        ipppExt->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppExt = IUnknownToPythonIIDObject(pUnk, &IID_IEnvelope);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppExt)
    {
        if (py_ppExt)
           Py_DECREF(py_ppExt);
        py_ppExt = Py_None;
        Py_INCREF(py_ppExt);
    }
    if (PyErr_Occurred())
      goto ilasreturnstatistics_get_extent_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppExt);
    goto ilasreturnstatistics_get_extent_method_cleanup;

    ilasreturnstatistics_get_extent_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppExt);
    if (ipppExt)
      ipppExt->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasReturnStatistics.get_Extent");
    return return_tuple;
}


PyMethodDef PyILasReturnStatisticsMethods[] = {
    {"supports", (PyCFunction)PyILasReturnStatistics_SupportsInterface, METH_O, ""},
    {"get_ReturnType", (PyCFunction)ILasReturnStatisticsMethod_get_ReturnType, METH_VARARGS, ""},
    {"get_PointCount", (PyCFunction)ILasReturnStatisticsMethod_get_PointCount, METH_VARARGS, ""},
    {"get_SyntheticPointCount", (PyCFunction)ILasReturnStatisticsMethod_get_SyntheticPointCount, METH_VARARGS, ""},
    {"get_KeyPointCount", (PyCFunction)ILasReturnStatisticsMethod_get_KeyPointCount, METH_VARARGS, ""},
    {"get_Extent", (PyCFunction)ILasReturnStatisticsMethod_get_Extent, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyILasReturnStatisticsGetSet[] = {
  {"_pUnk", (getter)PyILasReturnStatistics_GetpUnk, NULL, "Get opaque pointer to an Unknown from ILasReturnStatistics", NULL},
  {"_pointer", (getter)PyILasReturnStatistics_GetPointer, NULL, "Get memory address for ILasReturnStatistics", NULL},
  {"_IID", (getter)PyILasReturnStatistics_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyILasReturnStatistics_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyILasReturnStatistics_GetIgnoreFailures, (setter)PyILasReturnStatistics_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyILasReturnStatisticsObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.ILasReturnStatisticsObject",                          
                                              /* tp_name */
  sizeof(PyILasReturnStatisticsObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyILasReturnStatisticsObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyILasReturnStatisticsMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyILasReturnStatisticsGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyILasReturnStatisticsObject_new,                      
                                              /* tp_new */
};

// Interface ILasClassCodeStatistics

typedef struct PyILasClassCodeStatisticsObject {
    PyObject_HEAD
    ILasClassCodeStatistics* m_pILasClassCodeStatistics;
    HRESULT m_HR;
    int m_ignore_failures;
} PyILasClassCodeStatisticsObject;

static PyObject*
PyILasClassCodeStatisticsObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyILasClassCodeStatisticsObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ILasClassCodeStatistics* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ILasClassCodeStatistics, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ILasClassCodeStatistics with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyILasClassCodeStatisticsObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ILasClassCodeStatistics");
            return NULL;
        }
        self->m_pILasClassCodeStatistics = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ILasClassCodeStatistics");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ILasClassCodeStatistics");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ILasClassCodeStatistics* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ILasClassCodeStatistics, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ILasClassCodeStatistics");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyILasClassCodeStatisticsObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ILasClassCodeStatistics");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pILasClassCodeStatistics = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyILasClassCodeStatisticsObject_dealloc(PyILasClassCodeStatisticsObject* self)
{
    if (self->m_pILasClassCodeStatistics)
        self->m_pILasClassCodeStatistics->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyILasClassCodeStatistics_GetpUnk(PyILasClassCodeStatisticsObject* self)
{
    if (!self->m_pILasClassCodeStatistics)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pILasClassCodeStatistics->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ILasClassCodeStatistics to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyILasClassCodeStatistics_GetPointer(PyILasClassCodeStatisticsObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pILasClassCodeStatistics);
}

static PyObject*
PyILasClassCodeStatistics_GetIID(PyILasClassCodeStatisticsObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "89e4489f-87e2-4690-8385-5143fe6d9753");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyILasClassCodeStatistics_GetHR(PyILasClassCodeStatisticsObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyILasClassCodeStatistics_GetIgnoreFailures(PyILasClassCodeStatisticsObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyILasClassCodeStatistics_SetIgnoreFailures(PyILasClassCodeStatisticsObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyILasClassCodeStatistics_SupportsInterface(PyILasClassCodeStatisticsObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pILasClassCodeStatistics->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ILasClassCodeStatisticsMethod_get_ClassCode(PyILasClassCodeStatisticsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpCode = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pCode

    // Call method on actual COM interface
    hr = self->m_pILasClassCodeStatistics->get_ClassCode(&lpCode);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasClassCodeStatistics->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasClassCodeStatistics) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasClassCodeStatistics.get_ClassCode() returned %ld", (long)hr);
        goto ilasclasscodestatistics_get_classcode_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pCode

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpCode);
    goto ilasclasscodestatistics_get_classcode_method_cleanup;

    ilasclasscodestatistics_get_classcode_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pCode
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasClassCodeStatistics.get_ClassCode");
    return return_tuple;
}

static PyObject*
ILasClassCodeStatisticsMethod_get_PointCount(PyILasClassCodeStatisticsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dpCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pCount

    // Call method on actual COM interface
    hr = self->m_pILasClassCodeStatistics->get_PointCount(&dpCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasClassCodeStatistics->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasClassCodeStatistics) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasClassCodeStatistics.get_PointCount() returned %ld", (long)hr);
        goto ilasclasscodestatistics_get_pointcount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pCount

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dpCount);
    goto ilasclasscodestatistics_get_pointcount_method_cleanup;

    ilasclasscodestatistics_get_pointcount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pCount
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasClassCodeStatistics.get_PointCount");
    return return_tuple;
}

static PyObject*
ILasClassCodeStatisticsMethod_get_SyntheticPointCount(PyILasClassCodeStatisticsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dpCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pCount

    // Call method on actual COM interface
    hr = self->m_pILasClassCodeStatistics->get_SyntheticPointCount(&dpCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasClassCodeStatistics->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasClassCodeStatistics) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasClassCodeStatistics.get_SyntheticPointCount() returned %ld", (long)hr);
        goto ilasclasscodestatistics_get_syntheticpointcount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pCount

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dpCount);
    goto ilasclasscodestatistics_get_syntheticpointcount_method_cleanup;

    ilasclasscodestatistics_get_syntheticpointcount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pCount
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasClassCodeStatistics.get_SyntheticPointCount");
    return return_tuple;
}

static PyObject*
ILasClassCodeStatisticsMethod_get_KeyPointCount(PyILasClassCodeStatisticsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dpCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pCount

    // Call method on actual COM interface
    hr = self->m_pILasClassCodeStatistics->get_KeyPointCount(&dpCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasClassCodeStatistics->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasClassCodeStatistics) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasClassCodeStatistics.get_KeyPointCount() returned %ld", (long)hr);
        goto ilasclasscodestatistics_get_keypointcount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pCount

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dpCount);
    goto ilasclasscodestatistics_get_keypointcount_method_cleanup;

    ilasclasscodestatistics_get_keypointcount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pCount
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasClassCodeStatistics.get_KeyPointCount");
    return return_tuple;
}

static PyObject*
ILasClassCodeStatisticsMethod_get_Extent(PyILasClassCodeStatisticsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IEnvelope* ipppExt = NULL;
    PyObject* py_ppExt = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppExt

    // Call method on actual COM interface
    hr = self->m_pILasClassCodeStatistics->get_Extent(&ipppExt);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasClassCodeStatistics->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasClassCodeStatistics) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasClassCodeStatistics.get_Extent() returned %ld", (long)hr);
        goto ilasclasscodestatistics_get_extent_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppExt);
    if (ipppExt)
    {
        IUnknown* pUnk = NULL;
        ipppExt->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppExt = IUnknownToPythonIIDObject(pUnk, &IID_IEnvelope);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppExt)
    {
        if (py_ppExt)
           Py_DECREF(py_ppExt);
        py_ppExt = Py_None;
        Py_INCREF(py_ppExt);
    }
    if (PyErr_Occurred())
      goto ilasclasscodestatistics_get_extent_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppExt);
    goto ilasclasscodestatistics_get_extent_method_cleanup;

    ilasclasscodestatistics_get_extent_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppExt);
    if (ipppExt)
      ipppExt->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasClassCodeStatistics.get_Extent");
    return return_tuple;
}

static PyObject*
ILasClassCodeStatisticsMethod_GetIntensityRange(PyILasClassCodeStatisticsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpMin = 0;
    long lpMax = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pMin
    // No setup for pMax

    // Call method on actual COM interface
    hr = self->m_pILasClassCodeStatistics->GetIntensityRange(&lpMin, &lpMax);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasClassCodeStatistics->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasClassCodeStatistics) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasClassCodeStatistics.GetIntensityRange() returned %ld", (long)hr);
        goto ilasclasscodestatistics_getintensityrange_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pMin
    // No teardown for pMax

    // Initialize output tuple
    return_tuple = Py_BuildValue("ll",
                                            lpMin, lpMax);
    goto ilasclasscodestatistics_getintensityrange_method_cleanup;

    ilasclasscodestatistics_getintensityrange_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pMin
    // No cleanup for pMax
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasClassCodeStatistics.GetIntensityRange");
    return return_tuple;
}


PyMethodDef PyILasClassCodeStatisticsMethods[] = {
    {"supports", (PyCFunction)PyILasClassCodeStatistics_SupportsInterface, METH_O, ""},
    {"get_ClassCode", (PyCFunction)ILasClassCodeStatisticsMethod_get_ClassCode, METH_VARARGS, ""},
    {"get_PointCount", (PyCFunction)ILasClassCodeStatisticsMethod_get_PointCount, METH_VARARGS, ""},
    {"get_SyntheticPointCount", (PyCFunction)ILasClassCodeStatisticsMethod_get_SyntheticPointCount, METH_VARARGS, ""},
    {"get_KeyPointCount", (PyCFunction)ILasClassCodeStatisticsMethod_get_KeyPointCount, METH_VARARGS, ""},
    {"get_Extent", (PyCFunction)ILasClassCodeStatisticsMethod_get_Extent, METH_VARARGS, ""},
    {"GetIntensityRange", (PyCFunction)ILasClassCodeStatisticsMethod_GetIntensityRange, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyILasClassCodeStatisticsGetSet[] = {
  {"_pUnk", (getter)PyILasClassCodeStatistics_GetpUnk, NULL, "Get opaque pointer to an Unknown from ILasClassCodeStatistics", NULL},
  {"_pointer", (getter)PyILasClassCodeStatistics_GetPointer, NULL, "Get memory address for ILasClassCodeStatistics", NULL},
  {"_IID", (getter)PyILasClassCodeStatistics_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyILasClassCodeStatistics_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyILasClassCodeStatistics_GetIgnoreFailures, (setter)PyILasClassCodeStatistics_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyILasClassCodeStatisticsObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.ILasClassCodeStatisticsObject",                          
                                              /* tp_name */
  sizeof(PyILasClassCodeStatisticsObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyILasClassCodeStatisticsObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyILasClassCodeStatisticsMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyILasClassCodeStatisticsGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyILasClassCodeStatisticsObject_new,                      
                                              /* tp_new */
};

// Interface ILasStatistics

typedef struct PyILasStatisticsObject {
    PyObject_HEAD
    ILasStatistics* m_pILasStatistics;
    HRESULT m_HR;
    int m_ignore_failures;
} PyILasStatisticsObject;

static PyObject*
PyILasStatisticsObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyILasStatisticsObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ILasStatistics* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ILasStatistics, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ILasStatistics with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyILasStatisticsObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ILasStatistics");
            return NULL;
        }
        self->m_pILasStatistics = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ILasStatistics");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ILasStatistics");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ILasStatistics* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ILasStatistics, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ILasStatistics");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyILasStatisticsObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ILasStatistics");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pILasStatistics = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyILasStatisticsObject_dealloc(PyILasStatisticsObject* self)
{
    if (self->m_pILasStatistics)
        self->m_pILasStatistics->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyILasStatistics_GetpUnk(PyILasStatisticsObject* self)
{
    if (!self->m_pILasStatistics)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pILasStatistics->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ILasStatistics to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyILasStatistics_GetPointer(PyILasStatisticsObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pILasStatistics);
}

static PyObject*
PyILasStatistics_GetIID(PyILasStatisticsObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "23afc48e-4efb-479f-9164-959e70e01918");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyILasStatistics_GetHR(PyILasStatisticsObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyILasStatistics_GetIgnoreFailures(PyILasStatisticsObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyILasStatistics_SetIgnoreFailures(PyILasStatisticsObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyILasStatistics_SupportsInterface(PyILasStatisticsObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pILasStatistics->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ILasStatisticsMethod_get_WithheldPointCount(PyILasStatisticsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dpCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pCount

    // Call method on actual COM interface
    hr = self->m_pILasStatistics->get_WithheldPointCount(&dpCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasStatistics->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasStatistics) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasStatistics.get_WithheldPointCount() returned %ld", (long)hr);
        goto ilasstatistics_get_withheldpointcount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pCount

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dpCount);
    goto ilasstatistics_get_withheldpointcount_method_cleanup;

    ilasstatistics_get_withheldpointcount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pCount
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasStatistics.get_WithheldPointCount");
    return return_tuple;
}

static PyObject*
ILasStatisticsMethod_get_WithheldExtent(PyILasStatisticsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IEnvelope* ipppExt = NULL;
    PyObject* py_ppExt = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppExt

    // Call method on actual COM interface
    hr = self->m_pILasStatistics->get_WithheldExtent(&ipppExt);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasStatistics->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasStatistics) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasStatistics.get_WithheldExtent() returned %ld", (long)hr);
        goto ilasstatistics_get_withheldextent_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppExt);
    if (ipppExt)
    {
        IUnknown* pUnk = NULL;
        ipppExt->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppExt = IUnknownToPythonIIDObject(pUnk, &IID_IEnvelope);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppExt)
    {
        if (py_ppExt)
           Py_DECREF(py_ppExt);
        py_ppExt = Py_None;
        Py_INCREF(py_ppExt);
    }
    if (PyErr_Occurred())
      goto ilasstatistics_get_withheldextent_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppExt);
    goto ilasstatistics_get_withheldextent_method_cleanup;

    ilasstatistics_get_withheldextent_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppExt);
    if (ipppExt)
      ipppExt->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasStatistics.get_WithheldExtent");
    return return_tuple;
}

static PyObject*
ILasStatisticsMethod_GetAttributeStatistics(PyILasStatisticsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriLasAttributeType eAttribute;
    ISimpleStatistics* ipppStatistics = NULL;
    PyObject* py_ppStatistics = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&eAttribute))
      goto ilasstatistics_getattributestatistics_method_cleanup;

    // Set up initial variable values as needed
    // No setup for Attribute
    // No setup for ppStatistics

    // Call method on actual COM interface
    hr = self->m_pILasStatistics->GetAttributeStatistics(eAttribute, &ipppStatistics);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasStatistics->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasStatistics) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasStatistics.GetAttributeStatistics() returned %ld", (long)hr);
        goto ilasstatistics_getattributestatistics_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Attribute
    Py_XDECREF(py_ppStatistics);
    if (ipppStatistics)
    {
        IUnknown* pUnk = NULL;
        ipppStatistics->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppStatistics = IUnknownToPythonIIDObject(pUnk, &IID_ISimpleStatistics);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppStatistics)
    {
        if (py_ppStatistics)
           Py_DECREF(py_ppStatistics);
        py_ppStatistics = Py_None;
        Py_INCREF(py_ppStatistics);
    }
    if (PyErr_Occurred())
      goto ilasstatistics_getattributestatistics_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppStatistics);
    goto ilasstatistics_getattributestatistics_method_cleanup;

    ilasstatistics_getattributestatistics_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Attribute
    Py_XDECREF(py_ppStatistics);
    if (ipppStatistics)
      ipppStatistics->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasStatistics.GetAttributeStatistics");
    return return_tuple;
}

static PyObject*
ILasStatisticsMethod_GetUniqueReturns(PyILasStatisticsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ILongArray* ipppReturns = NULL;
    PyObject* py_ppReturns = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppReturns

    // Call method on actual COM interface
    hr = self->m_pILasStatistics->GetUniqueReturns(&ipppReturns);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasStatistics->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasStatistics) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasStatistics.GetUniqueReturns() returned %ld", (long)hr);
        goto ilasstatistics_getuniquereturns_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppReturns);
    if (ipppReturns)
    {
        IUnknown* pUnk = NULL;
        ipppReturns->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppReturns = IUnknownToPythonIIDObject(pUnk, &IID_ILongArray);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppReturns)
    {
        if (py_ppReturns)
           Py_DECREF(py_ppReturns);
        py_ppReturns = Py_None;
        Py_INCREF(py_ppReturns);
    }
    if (PyErr_Occurred())
      goto ilasstatistics_getuniquereturns_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppReturns);
    goto ilasstatistics_getuniquereturns_method_cleanup;

    ilasstatistics_getuniquereturns_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppReturns);
    if (ipppReturns)
      ipppReturns->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasStatistics.GetUniqueReturns");
    return return_tuple;
}

static PyObject*
ILasStatisticsMethod_GetUniqueClassCodes(PyILasStatisticsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ILongArray* ipppCodes = NULL;
    PyObject* py_ppCodes = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppCodes

    // Call method on actual COM interface
    hr = self->m_pILasStatistics->GetUniqueClassCodes(&ipppCodes);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasStatistics->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasStatistics) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasStatistics.GetUniqueClassCodes() returned %ld", (long)hr);
        goto ilasstatistics_getuniqueclasscodes_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppCodes);
    if (ipppCodes)
    {
        IUnknown* pUnk = NULL;
        ipppCodes->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppCodes = IUnknownToPythonIIDObject(pUnk, &IID_ILongArray);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppCodes)
    {
        if (py_ppCodes)
           Py_DECREF(py_ppCodes);
        py_ppCodes = Py_None;
        Py_INCREF(py_ppCodes);
    }
    if (PyErr_Occurred())
      goto ilasstatistics_getuniqueclasscodes_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppCodes);
    goto ilasstatistics_getuniqueclasscodes_method_cleanup;

    ilasstatistics_getuniqueclasscodes_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppCodes);
    if (ipppCodes)
      ipppCodes->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasStatistics.GetUniqueClassCodes");
    return return_tuple;
}

static PyObject*
ILasStatisticsMethod_GetReturnStatistics(PyILasStatisticsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriTerrainLasReturnType eType;
    ILasReturnStatistics* ipppStatistics = NULL;
    PyObject* py_ppStatistics = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&eType))
      goto ilasstatistics_getreturnstatistics_method_cleanup;

    // Set up initial variable values as needed
    // No setup for Type
    // No setup for ppStatistics

    // Call method on actual COM interface
    hr = self->m_pILasStatistics->GetReturnStatistics(eType, &ipppStatistics);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasStatistics->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasStatistics) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasStatistics.GetReturnStatistics() returned %ld", (long)hr);
        goto ilasstatistics_getreturnstatistics_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Type
    Py_XDECREF(py_ppStatistics);
    if (ipppStatistics)
    {
        IUnknown* pUnk = NULL;
        ipppStatistics->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppStatistics = IUnknownToPythonIIDObject(pUnk, &IID_ILasReturnStatistics);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppStatistics)
    {
        if (py_ppStatistics)
           Py_DECREF(py_ppStatistics);
        py_ppStatistics = Py_None;
        Py_INCREF(py_ppStatistics);
    }
    if (PyErr_Occurred())
      goto ilasstatistics_getreturnstatistics_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppStatistics);
    goto ilasstatistics_getreturnstatistics_method_cleanup;

    ilasstatistics_getreturnstatistics_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Type
    Py_XDECREF(py_ppStatistics);
    if (ipppStatistics)
      ipppStatistics->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasStatistics.GetReturnStatistics");
    return return_tuple;
}

static PyObject*
ILasStatisticsMethod_GetClassCodeStatistics(PyILasStatisticsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lClassCode = 0;
    ILasClassCodeStatistics* ipppStatistics = NULL;
    PyObject* py_ppStatistics = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lClassCode))
      goto ilasstatistics_getclasscodestatistics_method_cleanup;

    // Set up initial variable values as needed
    // No setup for ClassCode
    // No setup for ppStatistics

    // Call method on actual COM interface
    hr = self->m_pILasStatistics->GetClassCodeStatistics(lClassCode, &ipppStatistics);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasStatistics->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasStatistics) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasStatistics.GetClassCodeStatistics() returned %ld", (long)hr);
        goto ilasstatistics_getclasscodestatistics_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ClassCode
    Py_XDECREF(py_ppStatistics);
    if (ipppStatistics)
    {
        IUnknown* pUnk = NULL;
        ipppStatistics->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppStatistics = IUnknownToPythonIIDObject(pUnk, &IID_ILasClassCodeStatistics);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppStatistics)
    {
        if (py_ppStatistics)
           Py_DECREF(py_ppStatistics);
        py_ppStatistics = Py_None;
        Py_INCREF(py_ppStatistics);
    }
    if (PyErr_Occurred())
      goto ilasstatistics_getclasscodestatistics_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppStatistics);
    goto ilasstatistics_getclasscodestatistics_method_cleanup;

    ilasstatistics_getclasscodestatistics_method_cleanup:
    self->m_HR = hr;
    // No cleanup for ClassCode
    Py_XDECREF(py_ppStatistics);
    if (ipppStatistics)
      ipppStatistics->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasStatistics.GetClassCodeStatistics");
    return return_tuple;
}


PyMethodDef PyILasStatisticsMethods[] = {
    {"supports", (PyCFunction)PyILasStatistics_SupportsInterface, METH_O, ""},
    {"get_WithheldPointCount", (PyCFunction)ILasStatisticsMethod_get_WithheldPointCount, METH_VARARGS, ""},
    {"get_WithheldExtent", (PyCFunction)ILasStatisticsMethod_get_WithheldExtent, METH_VARARGS, ""},
    {"GetAttributeStatistics", (PyCFunction)ILasStatisticsMethod_GetAttributeStatistics, METH_VARARGS, ""},
    {"GetUniqueReturns", (PyCFunction)ILasStatisticsMethod_GetUniqueReturns, METH_VARARGS, ""},
    {"GetUniqueClassCodes", (PyCFunction)ILasStatisticsMethod_GetUniqueClassCodes, METH_VARARGS, ""},
    {"GetReturnStatistics", (PyCFunction)ILasStatisticsMethod_GetReturnStatistics, METH_VARARGS, ""},
    {"GetClassCodeStatistics", (PyCFunction)ILasStatisticsMethod_GetClassCodeStatistics, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyILasStatisticsGetSet[] = {
  {"_pUnk", (getter)PyILasStatistics_GetpUnk, NULL, "Get opaque pointer to an Unknown from ILasStatistics", NULL},
  {"_pointer", (getter)PyILasStatistics_GetPointer, NULL, "Get memory address for ILasStatistics", NULL},
  {"_IID", (getter)PyILasStatistics_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyILasStatistics_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyILasStatistics_GetIgnoreFailures, (setter)PyILasStatistics_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyILasStatisticsObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.ILasStatisticsObject",                          
                                              /* tp_name */
  sizeof(PyILasStatisticsObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyILasStatisticsObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyILasStatisticsMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyILasStatisticsGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyILasStatisticsObject_new,                      
                                              /* tp_new */
};

// Interface ILasHeaderInfo

typedef struct PyILasHeaderInfoObject {
    PyObject_HEAD
    ILasHeaderInfo* m_pILasHeaderInfo;
    HRESULT m_HR;
    int m_ignore_failures;
} PyILasHeaderInfoObject;

static PyObject*
PyILasHeaderInfoObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyILasHeaderInfoObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ILasHeaderInfo* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ILasHeaderInfo, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ILasHeaderInfo with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyILasHeaderInfoObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ILasHeaderInfo");
            return NULL;
        }
        self->m_pILasHeaderInfo = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ILasHeaderInfo");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ILasHeaderInfo");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ILasHeaderInfo* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ILasHeaderInfo, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ILasHeaderInfo");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyILasHeaderInfoObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ILasHeaderInfo");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pILasHeaderInfo = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyILasHeaderInfoObject_dealloc(PyILasHeaderInfoObject* self)
{
    if (self->m_pILasHeaderInfo)
        self->m_pILasHeaderInfo->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyILasHeaderInfo_GetpUnk(PyILasHeaderInfoObject* self)
{
    if (!self->m_pILasHeaderInfo)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pILasHeaderInfo->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ILasHeaderInfo to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyILasHeaderInfo_GetPointer(PyILasHeaderInfoObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pILasHeaderInfo);
}

static PyObject*
PyILasHeaderInfo_GetIID(PyILasHeaderInfoObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "89f48c7a-ac12-4371-92c3-194559bb354b");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyILasHeaderInfo_GetHR(PyILasHeaderInfoObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyILasHeaderInfo_GetIgnoreFailures(PyILasHeaderInfoObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyILasHeaderInfo_SetIgnoreFailures(PyILasHeaderInfoObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyILasHeaderInfo_SupportsInterface(PyILasHeaderInfoObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pILasHeaderInfo->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ILasHeaderInfoMethod_GetVersion(PyILasHeaderInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpMajor = 0;
    long lpMinor = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pMajor
    // No setup for pMinor

    // Call method on actual COM interface
    hr = self->m_pILasHeaderInfo->GetVersion(&lpMajor, &lpMinor);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasHeaderInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasHeaderInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasHeaderInfo.GetVersion() returned %ld", (long)hr);
        goto ilasheaderinfo_getversion_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pMajor
    // No teardown for pMinor

    // Initialize output tuple
    return_tuple = Py_BuildValue("ll",
                                            lpMajor, lpMinor);
    goto ilasheaderinfo_getversion_method_cleanup;

    ilasheaderinfo_getversion_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pMajor
    // No cleanup for pMinor
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasHeaderInfo.GetVersion");
    return return_tuple;
}

static PyObject*
ILasHeaderInfoMethod_get_PointDataFormat(PyILasHeaderInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpFormat = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pFormat

    // Call method on actual COM interface
    hr = self->m_pILasHeaderInfo->get_PointDataFormat(&lpFormat);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasHeaderInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasHeaderInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasHeaderInfo.get_PointDataFormat() returned %ld", (long)hr);
        goto ilasheaderinfo_get_pointdataformat_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pFormat

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpFormat);
    goto ilasheaderinfo_get_pointdataformat_method_cleanup;

    ilasheaderinfo_get_pointdataformat_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pFormat
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasHeaderInfo.get_PointDataFormat");
    return return_tuple;
}

static PyObject*
ILasHeaderInfoMethod_get_SystemID(PyILasHeaderInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspID;
    PyObject* pyvar_pID = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pID

    // Call method on actual COM interface
    hr = self->m_pILasHeaderInfo->get_SystemID(&bspID);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasHeaderInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasHeaderInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasHeaderInfo.get_SystemID() returned %ld", (long)hr);
        goto ilasheaderinfo_get_systemid_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pID = PyUnicode_FromWideChar(bspID,::SysStringLen(bspID));
    ::SysFreeString(bspID);
    
    if (PyErr_Occurred())
      goto ilasheaderinfo_get_systemid_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pID);
    goto ilasheaderinfo_get_systemid_method_cleanup;

    ilasheaderinfo_get_systemid_method_cleanup:
    self->m_HR = hr;
    if (pyvar_pID != Py_None)
        Py_XDECREF(pyvar_pID);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasHeaderInfo.get_SystemID");
    return return_tuple;
}

static PyObject*
ILasHeaderInfoMethod_get_GeneratingSoftware(PyILasHeaderInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspName;
    PyObject* pyvar_pName = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pName

    // Call method on actual COM interface
    hr = self->m_pILasHeaderInfo->get_GeneratingSoftware(&bspName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasHeaderInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasHeaderInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasHeaderInfo.get_GeneratingSoftware() returned %ld", (long)hr);
        goto ilasheaderinfo_get_generatingsoftware_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pName = PyUnicode_FromWideChar(bspName,::SysStringLen(bspName));
    ::SysFreeString(bspName);
    
    if (PyErr_Occurred())
      goto ilasheaderinfo_get_generatingsoftware_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pName);
    goto ilasheaderinfo_get_generatingsoftware_method_cleanup;

    ilasheaderinfo_get_generatingsoftware_method_cleanup:
    self->m_HR = hr;
    if (pyvar_pName != Py_None)
        Py_XDECREF(pyvar_pName);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasHeaderInfo.get_GeneratingSoftware");
    return return_tuple;
}

static PyObject*
ILasHeaderInfoMethod_get_FlightDateJulian(PyILasHeaderInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpDate = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pDate

    // Call method on actual COM interface
    hr = self->m_pILasHeaderInfo->get_FlightDateJulian(&lpDate);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasHeaderInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasHeaderInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasHeaderInfo.get_FlightDateJulian() returned %ld", (long)hr);
        goto ilasheaderinfo_get_flightdatejulian_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pDate

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpDate);
    goto ilasheaderinfo_get_flightdatejulian_method_cleanup;

    ilasheaderinfo_get_flightdatejulian_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pDate
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasHeaderInfo.get_FlightDateJulian");
    return return_tuple;
}

static PyObject*
ILasHeaderInfoMethod_get_Year(PyILasHeaderInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpYear = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pYear

    // Call method on actual COM interface
    hr = self->m_pILasHeaderInfo->get_Year(&lpYear);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasHeaderInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasHeaderInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasHeaderInfo.get_Year() returned %ld", (long)hr);
        goto ilasheaderinfo_get_year_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pYear

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpYear);
    goto ilasheaderinfo_get_year_method_cleanup;

    ilasheaderinfo_get_year_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pYear
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasHeaderInfo.get_Year");
    return return_tuple;
}

static PyObject*
ILasHeaderInfoMethod_get_NumberOfPointRecords(PyILasHeaderInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dpcRecords = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pcRecords

    // Call method on actual COM interface
    hr = self->m_pILasHeaderInfo->get_NumberOfPointRecords(&dpcRecords);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasHeaderInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasHeaderInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasHeaderInfo.get_NumberOfPointRecords() returned %ld", (long)hr);
        goto ilasheaderinfo_get_numberofpointrecords_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pcRecords

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dpcRecords);
    goto ilasheaderinfo_get_numberofpointrecords_method_cleanup;

    ilasheaderinfo_get_numberofpointrecords_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pcRecords
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasHeaderInfo.get_NumberOfPointRecords");
    return return_tuple;
}

static PyObject*
ILasHeaderInfoMethod_GetNumberOfPointsByReturn(PyILasHeaderInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lReturnNumber = 0;
    double dpcPoints = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lReturnNumber))
      goto ilasheaderinfo_getnumberofpointsbyreturn_method_cleanup;

    // Set up initial variable values as needed
    // No setup for ReturnNumber
    // No setup for pcPoints

    // Call method on actual COM interface
    hr = self->m_pILasHeaderInfo->GetNumberOfPointsByReturn(lReturnNumber, &dpcPoints);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasHeaderInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasHeaderInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasHeaderInfo.GetNumberOfPointsByReturn() returned %ld", (long)hr);
        goto ilasheaderinfo_getnumberofpointsbyreturn_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ReturnNumber
    // No teardown for pcPoints

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dpcPoints);
    goto ilasheaderinfo_getnumberofpointsbyreturn_method_cleanup;

    ilasheaderinfo_getnumberofpointsbyreturn_method_cleanup:
    self->m_HR = hr;
    // No cleanup for ReturnNumber
    // No cleanup for pcPoints
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasHeaderInfo.GetNumberOfPointsByReturn");
    return return_tuple;
}

static PyObject*
ILasHeaderInfoMethod_get_ProjectID(PyILasHeaderInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IUID* ipppGuid = NULL;
    PyObject* py_ppGuid = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppGuid

    // Call method on actual COM interface
    hr = self->m_pILasHeaderInfo->get_ProjectID(&ipppGuid);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasHeaderInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasHeaderInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasHeaderInfo.get_ProjectID() returned %ld", (long)hr);
        goto ilasheaderinfo_get_projectid_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppGuid);
    if (ipppGuid)
    {
        IUnknown* pUnk = NULL;
        ipppGuid->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppGuid = IUnknownToPythonIIDObject(pUnk, &IID_IUID);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppGuid)
    {
        if (py_ppGuid)
           Py_DECREF(py_ppGuid);
        py_ppGuid = Py_None;
        Py_INCREF(py_ppGuid);
    }
    if (PyErr_Occurred())
      goto ilasheaderinfo_get_projectid_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppGuid);
    goto ilasheaderinfo_get_projectid_method_cleanup;

    ilasheaderinfo_get_projectid_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppGuid);
    if (ipppGuid)
      ipppGuid->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasHeaderInfo.get_ProjectID");
    return return_tuple;
}

static PyObject*
ILasHeaderInfoMethod_get_FileSourceID(PyILasHeaderInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpID = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pID

    // Call method on actual COM interface
    hr = self->m_pILasHeaderInfo->get_FileSourceID(&lpID);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasHeaderInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasHeaderInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasHeaderInfo.get_FileSourceID() returned %ld", (long)hr);
        goto ilasheaderinfo_get_filesourceid_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pID

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpID);
    goto ilasheaderinfo_get_filesourceid_method_cleanup;

    ilasheaderinfo_get_filesourceid_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pID
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasHeaderInfo.get_FileSourceID");
    return return_tuple;
}

static PyObject*
ILasHeaderInfoMethod_get_HasRGB(PyILasHeaderInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pbHasRGB = VARIANT_FALSE;
    PyObject* pyvar_pbHasRGB = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pbHasRGB

    // Call method on actual COM interface
    hr = self->m_pILasHeaderInfo->get_HasRGB(&b_pbHasRGB);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasHeaderInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasHeaderInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasHeaderInfo.get_HasRGB() returned %ld", (long)hr);
        goto ilasheaderinfo_get_hasrgb_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pbHasRGB = ((b_pbHasRGB == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto ilasheaderinfo_get_hasrgb_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pbHasRGB);
    goto ilasheaderinfo_get_hasrgb_method_cleanup;

    ilasheaderinfo_get_hasrgb_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pbHasRGB
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasHeaderInfo.get_HasRGB");
    return return_tuple;
}

static PyObject*
ILasHeaderInfoMethod_get_HasGpsTime(PyILasHeaderInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pbHasGpsTime = VARIANT_FALSE;
    PyObject* pyvar_pbHasGpsTime = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pbHasGpsTime

    // Call method on actual COM interface
    hr = self->m_pILasHeaderInfo->get_HasGpsTime(&b_pbHasGpsTime);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasHeaderInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasHeaderInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasHeaderInfo.get_HasGpsTime() returned %ld", (long)hr);
        goto ilasheaderinfo_get_hasgpstime_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pbHasGpsTime = ((b_pbHasGpsTime == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto ilasheaderinfo_get_hasgpstime_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pbHasGpsTime);
    goto ilasheaderinfo_get_hasgpstime_method_cleanup;

    ilasheaderinfo_get_hasgpstime_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pbHasGpsTime
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasHeaderInfo.get_HasGpsTime");
    return return_tuple;
}

static PyObject*
ILasHeaderInfoMethod_get_IsStandardGpsTime(PyILasHeaderInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pbIsAStandard = VARIANT_FALSE;
    PyObject* pyvar_pbIsAStandard = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pbIsAStandard

    // Call method on actual COM interface
    hr = self->m_pILasHeaderInfo->get_IsStandardGpsTime(&b_pbIsAStandard);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasHeaderInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasHeaderInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasHeaderInfo.get_IsStandardGpsTime() returned %ld", (long)hr);
        goto ilasheaderinfo_get_isstandardgpstime_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pbIsAStandard = ((b_pbIsAStandard == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto ilasheaderinfo_get_isstandardgpstime_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pbIsAStandard);
    goto ilasheaderinfo_get_isstandardgpstime_method_cleanup;

    ilasheaderinfo_get_isstandardgpstime_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pbIsAStandard
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasHeaderInfo.get_IsStandardGpsTime");
    return return_tuple;
}

static PyObject*
ILasHeaderInfoMethod_get_Extent(PyILasHeaderInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IEnvelope* ipppExt = NULL;
    PyObject* py_ppExt = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppExt

    // Call method on actual COM interface
    hr = self->m_pILasHeaderInfo->get_Extent(&ipppExt);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasHeaderInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasHeaderInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasHeaderInfo.get_Extent() returned %ld", (long)hr);
        goto ilasheaderinfo_get_extent_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppExt);
    if (ipppExt)
    {
        IUnknown* pUnk = NULL;
        ipppExt->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppExt = IUnknownToPythonIIDObject(pUnk, &IID_IEnvelope);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppExt)
    {
        if (py_ppExt)
           Py_DECREF(py_ppExt);
        py_ppExt = Py_None;
        Py_INCREF(py_ppExt);
    }
    if (PyErr_Occurred())
      goto ilasheaderinfo_get_extent_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppExt);
    goto ilasheaderinfo_get_extent_method_cleanup;

    ilasheaderinfo_get_extent_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppExt);
    if (ipppExt)
      ipppExt->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasHeaderInfo.get_Extent");
    return return_tuple;
}

static PyObject*
ILasHeaderInfoMethod_get_SpatialReference(PyILasHeaderInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ISpatialReference* ipppSpatialReference = NULL;
    PyObject* py_ppSpatialReference = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppSpatialReference

    // Call method on actual COM interface
    hr = self->m_pILasHeaderInfo->get_SpatialReference(&ipppSpatialReference);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasHeaderInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasHeaderInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasHeaderInfo.get_SpatialReference() returned %ld", (long)hr);
        goto ilasheaderinfo_get_spatialreference_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppSpatialReference);
    if (ipppSpatialReference)
    {
        IUnknown* pUnk = NULL;
        ipppSpatialReference->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppSpatialReference = IUnknownToPythonIIDObject(pUnk, &IID_ISpatialReference);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppSpatialReference)
    {
        if (py_ppSpatialReference)
           Py_DECREF(py_ppSpatialReference);
        py_ppSpatialReference = Py_None;
        Py_INCREF(py_ppSpatialReference);
    }
    if (PyErr_Occurred())
      goto ilasheaderinfo_get_spatialreference_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppSpatialReference);
    goto ilasheaderinfo_get_spatialreference_method_cleanup;

    ilasheaderinfo_get_spatialreference_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppSpatialReference);
    if (ipppSpatialReference)
      ipppSpatialReference->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasHeaderInfo.get_SpatialReference");
    return return_tuple;
}

static PyObject*
ILasHeaderInfoMethod_GetOffsets(PyILasHeaderInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dpOffsetX = 0;
    double dpOffsetY = 0;
    double dpOffsetZ = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pOffsetX
    // No setup for pOffsetY
    // No setup for pOffsetZ

    // Call method on actual COM interface
    hr = self->m_pILasHeaderInfo->GetOffsets(&dpOffsetX, &dpOffsetY, &dpOffsetZ);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasHeaderInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasHeaderInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasHeaderInfo.GetOffsets() returned %ld", (long)hr);
        goto ilasheaderinfo_getoffsets_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pOffsetX
    // No teardown for pOffsetY
    // No teardown for pOffsetZ

    // Initialize output tuple
    return_tuple = Py_BuildValue("ddd",
                                            dpOffsetX, dpOffsetY, dpOffsetZ);
    goto ilasheaderinfo_getoffsets_method_cleanup;

    ilasheaderinfo_getoffsets_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pOffsetX
    // No cleanup for pOffsetY
    // No cleanup for pOffsetZ
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasHeaderInfo.GetOffsets");
    return return_tuple;
}

static PyObject*
ILasHeaderInfoMethod_GetScaleFactors(PyILasHeaderInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dpFactorX = 0;
    double dpFactorY = 0;
    double dpFactorZ = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pFactorX
    // No setup for pFactorY
    // No setup for pFactorZ

    // Call method on actual COM interface
    hr = self->m_pILasHeaderInfo->GetScaleFactors(&dpFactorX, &dpFactorY, &dpFactorZ);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasHeaderInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasHeaderInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasHeaderInfo.GetScaleFactors() returned %ld", (long)hr);
        goto ilasheaderinfo_getscalefactors_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pFactorX
    // No teardown for pFactorY
    // No teardown for pFactorZ

    // Initialize output tuple
    return_tuple = Py_BuildValue("ddd",
                                            dpFactorX, dpFactorY, dpFactorZ);
    goto ilasheaderinfo_getscalefactors_method_cleanup;

    ilasheaderinfo_getscalefactors_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pFactorX
    // No cleanup for pFactorY
    // No cleanup for pFactorZ
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasHeaderInfo.GetScaleFactors");
    return return_tuple;
}

static PyObject*
ILasHeaderInfoMethod_get_NumberOfVariableLengthRecords(PyILasHeaderInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dpcRecords = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pcRecords

    // Call method on actual COM interface
    hr = self->m_pILasHeaderInfo->get_NumberOfVariableLengthRecords(&dpcRecords);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasHeaderInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasHeaderInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasHeaderInfo.get_NumberOfVariableLengthRecords() returned %ld", (long)hr);
        goto ilasheaderinfo_get_numberofvariablelengthrecords_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pcRecords

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dpcRecords);
    goto ilasheaderinfo_get_numberofvariablelengthrecords_method_cleanup;

    ilasheaderinfo_get_numberofvariablelengthrecords_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pcRecords
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasHeaderInfo.get_NumberOfVariableLengthRecords");
    return return_tuple;
}

static PyObject*
ILasHeaderInfoMethod_GetVariableLengthRecords(PyILasHeaderInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IStringArray* ipppUserIDs = NULL;
    PyObject* py_ppUserIDs = NULL;
    ILongArray* iprecordIDs = NULL;
    PyObject* py_recordIDs = NULL;
    IDoubleArray* ipppRecordLengths = NULL;
    PyObject* py_ppRecordLengths = NULL;
    IStringArray* ipppDescriptions = NULL;
    PyObject* py_ppDescriptions = NULL;
    VARIANT_BOOL b_pbOverLimit = VARIANT_FALSE;
    PyObject* pyvar_pbOverLimit = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppUserIDs
    // No setup for recordIDs
    // No setup for ppRecordLengths
    // No setup for ppDescriptions
    // No setup for pbOverLimit

    // Call method on actual COM interface
    hr = self->m_pILasHeaderInfo->GetVariableLengthRecords(&ipppUserIDs, &iprecordIDs, &ipppRecordLengths, &ipppDescriptions, &b_pbOverLimit);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasHeaderInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasHeaderInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasHeaderInfo.GetVariableLengthRecords() returned %ld", (long)hr);
        goto ilasheaderinfo_getvariablelengthrecords_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppUserIDs);
    if (ipppUserIDs)
    {
        IUnknown* pUnk = NULL;
        ipppUserIDs->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppUserIDs = IUnknownToPythonIIDObject(pUnk, &IID_IStringArray);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppUserIDs)
    {
        if (py_ppUserIDs)
           Py_DECREF(py_ppUserIDs);
        py_ppUserIDs = Py_None;
        Py_INCREF(py_ppUserIDs);
    }
    if (PyErr_Occurred())
      goto ilasheaderinfo_getvariablelengthrecords_method_cleanup;
    
    Py_XDECREF(py_recordIDs);
    if (iprecordIDs)
    {
        IUnknown* pUnk = NULL;
        iprecordIDs->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_recordIDs = IUnknownToPythonIIDObject(pUnk, &IID_ILongArray);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_recordIDs)
    {
        if (py_recordIDs)
           Py_DECREF(py_recordIDs);
        py_recordIDs = Py_None;
        Py_INCREF(py_recordIDs);
    }
    if (PyErr_Occurred())
      goto ilasheaderinfo_getvariablelengthrecords_method_cleanup;
    
    Py_XDECREF(py_ppRecordLengths);
    if (ipppRecordLengths)
    {
        IUnknown* pUnk = NULL;
        ipppRecordLengths->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppRecordLengths = IUnknownToPythonIIDObject(pUnk, &IID_IDoubleArray);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppRecordLengths)
    {
        if (py_ppRecordLengths)
           Py_DECREF(py_ppRecordLengths);
        py_ppRecordLengths = Py_None;
        Py_INCREF(py_ppRecordLengths);
    }
    if (PyErr_Occurred())
      goto ilasheaderinfo_getvariablelengthrecords_method_cleanup;
    
    Py_XDECREF(py_ppDescriptions);
    if (ipppDescriptions)
    {
        IUnknown* pUnk = NULL;
        ipppDescriptions->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppDescriptions = IUnknownToPythonIIDObject(pUnk, &IID_IStringArray);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppDescriptions)
    {
        if (py_ppDescriptions)
           Py_DECREF(py_ppDescriptions);
        py_ppDescriptions = Py_None;
        Py_INCREF(py_ppDescriptions);
    }
    if (PyErr_Occurred())
      goto ilasheaderinfo_getvariablelengthrecords_method_cleanup;
    
    pyvar_pbOverLimit = ((b_pbOverLimit == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto ilasheaderinfo_getvariablelengthrecords_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("OOOOO",
                                            py_ppUserIDs, py_recordIDs, py_ppRecordLengths, py_ppDescriptions, pyvar_pbOverLimit);
    goto ilasheaderinfo_getvariablelengthrecords_method_cleanup;

    ilasheaderinfo_getvariablelengthrecords_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppUserIDs);
    if (ipppUserIDs)
      ipppUserIDs->Release();
    Py_XDECREF(py_recordIDs);
    if (iprecordIDs)
      iprecordIDs->Release();
    Py_XDECREF(py_ppRecordLengths);
    if (ipppRecordLengths)
      ipppRecordLengths->Release();
    Py_XDECREF(py_ppDescriptions);
    if (ipppDescriptions)
      ipppDescriptions->Release();
    // No cleanup for pbOverLimit
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasHeaderInfo.GetVariableLengthRecords");
    return return_tuple;
}


PyMethodDef PyILasHeaderInfoMethods[] = {
    {"supports", (PyCFunction)PyILasHeaderInfo_SupportsInterface, METH_O, ""},
    {"GetVersion", (PyCFunction)ILasHeaderInfoMethod_GetVersion, METH_VARARGS, ""},
    {"get_PointDataFormat", (PyCFunction)ILasHeaderInfoMethod_get_PointDataFormat, METH_VARARGS, ""},
    {"get_SystemID", (PyCFunction)ILasHeaderInfoMethod_get_SystemID, METH_VARARGS, ""},
    {"get_GeneratingSoftware", (PyCFunction)ILasHeaderInfoMethod_get_GeneratingSoftware, METH_VARARGS, ""},
    {"get_FlightDateJulian", (PyCFunction)ILasHeaderInfoMethod_get_FlightDateJulian, METH_VARARGS, ""},
    {"get_Year", (PyCFunction)ILasHeaderInfoMethod_get_Year, METH_VARARGS, ""},
    {"get_NumberOfPointRecords", (PyCFunction)ILasHeaderInfoMethod_get_NumberOfPointRecords, METH_VARARGS, ""},
    {"GetNumberOfPointsByReturn", (PyCFunction)ILasHeaderInfoMethod_GetNumberOfPointsByReturn, METH_VARARGS, ""},
    {"get_ProjectID", (PyCFunction)ILasHeaderInfoMethod_get_ProjectID, METH_VARARGS, ""},
    {"get_FileSourceID", (PyCFunction)ILasHeaderInfoMethod_get_FileSourceID, METH_VARARGS, ""},
    {"get_HasRGB", (PyCFunction)ILasHeaderInfoMethod_get_HasRGB, METH_VARARGS, ""},
    {"get_HasGpsTime", (PyCFunction)ILasHeaderInfoMethod_get_HasGpsTime, METH_VARARGS, ""},
    {"get_IsStandardGpsTime", (PyCFunction)ILasHeaderInfoMethod_get_IsStandardGpsTime, METH_VARARGS, ""},
    {"get_Extent", (PyCFunction)ILasHeaderInfoMethod_get_Extent, METH_VARARGS, ""},
    {"get_SpatialReference", (PyCFunction)ILasHeaderInfoMethod_get_SpatialReference, METH_VARARGS, ""},
    {"GetOffsets", (PyCFunction)ILasHeaderInfoMethod_GetOffsets, METH_VARARGS, ""},
    {"GetScaleFactors", (PyCFunction)ILasHeaderInfoMethod_GetScaleFactors, METH_VARARGS, ""},
    {"get_NumberOfVariableLengthRecords", (PyCFunction)ILasHeaderInfoMethod_get_NumberOfVariableLengthRecords, METH_VARARGS, ""},
    {"GetVariableLengthRecords", (PyCFunction)ILasHeaderInfoMethod_GetVariableLengthRecords, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyILasHeaderInfoGetSet[] = {
  {"_pUnk", (getter)PyILasHeaderInfo_GetpUnk, NULL, "Get opaque pointer to an Unknown from ILasHeaderInfo", NULL},
  {"_pointer", (getter)PyILasHeaderInfo_GetPointer, NULL, "Get memory address for ILasHeaderInfo", NULL},
  {"_IID", (getter)PyILasHeaderInfo_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyILasHeaderInfo_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyILasHeaderInfo_GetIgnoreFailures, (setter)PyILasHeaderInfo_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyILasHeaderInfoObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.ILasHeaderInfoObject",                          
                                              /* tp_name */
  sizeof(PyILasHeaderInfoObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyILasHeaderInfoObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyILasHeaderInfoMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyILasHeaderInfoGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyILasHeaderInfoObject_new,                      
                                              /* tp_new */
};

// Interface ILasFile

typedef struct PyILasFileObject {
    PyObject_HEAD
    ILasFile* m_pILasFile;
    HRESULT m_HR;
    int m_ignore_failures;
} PyILasFileObject;

static PyObject*
PyILasFileObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyILasFileObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ILasFile* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ILasFile, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ILasFile with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyILasFileObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ILasFile");
            return NULL;
        }
        self->m_pILasFile = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ILasFile");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ILasFile");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ILasFile* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ILasFile, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ILasFile");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyILasFileObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ILasFile");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pILasFile = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyILasFileObject_dealloc(PyILasFileObject* self)
{
    if (self->m_pILasFile)
        self->m_pILasFile->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyILasFile_GetpUnk(PyILasFileObject* self)
{
    if (!self->m_pILasFile)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pILasFile->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ILasFile to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyILasFile_GetPointer(PyILasFileObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pILasFile);
}

static PyObject*
PyILasFile_GetIID(PyILasFileObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "36ccbfd3-8a6c-4c11-8551-96ae8629aad9");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyILasFile_GetHR(PyILasFileObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyILasFile_GetIgnoreFailures(PyILasFileObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyILasFile_SetIgnoreFailures(PyILasFileObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyILasFile_SupportsInterface(PyILasFileObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pILasFile->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ILasFileMethod_get_Name(PyILasFileObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspName;
    PyObject* pyvar_pName = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pName

    // Call method on actual COM interface
    hr = self->m_pILasFile->get_Name(&bspName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasFile->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasFile) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasFile.get_Name() returned %ld", (long)hr);
        goto ilasfile_get_name_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pName = PyUnicode_FromWideChar(bspName,::SysStringLen(bspName));
    ::SysFreeString(bspName);
    
    if (PyErr_Occurred())
      goto ilasfile_get_name_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pName);
    goto ilasfile_get_name_method_cleanup;

    ilasfile_get_name_method_cleanup:
    self->m_HR = hr;
    if (pyvar_pName != Py_None)
        Py_XDECREF(pyvar_pName);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasFile.get_Name");
    return return_tuple;
}

static PyObject*
ILasFileMethod_GetVersion(PyILasFileObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpMajor = 0;
    long lpMinor = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pMajor
    // No setup for pMinor

    // Call method on actual COM interface
    hr = self->m_pILasFile->GetVersion(&lpMajor, &lpMinor);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasFile->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasFile) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasFile.GetVersion() returned %ld", (long)hr);
        goto ilasfile_getversion_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pMajor
    // No teardown for pMinor

    // Initialize output tuple
    return_tuple = Py_BuildValue("ll",
                                            lpMajor, lpMinor);
    goto ilasfile_getversion_method_cleanup;

    ilasfile_getversion_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pMajor
    // No cleanup for pMinor
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasFile.GetVersion");
    return return_tuple;
}

static PyObject*
ILasFileMethod_get_PointDataFormat(PyILasFileObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpFormat = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pFormat

    // Call method on actual COM interface
    hr = self->m_pILasFile->get_PointDataFormat(&lpFormat);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasFile->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasFile) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasFile.get_PointDataFormat() returned %ld", (long)hr);
        goto ilasfile_get_pointdataformat_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pFormat

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpFormat);
    goto ilasfile_get_pointdataformat_method_cleanup;

    ilasfile_get_pointdataformat_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pFormat
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasFile.get_PointDataFormat");
    return return_tuple;
}

static PyObject*
ILasFileMethod_get_NumberOfPointRecords(PyILasFileObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dpcRecords = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pcRecords

    // Call method on actual COM interface
    hr = self->m_pILasFile->get_NumberOfPointRecords(&dpcRecords);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasFile->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasFile) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasFile.get_NumberOfPointRecords() returned %ld", (long)hr);
        goto ilasfile_get_numberofpointrecords_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pcRecords

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dpcRecords);
    goto ilasfile_get_numberofpointrecords_method_cleanup;

    ilasfile_get_numberofpointrecords_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pcRecords
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasFile.get_NumberOfPointRecords");
    return return_tuple;
}

static PyObject*
ILasFileMethod_GetNumberOfPointsByReturn(PyILasFileObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lReturnNumber = 0;
    double dpcPoints = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lReturnNumber))
      goto ilasfile_getnumberofpointsbyreturn_method_cleanup;

    // Set up initial variable values as needed
    // No setup for ReturnNumber
    // No setup for pcPoints

    // Call method on actual COM interface
    hr = self->m_pILasFile->GetNumberOfPointsByReturn(lReturnNumber, &dpcPoints);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasFile->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasFile) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasFile.GetNumberOfPointsByReturn() returned %ld", (long)hr);
        goto ilasfile_getnumberofpointsbyreturn_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ReturnNumber
    // No teardown for pcPoints

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dpcPoints);
    goto ilasfile_getnumberofpointsbyreturn_method_cleanup;

    ilasfile_getnumberofpointsbyreturn_method_cleanup:
    self->m_HR = hr;
    // No cleanup for ReturnNumber
    // No cleanup for pcPoints
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasFile.GetNumberOfPointsByReturn");
    return return_tuple;
}

static PyObject*
ILasFileMethod_get_SizeInBytes(PyILasFileObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dpcBytes = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pcBytes

    // Call method on actual COM interface
    hr = self->m_pILasFile->get_SizeInBytes(&dpcBytes);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasFile->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasFile) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasFile.get_SizeInBytes() returned %ld", (long)hr);
        goto ilasfile_get_sizeinbytes_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pcBytes

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dpcBytes);
    goto ilasfile_get_sizeinbytes_method_cleanup;

    ilasfile_get_sizeinbytes_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pcBytes
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasFile.get_SizeInBytes");
    return return_tuple;
}

static PyObject*
ILasFileMethod_get_HasRGB(PyILasFileObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pbHasRGB = VARIANT_FALSE;
    PyObject* pyvar_pbHasRGB = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pbHasRGB

    // Call method on actual COM interface
    hr = self->m_pILasFile->get_HasRGB(&b_pbHasRGB);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasFile->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasFile) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasFile.get_HasRGB() returned %ld", (long)hr);
        goto ilasfile_get_hasrgb_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pbHasRGB = ((b_pbHasRGB == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto ilasfile_get_hasrgb_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pbHasRGB);
    goto ilasfile_get_hasrgb_method_cleanup;

    ilasfile_get_hasrgb_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pbHasRGB
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasFile.get_HasRGB");
    return return_tuple;
}

static PyObject*
ILasFileMethod_get_HasGpsTime(PyILasFileObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pbHasGpsTime = VARIANT_FALSE;
    PyObject* pyvar_pbHasGpsTime = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pbHasGpsTime

    // Call method on actual COM interface
    hr = self->m_pILasFile->get_HasGpsTime(&b_pbHasGpsTime);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasFile->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasFile) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasFile.get_HasGpsTime() returned %ld", (long)hr);
        goto ilasfile_get_hasgpstime_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pbHasGpsTime = ((b_pbHasGpsTime == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto ilasfile_get_hasgpstime_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pbHasGpsTime);
    goto ilasfile_get_hasgpstime_method_cleanup;

    ilasfile_get_hasgpstime_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pbHasGpsTime
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasFile.get_HasGpsTime");
    return return_tuple;
}

static PyObject*
ILasFileMethod_get_IsStandardGpsTime(PyILasFileObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pbIsAStandard = VARIANT_FALSE;
    PyObject* pyvar_pbIsAStandard = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pbIsAStandard

    // Call method on actual COM interface
    hr = self->m_pILasFile->get_IsStandardGpsTime(&b_pbIsAStandard);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasFile->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasFile) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasFile.get_IsStandardGpsTime() returned %ld", (long)hr);
        goto ilasfile_get_isstandardgpstime_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pbIsAStandard = ((b_pbIsAStandard == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto ilasfile_get_isstandardgpstime_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pbIsAStandard);
    goto ilasfile_get_isstandardgpstime_method_cleanup;

    ilasfile_get_isstandardgpstime_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pbIsAStandard
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasFile.get_IsStandardGpsTime");
    return return_tuple;
}

static PyObject*
ILasFileMethod_get_Extent(PyILasFileObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IEnvelope* ipppExt = NULL;
    PyObject* py_ppExt = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppExt

    // Call method on actual COM interface
    hr = self->m_pILasFile->get_Extent(&ipppExt);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasFile->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasFile) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasFile.get_Extent() returned %ld", (long)hr);
        goto ilasfile_get_extent_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppExt);
    if (ipppExt)
    {
        IUnknown* pUnk = NULL;
        ipppExt->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppExt = IUnknownToPythonIIDObject(pUnk, &IID_IEnvelope);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppExt)
    {
        if (py_ppExt)
           Py_DECREF(py_ppExt);
        py_ppExt = Py_None;
        Py_INCREF(py_ppExt);
    }
    if (PyErr_Occurred())
      goto ilasfile_get_extent_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppExt);
    goto ilasfile_get_extent_method_cleanup;

    ilasfile_get_extent_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppExt);
    if (ipppExt)
      ipppExt->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasFile.get_Extent");
    return return_tuple;
}

static PyObject*
ILasFileMethod_get_SpatialReference(PyILasFileObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ISpatialReference* ipppSpatialReference = NULL;
    PyObject* py_ppSpatialReference = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppSpatialReference

    // Call method on actual COM interface
    hr = self->m_pILasFile->get_SpatialReference(&ipppSpatialReference);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasFile->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasFile) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasFile.get_SpatialReference() returned %ld", (long)hr);
        goto ilasfile_get_spatialreference_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppSpatialReference);
    if (ipppSpatialReference)
    {
        IUnknown* pUnk = NULL;
        ipppSpatialReference->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppSpatialReference = IUnknownToPythonIIDObject(pUnk, &IID_ISpatialReference);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppSpatialReference)
    {
        if (py_ppSpatialReference)
           Py_DECREF(py_ppSpatialReference);
        py_ppSpatialReference = Py_None;
        Py_INCREF(py_ppSpatialReference);
    }
    if (PyErr_Occurred())
      goto ilasfile_get_spatialreference_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppSpatialReference);
    goto ilasfile_get_spatialreference_method_cleanup;

    ilasfile_get_spatialreference_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppSpatialReference);
    if (ipppSpatialReference)
      ipppSpatialReference->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasFile.get_SpatialReference");
    return return_tuple;
}

static PyObject*
ILasFileMethod_get_NativeSpatialReference(PyILasFileObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ISpatialReference* ipppSpatialReference = NULL;
    PyObject* py_ppSpatialReference = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppSpatialReference

    // Call method on actual COM interface
    hr = self->m_pILasFile->get_NativeSpatialReference(&ipppSpatialReference);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasFile->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasFile) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasFile.get_NativeSpatialReference() returned %ld", (long)hr);
        goto ilasfile_get_nativespatialreference_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppSpatialReference);
    if (ipppSpatialReference)
    {
        IUnknown* pUnk = NULL;
        ipppSpatialReference->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppSpatialReference = IUnknownToPythonIIDObject(pUnk, &IID_ISpatialReference);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppSpatialReference)
    {
        if (py_ppSpatialReference)
           Py_DECREF(py_ppSpatialReference);
        py_ppSpatialReference = Py_None;
        Py_INCREF(py_ppSpatialReference);
    }
    if (PyErr_Occurred())
      goto ilasfile_get_nativespatialreference_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppSpatialReference);
    goto ilasfile_get_nativespatialreference_method_cleanup;

    ilasfile_get_nativespatialreference_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppSpatialReference);
    if (ipppSpatialReference)
      ipppSpatialReference->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasFile.get_NativeSpatialReference");
    return return_tuple;
}

static PyObject*
ILasFileMethod_get_IsFileMissing(PyILasFileObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pbIsMissing = VARIANT_FALSE;
    PyObject* pyvar_pbIsMissing = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pbIsMissing

    // Call method on actual COM interface
    hr = self->m_pILasFile->get_IsFileMissing(&b_pbIsMissing);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasFile->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasFile) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasFile.get_IsFileMissing() returned %ld", (long)hr);
        goto ilasfile_get_isfilemissing_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pbIsMissing = ((b_pbIsMissing == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto ilasfile_get_isfilemissing_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pbIsMissing);
    goto ilasfile_get_isfilemissing_method_cleanup;

    ilasfile_get_isfilemissing_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pbIsMissing
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasFile.get_IsFileMissing");
    return return_tuple;
}

static PyObject*
ILasFileMethod_get_IsFileValid(PyILasFileObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pbIsValid = VARIANT_FALSE;
    PyObject* pyvar_pbIsValid = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pbIsValid

    // Call method on actual COM interface
    hr = self->m_pILasFile->get_IsFileValid(&b_pbIsValid);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasFile->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasFile) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasFile.get_IsFileValid() returned %ld", (long)hr);
        goto ilasfile_get_isfilevalid_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pbIsValid = ((b_pbIsValid == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto ilasfile_get_isfilevalid_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pbIsValid);
    goto ilasfile_get_isfilevalid_method_cleanup;

    ilasfile_get_isfilevalid_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pbIsValid
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasFile.get_IsFileValid");
    return return_tuple;
}

static PyObject*
ILasFileMethod_get_HasPrjFile(PyILasFileObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pbHasPRJ = VARIANT_FALSE;
    PyObject* pyvar_pbHasPRJ = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pbHasPRJ

    // Call method on actual COM interface
    hr = self->m_pILasFile->get_HasPrjFile(&b_pbHasPRJ);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasFile->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasFile) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasFile.get_HasPrjFile() returned %ld", (long)hr);
        goto ilasfile_get_hasprjfile_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pbHasPRJ = ((b_pbHasPRJ == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto ilasfile_get_hasprjfile_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pbHasPRJ);
    goto ilasfile_get_hasprjfile_method_cleanup;

    ilasfile_get_hasprjfile_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pbHasPRJ
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasFile.get_HasPrjFile");
    return return_tuple;
}

static PyObject*
ILasFileMethod_get_HasStatistics(PyILasFileObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pbHasStats = VARIANT_FALSE;
    PyObject* pyvar_pbHasStats = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pbHasStats

    // Call method on actual COM interface
    hr = self->m_pILasFile->get_HasStatistics(&b_pbHasStats);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasFile->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasFile) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasFile.get_HasStatistics() returned %ld", (long)hr);
        goto ilasfile_get_hasstatistics_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pbHasStats = ((b_pbHasStats == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto ilasfile_get_hasstatistics_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pbHasStats);
    goto ilasfile_get_hasstatistics_method_cleanup;

    ilasfile_get_hasstatistics_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pbHasStats
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasFile.get_HasStatistics");
    return return_tuple;
}

static PyObject*
ILasFileMethod_get_NeedsUpdateStatistics(PyILasFileObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pbNeedsUpdate = VARIANT_FALSE;
    PyObject* pyvar_pbNeedsUpdate = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pbNeedsUpdate

    // Call method on actual COM interface
    hr = self->m_pILasFile->get_NeedsUpdateStatistics(&b_pbNeedsUpdate);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasFile->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasFile) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasFile.get_NeedsUpdateStatistics() returned %ld", (long)hr);
        goto ilasfile_get_needsupdatestatistics_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pbNeedsUpdate = ((b_pbNeedsUpdate == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto ilasfile_get_needsupdatestatistics_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pbNeedsUpdate);
    goto ilasfile_get_needsupdatestatistics_method_cleanup;

    ilasfile_get_needsupdatestatistics_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pbNeedsUpdate
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasFile.get_NeedsUpdateStatistics");
    return return_tuple;
}

static PyObject*
ILasFileMethod_GetStatistics(PyILasFileObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ILasStatistics* ipppStatistics = NULL;
    PyObject* py_ppStatistics = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppStatistics

    // Call method on actual COM interface
    hr = self->m_pILasFile->GetStatistics(&ipppStatistics);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasFile->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasFile) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasFile.GetStatistics() returned %ld", (long)hr);
        goto ilasfile_getstatistics_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppStatistics);
    if (ipppStatistics)
    {
        IUnknown* pUnk = NULL;
        ipppStatistics->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppStatistics = IUnknownToPythonIIDObject(pUnk, &IID_ILasStatistics);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppStatistics)
    {
        if (py_ppStatistics)
           Py_DECREF(py_ppStatistics);
        py_ppStatistics = Py_None;
        Py_INCREF(py_ppStatistics);
    }
    if (PyErr_Occurred())
      goto ilasfile_getstatistics_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppStatistics);
    goto ilasfile_getstatistics_method_cleanup;

    ilasfile_getstatistics_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppStatistics);
    if (ipppStatistics)
      ipppStatistics->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasFile.GetStatistics");
    return return_tuple;
}

static PyObject*
ILasFileMethod_GetHeaderInfo(PyILasFileObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ILasHeaderInfo* ipppHeaderInfo = NULL;
    PyObject* py_ppHeaderInfo = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppHeaderInfo

    // Call method on actual COM interface
    hr = self->m_pILasFile->GetHeaderInfo(&ipppHeaderInfo);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasFile->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasFile) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasFile.GetHeaderInfo() returned %ld", (long)hr);
        goto ilasfile_getheaderinfo_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppHeaderInfo);
    if (ipppHeaderInfo)
    {
        IUnknown* pUnk = NULL;
        ipppHeaderInfo->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppHeaderInfo = IUnknownToPythonIIDObject(pUnk, &IID_ILasHeaderInfo);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppHeaderInfo)
    {
        if (py_ppHeaderInfo)
           Py_DECREF(py_ppHeaderInfo);
        py_ppHeaderInfo = Py_None;
        Py_INCREF(py_ppHeaderInfo);
    }
    if (PyErr_Occurred())
      goto ilasfile_getheaderinfo_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppHeaderInfo);
    goto ilasfile_getheaderinfo_method_cleanup;

    ilasfile_getheaderinfo_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppHeaderInfo);
    if (ipppHeaderInfo)
      ipppHeaderInfo->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasFile.GetHeaderInfo");
    return return_tuple;
}

static PyObject*
ILasFileMethod_EstimatePointSpacing(PyILasFileObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_bUseStatistics = VARIANT_FALSE;
    PyObject* pyvar_bUseStatistics = NULL;
    double dpSpacing = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_bUseStatistics))
      goto ilasfile_estimatepointspacing_method_cleanup;

    // Set up initial variable values as needed
    b_bUseStatistics = ((PyObject_IsTrue(pyvar_bUseStatistics) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto ilasfile_estimatepointspacing_method_cleanup;
    
    // No setup for pSpacing

    // Call method on actual COM interface
    hr = self->m_pILasFile->EstimatePointSpacing(b_bUseStatistics, &dpSpacing);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasFile->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasFile) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasFile.EstimatePointSpacing() returned %ld", (long)hr);
        goto ilasfile_estimatepointspacing_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for bUseStatistics
    // No teardown for pSpacing

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dpSpacing);
    goto ilasfile_estimatepointspacing_method_cleanup;

    ilasfile_estimatepointspacing_method_cleanup:
    self->m_HR = hr;
    // No cleanup for bUseStatistics
    // No cleanup for pSpacing
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasFile.EstimatePointSpacing");
    return return_tuple;
}

static PyObject*
ILasFileMethod_EstimatePointCount(PyILasFileObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IGeometry* ippAOI = NULL;
    PyObject* py_pAOI;
    double dpcPoints = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_pAOI))
      goto ilasfile_estimatepointcount_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pAOI, &IID_IGeometry, (void**)&ippAOI))
        PyErr_SetString(PyExc_TypeError, "Argument pAOI (position 0) is not IGeometry");
    
    if (PyErr_Occurred())
      goto ilasfile_estimatepointcount_method_cleanup;
    
    // No setup for pcPoints

    // Call method on actual COM interface
    hr = self->m_pILasFile->EstimatePointCount(ippAOI, &dpcPoints);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasFile->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasFile) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasFile.EstimatePointCount() returned %ld", (long)hr);
        goto ilasfile_estimatepointcount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pAOI
    // No teardown for pcPoints

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dpcPoints);
    goto ilasfile_estimatepointcount_method_cleanup;

    ilasfile_estimatepointcount_method_cleanup:
    self->m_HR = hr;
    if (ippAOI)
      ippAOI->Release();
    // No cleanup for pcPoints
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasFile.EstimatePointCount");
    return return_tuple;
}


PyMethodDef PyILasFileMethods[] = {
    {"supports", (PyCFunction)PyILasFile_SupportsInterface, METH_O, ""},
    {"get_Name", (PyCFunction)ILasFileMethod_get_Name, METH_VARARGS, ""},
    {"GetVersion", (PyCFunction)ILasFileMethod_GetVersion, METH_VARARGS, ""},
    {"get_PointDataFormat", (PyCFunction)ILasFileMethod_get_PointDataFormat, METH_VARARGS, ""},
    {"get_NumberOfPointRecords", (PyCFunction)ILasFileMethod_get_NumberOfPointRecords, METH_VARARGS, ""},
    {"GetNumberOfPointsByReturn", (PyCFunction)ILasFileMethod_GetNumberOfPointsByReturn, METH_VARARGS, ""},
    {"get_SizeInBytes", (PyCFunction)ILasFileMethod_get_SizeInBytes, METH_VARARGS, ""},
    {"get_HasRGB", (PyCFunction)ILasFileMethod_get_HasRGB, METH_VARARGS, ""},
    {"get_HasGpsTime", (PyCFunction)ILasFileMethod_get_HasGpsTime, METH_VARARGS, ""},
    {"get_IsStandardGpsTime", (PyCFunction)ILasFileMethod_get_IsStandardGpsTime, METH_VARARGS, ""},
    {"get_Extent", (PyCFunction)ILasFileMethod_get_Extent, METH_VARARGS, ""},
    {"get_SpatialReference", (PyCFunction)ILasFileMethod_get_SpatialReference, METH_VARARGS, ""},
    {"get_NativeSpatialReference", (PyCFunction)ILasFileMethod_get_NativeSpatialReference, METH_VARARGS, ""},
    {"get_IsFileMissing", (PyCFunction)ILasFileMethod_get_IsFileMissing, METH_VARARGS, ""},
    {"get_IsFileValid", (PyCFunction)ILasFileMethod_get_IsFileValid, METH_VARARGS, ""},
    {"get_HasPrjFile", (PyCFunction)ILasFileMethod_get_HasPrjFile, METH_VARARGS, ""},
    {"get_HasStatistics", (PyCFunction)ILasFileMethod_get_HasStatistics, METH_VARARGS, ""},
    {"get_NeedsUpdateStatistics", (PyCFunction)ILasFileMethod_get_NeedsUpdateStatistics, METH_VARARGS, ""},
    {"GetStatistics", (PyCFunction)ILasFileMethod_GetStatistics, METH_VARARGS, ""},
    {"GetHeaderInfo", (PyCFunction)ILasFileMethod_GetHeaderInfo, METH_VARARGS, ""},
    {"EstimatePointSpacing", (PyCFunction)ILasFileMethod_EstimatePointSpacing, METH_VARARGS, ""},
    {"EstimatePointCount", (PyCFunction)ILasFileMethod_EstimatePointCount, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyILasFileGetSet[] = {
  {"_pUnk", (getter)PyILasFile_GetpUnk, NULL, "Get opaque pointer to an Unknown from ILasFile", NULL},
  {"_pointer", (getter)PyILasFile_GetPointer, NULL, "Get memory address for ILasFile", NULL},
  {"_IID", (getter)PyILasFile_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyILasFile_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyILasFile_GetIgnoreFailures, (setter)PyILasFile_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyILasFileObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.ILasFileObject",                          
                                              /* tp_name */
  sizeof(PyILasFileObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyILasFileObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyILasFileMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyILasFileGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyILasFileObject_new,                      
                                              /* tp_new */
};

// Interface ILasAttributeFilter

typedef struct PyILasAttributeFilterObject {
    PyObject_HEAD
    ILasAttributeFilter* m_pILasAttributeFilter;
    HRESULT m_HR;
    int m_ignore_failures;
} PyILasAttributeFilterObject;

static PyObject*
PyILasAttributeFilterObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyILasAttributeFilterObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ILasAttributeFilter* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ILasAttributeFilter, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ILasAttributeFilter with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyILasAttributeFilterObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ILasAttributeFilter");
            return NULL;
        }
        self->m_pILasAttributeFilter = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ILasAttributeFilter");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ILasAttributeFilter");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ILasAttributeFilter* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ILasAttributeFilter, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ILasAttributeFilter");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyILasAttributeFilterObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ILasAttributeFilter");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pILasAttributeFilter = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyILasAttributeFilterObject_dealloc(PyILasAttributeFilterObject* self)
{
    if (self->m_pILasAttributeFilter)
        self->m_pILasAttributeFilter->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyILasAttributeFilter_GetpUnk(PyILasAttributeFilterObject* self)
{
    if (!self->m_pILasAttributeFilter)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pILasAttributeFilter->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ILasAttributeFilter to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyILasAttributeFilter_GetPointer(PyILasAttributeFilterObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pILasAttributeFilter);
}

static PyObject*
PyILasAttributeFilter_GetIID(PyILasAttributeFilterObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "2a37e73c-2b6d-4d82-9f32-72a2e268394d");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyILasAttributeFilter_GetHR(PyILasAttributeFilterObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyILasAttributeFilter_GetIgnoreFailures(PyILasAttributeFilterObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyILasAttributeFilter_SetIgnoreFailures(PyILasAttributeFilterObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyILasAttributeFilter_SupportsInterface(PyILasAttributeFilterObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pILasAttributeFilter->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ILasAttributeFilterMethod_put_Returns(PyILasAttributeFilterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ILongArray* ipppReturns = NULL;
    PyObject* py_ppReturns;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_ppReturns))
      goto ilasattributefilter_put_returns_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_ppReturns, &IID_ILongArray, (void**)&ipppReturns))
        PyErr_SetString(PyExc_TypeError, "Argument ppReturns (position 0) is not ILongArray");
    
    if (PyErr_Occurred())
      goto ilasattributefilter_put_returns_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pILasAttributeFilter->put_Returns(ipppReturns);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasAttributeFilter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasAttributeFilter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasAttributeFilter.put_Returns() returned %ld", (long)hr);
        goto ilasattributefilter_put_returns_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ppReturns

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ilasattributefilter_put_returns_method_cleanup;

    ilasattributefilter_put_returns_method_cleanup:
    self->m_HR = hr;
    if (ipppReturns)
      ipppReturns->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasAttributeFilter.put_Returns");
    return return_tuple;
}

static PyObject*
ILasAttributeFilterMethod_get_Returns(PyILasAttributeFilterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ILongArray* ipppReturns = NULL;
    PyObject* py_ppReturns = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppReturns

    // Call method on actual COM interface
    hr = self->m_pILasAttributeFilter->get_Returns(&ipppReturns);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasAttributeFilter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasAttributeFilter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasAttributeFilter.get_Returns() returned %ld", (long)hr);
        goto ilasattributefilter_get_returns_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppReturns);
    if (ipppReturns)
    {
        IUnknown* pUnk = NULL;
        ipppReturns->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppReturns = IUnknownToPythonIIDObject(pUnk, &IID_ILongArray);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppReturns)
    {
        if (py_ppReturns)
           Py_DECREF(py_ppReturns);
        py_ppReturns = Py_None;
        Py_INCREF(py_ppReturns);
    }
    if (PyErr_Occurred())
      goto ilasattributefilter_get_returns_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppReturns);
    goto ilasattributefilter_get_returns_method_cleanup;

    ilasattributefilter_get_returns_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppReturns);
    if (ipppReturns)
      ipppReturns->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasAttributeFilter.get_Returns");
    return return_tuple;
}

static PyObject*
ILasAttributeFilterMethod_put_ClassCodes(PyILasAttributeFilterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ILongArray* ipppCodes = NULL;
    PyObject* py_ppCodes;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_ppCodes))
      goto ilasattributefilter_put_classcodes_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_ppCodes, &IID_ILongArray, (void**)&ipppCodes))
        PyErr_SetString(PyExc_TypeError, "Argument ppCodes (position 0) is not ILongArray");
    
    if (PyErr_Occurred())
      goto ilasattributefilter_put_classcodes_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pILasAttributeFilter->put_ClassCodes(ipppCodes);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasAttributeFilter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasAttributeFilter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasAttributeFilter.put_ClassCodes() returned %ld", (long)hr);
        goto ilasattributefilter_put_classcodes_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ppCodes

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ilasattributefilter_put_classcodes_method_cleanup;

    ilasattributefilter_put_classcodes_method_cleanup:
    self->m_HR = hr;
    if (ipppCodes)
      ipppCodes->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasAttributeFilter.put_ClassCodes");
    return return_tuple;
}

static PyObject*
ILasAttributeFilterMethod_get_ClassCodes(PyILasAttributeFilterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ILongArray* ipppCodes = NULL;
    PyObject* py_ppCodes = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppCodes

    // Call method on actual COM interface
    hr = self->m_pILasAttributeFilter->get_ClassCodes(&ipppCodes);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasAttributeFilter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasAttributeFilter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasAttributeFilter.get_ClassCodes() returned %ld", (long)hr);
        goto ilasattributefilter_get_classcodes_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppCodes);
    if (ipppCodes)
    {
        IUnknown* pUnk = NULL;
        ipppCodes->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppCodes = IUnknownToPythonIIDObject(pUnk, &IID_ILongArray);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppCodes)
    {
        if (py_ppCodes)
           Py_DECREF(py_ppCodes);
        py_ppCodes = Py_None;
        Py_INCREF(py_ppCodes);
    }
    if (PyErr_Occurred())
      goto ilasattributefilter_get_classcodes_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppCodes);
    goto ilasattributefilter_get_classcodes_method_cleanup;

    ilasattributefilter_get_classcodes_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppCodes);
    if (ipppCodes)
      ipppCodes->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasAttributeFilter.get_ClassCodes");
    return return_tuple;
}

static PyObject*
ILasAttributeFilterMethod_put_ClassFlags(PyILasAttributeFilterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpFlags = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lpFlags))
      goto ilasattributefilter_put_classflags_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pFlags

    // Call method on actual COM interface
    hr = self->m_pILasAttributeFilter->put_ClassFlags(lpFlags);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasAttributeFilter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasAttributeFilter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasAttributeFilter.put_ClassFlags() returned %ld", (long)hr);
        goto ilasattributefilter_put_classflags_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pFlags

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ilasattributefilter_put_classflags_method_cleanup;

    ilasattributefilter_put_classflags_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pFlags
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasAttributeFilter.put_ClassFlags");
    return return_tuple;
}

static PyObject*
ILasAttributeFilterMethod_get_ClassFlags(PyILasAttributeFilterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpFlags = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pFlags

    // Call method on actual COM interface
    hr = self->m_pILasAttributeFilter->get_ClassFlags(&lpFlags);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasAttributeFilter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasAttributeFilter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasAttributeFilter.get_ClassFlags() returned %ld", (long)hr);
        goto ilasattributefilter_get_classflags_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pFlags

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpFlags);
    goto ilasattributefilter_get_classflags_method_cleanup;

    ilasattributefilter_get_classflags_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pFlags
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasAttributeFilter.get_ClassFlags");
    return return_tuple;
}


PyMethodDef PyILasAttributeFilterMethods[] = {
    {"supports", (PyCFunction)PyILasAttributeFilter_SupportsInterface, METH_O, ""},
    {"put_Returns", (PyCFunction)ILasAttributeFilterMethod_put_Returns, METH_VARARGS, ""},
    {"get_Returns", (PyCFunction)ILasAttributeFilterMethod_get_Returns, METH_VARARGS, ""},
    {"put_ClassCodes", (PyCFunction)ILasAttributeFilterMethod_put_ClassCodes, METH_VARARGS, ""},
    {"get_ClassCodes", (PyCFunction)ILasAttributeFilterMethod_get_ClassCodes, METH_VARARGS, ""},
    {"put_ClassFlags", (PyCFunction)ILasAttributeFilterMethod_put_ClassFlags, METH_VARARGS, ""},
    {"get_ClassFlags", (PyCFunction)ILasAttributeFilterMethod_get_ClassFlags, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyILasAttributeFilterGetSet[] = {
  {"_pUnk", (getter)PyILasAttributeFilter_GetpUnk, NULL, "Get opaque pointer to an Unknown from ILasAttributeFilter", NULL},
  {"_pointer", (getter)PyILasAttributeFilter_GetPointer, NULL, "Get memory address for ILasAttributeFilter", NULL},
  {"_IID", (getter)PyILasAttributeFilter_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyILasAttributeFilter_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyILasAttributeFilter_GetIgnoreFailures, (setter)PyILasAttributeFilter_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyILasAttributeFilterObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.ILasAttributeFilterObject",                          
                                              /* tp_name */
  sizeof(PyILasAttributeFilterObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyILasAttributeFilterObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyILasAttributeFilterMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyILasAttributeFilterGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyILasAttributeFilterObject_new,                      
                                              /* tp_new */
};

// Interface ILasPointFilter

typedef struct PyILasPointFilterObject {
    PyObject_HEAD
    ILasPointFilter* m_pILasPointFilter;
    HRESULT m_HR;
    int m_ignore_failures;
} PyILasPointFilterObject;

static PyObject*
PyILasPointFilterObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyILasPointFilterObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ILasPointFilter* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ILasPointFilter, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ILasPointFilter with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyILasPointFilterObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ILasPointFilter");
            return NULL;
        }
        self->m_pILasPointFilter = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ILasPointFilter");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ILasPointFilter");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ILasPointFilter* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ILasPointFilter, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ILasPointFilter");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyILasPointFilterObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ILasPointFilter");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pILasPointFilter = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyILasPointFilterObject_dealloc(PyILasPointFilterObject* self)
{
    if (self->m_pILasPointFilter)
        self->m_pILasPointFilter->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyILasPointFilter_GetpUnk(PyILasPointFilterObject* self)
{
    if (!self->m_pILasPointFilter)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pILasPointFilter->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ILasPointFilter to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyILasPointFilter_GetPointer(PyILasPointFilterObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pILasPointFilter);
}

static PyObject*
PyILasPointFilter_GetIID(PyILasPointFilterObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "53bc0282-1396-450f-bca9-0c3398550895");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyILasPointFilter_GetHR(PyILasPointFilterObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyILasPointFilter_GetIgnoreFailures(PyILasPointFilterObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyILasPointFilter_SetIgnoreFailures(PyILasPointFilterObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyILasPointFilter_SupportsInterface(PyILasPointFilterObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pILasPointFilter->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ILasPointFilterMethod_putref_AreaOfInterest(PyILasPointFilterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IGeometry* ipppAOI = NULL;
    PyObject* py_ppAOI;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_ppAOI))
      goto ilaspointfilter_putref_areaofinterest_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_ppAOI, &IID_IGeometry, (void**)&ipppAOI))
        PyErr_SetString(PyExc_TypeError, "Argument ppAOI (position 0) is not IGeometry");
    
    if (PyErr_Occurred())
      goto ilaspointfilter_putref_areaofinterest_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pILasPointFilter->putref_AreaOfInterest(ipppAOI);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasPointFilter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasPointFilter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasPointFilter.putref_AreaOfInterest() returned %ld", (long)hr);
        goto ilaspointfilter_putref_areaofinterest_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ppAOI

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ilaspointfilter_putref_areaofinterest_method_cleanup;

    ilaspointfilter_putref_areaofinterest_method_cleanup:
    self->m_HR = hr;
    if (ipppAOI)
      ipppAOI->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasPointFilter.putref_AreaOfInterest");
    return return_tuple;
}

static PyObject*
ILasPointFilterMethod_get_AreaOfInterest(PyILasPointFilterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IGeometry* ipppAOI = NULL;
    PyObject* py_ppAOI = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppAOI

    // Call method on actual COM interface
    hr = self->m_pILasPointFilter->get_AreaOfInterest(&ipppAOI);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasPointFilter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasPointFilter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasPointFilter.get_AreaOfInterest() returned %ld", (long)hr);
        goto ilaspointfilter_get_areaofinterest_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppAOI);
    if (ipppAOI)
    {
        IUnknown* pUnk = NULL;
        ipppAOI->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppAOI = IUnknownToPythonIIDObject(pUnk, &IID_IGeometry);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppAOI)
    {
        if (py_ppAOI)
           Py_DECREF(py_ppAOI);
        py_ppAOI = Py_None;
        Py_INCREF(py_ppAOI);
    }
    if (PyErr_Occurred())
      goto ilaspointfilter_get_areaofinterest_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppAOI);
    goto ilaspointfilter_get_areaofinterest_method_cleanup;

    ilaspointfilter_get_areaofinterest_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppAOI);
    if (ipppAOI)
      ipppAOI->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasPointFilter.get_AreaOfInterest");
    return return_tuple;
}

static PyObject*
ILasPointFilterMethod_put_Returns(PyILasPointFilterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ILongArray* ipppReturns = NULL;
    PyObject* py_ppReturns;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_ppReturns))
      goto ilaspointfilter_put_returns_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_ppReturns, &IID_ILongArray, (void**)&ipppReturns))
        PyErr_SetString(PyExc_TypeError, "Argument ppReturns (position 0) is not ILongArray");
    
    if (PyErr_Occurred())
      goto ilaspointfilter_put_returns_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pILasPointFilter->put_Returns(ipppReturns);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasPointFilter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasPointFilter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasPointFilter.put_Returns() returned %ld", (long)hr);
        goto ilaspointfilter_put_returns_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ppReturns

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ilaspointfilter_put_returns_method_cleanup;

    ilaspointfilter_put_returns_method_cleanup:
    self->m_HR = hr;
    if (ipppReturns)
      ipppReturns->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasPointFilter.put_Returns");
    return return_tuple;
}

static PyObject*
ILasPointFilterMethod_get_Returns(PyILasPointFilterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ILongArray* ipppReturns = NULL;
    PyObject* py_ppReturns = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppReturns

    // Call method on actual COM interface
    hr = self->m_pILasPointFilter->get_Returns(&ipppReturns);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasPointFilter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasPointFilter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasPointFilter.get_Returns() returned %ld", (long)hr);
        goto ilaspointfilter_get_returns_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppReturns);
    if (ipppReturns)
    {
        IUnknown* pUnk = NULL;
        ipppReturns->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppReturns = IUnknownToPythonIIDObject(pUnk, &IID_ILongArray);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppReturns)
    {
        if (py_ppReturns)
           Py_DECREF(py_ppReturns);
        py_ppReturns = Py_None;
        Py_INCREF(py_ppReturns);
    }
    if (PyErr_Occurred())
      goto ilaspointfilter_get_returns_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppReturns);
    goto ilaspointfilter_get_returns_method_cleanup;

    ilaspointfilter_get_returns_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppReturns);
    if (ipppReturns)
      ipppReturns->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasPointFilter.get_Returns");
    return return_tuple;
}

static PyObject*
ILasPointFilterMethod_put_ClassCodes(PyILasPointFilterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ILongArray* ipppCodes = NULL;
    PyObject* py_ppCodes;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_ppCodes))
      goto ilaspointfilter_put_classcodes_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_ppCodes, &IID_ILongArray, (void**)&ipppCodes))
        PyErr_SetString(PyExc_TypeError, "Argument ppCodes (position 0) is not ILongArray");
    
    if (PyErr_Occurred())
      goto ilaspointfilter_put_classcodes_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pILasPointFilter->put_ClassCodes(ipppCodes);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasPointFilter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasPointFilter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasPointFilter.put_ClassCodes() returned %ld", (long)hr);
        goto ilaspointfilter_put_classcodes_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ppCodes

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ilaspointfilter_put_classcodes_method_cleanup;

    ilaspointfilter_put_classcodes_method_cleanup:
    self->m_HR = hr;
    if (ipppCodes)
      ipppCodes->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasPointFilter.put_ClassCodes");
    return return_tuple;
}

static PyObject*
ILasPointFilterMethod_get_ClassCodes(PyILasPointFilterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ILongArray* ipppCodes = NULL;
    PyObject* py_ppCodes = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppCodes

    // Call method on actual COM interface
    hr = self->m_pILasPointFilter->get_ClassCodes(&ipppCodes);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasPointFilter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasPointFilter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasPointFilter.get_ClassCodes() returned %ld", (long)hr);
        goto ilaspointfilter_get_classcodes_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppCodes);
    if (ipppCodes)
    {
        IUnknown* pUnk = NULL;
        ipppCodes->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppCodes = IUnknownToPythonIIDObject(pUnk, &IID_ILongArray);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppCodes)
    {
        if (py_ppCodes)
           Py_DECREF(py_ppCodes);
        py_ppCodes = Py_None;
        Py_INCREF(py_ppCodes);
    }
    if (PyErr_Occurred())
      goto ilaspointfilter_get_classcodes_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppCodes);
    goto ilaspointfilter_get_classcodes_method_cleanup;

    ilaspointfilter_get_classcodes_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppCodes);
    if (ipppCodes)
      ipppCodes->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasPointFilter.get_ClassCodes");
    return return_tuple;
}

static PyObject*
ILasPointFilterMethod_put_ClassFlags(PyILasPointFilterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpFlags = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lpFlags))
      goto ilaspointfilter_put_classflags_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pFlags

    // Call method on actual COM interface
    hr = self->m_pILasPointFilter->put_ClassFlags(lpFlags);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasPointFilter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasPointFilter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasPointFilter.put_ClassFlags() returned %ld", (long)hr);
        goto ilaspointfilter_put_classflags_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pFlags

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ilaspointfilter_put_classflags_method_cleanup;

    ilaspointfilter_put_classflags_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pFlags
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasPointFilter.put_ClassFlags");
    return return_tuple;
}

static PyObject*
ILasPointFilterMethod_get_ClassFlags(PyILasPointFilterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpFlags = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pFlags

    // Call method on actual COM interface
    hr = self->m_pILasPointFilter->get_ClassFlags(&lpFlags);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasPointFilter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasPointFilter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasPointFilter.get_ClassFlags() returned %ld", (long)hr);
        goto ilaspointfilter_get_classflags_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pFlags

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpFlags);
    goto ilaspointfilter_get_classflags_method_cleanup;

    ilaspointfilter_get_classflags_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pFlags
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasPointFilter.get_ClassFlags");
    return return_tuple;
}


PyMethodDef PyILasPointFilterMethods[] = {
    {"supports", (PyCFunction)PyILasPointFilter_SupportsInterface, METH_O, ""},
    {"putref_AreaOfInterest", (PyCFunction)ILasPointFilterMethod_putref_AreaOfInterest, METH_VARARGS, ""},
    {"get_AreaOfInterest", (PyCFunction)ILasPointFilterMethod_get_AreaOfInterest, METH_VARARGS, ""},
    {"put_Returns", (PyCFunction)ILasPointFilterMethod_put_Returns, METH_VARARGS, ""},
    {"get_Returns", (PyCFunction)ILasPointFilterMethod_get_Returns, METH_VARARGS, ""},
    {"put_ClassCodes", (PyCFunction)ILasPointFilterMethod_put_ClassCodes, METH_VARARGS, ""},
    {"get_ClassCodes", (PyCFunction)ILasPointFilterMethod_get_ClassCodes, METH_VARARGS, ""},
    {"put_ClassFlags", (PyCFunction)ILasPointFilterMethod_put_ClassFlags, METH_VARARGS, ""},
    {"get_ClassFlags", (PyCFunction)ILasPointFilterMethod_get_ClassFlags, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyILasPointFilterGetSet[] = {
  {"_pUnk", (getter)PyILasPointFilter_GetpUnk, NULL, "Get opaque pointer to an Unknown from ILasPointFilter", NULL},
  {"_pointer", (getter)PyILasPointFilter_GetPointer, NULL, "Get memory address for ILasPointFilter", NULL},
  {"_IID", (getter)PyILasPointFilter_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyILasPointFilter_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyILasPointFilter_GetIgnoreFailures, (setter)PyILasPointFilter_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyILasPointFilterObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.ILasPointFilterObject",                          
                                              /* tp_name */
  sizeof(PyILasPointFilterObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyILasPointFilterObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyILasPointFilterMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyILasPointFilterGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyILasPointFilterObject_new,                      
                                              /* tp_new */
};

// Interface ILasFilter

typedef struct PyILasFilterObject {
    PyObject_HEAD
    ILasFilter* m_pILasFilter;
    HRESULT m_HR;
    int m_ignore_failures;
} PyILasFilterObject;

static PyObject*
PyILasFilterObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyILasFilterObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ILasFilter* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ILasFilter, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ILasFilter with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyILasFilterObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ILasFilter");
            return NULL;
        }
        self->m_pILasFilter = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ILasFilter");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ILasFilter");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ILasFilter* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ILasFilter, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ILasFilter");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyILasFilterObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ILasFilter");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pILasFilter = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyILasFilterObject_dealloc(PyILasFilterObject* self)
{
    if (self->m_pILasFilter)
        self->m_pILasFilter->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyILasFilter_GetpUnk(PyILasFilterObject* self)
{
    if (!self->m_pILasFilter)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pILasFilter->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ILasFilter to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyILasFilter_GetPointer(PyILasFilterObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pILasFilter);
}

static PyObject*
PyILasFilter_GetIID(PyILasFilterObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "9ae04cb6-3c51-4322-b5b5-e891e2dcae0b");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyILasFilter_GetHR(PyILasFilterObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyILasFilter_GetIgnoreFailures(PyILasFilterObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyILasFilter_SetIgnoreFailures(PyILasFilterObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyILasFilter_SupportsInterface(PyILasFilterObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pILasFilter->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ILasFilterMethod_put_SurfaceConstraints(PyILasFilterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IArray* ipppConstraintIDs = NULL;
    PyObject* py_ppConstraintIDs;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_ppConstraintIDs))
      goto ilasfilter_put_surfaceconstraints_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_ppConstraintIDs, &IID_IArray, (void**)&ipppConstraintIDs))
        PyErr_SetString(PyExc_TypeError, "Argument ppConstraintIDs (position 0) is not IArray");
    
    if (PyErr_Occurred())
      goto ilasfilter_put_surfaceconstraints_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pILasFilter->put_SurfaceConstraints(ipppConstraintIDs);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasFilter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasFilter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasFilter.put_SurfaceConstraints() returned %ld", (long)hr);
        goto ilasfilter_put_surfaceconstraints_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ppConstraintIDs

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ilasfilter_put_surfaceconstraints_method_cleanup;

    ilasfilter_put_surfaceconstraints_method_cleanup:
    self->m_HR = hr;
    if (ipppConstraintIDs)
      ipppConstraintIDs->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasFilter.put_SurfaceConstraints");
    return return_tuple;
}

static PyObject*
ILasFilterMethod_get_SurfaceConstraints(PyILasFilterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IArray* ipppConstraintIDs = NULL;
    PyObject* py_ppConstraintIDs = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppConstraintIDs

    // Call method on actual COM interface
    hr = self->m_pILasFilter->get_SurfaceConstraints(&ipppConstraintIDs);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasFilter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasFilter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasFilter.get_SurfaceConstraints() returned %ld", (long)hr);
        goto ilasfilter_get_surfaceconstraints_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppConstraintIDs);
    if (ipppConstraintIDs)
    {
        IUnknown* pUnk = NULL;
        ipppConstraintIDs->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppConstraintIDs = IUnknownToPythonIIDObject(pUnk, &IID_IArray);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppConstraintIDs)
    {
        if (py_ppConstraintIDs)
           Py_DECREF(py_ppConstraintIDs);
        py_ppConstraintIDs = Py_None;
        Py_INCREF(py_ppConstraintIDs);
    }
    if (PyErr_Occurred())
      goto ilasfilter_get_surfaceconstraints_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppConstraintIDs);
    goto ilasfilter_get_surfaceconstraints_method_cleanup;

    ilasfilter_get_surfaceconstraints_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppConstraintIDs);
    if (ipppConstraintIDs)
      ipppConstraintIDs->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasFilter.get_SurfaceConstraints");
    return return_tuple;
}

static PyObject*
ILasFilterMethod_Clone(PyILasFilterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ILasFilter* ipppClone = NULL;
    PyObject* py_ppClone = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppClone

    // Call method on actual COM interface
    hr = self->m_pILasFilter->Clone(&ipppClone);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasFilter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasFilter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasFilter.Clone() returned %ld", (long)hr);
        goto ilasfilter_clone_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppClone);
    if (ipppClone)
    {
        IUnknown* pUnk = NULL;
        ipppClone->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppClone = IUnknownToPythonIIDObject(pUnk, &IID_ILasFilter);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppClone)
    {
        if (py_ppClone)
           Py_DECREF(py_ppClone);
        py_ppClone = Py_None;
        Py_INCREF(py_ppClone);
    }
    if (PyErr_Occurred())
      goto ilasfilter_clone_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppClone);
    goto ilasfilter_clone_method_cleanup;

    ilasfilter_clone_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppClone);
    if (ipppClone)
      ipppClone->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasFilter.Clone");
    return return_tuple;
}

static PyObject*
ILasFilterMethod_putref_AreaOfInterest(PyILasFilterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IGeometry* ipppAOI = NULL;
    PyObject* py_ppAOI;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_ppAOI))
      goto ilasfilter_putref_areaofinterest_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_ppAOI, &IID_IGeometry, (void**)&ipppAOI))
        PyErr_SetString(PyExc_TypeError, "Argument ppAOI (position 0) is not IGeometry");
    
    if (PyErr_Occurred())
      goto ilasfilter_putref_areaofinterest_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pILasFilter->putref_AreaOfInterest(ipppAOI);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasFilter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasFilter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasFilter.putref_AreaOfInterest() returned %ld", (long)hr);
        goto ilasfilter_putref_areaofinterest_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ppAOI

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ilasfilter_putref_areaofinterest_method_cleanup;

    ilasfilter_putref_areaofinterest_method_cleanup:
    self->m_HR = hr;
    if (ipppAOI)
      ipppAOI->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasFilter.putref_AreaOfInterest");
    return return_tuple;
}

static PyObject*
ILasFilterMethod_get_AreaOfInterest(PyILasFilterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IGeometry* ipppAOI = NULL;
    PyObject* py_ppAOI = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppAOI

    // Call method on actual COM interface
    hr = self->m_pILasFilter->get_AreaOfInterest(&ipppAOI);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasFilter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasFilter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasFilter.get_AreaOfInterest() returned %ld", (long)hr);
        goto ilasfilter_get_areaofinterest_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppAOI);
    if (ipppAOI)
    {
        IUnknown* pUnk = NULL;
        ipppAOI->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppAOI = IUnknownToPythonIIDObject(pUnk, &IID_IGeometry);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppAOI)
    {
        if (py_ppAOI)
           Py_DECREF(py_ppAOI);
        py_ppAOI = Py_None;
        Py_INCREF(py_ppAOI);
    }
    if (PyErr_Occurred())
      goto ilasfilter_get_areaofinterest_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppAOI);
    goto ilasfilter_get_areaofinterest_method_cleanup;

    ilasfilter_get_areaofinterest_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppAOI);
    if (ipppAOI)
      ipppAOI->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasFilter.get_AreaOfInterest");
    return return_tuple;
}

static PyObject*
ILasFilterMethod_put_Returns(PyILasFilterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ILongArray* ipppReturns = NULL;
    PyObject* py_ppReturns;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_ppReturns))
      goto ilasfilter_put_returns_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_ppReturns, &IID_ILongArray, (void**)&ipppReturns))
        PyErr_SetString(PyExc_TypeError, "Argument ppReturns (position 0) is not ILongArray");
    
    if (PyErr_Occurred())
      goto ilasfilter_put_returns_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pILasFilter->put_Returns(ipppReturns);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasFilter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasFilter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasFilter.put_Returns() returned %ld", (long)hr);
        goto ilasfilter_put_returns_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ppReturns

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ilasfilter_put_returns_method_cleanup;

    ilasfilter_put_returns_method_cleanup:
    self->m_HR = hr;
    if (ipppReturns)
      ipppReturns->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasFilter.put_Returns");
    return return_tuple;
}

static PyObject*
ILasFilterMethod_get_Returns(PyILasFilterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ILongArray* ipppReturns = NULL;
    PyObject* py_ppReturns = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppReturns

    // Call method on actual COM interface
    hr = self->m_pILasFilter->get_Returns(&ipppReturns);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasFilter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasFilter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasFilter.get_Returns() returned %ld", (long)hr);
        goto ilasfilter_get_returns_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppReturns);
    if (ipppReturns)
    {
        IUnknown* pUnk = NULL;
        ipppReturns->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppReturns = IUnknownToPythonIIDObject(pUnk, &IID_ILongArray);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppReturns)
    {
        if (py_ppReturns)
           Py_DECREF(py_ppReturns);
        py_ppReturns = Py_None;
        Py_INCREF(py_ppReturns);
    }
    if (PyErr_Occurred())
      goto ilasfilter_get_returns_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppReturns);
    goto ilasfilter_get_returns_method_cleanup;

    ilasfilter_get_returns_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppReturns);
    if (ipppReturns)
      ipppReturns->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasFilter.get_Returns");
    return return_tuple;
}

static PyObject*
ILasFilterMethod_put_ClassCodes(PyILasFilterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ILongArray* ipppCodes = NULL;
    PyObject* py_ppCodes;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_ppCodes))
      goto ilasfilter_put_classcodes_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_ppCodes, &IID_ILongArray, (void**)&ipppCodes))
        PyErr_SetString(PyExc_TypeError, "Argument ppCodes (position 0) is not ILongArray");
    
    if (PyErr_Occurred())
      goto ilasfilter_put_classcodes_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pILasFilter->put_ClassCodes(ipppCodes);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasFilter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasFilter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasFilter.put_ClassCodes() returned %ld", (long)hr);
        goto ilasfilter_put_classcodes_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ppCodes

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ilasfilter_put_classcodes_method_cleanup;

    ilasfilter_put_classcodes_method_cleanup:
    self->m_HR = hr;
    if (ipppCodes)
      ipppCodes->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasFilter.put_ClassCodes");
    return return_tuple;
}

static PyObject*
ILasFilterMethod_get_ClassCodes(PyILasFilterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ILongArray* ipppCodes = NULL;
    PyObject* py_ppCodes = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppCodes

    // Call method on actual COM interface
    hr = self->m_pILasFilter->get_ClassCodes(&ipppCodes);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasFilter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasFilter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasFilter.get_ClassCodes() returned %ld", (long)hr);
        goto ilasfilter_get_classcodes_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppCodes);
    if (ipppCodes)
    {
        IUnknown* pUnk = NULL;
        ipppCodes->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppCodes = IUnknownToPythonIIDObject(pUnk, &IID_ILongArray);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppCodes)
    {
        if (py_ppCodes)
           Py_DECREF(py_ppCodes);
        py_ppCodes = Py_None;
        Py_INCREF(py_ppCodes);
    }
    if (PyErr_Occurred())
      goto ilasfilter_get_classcodes_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppCodes);
    goto ilasfilter_get_classcodes_method_cleanup;

    ilasfilter_get_classcodes_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppCodes);
    if (ipppCodes)
      ipppCodes->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasFilter.get_ClassCodes");
    return return_tuple;
}

static PyObject*
ILasFilterMethod_put_ClassFlags(PyILasFilterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpFlags = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lpFlags))
      goto ilasfilter_put_classflags_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pFlags

    // Call method on actual COM interface
    hr = self->m_pILasFilter->put_ClassFlags(lpFlags);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasFilter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasFilter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasFilter.put_ClassFlags() returned %ld", (long)hr);
        goto ilasfilter_put_classflags_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pFlags

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ilasfilter_put_classflags_method_cleanup;

    ilasfilter_put_classflags_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pFlags
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasFilter.put_ClassFlags");
    return return_tuple;
}

static PyObject*
ILasFilterMethod_get_ClassFlags(PyILasFilterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpFlags = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pFlags

    // Call method on actual COM interface
    hr = self->m_pILasFilter->get_ClassFlags(&lpFlags);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasFilter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasFilter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasFilter.get_ClassFlags() returned %ld", (long)hr);
        goto ilasfilter_get_classflags_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pFlags

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpFlags);
    goto ilasfilter_get_classflags_method_cleanup;

    ilasfilter_get_classflags_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pFlags
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasFilter.get_ClassFlags");
    return return_tuple;
}


PyMethodDef PyILasFilterMethods[] = {
    {"supports", (PyCFunction)PyILasFilter_SupportsInterface, METH_O, ""},
    {"put_SurfaceConstraints", (PyCFunction)ILasFilterMethod_put_SurfaceConstraints, METH_VARARGS, ""},
    {"get_SurfaceConstraints", (PyCFunction)ILasFilterMethod_get_SurfaceConstraints, METH_VARARGS, ""},
    {"Clone", (PyCFunction)ILasFilterMethod_Clone, METH_VARARGS, ""},
    {"putref_AreaOfInterest", (PyCFunction)ILasFilterMethod_putref_AreaOfInterest, METH_VARARGS, ""},
    {"get_AreaOfInterest", (PyCFunction)ILasFilterMethod_get_AreaOfInterest, METH_VARARGS, ""},
    {"put_Returns", (PyCFunction)ILasFilterMethod_put_Returns, METH_VARARGS, ""},
    {"get_Returns", (PyCFunction)ILasFilterMethod_get_Returns, METH_VARARGS, ""},
    {"put_ClassCodes", (PyCFunction)ILasFilterMethod_put_ClassCodes, METH_VARARGS, ""},
    {"get_ClassCodes", (PyCFunction)ILasFilterMethod_get_ClassCodes, METH_VARARGS, ""},
    {"put_ClassFlags", (PyCFunction)ILasFilterMethod_put_ClassFlags, METH_VARARGS, ""},
    {"get_ClassFlags", (PyCFunction)ILasFilterMethod_get_ClassFlags, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyILasFilterGetSet[] = {
  {"_pUnk", (getter)PyILasFilter_GetpUnk, NULL, "Get opaque pointer to an Unknown from ILasFilter", NULL},
  {"_pointer", (getter)PyILasFilter_GetPointer, NULL, "Get memory address for ILasFilter", NULL},
  {"_IID", (getter)PyILasFilter_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyILasFilter_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyILasFilter_GetIgnoreFailures, (setter)PyILasFilter_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyILasFilterObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.ILasFilterObject",                          
                                              /* tp_name */
  sizeof(PyILasFilterObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyILasFilterObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyILasFilterMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyILasFilterGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyILasFilterObject_new,                      
                                              /* tp_new */
};

// Interface ILasSurface

typedef struct PyILasSurfaceObject {
    PyObject_HEAD
    ILasSurface* m_pILasSurface;
    HRESULT m_HR;
    int m_ignore_failures;
} PyILasSurfaceObject;

static PyObject*
PyILasSurfaceObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyILasSurfaceObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ILasSurface* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ILasSurface, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ILasSurface with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyILasSurfaceObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ILasSurface");
            return NULL;
        }
        self->m_pILasSurface = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ILasSurface");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ILasSurface");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ILasSurface* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ILasSurface, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ILasSurface");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyILasSurfaceObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ILasSurface");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pILasSurface = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyILasSurfaceObject_dealloc(PyILasSurfaceObject* self)
{
    if (self->m_pILasSurface)
        self->m_pILasSurface->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyILasSurface_GetpUnk(PyILasSurfaceObject* self)
{
    if (!self->m_pILasSurface)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pILasSurface->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ILasSurface to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyILasSurface_GetPointer(PyILasSurfaceObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pILasSurface);
}

static PyObject*
PyILasSurface_GetIID(PyILasSurfaceObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "81792712-2296-4b3f-ba19-3d37bd0b245d");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyILasSurface_GetHR(PyILasSurfaceObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyILasSurface_GetIgnoreFailures(PyILasSurfaceObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyILasSurface_SetIgnoreFailures(PyILasSurfaceObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyILasSurface_SupportsInterface(PyILasSurfaceObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pILasSurface->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ILasSurfaceMethod_AsTin(PyILasSurfaceObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;
    ILasFilter* ippFilter = NULL;
    PyObject* py_pFilter;
    double dResolution = 0;
    esriTinPointSelectionMethod eMethod;
    double dZFactor = 0;
    ITin* ipppTin = NULL;
    PyObject* py_ppTin = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOdid", &py_pTrackCancel, &py_pFilter, &dResolution, (int *)&eMethod, &dZFactor))
      goto ilassurface_astin_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 0) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto ilassurface_astin_method_cleanup;
    
    if (!IFaceFromPyObject(py_pFilter, &IID_ILasFilter, (void**)&ippFilter))
        PyErr_SetString(PyExc_TypeError, "Argument pFilter (position 1) is not ILasFilter");
    
    if (PyErr_Occurred())
      goto ilassurface_astin_method_cleanup;
    
    // No setup for Resolution
    // No setup for Method
    // No setup for ZFactor
    // No setup for ppTin

    // Call method on actual COM interface
    hr = self->m_pILasSurface->AsTin(ippTrackCancel, ippFilter, dResolution, eMethod, dZFactor, &ipppTin);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasSurface->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasSurface) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasSurface.AsTin() returned %ld", (long)hr);
        goto ilassurface_astin_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pTrackCancel
    // No teardown for pFilter
    // No teardown for Resolution
    // No teardown for Method
    // No teardown for ZFactor
    Py_XDECREF(py_ppTin);
    if (ipppTin)
    {
        IUnknown* pUnk = NULL;
        ipppTin->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppTin = IUnknownToPythonIIDObject(pUnk, &IID_ITin);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppTin)
    {
        if (py_ppTin)
           Py_DECREF(py_ppTin);
        py_ppTin = Py_None;
        Py_INCREF(py_ppTin);
    }
    if (PyErr_Occurred())
      goto ilassurface_astin_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppTin);
    goto ilassurface_astin_method_cleanup;

    ilassurface_astin_method_cleanup:
    self->m_HR = hr;
    if (ippTrackCancel)
      ippTrackCancel->Release();
    if (ippFilter)
      ippFilter->Release();
    // No cleanup for Resolution
    // No cleanup for Method
    // No cleanup for ZFactor
    Py_XDECREF(py_ppTin);
    if (ipppTin)
      ipppTin->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasSurface.AsTin");
    return return_tuple;
}

static PyObject*
ILasSurfaceMethod_AsRaster(PyILasSurfaceObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;
    ILasFilter* ippFilter = NULL;
    PyObject* py_pFilter;
    IRasterDataset* ippDataset = NULL;
    PyObject* py_pDataset;
    esriPointToRasterMethod eMethod;
    esriLasZSource ezSource;
    esriPointToRasterVoidFillMethod efillMethod;
    esriSurfaceInterpolationType eType;
    double dZFactor = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOOiiiid", &py_pTrackCancel, &py_pFilter, &py_pDataset, (int *)&eMethod, (int *)&ezSource, (int *)&efillMethod, (int *)&eType, &dZFactor))
      goto ilassurface_asraster_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 0) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto ilassurface_asraster_method_cleanup;
    
    if (!IFaceFromPyObject(py_pFilter, &IID_ILasFilter, (void**)&ippFilter))
        PyErr_SetString(PyExc_TypeError, "Argument pFilter (position 1) is not ILasFilter");
    
    if (PyErr_Occurred())
      goto ilassurface_asraster_method_cleanup;
    
    if (!IFaceFromPyObject(py_pDataset, &IID_IRasterDataset, (void**)&ippDataset))
        PyErr_SetString(PyExc_TypeError, "Argument pDataset (position 2) is not IRasterDataset");
    
    if (PyErr_Occurred())
      goto ilassurface_asraster_method_cleanup;
    
    // No setup for Method
    // No setup for zSource
    // No setup for fillMethod
    // No setup for Type
    // No setup for ZFactor

    // Call method on actual COM interface
    hr = self->m_pILasSurface->AsRaster(ippTrackCancel, ippFilter, ippDataset, eMethod, ezSource, efillMethod, eType, dZFactor);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasSurface->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasSurface) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasSurface.AsRaster() returned %ld", (long)hr);
        goto ilassurface_asraster_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pTrackCancel
    // No teardown for pFilter
    // No teardown for pDataset
    // No teardown for Method
    // No teardown for zSource
    // No teardown for fillMethod
    // No teardown for Type
    // No teardown for ZFactor

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ilassurface_asraster_method_cleanup;

    ilassurface_asraster_method_cleanup:
    self->m_HR = hr;
    if (ippTrackCancel)
      ippTrackCancel->Release();
    if (ippFilter)
      ippFilter->Release();
    if (ippDataset)
      ippDataset->Release();
    // No cleanup for Method
    // No cleanup for zSource
    // No cleanup for fillMethod
    // No cleanup for Type
    // No cleanup for ZFactor
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasSurface.AsRaster");
    return return_tuple;
}

static PyObject*
ILasSurfaceMethod_InterpolateRaster(PyILasSurfaceObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;
    ILasFilter* ippLasFilter = NULL;
    PyObject* py_pLasFilter;
    IRasterDataset* ippDataset = NULL;
    PyObject* py_pDataset;
    double dResolution = 0;
    esriTinPointSelectionMethod eMethod;
    esriSurfaceInterpolationType eType;
    double dZFactor = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOOdiid", &py_pTrackCancel, &py_pLasFilter, &py_pDataset, &dResolution, (int *)&eMethod, (int *)&eType, &dZFactor))
      goto ilassurface_interpolateraster_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 0) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto ilassurface_interpolateraster_method_cleanup;
    
    if (!IFaceFromPyObject(py_pLasFilter, &IID_ILasFilter, (void**)&ippLasFilter))
        PyErr_SetString(PyExc_TypeError, "Argument pLasFilter (position 1) is not ILasFilter");
    
    if (PyErr_Occurred())
      goto ilassurface_interpolateraster_method_cleanup;
    
    if (!IFaceFromPyObject(py_pDataset, &IID_IRasterDataset, (void**)&ippDataset))
        PyErr_SetString(PyExc_TypeError, "Argument pDataset (position 2) is not IRasterDataset");
    
    if (PyErr_Occurred())
      goto ilassurface_interpolateraster_method_cleanup;
    
    // No setup for Resolution
    // No setup for Method
    // No setup for Type
    // No setup for ZFactor

    // Call method on actual COM interface
    hr = self->m_pILasSurface->InterpolateRaster(ippTrackCancel, ippLasFilter, ippDataset, dResolution, eMethod, eType, dZFactor);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasSurface->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasSurface) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasSurface.InterpolateRaster() returned %ld", (long)hr);
        goto ilassurface_interpolateraster_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pTrackCancel
    // No teardown for pLasFilter
    // No teardown for pDataset
    // No teardown for Resolution
    // No teardown for Method
    // No teardown for Type
    // No teardown for ZFactor

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ilassurface_interpolateraster_method_cleanup;

    ilassurface_interpolateraster_method_cleanup:
    self->m_HR = hr;
    if (ippTrackCancel)
      ippTrackCancel->Release();
    if (ippLasFilter)
      ippLasFilter->Release();
    if (ippDataset)
      ippDataset->Release();
    // No cleanup for Resolution
    // No cleanup for Method
    // No cleanup for Type
    // No cleanup for ZFactor
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasSurface.InterpolateRaster");
    return return_tuple;
}

static PyObject*
ILasSurfaceMethod_InterpolateFeatureClass(PyILasSurfaceObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;
    ILasFilter* ippLasFilter = NULL;
    PyObject* py_pLasFilter;
    double dResolution = 0;
    esriTinPointSelectionMethod eMethod;
    esriSurfaceInterpolationType eType;
    double dZFactor = 0;
    IFeatureClass* ippInClass = NULL;
    PyObject* py_pInClass;
    IQueryFilter* ippQueryFilter = NULL;
    PyObject* py_pQueryFilter;
    IFeatureClass* ippOutClass = NULL;
    PyObject* py_pOutClass;
    VARIANT vpStepSize;
    ::VariantInit(&vpStepSize);
    PyObject* pyvar_pStepSize = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOdiidOOOO", &py_pTrackCancel, &py_pLasFilter, &dResolution, (int *)&eMethod, (int *)&eType, &dZFactor, &py_pInClass, &py_pQueryFilter, &py_pOutClass, &pyvar_pStepSize))
      goto ilassurface_interpolatefeatureclass_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 0) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto ilassurface_interpolatefeatureclass_method_cleanup;
    
    if (!IFaceFromPyObject(py_pLasFilter, &IID_ILasFilter, (void**)&ippLasFilter))
        PyErr_SetString(PyExc_TypeError, "Argument pLasFilter (position 1) is not ILasFilter");
    
    if (PyErr_Occurred())
      goto ilassurface_interpolatefeatureclass_method_cleanup;
    
    // No setup for Resolution
    // No setup for Method
    // No setup for Type
    // No setup for ZFactor
    if (!IFaceFromPyObject(py_pInClass, &IID_IFeatureClass, (void**)&ippInClass))
        PyErr_SetString(PyExc_TypeError, "Argument pInClass (position 6) is not IFeatureClass");
    
    if (PyErr_Occurred())
      goto ilassurface_interpolatefeatureclass_method_cleanup;
    
    if (!IFaceFromPyObject(py_pQueryFilter, &IID_IQueryFilter, (void**)&ippQueryFilter))
        PyErr_SetString(PyExc_TypeError, "Argument pQueryFilter (position 7) is not IQueryFilter");
    
    if (PyErr_Occurred())
      goto ilassurface_interpolatefeatureclass_method_cleanup;
    
    if (!IFaceFromPyObject(py_pOutClass, &IID_IFeatureClass, (void**)&ippOutClass))
        PyErr_SetString(PyExc_TypeError, "Argument pOutClass (position 8) is not IFeatureClass");
    
    if (PyErr_Occurred())
      goto ilassurface_interpolatefeatureclass_method_cleanup;
    
    PyObject_AsVariant(pyvar_pStepSize, &vpStepSize);
    
    if (PyErr_Occurred())
      goto ilassurface_interpolatefeatureclass_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pILasSurface->InterpolateFeatureClass(ippTrackCancel, ippLasFilter, dResolution, eMethod, eType, dZFactor, ippInClass, ippQueryFilter, ippOutClass, &vpStepSize);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasSurface->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasSurface) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasSurface.InterpolateFeatureClass() returned %ld", (long)hr);
        goto ilassurface_interpolatefeatureclass_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pTrackCancel
    // No teardown for pLasFilter
    // No teardown for Resolution
    // No teardown for Method
    // No teardown for Type
    // No teardown for ZFactor
    // No teardown for pInClass
    // No teardown for pQueryFilter
    // No teardown for pOutClass
    // No teardown for pStepSize

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ilassurface_interpolatefeatureclass_method_cleanup;

    ilassurface_interpolatefeatureclass_method_cleanup:
    self->m_HR = hr;
    if (ippTrackCancel)
      ippTrackCancel->Release();
    if (ippLasFilter)
      ippLasFilter->Release();
    // No cleanup for Resolution
    // No cleanup for Method
    // No cleanup for Type
    // No cleanup for ZFactor
    if (ippInClass)
      ippInClass->Release();
    if (ippQueryFilter)
      ippQueryFilter->Release();
    if (ippOutClass)
      ippOutClass->Release();
    ::VariantClear(&vpStepSize);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasSurface.InterpolateFeatureClass");
    return return_tuple;
}

static PyObject*
ILasSurfaceMethod_InterpolateFeatureClassVertices(PyILasSurfaceObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;
    ILasFilter* ippLasFilter = NULL;
    PyObject* py_pLasFilter;
    double dResolution = 0;
    esriTinPointSelectionMethod eMethod;
    esriSurfaceInterpolationType eType;
    double dZFactor = 0;
    IFeatureClass* ippInClass = NULL;
    PyObject* py_pInClass;
    IQueryFilter* ippQueryFilter = NULL;
    PyObject* py_pQueryFilter;
    IFeatureClass* ippOutClass = NULL;
    PyObject* py_pOutClass;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOdiidOOO", &py_pTrackCancel, &py_pLasFilter, &dResolution, (int *)&eMethod, (int *)&eType, &dZFactor, &py_pInClass, &py_pQueryFilter, &py_pOutClass))
      goto ilassurface_interpolatefeatureclassvertices_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 0) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto ilassurface_interpolatefeatureclassvertices_method_cleanup;
    
    if (!IFaceFromPyObject(py_pLasFilter, &IID_ILasFilter, (void**)&ippLasFilter))
        PyErr_SetString(PyExc_TypeError, "Argument pLasFilter (position 1) is not ILasFilter");
    
    if (PyErr_Occurred())
      goto ilassurface_interpolatefeatureclassvertices_method_cleanup;
    
    // No setup for Resolution
    // No setup for Method
    // No setup for Type
    // No setup for ZFactor
    if (!IFaceFromPyObject(py_pInClass, &IID_IFeatureClass, (void**)&ippInClass))
        PyErr_SetString(PyExc_TypeError, "Argument pInClass (position 6) is not IFeatureClass");
    
    if (PyErr_Occurred())
      goto ilassurface_interpolatefeatureclassvertices_method_cleanup;
    
    if (!IFaceFromPyObject(py_pQueryFilter, &IID_IQueryFilter, (void**)&ippQueryFilter))
        PyErr_SetString(PyExc_TypeError, "Argument pQueryFilter (position 7) is not IQueryFilter");
    
    if (PyErr_Occurred())
      goto ilassurface_interpolatefeatureclassvertices_method_cleanup;
    
    if (!IFaceFromPyObject(py_pOutClass, &IID_IFeatureClass, (void**)&ippOutClass))
        PyErr_SetString(PyExc_TypeError, "Argument pOutClass (position 8) is not IFeatureClass");
    
    if (PyErr_Occurred())
      goto ilassurface_interpolatefeatureclassvertices_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pILasSurface->InterpolateFeatureClassVertices(ippTrackCancel, ippLasFilter, dResolution, eMethod, eType, dZFactor, ippInClass, ippQueryFilter, ippOutClass);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasSurface->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasSurface) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasSurface.InterpolateFeatureClassVertices() returned %ld", (long)hr);
        goto ilassurface_interpolatefeatureclassvertices_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pTrackCancel
    // No teardown for pLasFilter
    // No teardown for Resolution
    // No teardown for Method
    // No teardown for Type
    // No teardown for ZFactor
    // No teardown for pInClass
    // No teardown for pQueryFilter
    // No teardown for pOutClass

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ilassurface_interpolatefeatureclassvertices_method_cleanup;

    ilassurface_interpolatefeatureclassvertices_method_cleanup:
    self->m_HR = hr;
    if (ippTrackCancel)
      ippTrackCancel->Release();
    if (ippLasFilter)
      ippLasFilter->Release();
    // No cleanup for Resolution
    // No cleanup for Method
    // No cleanup for Type
    // No cleanup for ZFactor
    if (ippInClass)
      ippInClass->Release();
    if (ippQueryFilter)
      ippQueryFilter->Release();
    if (ippOutClass)
      ippOutClass->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasSurface.InterpolateFeatureClassVertices");
    return return_tuple;
}

static PyObject*
ILasSurfaceMethod_get_CanDoCurvature(PyILasSurfaceObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pbCanDo = VARIANT_FALSE;
    PyObject* pyvar_pbCanDo = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pbCanDo

    // Call method on actual COM interface
    hr = self->m_pILasSurface->get_CanDoCurvature(&b_pbCanDo);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasSurface->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasSurface) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasSurface.get_CanDoCurvature() returned %ld", (long)hr);
        goto ilassurface_get_candocurvature_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pbCanDo = ((b_pbCanDo == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto ilassurface_get_candocurvature_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pbCanDo);
    goto ilassurface_get_candocurvature_method_cleanup;

    ilassurface_get_candocurvature_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pbCanDo
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasSurface.get_CanDoCurvature");
    return return_tuple;
}

static PyObject*
ILasSurfaceMethod_GetLineOfSightFeatureClass(PyILasSurfaceObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;
    ILasFilter* ippLasFilter = NULL;
    PyObject* py_pLasFilter;
    double dResolution = 0;
    esriTinPointSelectionMethod eMethod;
    double dZFactor = 0;
    IFeatureClass* ippInputLines = NULL;
    PyObject* py_pInputLines;
    IQueryFilter* ippQueryFilter = NULL;
    PyObject* py_pQueryFilter;
    IFeatureClass* ippOutputLines = NULL;
    PyObject* py_pOutputLines;
    IFeatureClass* ippObstructionPoints = NULL;
    PyObject* py_pObstructionPoints;
    VARIANT_BOOL b_bApplyCurvature = VARIANT_FALSE;
    PyObject* pyvar_bApplyCurvature = NULL;
    VARIANT_BOOL b_bApplyRefraction = VARIANT_FALSE;
    PyObject* pyvar_bApplyRefraction = NULL;
    VARIANT vpRefractionFactor;
    ::VariantInit(&vpRefractionFactor);
    PyObject* pyvar_pRefractionFactor = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOdidOOOOOOO", &py_pTrackCancel, &py_pLasFilter, &dResolution, (int *)&eMethod, &dZFactor, &py_pInputLines, &py_pQueryFilter, &py_pOutputLines, &py_pObstructionPoints, &pyvar_bApplyCurvature, &pyvar_bApplyRefraction, &pyvar_pRefractionFactor))
      goto ilassurface_getlineofsightfeatureclass_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 0) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto ilassurface_getlineofsightfeatureclass_method_cleanup;
    
    if (!IFaceFromPyObject(py_pLasFilter, &IID_ILasFilter, (void**)&ippLasFilter))
        PyErr_SetString(PyExc_TypeError, "Argument pLasFilter (position 1) is not ILasFilter");
    
    if (PyErr_Occurred())
      goto ilassurface_getlineofsightfeatureclass_method_cleanup;
    
    // No setup for Resolution
    // No setup for Method
    // No setup for ZFactor
    if (!IFaceFromPyObject(py_pInputLines, &IID_IFeatureClass, (void**)&ippInputLines))
        PyErr_SetString(PyExc_TypeError, "Argument pInputLines (position 5) is not IFeatureClass");
    
    if (PyErr_Occurred())
      goto ilassurface_getlineofsightfeatureclass_method_cleanup;
    
    if (!IFaceFromPyObject(py_pQueryFilter, &IID_IQueryFilter, (void**)&ippQueryFilter))
        PyErr_SetString(PyExc_TypeError, "Argument pQueryFilter (position 6) is not IQueryFilter");
    
    if (PyErr_Occurred())
      goto ilassurface_getlineofsightfeatureclass_method_cleanup;
    
    if (!IFaceFromPyObject(py_pOutputLines, &IID_IFeatureClass, (void**)&ippOutputLines))
        PyErr_SetString(PyExc_TypeError, "Argument pOutputLines (position 7) is not IFeatureClass");
    
    if (PyErr_Occurred())
      goto ilassurface_getlineofsightfeatureclass_method_cleanup;
    
    if (!IFaceFromPyObject(py_pObstructionPoints, &IID_IFeatureClass, (void**)&ippObstructionPoints))
        PyErr_SetString(PyExc_TypeError, "Argument pObstructionPoints (position 8) is not IFeatureClass");
    
    if (PyErr_Occurred())
      goto ilassurface_getlineofsightfeatureclass_method_cleanup;
    
    b_bApplyCurvature = ((PyObject_IsTrue(pyvar_bApplyCurvature) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto ilassurface_getlineofsightfeatureclass_method_cleanup;
    
    b_bApplyRefraction = ((PyObject_IsTrue(pyvar_bApplyRefraction) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto ilassurface_getlineofsightfeatureclass_method_cleanup;
    
    PyObject_AsVariant(pyvar_pRefractionFactor, &vpRefractionFactor);
    
    if (PyErr_Occurred())
      goto ilassurface_getlineofsightfeatureclass_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pILasSurface->GetLineOfSightFeatureClass(ippTrackCancel, ippLasFilter, dResolution, eMethod, dZFactor, ippInputLines, ippQueryFilter, ippOutputLines, ippObstructionPoints, b_bApplyCurvature, b_bApplyRefraction, &vpRefractionFactor);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasSurface->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasSurface) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasSurface.GetLineOfSightFeatureClass() returned %ld", (long)hr);
        goto ilassurface_getlineofsightfeatureclass_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pTrackCancel
    // No teardown for pLasFilter
    // No teardown for Resolution
    // No teardown for Method
    // No teardown for ZFactor
    // No teardown for pInputLines
    // No teardown for pQueryFilter
    // No teardown for pOutputLines
    // No teardown for pObstructionPoints
    // No teardown for bApplyCurvature
    // No teardown for bApplyRefraction
    // No teardown for pRefractionFactor

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ilassurface_getlineofsightfeatureclass_method_cleanup;

    ilassurface_getlineofsightfeatureclass_method_cleanup:
    self->m_HR = hr;
    if (ippTrackCancel)
      ippTrackCancel->Release();
    if (ippLasFilter)
      ippLasFilter->Release();
    // No cleanup for Resolution
    // No cleanup for Method
    // No cleanup for ZFactor
    if (ippInputLines)
      ippInputLines->Release();
    if (ippQueryFilter)
      ippQueryFilter->Release();
    if (ippOutputLines)
      ippOutputLines->Release();
    if (ippObstructionPoints)
      ippObstructionPoints->Release();
    // No cleanup for bApplyCurvature
    // No cleanup for bApplyRefraction
    ::VariantClear(&vpRefractionFactor);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasSurface.GetLineOfSightFeatureClass");
    return return_tuple;
}


PyMethodDef PyILasSurfaceMethods[] = {
    {"supports", (PyCFunction)PyILasSurface_SupportsInterface, METH_O, ""},
    {"AsTin", (PyCFunction)ILasSurfaceMethod_AsTin, METH_VARARGS, ""},
    {"AsRaster", (PyCFunction)ILasSurfaceMethod_AsRaster, METH_VARARGS, ""},
    {"InterpolateRaster", (PyCFunction)ILasSurfaceMethod_InterpolateRaster, METH_VARARGS, ""},
    {"InterpolateFeatureClass", (PyCFunction)ILasSurfaceMethod_InterpolateFeatureClass, METH_VARARGS, ""},
    {"InterpolateFeatureClassVertices", (PyCFunction)ILasSurfaceMethod_InterpolateFeatureClassVertices, METH_VARARGS, ""},
    {"get_CanDoCurvature", (PyCFunction)ILasSurfaceMethod_get_CanDoCurvature, METH_VARARGS, ""},
    {"GetLineOfSightFeatureClass", (PyCFunction)ILasSurfaceMethod_GetLineOfSightFeatureClass, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyILasSurfaceGetSet[] = {
  {"_pUnk", (getter)PyILasSurface_GetpUnk, NULL, "Get opaque pointer to an Unknown from ILasSurface", NULL},
  {"_pointer", (getter)PyILasSurface_GetPointer, NULL, "Get memory address for ILasSurface", NULL},
  {"_IID", (getter)PyILasSurface_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyILasSurface_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyILasSurface_GetIgnoreFailures, (setter)PyILasSurface_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyILasSurfaceObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.ILasSurfaceObject",                          
                                              /* tp_name */
  sizeof(PyILasSurfaceObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyILasSurfaceObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyILasSurfaceMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyILasSurfaceGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyILasSurfaceObject_new,                      
                                              /* tp_new */
};

// Interface ILasDataset

typedef struct PyILasDatasetObject {
    PyObject_HEAD
    ILasDataset* m_pILasDataset;
    HRESULT m_HR;
    int m_ignore_failures;
} PyILasDatasetObject;

static PyObject*
PyILasDatasetObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyILasDatasetObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ILasDataset* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ILasDataset, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ILasDataset with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyILasDatasetObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ILasDataset");
            return NULL;
        }
        self->m_pILasDataset = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ILasDataset");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ILasDataset");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ILasDataset* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ILasDataset, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ILasDataset");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyILasDatasetObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ILasDataset");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pILasDataset = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyILasDatasetObject_dealloc(PyILasDatasetObject* self)
{
    if (self->m_pILasDataset)
        self->m_pILasDataset->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyILasDataset_GetpUnk(PyILasDatasetObject* self)
{
    if (!self->m_pILasDataset)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pILasDataset->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ILasDataset to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyILasDataset_GetPointer(PyILasDatasetObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pILasDataset);
}

static PyObject*
PyILasDataset_GetIID(PyILasDatasetObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "3ac637a3-1671-4dfe-babe-d7947d57f050");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyILasDataset_GetHR(PyILasDatasetObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyILasDataset_GetIgnoreFailures(PyILasDatasetObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyILasDataset_SetIgnoreFailures(PyILasDatasetObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyILasDataset_SupportsInterface(PyILasDatasetObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pILasDataset->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ILasDatasetMethod_SetEmpty(PyILasDatasetObject* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pILasDataset->SetEmpty();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasDataset->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasDataset) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasDataset.SetEmpty() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}

static PyObject*
ILasDatasetMethod_Init(PyILasDatasetObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName = 0;
    PyObject* pyvar_Name;
    PyObject* unicodeName = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_Name))
      goto ilasdataset_init_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_Name))
        unicodeName = PyUnicode_FromObject(pyvar_Name);
    else if (PyUnicode_Check(pyvar_Name))
    {
        unicodeName = pyvar_Name;
        Py_INCREF(unicodeName);
    }
    else if (pyvar_Name != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Name at index 0");
    if (unicodeName)
        bsName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeName));
    
    if (PyErr_Occurred())
      goto ilasdataset_init_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pILasDataset->Init(bsName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasDataset->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasDataset) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasDataset.Init() returned %ld", (long)hr);
        goto ilasdataset_init_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Name

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ilasdataset_init_method_cleanup;

    ilasdataset_init_method_cleanup:
    self->m_HR = hr;
    if (bsName)
        ::SysFreeString(bsName);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasDataset.Init");
    return return_tuple;
}

static PyObject*
ILasDatasetMethod_SaveAs(PyILasDatasetObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName = 0;
    PyObject* pyvar_Name;
    PyObject* unicodeName = NULL;
    VARIANT_BOOL b_bOverWrite = VARIANT_FALSE;
    PyObject* pyvar_bOverWrite = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OO", &pyvar_Name, &pyvar_bOverWrite))
      goto ilasdataset_saveas_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_Name))
        unicodeName = PyUnicode_FromObject(pyvar_Name);
    else if (PyUnicode_Check(pyvar_Name))
    {
        unicodeName = pyvar_Name;
        Py_INCREF(unicodeName);
    }
    else if (pyvar_Name != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Name at index 0");
    if (unicodeName)
        bsName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeName));
    
    if (PyErr_Occurred())
      goto ilasdataset_saveas_method_cleanup;
    
    b_bOverWrite = ((PyObject_IsTrue(pyvar_bOverWrite) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto ilasdataset_saveas_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pILasDataset->SaveAs(bsName, b_bOverWrite);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasDataset->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasDataset) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasDataset.SaveAs() returned %ld", (long)hr);
        goto ilasdataset_saveas_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Name
    // No teardown for bOverWrite

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ilasdataset_saveas_method_cleanup;

    ilasdataset_saveas_method_cleanup:
    self->m_HR = hr;
    if (bsName)
        ::SysFreeString(bsName);
    
    // No cleanup for bOverWrite
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasDataset.SaveAs");
    return return_tuple;
}

static PyObject*
ILasDatasetMethod_get_Name(PyILasDatasetObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspName;
    PyObject* pyvar_pName = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pName

    // Call method on actual COM interface
    hr = self->m_pILasDataset->get_Name(&bspName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasDataset->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasDataset) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasDataset.get_Name() returned %ld", (long)hr);
        goto ilasdataset_get_name_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pName = PyUnicode_FromWideChar(bspName,::SysStringLen(bspName));
    ::SysFreeString(bspName);
    
    if (PyErr_Occurred())
      goto ilasdataset_get_name_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pName);
    goto ilasdataset_get_name_method_cleanup;

    ilasdataset_get_name_method_cleanup:
    self->m_HR = hr;
    if (pyvar_pName != Py_None)
        Py_XDECREF(pyvar_pName);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasDataset.get_Name");
    return return_tuple;
}

static PyObject*
ILasDatasetMethod_get_UsesRelativePath(PyILasDatasetObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pbUsesRelativePath = VARIANT_FALSE;
    PyObject* pyvar_pbUsesRelativePath = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pbUsesRelativePath

    // Call method on actual COM interface
    hr = self->m_pILasDataset->get_UsesRelativePath(&b_pbUsesRelativePath);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasDataset->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasDataset) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasDataset.get_UsesRelativePath() returned %ld", (long)hr);
        goto ilasdataset_get_usesrelativepath_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pbUsesRelativePath = ((b_pbUsesRelativePath == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto ilasdataset_get_usesrelativepath_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pbUsesRelativePath);
    goto ilasdataset_get_usesrelativepath_method_cleanup;

    ilasdataset_get_usesrelativepath_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pbUsesRelativePath
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasDataset.get_UsesRelativePath");
    return return_tuple;
}

static PyObject*
ILasDatasetMethod_get_IsDirty(PyILasDatasetObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pbIsDirty = VARIANT_FALSE;
    PyObject* pyvar_pbIsDirty = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pbIsDirty

    // Call method on actual COM interface
    hr = self->m_pILasDataset->get_IsDirty(&b_pbIsDirty);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasDataset->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasDataset) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasDataset.get_IsDirty() returned %ld", (long)hr);
        goto ilasdataset_get_isdirty_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pbIsDirty = ((b_pbIsDirty == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto ilasdataset_get_isdirty_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pbIsDirty);
    goto ilasdataset_get_isdirty_method_cleanup;

    ilasdataset_get_isdirty_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pbIsDirty
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasDataset.get_IsDirty");
    return return_tuple;
}

static PyObject*
ILasDatasetMethod_get_SpatialReference(PyILasDatasetObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ISpatialReference* ipppSpatialRef = NULL;
    PyObject* py_ppSpatialRef = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppSpatialRef

    // Call method on actual COM interface
    hr = self->m_pILasDataset->get_SpatialReference(&ipppSpatialRef);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasDataset->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasDataset) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasDataset.get_SpatialReference() returned %ld", (long)hr);
        goto ilasdataset_get_spatialreference_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppSpatialRef);
    if (ipppSpatialRef)
    {
        IUnknown* pUnk = NULL;
        ipppSpatialRef->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppSpatialRef = IUnknownToPythonIIDObject(pUnk, &IID_ISpatialReference);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppSpatialRef)
    {
        if (py_ppSpatialRef)
           Py_DECREF(py_ppSpatialRef);
        py_ppSpatialRef = Py_None;
        Py_INCREF(py_ppSpatialRef);
    }
    if (PyErr_Occurred())
      goto ilasdataset_get_spatialreference_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppSpatialRef);
    goto ilasdataset_get_spatialreference_method_cleanup;

    ilasdataset_get_spatialreference_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppSpatialRef);
    if (ipppSpatialRef)
      ipppSpatialRef->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasDataset.get_SpatialReference");
    return return_tuple;
}

static PyObject*
ILasDatasetMethod_get_Extent(PyILasDatasetObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IEnvelope* ipppExtent = NULL;
    PyObject* py_ppExtent = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppExtent

    // Call method on actual COM interface
    hr = self->m_pILasDataset->get_Extent(&ipppExtent);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasDataset->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasDataset) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasDataset.get_Extent() returned %ld", (long)hr);
        goto ilasdataset_get_extent_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppExtent);
    if (ipppExtent)
    {
        IUnknown* pUnk = NULL;
        ipppExtent->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppExtent = IUnknownToPythonIIDObject(pUnk, &IID_IEnvelope);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppExtent)
    {
        if (py_ppExtent)
           Py_DECREF(py_ppExtent);
        py_ppExtent = Py_None;
        Py_INCREF(py_ppExtent);
    }
    if (PyErr_Occurred())
      goto ilasdataset_get_extent_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppExtent);
    goto ilasdataset_get_extent_method_cleanup;

    ilasdataset_get_extent_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppExtent);
    if (ipppExtent)
      ipppExtent->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasDataset.get_Extent");
    return return_tuple;
}

static PyObject*
ILasDatasetMethod_get_FileCount(PyILasDatasetObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpcFiles = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pcFiles

    // Call method on actual COM interface
    hr = self->m_pILasDataset->get_FileCount(&lpcFiles);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasDataset->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasDataset) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasDataset.get_FileCount() returned %ld", (long)hr);
        goto ilasdataset_get_filecount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pcFiles

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpcFiles);
    goto ilasdataset_get_filecount_method_cleanup;

    ilasdataset_get_filecount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pcFiles
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasDataset.get_FileCount");
    return return_tuple;
}

static PyObject*
ILasDatasetMethod_get_File(PyILasDatasetObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;
    ILasFile* ipppFile = NULL;
    PyObject* py_ppFile = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lindex))
      goto ilasdataset_get_file_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index
    // No setup for ppFile

    // Call method on actual COM interface
    hr = self->m_pILasDataset->get_File(lindex, &ipppFile);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasDataset->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasDataset) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasDataset.get_File() returned %ld", (long)hr);
        goto ilasdataset_get_file_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index
    Py_XDECREF(py_ppFile);
    if (ipppFile)
    {
        IUnknown* pUnk = NULL;
        ipppFile->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppFile = IUnknownToPythonIIDObject(pUnk, &IID_ILasFile);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppFile)
    {
        if (py_ppFile)
           Py_DECREF(py_ppFile);
        py_ppFile = Py_None;
        Py_INCREF(py_ppFile);
    }
    if (PyErr_Occurred())
      goto ilasdataset_get_file_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppFile);
    goto ilasdataset_get_file_method_cleanup;

    ilasdataset_get_file_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    Py_XDECREF(py_ppFile);
    if (ipppFile)
      ipppFile->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasDataset.get_File");
    return return_tuple;
}

static PyObject*
ILasDatasetMethod_get_SurfaceConstraintCount(PyILasDatasetObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpcConstraints = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pcConstraints

    // Call method on actual COM interface
    hr = self->m_pILasDataset->get_SurfaceConstraintCount(&lpcConstraints);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasDataset->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasDataset) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasDataset.get_SurfaceConstraintCount() returned %ld", (long)hr);
        goto ilasdataset_get_surfaceconstraintcount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pcConstraints

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpcConstraints);
    goto ilasdataset_get_surfaceconstraintcount_method_cleanup;

    ilasdataset_get_surfaceconstraintcount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pcConstraints
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasDataset.get_SurfaceConstraintCount");
    return return_tuple;
}

static PyObject*
ILasDatasetMethod_GetSurfaceConstraint(PyILasDatasetObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;
    IFeatureClass* ipppClass = NULL;
    PyObject* py_ppClass = NULL;
    IField* ipppHeightField = NULL;
    PyObject* py_ppHeightField = NULL;
    IField* ipppTagField = NULL;
    PyObject* py_ppTagField = NULL;
    esriTinSurfaceType epType;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lindex))
      goto ilasdataset_getsurfaceconstraint_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index
    // No setup for ppClass
    // No setup for ppHeightField
    // No setup for ppTagField
    // No setup for pType

    // Call method on actual COM interface
    hr = self->m_pILasDataset->GetSurfaceConstraint(lindex, &ipppClass, &ipppHeightField, &ipppTagField, &epType);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasDataset->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasDataset) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasDataset.GetSurfaceConstraint() returned %ld", (long)hr);
        goto ilasdataset_getsurfaceconstraint_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index
    Py_XDECREF(py_ppClass);
    if (ipppClass)
    {
        IUnknown* pUnk = NULL;
        ipppClass->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppClass = IUnknownToPythonIIDObject(pUnk, &IID_IFeatureClass);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppClass)
    {
        if (py_ppClass)
           Py_DECREF(py_ppClass);
        py_ppClass = Py_None;
        Py_INCREF(py_ppClass);
    }
    if (PyErr_Occurred())
      goto ilasdataset_getsurfaceconstraint_method_cleanup;
    
    Py_XDECREF(py_ppHeightField);
    if (ipppHeightField)
    {
        IUnknown* pUnk = NULL;
        ipppHeightField->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppHeightField = IUnknownToPythonIIDObject(pUnk, &IID_IField);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppHeightField)
    {
        if (py_ppHeightField)
           Py_DECREF(py_ppHeightField);
        py_ppHeightField = Py_None;
        Py_INCREF(py_ppHeightField);
    }
    if (PyErr_Occurred())
      goto ilasdataset_getsurfaceconstraint_method_cleanup;
    
    Py_XDECREF(py_ppTagField);
    if (ipppTagField)
    {
        IUnknown* pUnk = NULL;
        ipppTagField->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppTagField = IUnknownToPythonIIDObject(pUnk, &IID_IField);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppTagField)
    {
        if (py_ppTagField)
           Py_DECREF(py_ppTagField);
        py_ppTagField = Py_None;
        Py_INCREF(py_ppTagField);
    }
    if (PyErr_Occurred())
      goto ilasdataset_getsurfaceconstraint_method_cleanup;
    
    // No teardown for pType

    // Initialize output tuple
    return_tuple = Py_BuildValue("OOOi",
                                            py_ppClass, py_ppHeightField, py_ppTagField, (int)epType);
    goto ilasdataset_getsurfaceconstraint_method_cleanup;

    ilasdataset_getsurfaceconstraint_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    Py_XDECREF(py_ppClass);
    if (ipppClass)
      ipppClass->Release();
    Py_XDECREF(py_ppHeightField);
    if (ipppHeightField)
      ipppHeightField->Release();
    Py_XDECREF(py_ppTagField);
    if (ipppTagField)
      ipppTagField->Release();
    // No cleanup for pType
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasDataset.GetSurfaceConstraint");
    return return_tuple;
}

static PyObject*
ILasDatasetMethod_GetSurfaceConstraintName(PyILasDatasetObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;
    IFeatureClassName* ipppName = NULL;
    PyObject* py_ppName = NULL;
    BSTR bspHeightField;
    PyObject* pyvar_pHeightField = Py_None;
    BSTR bspTagField;
    PyObject* pyvar_pTagField = Py_None;
    esriTinSurfaceType epType;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lindex))
      goto ilasdataset_getsurfaceconstraintname_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index
    // No setup for ppName
    // No setup for pHeightField
    // No setup for pTagField
    // No setup for pType

    // Call method on actual COM interface
    hr = self->m_pILasDataset->GetSurfaceConstraintName(lindex, &ipppName, &bspHeightField, &bspTagField, &epType);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasDataset->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasDataset) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasDataset.GetSurfaceConstraintName() returned %ld", (long)hr);
        goto ilasdataset_getsurfaceconstraintname_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index
    Py_XDECREF(py_ppName);
    if (ipppName)
    {
        IUnknown* pUnk = NULL;
        ipppName->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppName = IUnknownToPythonIIDObject(pUnk, &IID_IFeatureClassName);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppName)
    {
        if (py_ppName)
           Py_DECREF(py_ppName);
        py_ppName = Py_None;
        Py_INCREF(py_ppName);
    }
    if (PyErr_Occurred())
      goto ilasdataset_getsurfaceconstraintname_method_cleanup;
    
    pyvar_pHeightField = PyUnicode_FromWideChar(bspHeightField,::SysStringLen(bspHeightField));
    ::SysFreeString(bspHeightField);
    
    if (PyErr_Occurred())
      goto ilasdataset_getsurfaceconstraintname_method_cleanup;
    
    pyvar_pTagField = PyUnicode_FromWideChar(bspTagField,::SysStringLen(bspTagField));
    ::SysFreeString(bspTagField);
    
    if (PyErr_Occurred())
      goto ilasdataset_getsurfaceconstraintname_method_cleanup;
    
    // No teardown for pType

    // Initialize output tuple
    return_tuple = Py_BuildValue("OOOi",
                                            py_ppName, pyvar_pHeightField, pyvar_pTagField, (int)epType);
    goto ilasdataset_getsurfaceconstraintname_method_cleanup;

    ilasdataset_getsurfaceconstraintname_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    Py_XDECREF(py_ppName);
    if (ipppName)
      ipppName->Release();
    if (pyvar_pHeightField != Py_None)
        Py_XDECREF(pyvar_pHeightField);
    if (pyvar_pTagField != Py_None)
        Py_XDECREF(pyvar_pTagField);
    // No cleanup for pType
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasDataset.GetSurfaceConstraintName");
    return return_tuple;
}

static PyObject*
ILasDatasetMethod_GetSurfaceConstraintID(PyILasDatasetObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;
    IUID* ipppGuid = NULL;
    PyObject* py_ppGuid = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lindex))
      goto ilasdataset_getsurfaceconstraintid_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index
    // No setup for ppGuid

    // Call method on actual COM interface
    hr = self->m_pILasDataset->GetSurfaceConstraintID(lindex, &ipppGuid);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasDataset->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasDataset) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasDataset.GetSurfaceConstraintID() returned %ld", (long)hr);
        goto ilasdataset_getsurfaceconstraintid_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index
    Py_XDECREF(py_ppGuid);
    if (ipppGuid)
    {
        IUnknown* pUnk = NULL;
        ipppGuid->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppGuid = IUnknownToPythonIIDObject(pUnk, &IID_IUID);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppGuid)
    {
        if (py_ppGuid)
           Py_DECREF(py_ppGuid);
        py_ppGuid = Py_None;
        Py_INCREF(py_ppGuid);
    }
    if (PyErr_Occurred())
      goto ilasdataset_getsurfaceconstraintid_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppGuid);
    goto ilasdataset_getsurfaceconstraintid_method_cleanup;

    ilasdataset_getsurfaceconstraintid_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    Py_XDECREF(py_ppGuid);
    if (ipppGuid)
      ipppGuid->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasDataset.GetSurfaceConstraintID");
    return return_tuple;
}

static PyObject*
ILasDatasetMethod_GetSurfaceConstraintIndexFromID(PyILasDatasetObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IUID* ippGuid = NULL;
    PyObject* py_pGuid;
    long lpIndex = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_pGuid))
      goto ilasdataset_getsurfaceconstraintindexfromid_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pGuid, &IID_IUID, (void**)&ippGuid))
        PyErr_SetString(PyExc_TypeError, "Argument pGuid (position 0) is not IUID");
    
    if (PyErr_Occurred())
      goto ilasdataset_getsurfaceconstraintindexfromid_method_cleanup;
    
    // No setup for pIndex

    // Call method on actual COM interface
    hr = self->m_pILasDataset->GetSurfaceConstraintIndexFromID(ippGuid, &lpIndex);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasDataset->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasDataset) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasDataset.GetSurfaceConstraintIndexFromID() returned %ld", (long)hr);
        goto ilasdataset_getsurfaceconstraintindexfromid_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pGuid
    // No teardown for pIndex

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpIndex);
    goto ilasdataset_getsurfaceconstraintindexfromid_method_cleanup;

    ilasdataset_getsurfaceconstraintindexfromid_method_cleanup:
    self->m_HR = hr;
    if (ippGuid)
      ippGuid->Release();
    // No cleanup for pIndex
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasDataset.GetSurfaceConstraintIndexFromID");
    return return_tuple;
}

static PyObject*
ILasDatasetMethod_get_PointCount(PyILasDatasetObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dpCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pCount

    // Call method on actual COM interface
    hr = self->m_pILasDataset->get_PointCount(&dpCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasDataset->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasDataset) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasDataset.get_PointCount() returned %ld", (long)hr);
        goto ilasdataset_get_pointcount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pCount

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dpCount);
    goto ilasdataset_get_pointcount_method_cleanup;

    ilasdataset_get_pointcount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pCount
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasDataset.get_PointCount");
    return return_tuple;
}

static PyObject*
ILasDatasetMethod_get_SizeInBytes(PyILasDatasetObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dpcBytes = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pcBytes

    // Call method on actual COM interface
    hr = self->m_pILasDataset->get_SizeInBytes(&dpcBytes);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasDataset->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasDataset) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasDataset.get_SizeInBytes() returned %ld", (long)hr);
        goto ilasdataset_get_sizeinbytes_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pcBytes

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dpcBytes);
    goto ilasdataset_get_sizeinbytes_method_cleanup;

    ilasdataset_get_sizeinbytes_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pcBytes
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasDataset.get_SizeInBytes");
    return return_tuple;
}

static PyObject*
ILasDatasetMethod_get_HasStatistics(PyILasDatasetObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pbHasStats = VARIANT_FALSE;
    PyObject* pyvar_pbHasStats = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pbHasStats

    // Call method on actual COM interface
    hr = self->m_pILasDataset->get_HasStatistics(&b_pbHasStats);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasDataset->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasDataset) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasDataset.get_HasStatistics() returned %ld", (long)hr);
        goto ilasdataset_get_hasstatistics_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pbHasStats = ((b_pbHasStats == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto ilasdataset_get_hasstatistics_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pbHasStats);
    goto ilasdataset_get_hasstatistics_method_cleanup;

    ilasdataset_get_hasstatistics_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pbHasStats
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasDataset.get_HasStatistics");
    return return_tuple;
}

static PyObject*
ILasDatasetMethod_get_NeedsUpdateStatistics(PyILasDatasetObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pbNeedsUpdate = VARIANT_FALSE;
    PyObject* pyvar_pbNeedsUpdate = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pbNeedsUpdate

    // Call method on actual COM interface
    hr = self->m_pILasDataset->get_NeedsUpdateStatistics(&b_pbNeedsUpdate);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasDataset->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasDataset) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasDataset.get_NeedsUpdateStatistics() returned %ld", (long)hr);
        goto ilasdataset_get_needsupdatestatistics_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pbNeedsUpdate = ((b_pbNeedsUpdate == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto ilasdataset_get_needsupdatestatistics_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pbNeedsUpdate);
    goto ilasdataset_get_needsupdatestatistics_method_cleanup;

    ilasdataset_get_needsupdatestatistics_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pbNeedsUpdate
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasDataset.get_NeedsUpdateStatistics");
    return return_tuple;
}

static PyObject*
ILasDatasetMethod_GetStatistics(PyILasDatasetObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ILasStatistics* ipppStatistics = NULL;
    PyObject* py_ppStatistics = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppStatistics

    // Call method on actual COM interface
    hr = self->m_pILasDataset->GetStatistics(&ipppStatistics);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasDataset->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasDataset) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasDataset.GetStatistics() returned %ld", (long)hr);
        goto ilasdataset_getstatistics_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppStatistics);
    if (ipppStatistics)
    {
        IUnknown* pUnk = NULL;
        ipppStatistics->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppStatistics = IUnknownToPythonIIDObject(pUnk, &IID_ILasStatistics);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppStatistics)
    {
        if (py_ppStatistics)
           Py_DECREF(py_ppStatistics);
        py_ppStatistics = Py_None;
        Py_INCREF(py_ppStatistics);
    }
    if (PyErr_Occurred())
      goto ilasdataset_getstatistics_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppStatistics);
    goto ilasdataset_getstatistics_method_cleanup;

    ilasdataset_getstatistics_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppStatistics);
    if (ipppStatistics)
      ipppStatistics->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasDataset.GetStatistics");
    return return_tuple;
}

static PyObject*
ILasDatasetMethod_CreateDynamicSurface(PyILasDatasetObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ILasSurface* ipppSurface = NULL;
    PyObject* py_ppSurface = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppSurface

    // Call method on actual COM interface
    hr = self->m_pILasDataset->CreateDynamicSurface(&ipppSurface);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasDataset->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasDataset) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasDataset.CreateDynamicSurface() returned %ld", (long)hr);
        goto ilasdataset_createdynamicsurface_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppSurface);
    if (ipppSurface)
    {
        IUnknown* pUnk = NULL;
        ipppSurface->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppSurface = IUnknownToPythonIIDObject(pUnk, &IID_ILasSurface);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppSurface)
    {
        if (py_ppSurface)
           Py_DECREF(py_ppSurface);
        py_ppSurface = Py_None;
        Py_INCREF(py_ppSurface);
    }
    if (PyErr_Occurred())
      goto ilasdataset_createdynamicsurface_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppSurface);
    goto ilasdataset_createdynamicsurface_method_cleanup;

    ilasdataset_createdynamicsurface_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppSurface);
    if (ipppSurface)
      ipppSurface->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasDataset.CreateDynamicSurface");
    return return_tuple;
}

static PyObject*
ILasDatasetMethod_Export(PyILasDatasetObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;
    long lFileIndex = 0;
    ILasPointFilter* ippFilter = NULL;
    PyObject* py_pFilter;
    BSTR bsnewFileName = 0;
    PyObject* pyvar_newFileName;
    PyObject* unicodenewFileName = NULL;
    ISpatialReference* ippNewSpatialReference = NULL;
    PyObject* py_pNewSpatialReference;
    VARIANT_BOOL b_bProject = VARIANT_FALSE;
    PyObject* pyvar_bProject = NULL;
    VARIANT_BOOL b_bDropVLRs = VARIANT_FALSE;
    PyObject* pyvar_bDropVLRs = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OlOOOOO", &py_pTrackCancel, &lFileIndex, &py_pFilter, &pyvar_newFileName, &py_pNewSpatialReference, &pyvar_bProject, &pyvar_bDropVLRs))
      goto ilasdataset_export_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 0) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto ilasdataset_export_method_cleanup;
    
    // No setup for FileIndex
    if (!IFaceFromPyObject(py_pFilter, &IID_ILasPointFilter, (void**)&ippFilter))
        PyErr_SetString(PyExc_TypeError, "Argument pFilter (position 2) is not ILasPointFilter");
    
    if (PyErr_Occurred())
      goto ilasdataset_export_method_cleanup;
    
    if (PyString_Check(pyvar_newFileName))
        unicodenewFileName = PyUnicode_FromObject(pyvar_newFileName);
    else if (PyUnicode_Check(pyvar_newFileName))
    {
        unicodenewFileName = pyvar_newFileName;
        Py_INCREF(unicodenewFileName);
    }
    else if (pyvar_newFileName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter newFileName at index 3");
    if (unicodenewFileName)
        bsnewFileName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodenewFileName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodenewFileName));
    
    if (PyErr_Occurred())
      goto ilasdataset_export_method_cleanup;
    
    if (!IFaceFromPyObject(py_pNewSpatialReference, &IID_ISpatialReference, (void**)&ippNewSpatialReference))
        PyErr_SetString(PyExc_TypeError, "Argument pNewSpatialReference (position 4) is not ISpatialReference");
    
    if (PyErr_Occurred())
      goto ilasdataset_export_method_cleanup;
    
    b_bProject = ((PyObject_IsTrue(pyvar_bProject) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto ilasdataset_export_method_cleanup;
    
    b_bDropVLRs = ((PyObject_IsTrue(pyvar_bDropVLRs) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto ilasdataset_export_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pILasDataset->Export(ippTrackCancel, lFileIndex, ippFilter, bsnewFileName, ippNewSpatialReference, b_bProject, b_bDropVLRs);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasDataset->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasDataset) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasDataset.Export() returned %ld", (long)hr);
        goto ilasdataset_export_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pTrackCancel
    // No teardown for FileIndex
    // No teardown for pFilter
    // No teardown for newFileName
    // No teardown for pNewSpatialReference
    // No teardown for bProject
    // No teardown for bDropVLRs

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ilasdataset_export_method_cleanup;

    ilasdataset_export_method_cleanup:
    self->m_HR = hr;
    if (ippTrackCancel)
      ippTrackCancel->Release();
    // No cleanup for FileIndex
    if (ippFilter)
      ippFilter->Release();
    if (bsnewFileName)
        ::SysFreeString(bsnewFileName);
    
    if (ippNewSpatialReference)
      ippNewSpatialReference->Release();
    // No cleanup for bProject
    // No cleanup for bDropVLRs
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasDataset.Export");
    return return_tuple;
}


PyMethodDef PyILasDatasetMethods[] = {
    {"supports", (PyCFunction)PyILasDataset_SupportsInterface, METH_O, ""},
    {"SetEmpty", (PyCFunction)ILasDatasetMethod_SetEmpty, METH_NOARGS, ""},
    {"Init", (PyCFunction)ILasDatasetMethod_Init, METH_VARARGS, ""},
    {"SaveAs", (PyCFunction)ILasDatasetMethod_SaveAs, METH_VARARGS, ""},
    {"get_Name", (PyCFunction)ILasDatasetMethod_get_Name, METH_VARARGS, ""},
    {"get_UsesRelativePath", (PyCFunction)ILasDatasetMethod_get_UsesRelativePath, METH_VARARGS, ""},
    {"get_IsDirty", (PyCFunction)ILasDatasetMethod_get_IsDirty, METH_VARARGS, ""},
    {"get_SpatialReference", (PyCFunction)ILasDatasetMethod_get_SpatialReference, METH_VARARGS, ""},
    {"get_Extent", (PyCFunction)ILasDatasetMethod_get_Extent, METH_VARARGS, ""},
    {"get_FileCount", (PyCFunction)ILasDatasetMethod_get_FileCount, METH_VARARGS, ""},
    {"get_File", (PyCFunction)ILasDatasetMethod_get_File, METH_VARARGS, ""},
    {"get_SurfaceConstraintCount", (PyCFunction)ILasDatasetMethod_get_SurfaceConstraintCount, METH_VARARGS, ""},
    {"GetSurfaceConstraint", (PyCFunction)ILasDatasetMethod_GetSurfaceConstraint, METH_VARARGS, ""},
    {"GetSurfaceConstraintName", (PyCFunction)ILasDatasetMethod_GetSurfaceConstraintName, METH_VARARGS, ""},
    {"GetSurfaceConstraintID", (PyCFunction)ILasDatasetMethod_GetSurfaceConstraintID, METH_VARARGS, ""},
    {"GetSurfaceConstraintIndexFromID", (PyCFunction)ILasDatasetMethod_GetSurfaceConstraintIndexFromID, METH_VARARGS, ""},
    {"get_PointCount", (PyCFunction)ILasDatasetMethod_get_PointCount, METH_VARARGS, ""},
    {"get_SizeInBytes", (PyCFunction)ILasDatasetMethod_get_SizeInBytes, METH_VARARGS, ""},
    {"get_HasStatistics", (PyCFunction)ILasDatasetMethod_get_HasStatistics, METH_VARARGS, ""},
    {"get_NeedsUpdateStatistics", (PyCFunction)ILasDatasetMethod_get_NeedsUpdateStatistics, METH_VARARGS, ""},
    {"GetStatistics", (PyCFunction)ILasDatasetMethod_GetStatistics, METH_VARARGS, ""},
    {"CreateDynamicSurface", (PyCFunction)ILasDatasetMethod_CreateDynamicSurface, METH_VARARGS, ""},
    {"Export", (PyCFunction)ILasDatasetMethod_Export, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyILasDatasetGetSet[] = {
  {"_pUnk", (getter)PyILasDataset_GetpUnk, NULL, "Get opaque pointer to an Unknown from ILasDataset", NULL},
  {"_pointer", (getter)PyILasDataset_GetPointer, NULL, "Get memory address for ILasDataset", NULL},
  {"_IID", (getter)PyILasDataset_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyILasDataset_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyILasDataset_GetIgnoreFailures, (setter)PyILasDataset_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyILasDatasetObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.ILasDatasetObject",                          
                                              /* tp_name */
  sizeof(PyILasDatasetObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyILasDatasetObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyILasDatasetMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyILasDatasetGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyILasDatasetObject_new,                      
                                              /* tp_new */
};

// Interface ILasDatasetEdit

typedef struct PyILasDatasetEditObject {
    PyObject_HEAD
    ILasDatasetEdit* m_pILasDatasetEdit;
    HRESULT m_HR;
    int m_ignore_failures;
} PyILasDatasetEditObject;

static PyObject*
PyILasDatasetEditObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyILasDatasetEditObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ILasDatasetEdit* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ILasDatasetEdit, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ILasDatasetEdit with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyILasDatasetEditObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ILasDatasetEdit");
            return NULL;
        }
        self->m_pILasDatasetEdit = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ILasDatasetEdit");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ILasDatasetEdit");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ILasDatasetEdit* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ILasDatasetEdit, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ILasDatasetEdit");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyILasDatasetEditObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ILasDatasetEdit");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pILasDatasetEdit = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyILasDatasetEditObject_dealloc(PyILasDatasetEditObject* self)
{
    if (self->m_pILasDatasetEdit)
        self->m_pILasDatasetEdit->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyILasDatasetEdit_GetpUnk(PyILasDatasetEditObject* self)
{
    if (!self->m_pILasDatasetEdit)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pILasDatasetEdit->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ILasDatasetEdit to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyILasDatasetEdit_GetPointer(PyILasDatasetEditObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pILasDatasetEdit);
}

static PyObject*
PyILasDatasetEdit_GetIID(PyILasDatasetEditObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "ca6228e2-eb8f-442f-88cb-5e40233e88e8");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyILasDatasetEdit_GetHR(PyILasDatasetEditObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyILasDatasetEdit_GetIgnoreFailures(PyILasDatasetEditObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyILasDatasetEdit_SetIgnoreFailures(PyILasDatasetEditObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyILasDatasetEdit_SupportsInterface(PyILasDatasetEditObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pILasDatasetEdit->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ILasDatasetEditMethod_Save(PyILasDatasetEditObject* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pILasDatasetEdit->Save();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasDatasetEdit->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasDatasetEdit) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasDatasetEdit.Save() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}

static PyObject*
ILasDatasetEditMethod_put_UsesRelativePath(PyILasDatasetEditObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b__arg1 = VARIANT_FALSE;
    PyObject* pyvar__arg1 = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar__arg1))
      goto ilasdatasetedit_put_usesrelativepath_method_cleanup;

    // Set up initial variable values as needed
    b__arg1 = ((PyObject_IsTrue(pyvar__arg1) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto ilasdatasetedit_put_usesrelativepath_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pILasDatasetEdit->put_UsesRelativePath(b__arg1);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasDatasetEdit->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasDatasetEdit) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasDatasetEdit.put_UsesRelativePath() returned %ld", (long)hr);
        goto ilasdatasetedit_put_usesrelativepath_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for _arg1

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ilasdatasetedit_put_usesrelativepath_method_cleanup;

    ilasdatasetedit_put_usesrelativepath_method_cleanup:
    self->m_HR = hr;
    // No cleanup for _arg1
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasDatasetEdit.put_UsesRelativePath");
    return return_tuple;
}

static PyObject*
ILasDatasetEditMethod_SetSpatialReference(PyILasDatasetEditObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ISpatialReference* ippSpatialReference = NULL;
    PyObject* py_pSpatialReference;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_pSpatialReference))
      goto ilasdatasetedit_setspatialreference_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pSpatialReference, &IID_ISpatialReference, (void**)&ippSpatialReference))
        PyErr_SetString(PyExc_TypeError, "Argument pSpatialReference (position 0) is not ISpatialReference");
    
    if (PyErr_Occurred())
      goto ilasdatasetedit_setspatialreference_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pILasDatasetEdit->SetSpatialReference(ippSpatialReference);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasDatasetEdit->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasDatasetEdit) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasDatasetEdit.SetSpatialReference() returned %ld", (long)hr);
        goto ilasdatasetedit_setspatialreference_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pSpatialReference

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ilasdatasetedit_setspatialreference_method_cleanup;

    ilasdatasetedit_setspatialreference_method_cleanup:
    self->m_HR = hr;
    if (ippSpatialReference)
      ippSpatialReference->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasDatasetEdit.SetSpatialReference");
    return return_tuple;
}

static PyObject*
ILasDatasetEditMethod_AddFile(PyILasDatasetEditObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsfileName = 0;
    PyObject* pyvar_fileName;
    PyObject* unicodefileName = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_fileName))
      goto ilasdatasetedit_addfile_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_fileName))
        unicodefileName = PyUnicode_FromObject(pyvar_fileName);
    else if (PyUnicode_Check(pyvar_fileName))
    {
        unicodefileName = pyvar_fileName;
        Py_INCREF(unicodefileName);
    }
    else if (pyvar_fileName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter fileName at index 0");
    if (unicodefileName)
        bsfileName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodefileName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodefileName));
    
    if (PyErr_Occurred())
      goto ilasdatasetedit_addfile_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pILasDatasetEdit->AddFile(bsfileName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasDatasetEdit->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasDatasetEdit) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasDatasetEdit.AddFile() returned %ld", (long)hr);
        goto ilasdatasetedit_addfile_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for fileName

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ilasdatasetedit_addfile_method_cleanup;

    ilasdatasetedit_addfile_method_cleanup:
    self->m_HR = hr;
    if (bsfileName)
        ::SysFreeString(bsfileName);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasDatasetEdit.AddFile");
    return return_tuple;
}

static PyObject*
ILasDatasetEditMethod_AddFolder(PyILasDatasetEditObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsfolderName = 0;
    PyObject* pyvar_folderName;
    PyObject* unicodefolderName = NULL;
    BSTR bsfileExtension = 0;
    PyObject* pyvar_fileExtension;
    PyObject* unicodefileExtension = NULL;
    VARIANT_BOOL b_bRecursive = VARIANT_FALSE;
    PyObject* pyvar_bRecursive = NULL;
    IStringArray* ipppBadFiles = NULL;
    PyObject* py_ppBadFiles = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOO", &pyvar_folderName, &pyvar_fileExtension, &pyvar_bRecursive))
      goto ilasdatasetedit_addfolder_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_folderName))
        unicodefolderName = PyUnicode_FromObject(pyvar_folderName);
    else if (PyUnicode_Check(pyvar_folderName))
    {
        unicodefolderName = pyvar_folderName;
        Py_INCREF(unicodefolderName);
    }
    else if (pyvar_folderName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter folderName at index 0");
    if (unicodefolderName)
        bsfolderName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodefolderName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodefolderName));
    
    if (PyErr_Occurred())
      goto ilasdatasetedit_addfolder_method_cleanup;
    
    if (PyString_Check(pyvar_fileExtension))
        unicodefileExtension = PyUnicode_FromObject(pyvar_fileExtension);
    else if (PyUnicode_Check(pyvar_fileExtension))
    {
        unicodefileExtension = pyvar_fileExtension;
        Py_INCREF(unicodefileExtension);
    }
    else if (pyvar_fileExtension != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter fileExtension at index 1");
    if (unicodefileExtension)
        bsfileExtension = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodefileExtension), 
                                            (UINT)PyUnicode_GET_SIZE(unicodefileExtension));
    
    if (PyErr_Occurred())
      goto ilasdatasetedit_addfolder_method_cleanup;
    
    b_bRecursive = ((PyObject_IsTrue(pyvar_bRecursive) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto ilasdatasetedit_addfolder_method_cleanup;
    
    // No setup for ppBadFiles

    // Call method on actual COM interface
    hr = self->m_pILasDatasetEdit->AddFolder(bsfolderName, bsfileExtension, b_bRecursive, &ipppBadFiles);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasDatasetEdit->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasDatasetEdit) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasDatasetEdit.AddFolder() returned %ld", (long)hr);
        goto ilasdatasetedit_addfolder_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for folderName
    // No teardown for fileExtension
    // No teardown for bRecursive
    Py_XDECREF(py_ppBadFiles);
    if (ipppBadFiles)
    {
        IUnknown* pUnk = NULL;
        ipppBadFiles->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppBadFiles = IUnknownToPythonIIDObject(pUnk, &IID_IStringArray);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppBadFiles)
    {
        if (py_ppBadFiles)
           Py_DECREF(py_ppBadFiles);
        py_ppBadFiles = Py_None;
        Py_INCREF(py_ppBadFiles);
    }
    if (PyErr_Occurred())
      goto ilasdatasetedit_addfolder_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppBadFiles);
    goto ilasdatasetedit_addfolder_method_cleanup;

    ilasdatasetedit_addfolder_method_cleanup:
    self->m_HR = hr;
    if (bsfolderName)
        ::SysFreeString(bsfolderName);
    
    if (bsfileExtension)
        ::SysFreeString(bsfileExtension);
    
    // No cleanup for bRecursive
    Py_XDECREF(py_ppBadFiles);
    if (ipppBadFiles)
      ipppBadFiles->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasDatasetEdit.AddFolder");
    return return_tuple;
}

static PyObject*
ILasDatasetEditMethod_RemoveFile(PyILasDatasetEditObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lindex))
      goto ilasdatasetedit_removefile_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index

    // Call method on actual COM interface
    hr = self->m_pILasDatasetEdit->RemoveFile(lindex);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasDatasetEdit->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasDatasetEdit) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasDatasetEdit.RemoveFile() returned %ld", (long)hr);
        goto ilasdatasetedit_removefile_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ilasdatasetedit_removefile_method_cleanup;

    ilasdatasetedit_removefile_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasDatasetEdit.RemoveFile");
    return return_tuple;
}

static PyObject*
ILasDatasetEditMethod_RemoveFileByName(PyILasDatasetEditObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsfileName = 0;
    PyObject* pyvar_fileName;
    PyObject* unicodefileName = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_fileName))
      goto ilasdatasetedit_removefilebyname_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_fileName))
        unicodefileName = PyUnicode_FromObject(pyvar_fileName);
    else if (PyUnicode_Check(pyvar_fileName))
    {
        unicodefileName = pyvar_fileName;
        Py_INCREF(unicodefileName);
    }
    else if (pyvar_fileName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter fileName at index 0");
    if (unicodefileName)
        bsfileName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodefileName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodefileName));
    
    if (PyErr_Occurred())
      goto ilasdatasetedit_removefilebyname_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pILasDatasetEdit->RemoveFileByName(bsfileName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasDatasetEdit->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasDatasetEdit) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasDatasetEdit.RemoveFileByName() returned %ld", (long)hr);
        goto ilasdatasetedit_removefilebyname_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for fileName

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ilasdatasetedit_removefilebyname_method_cleanup;

    ilasdatasetedit_removefilebyname_method_cleanup:
    self->m_HR = hr;
    if (bsfileName)
        ::SysFreeString(bsfileName);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasDatasetEdit.RemoveFileByName");
    return return_tuple;
}

static PyObject*
ILasDatasetEditMethod_AddSurfaceConstraint(PyILasDatasetEditObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IFeatureClass* ippFeatureClass = NULL;
    PyObject* py_pFeatureClass;
    IField* ippHeightField = NULL;
    PyObject* py_pHeightField;
    IField* ippTagField = NULL;
    PyObject* py_pTagField;
    esriTinSurfaceType eType;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOOi", &py_pFeatureClass, &py_pHeightField, &py_pTagField, (int *)&eType))
      goto ilasdatasetedit_addsurfaceconstraint_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pFeatureClass, &IID_IFeatureClass, (void**)&ippFeatureClass))
        PyErr_SetString(PyExc_TypeError, "Argument pFeatureClass (position 0) is not IFeatureClass");
    
    if (PyErr_Occurred())
      goto ilasdatasetedit_addsurfaceconstraint_method_cleanup;
    
    if (!IFaceFromPyObject(py_pHeightField, &IID_IField, (void**)&ippHeightField))
        PyErr_SetString(PyExc_TypeError, "Argument pHeightField (position 1) is not IField");
    
    if (PyErr_Occurred())
      goto ilasdatasetedit_addsurfaceconstraint_method_cleanup;
    
    if (!IFaceFromPyObject(py_pTagField, &IID_IField, (void**)&ippTagField))
        PyErr_SetString(PyExc_TypeError, "Argument pTagField (position 2) is not IField");
    
    if (PyErr_Occurred())
      goto ilasdatasetedit_addsurfaceconstraint_method_cleanup;
    
    // No setup for Type

    // Call method on actual COM interface
    hr = self->m_pILasDatasetEdit->AddSurfaceConstraint(ippFeatureClass, ippHeightField, ippTagField, eType);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasDatasetEdit->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasDatasetEdit) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasDatasetEdit.AddSurfaceConstraint() returned %ld", (long)hr);
        goto ilasdatasetedit_addsurfaceconstraint_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pFeatureClass
    // No teardown for pHeightField
    // No teardown for pTagField
    // No teardown for Type

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ilasdatasetedit_addsurfaceconstraint_method_cleanup;

    ilasdatasetedit_addsurfaceconstraint_method_cleanup:
    self->m_HR = hr;
    if (ippFeatureClass)
      ippFeatureClass->Release();
    if (ippHeightField)
      ippHeightField->Release();
    if (ippTagField)
      ippTagField->Release();
    // No cleanup for Type
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasDatasetEdit.AddSurfaceConstraint");
    return return_tuple;
}

static PyObject*
ILasDatasetEditMethod_RemoveSurfaceConstraint(PyILasDatasetEditObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IFeatureClass* ippFeatureClass = NULL;
    PyObject* py_pFeatureClass;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_pFeatureClass))
      goto ilasdatasetedit_removesurfaceconstraint_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pFeatureClass, &IID_IFeatureClass, (void**)&ippFeatureClass))
        PyErr_SetString(PyExc_TypeError, "Argument pFeatureClass (position 0) is not IFeatureClass");
    
    if (PyErr_Occurred())
      goto ilasdatasetedit_removesurfaceconstraint_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pILasDatasetEdit->RemoveSurfaceConstraint(ippFeatureClass);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasDatasetEdit->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasDatasetEdit) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasDatasetEdit.RemoveSurfaceConstraint() returned %ld", (long)hr);
        goto ilasdatasetedit_removesurfaceconstraint_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pFeatureClass

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ilasdatasetedit_removesurfaceconstraint_method_cleanup;

    ilasdatasetedit_removesurfaceconstraint_method_cleanup:
    self->m_HR = hr;
    if (ippFeatureClass)
      ippFeatureClass->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasDatasetEdit.RemoveSurfaceConstraint");
    return return_tuple;
}

static PyObject*
ILasDatasetEditMethod_RemoveSurfaceConstraintByID(PyILasDatasetEditObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IUID* ippGuid = NULL;
    PyObject* py_pGuid;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_pGuid))
      goto ilasdatasetedit_removesurfaceconstraintbyid_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pGuid, &IID_IUID, (void**)&ippGuid))
        PyErr_SetString(PyExc_TypeError, "Argument pGuid (position 0) is not IUID");
    
    if (PyErr_Occurred())
      goto ilasdatasetedit_removesurfaceconstraintbyid_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pILasDatasetEdit->RemoveSurfaceConstraintByID(ippGuid);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasDatasetEdit->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasDatasetEdit) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasDatasetEdit.RemoveSurfaceConstraintByID() returned %ld", (long)hr);
        goto ilasdatasetedit_removesurfaceconstraintbyid_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pGuid

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ilasdatasetedit_removesurfaceconstraintbyid_method_cleanup;

    ilasdatasetedit_removesurfaceconstraintbyid_method_cleanup:
    self->m_HR = hr;
    if (ippGuid)
      ippGuid->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasDatasetEdit.RemoveSurfaceConstraintByID");
    return return_tuple;
}

static PyObject*
ILasDatasetEditMethod_CalculateStatistics(PyILasDatasetEditObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;
    VARIANT_BOOL b_bForce = VARIANT_FALSE;
    PyObject* pyvar_bForce = NULL;
    ILongArray* ipppBadFiles = NULL;
    PyObject* py_ppBadFiles = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OO", &py_pTrackCancel, &pyvar_bForce))
      goto ilasdatasetedit_calculatestatistics_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 0) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto ilasdatasetedit_calculatestatistics_method_cleanup;
    
    b_bForce = ((PyObject_IsTrue(pyvar_bForce) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto ilasdatasetedit_calculatestatistics_method_cleanup;
    
    // No setup for ppBadFiles

    // Call method on actual COM interface
    hr = self->m_pILasDatasetEdit->CalculateStatistics(ippTrackCancel, b_bForce, &ipppBadFiles);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasDatasetEdit->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasDatasetEdit) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasDatasetEdit.CalculateStatistics() returned %ld", (long)hr);
        goto ilasdatasetedit_calculatestatistics_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pTrackCancel
    // No teardown for bForce
    Py_XDECREF(py_ppBadFiles);
    if (ipppBadFiles)
    {
        IUnknown* pUnk = NULL;
        ipppBadFiles->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppBadFiles = IUnknownToPythonIIDObject(pUnk, &IID_ILongArray);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppBadFiles)
    {
        if (py_ppBadFiles)
           Py_DECREF(py_ppBadFiles);
        py_ppBadFiles = Py_None;
        Py_INCREF(py_ppBadFiles);
    }
    if (PyErr_Occurred())
      goto ilasdatasetedit_calculatestatistics_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppBadFiles);
    goto ilasdatasetedit_calculatestatistics_method_cleanup;

    ilasdatasetedit_calculatestatistics_method_cleanup:
    self->m_HR = hr;
    if (ippTrackCancel)
      ippTrackCancel->Release();
    // No cleanup for bForce
    Py_XDECREF(py_ppBadFiles);
    if (ipppBadFiles)
      ipppBadFiles->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasDatasetEdit.CalculateStatistics");
    return return_tuple;
}

static PyObject*
ILasDatasetEditMethod_CalculateFileStatistics(PyILasDatasetEditObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;
    long lindex = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "Ol", &py_pTrackCancel, &lindex))
      goto ilasdatasetedit_calculatefilestatistics_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 0) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto ilasdatasetedit_calculatefilestatistics_method_cleanup;
    
    // No setup for index

    // Call method on actual COM interface
    hr = self->m_pILasDatasetEdit->CalculateFileStatistics(ippTrackCancel, lindex);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasDatasetEdit->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasDatasetEdit) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasDatasetEdit.CalculateFileStatistics() returned %ld", (long)hr);
        goto ilasdatasetedit_calculatefilestatistics_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pTrackCancel
    // No teardown for index

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ilasdatasetedit_calculatefilestatistics_method_cleanup;

    ilasdatasetedit_calculatefilestatistics_method_cleanup:
    self->m_HR = hr;
    if (ippTrackCancel)
      ippTrackCancel->Release();
    // No cleanup for index
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasDatasetEdit.CalculateFileStatistics");
    return return_tuple;
}


PyMethodDef PyILasDatasetEditMethods[] = {
    {"supports", (PyCFunction)PyILasDatasetEdit_SupportsInterface, METH_O, ""},
    {"Save", (PyCFunction)ILasDatasetEditMethod_Save, METH_NOARGS, ""},
    {"put_UsesRelativePath", (PyCFunction)ILasDatasetEditMethod_put_UsesRelativePath, METH_VARARGS, ""},
    {"SetSpatialReference", (PyCFunction)ILasDatasetEditMethod_SetSpatialReference, METH_VARARGS, ""},
    {"AddFile", (PyCFunction)ILasDatasetEditMethod_AddFile, METH_VARARGS, ""},
    {"AddFolder", (PyCFunction)ILasDatasetEditMethod_AddFolder, METH_VARARGS, ""},
    {"RemoveFile", (PyCFunction)ILasDatasetEditMethod_RemoveFile, METH_VARARGS, ""},
    {"RemoveFileByName", (PyCFunction)ILasDatasetEditMethod_RemoveFileByName, METH_VARARGS, ""},
    {"AddSurfaceConstraint", (PyCFunction)ILasDatasetEditMethod_AddSurfaceConstraint, METH_VARARGS, ""},
    {"RemoveSurfaceConstraint", (PyCFunction)ILasDatasetEditMethod_RemoveSurfaceConstraint, METH_VARARGS, ""},
    {"RemoveSurfaceConstraintByID", (PyCFunction)ILasDatasetEditMethod_RemoveSurfaceConstraintByID, METH_VARARGS, ""},
    {"CalculateStatistics", (PyCFunction)ILasDatasetEditMethod_CalculateStatistics, METH_VARARGS, ""},
    {"CalculateFileStatistics", (PyCFunction)ILasDatasetEditMethod_CalculateFileStatistics, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyILasDatasetEditGetSet[] = {
  {"_pUnk", (getter)PyILasDatasetEdit_GetpUnk, NULL, "Get opaque pointer to an Unknown from ILasDatasetEdit", NULL},
  {"_pointer", (getter)PyILasDatasetEdit_GetPointer, NULL, "Get memory address for ILasDatasetEdit", NULL},
  {"_IID", (getter)PyILasDatasetEdit_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyILasDatasetEdit_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyILasDatasetEdit_GetIgnoreFailures, (setter)PyILasDatasetEdit_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyILasDatasetEditObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.ILasDatasetEditObject",                          
                                              /* tp_name */
  sizeof(PyILasDatasetEditObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyILasDatasetEditObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyILasDatasetEditMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyILasDatasetEditGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyILasDatasetEditObject_new,                      
                                              /* tp_new */
};

// Interface IEnumLasPoint

typedef struct PyIEnumLasPointObject {
    PyObject_HEAD
    IEnumLasPoint* m_pIEnumLasPoint;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIEnumLasPointObject;

static PyObject*
PyIEnumLasPointObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIEnumLasPointObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IEnumLasPoint* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IEnumLasPoint, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IEnumLasPoint with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIEnumLasPointObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IEnumLasPoint");
            return NULL;
        }
        self->m_pIEnumLasPoint = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IEnumLasPoint");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IEnumLasPoint");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IEnumLasPoint* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IEnumLasPoint, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IEnumLasPoint");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIEnumLasPointObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IEnumLasPoint");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIEnumLasPoint = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIEnumLasPointObject_dealloc(PyIEnumLasPointObject* self)
{
    if (self->m_pIEnumLasPoint)
        self->m_pIEnumLasPoint->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIEnumLasPoint_GetpUnk(PyIEnumLasPointObject* self)
{
    if (!self->m_pIEnumLasPoint)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIEnumLasPoint->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IEnumLasPoint to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIEnumLasPoint_GetPointer(PyIEnumLasPointObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIEnumLasPoint);
}

static PyObject*
PyIEnumLasPoint_GetIID(PyIEnumLasPointObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "41a9ea2b-b551-4987-a354-7fd3fe6dfc5e");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIEnumLasPoint_GetHR(PyIEnumLasPointObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIEnumLasPoint_GetIgnoreFailures(PyIEnumLasPointObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIEnumLasPoint_SetIgnoreFailures(PyIEnumLasPointObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIEnumLasPoint_SupportsInterface(PyIEnumLasPointObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIEnumLasPoint->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IEnumLasPointMethod_put_Attribute(PyIEnumLasPointObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriLasAttributeType epAttribute;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&epAttribute))
      goto ienumlaspoint_put_attribute_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pAttribute

    // Call method on actual COM interface
    hr = self->m_pIEnumLasPoint->put_Attribute(epAttribute);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIEnumLasPoint->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IEnumLasPoint) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IEnumLasPoint.put_Attribute() returned %ld", (long)hr);
        goto ienumlaspoint_put_attribute_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pAttribute

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ienumlaspoint_put_attribute_method_cleanup;

    ienumlaspoint_put_attribute_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pAttribute
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IEnumLasPoint.put_Attribute");
    return return_tuple;
}

static PyObject*
IEnumLasPointMethod_get_Attribute(PyIEnumLasPointObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriLasAttributeType epAttribute;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pAttribute

    // Call method on actual COM interface
    hr = self->m_pIEnumLasPoint->get_Attribute(&epAttribute);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIEnumLasPoint->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IEnumLasPoint) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IEnumLasPoint.get_Attribute() returned %ld", (long)hr);
        goto ienumlaspoint_get_attribute_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pAttribute

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)epAttribute);
    goto ienumlaspoint_get_attribute_method_cleanup;

    ienumlaspoint_get_attribute_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pAttribute
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IEnumLasPoint.get_Attribute");
    return return_tuple;
}

static PyObject*
IEnumLasPointMethod_Reset(PyIEnumLasPointObject* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pIEnumLasPoint->Reset();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIEnumLasPoint->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IEnumLasPoint) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IEnumLasPoint.Reset() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}

static PyObject*
IEnumLasPointMethod_Next(PyIEnumLasPointObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long larraySize = 0;
    long lpPointCount = 0;
    WKSPointZ spPoints;
    PyObject* py_pPoints = NULL;
    ILongArray* ippIntensity = NULL;
    PyObject* py_pIntensity;
    ILongArray* ippFileIndices = NULL;
    PyObject* py_pFileIndices;
    IDoubleArray* ippPointIDs = NULL;
    PyObject* py_pPointIDs;

    // Unpack values
    if (!PyArg_ParseTuple(args, "lOOO", &larraySize, &py_pIntensity, &py_pFileIndices, &py_pPointIDs))
      goto ienumlaspoint_next_method_cleanup;

    // Set up initial variable values as needed
    // No setup for arraySize
    // No setup for pPointCount
    // No setup for pPoints
    if (!IFaceFromPyObject(py_pIntensity, &IID_ILongArray, (void**)&ippIntensity))
        PyErr_SetString(PyExc_TypeError, "Argument pIntensity (position 3) is not ILongArray");
    
    if (PyErr_Occurred())
      goto ienumlaspoint_next_method_cleanup;
    
    if (!IFaceFromPyObject(py_pFileIndices, &IID_ILongArray, (void**)&ippFileIndices))
        PyErr_SetString(PyExc_TypeError, "Argument pFileIndices (position 4) is not ILongArray");
    
    if (PyErr_Occurred())
      goto ienumlaspoint_next_method_cleanup;
    
    if (!IFaceFromPyObject(py_pPointIDs, &IID_IDoubleArray, (void**)&ippPointIDs))
        PyErr_SetString(PyExc_TypeError, "Argument pPointIDs (position 5) is not IDoubleArray");
    
    if (PyErr_Occurred())
      goto ienumlaspoint_next_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIEnumLasPoint->Next(larraySize, &lpPointCount, &spPoints, ippIntensity, ippFileIndices, ippPointIDs);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIEnumLasPoint->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IEnumLasPoint) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IEnumLasPoint.Next() returned %ld", (long)hr);
        goto ienumlaspoint_next_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for arraySize
    // No teardown for pPointCount
    py_pPoints = PyByteArray_FromStringAndSize((char*)&spPoints, sizeof(WKSPointZ));
    PyObject* RecordWrappPoints = NULL;
    if (g_pRecordMap && (RecordWrappPoints = PyDict_GetItemString(g_pRecordMap, "WKSPointZ")))
    {
        PyObject* NewObj = PyObject_CallFunctionObjArgs(RecordWrappPoints, py_pPoints, NULL);
        if (NewObj)
        {
            Py_XDECREF(py_pPoints);
            py_pPoints = NewObj;
        }
        else
            PyErr_Clear();
    }
    else if (g_pRecordMap && !RecordWrappPoints)
        PyErr_Clear();
    Py_XDECREF(RecordWrappPoints);
    
    if (PyErr_Occurred())
      goto ienumlaspoint_next_method_cleanup;
    
    // No teardown for pIntensity
    // No teardown for pFileIndices
    // No teardown for pPointIDs

    // Initialize output tuple
    return_tuple = Py_BuildValue("lO",
                                            lpPointCount, py_pPoints);
    goto ienumlaspoint_next_method_cleanup;

    ienumlaspoint_next_method_cleanup:
    self->m_HR = hr;
    // No cleanup for arraySize
    // No cleanup for pPointCount
    Py_XDECREF(py_pPoints);
    if (ippIntensity)
      ippIntensity->Release();
    if (ippFileIndices)
      ippFileIndices->Release();
    if (ippPointIDs)
      ippPointIDs->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IEnumLasPoint.Next");
    return return_tuple;
}

static PyObject*
IEnumLasPointMethod_NextAttrLong(PyIEnumLasPointObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long larraySize = 0;
    long lpPointCount = 0;
    WKSPointZ spPoints;
    PyObject* py_pPoints = NULL;
    long lpAttribute = 0;
    ILongArray* ippIntensity = NULL;
    PyObject* py_pIntensity;
    ILongArray* ippFileIndices = NULL;
    PyObject* py_pFileIndices;
    IDoubleArray* ippPointIDs = NULL;
    PyObject* py_pPointIDs;

    // Unpack values
    if (!PyArg_ParseTuple(args, "lOOO", &larraySize, &py_pIntensity, &py_pFileIndices, &py_pPointIDs))
      goto ienumlaspoint_nextattrlong_method_cleanup;

    // Set up initial variable values as needed
    // No setup for arraySize
    // No setup for pPointCount
    // No setup for pPoints
    // No setup for pAttribute
    if (!IFaceFromPyObject(py_pIntensity, &IID_ILongArray, (void**)&ippIntensity))
        PyErr_SetString(PyExc_TypeError, "Argument pIntensity (position 4) is not ILongArray");
    
    if (PyErr_Occurred())
      goto ienumlaspoint_nextattrlong_method_cleanup;
    
    if (!IFaceFromPyObject(py_pFileIndices, &IID_ILongArray, (void**)&ippFileIndices))
        PyErr_SetString(PyExc_TypeError, "Argument pFileIndices (position 5) is not ILongArray");
    
    if (PyErr_Occurred())
      goto ienumlaspoint_nextattrlong_method_cleanup;
    
    if (!IFaceFromPyObject(py_pPointIDs, &IID_IDoubleArray, (void**)&ippPointIDs))
        PyErr_SetString(PyExc_TypeError, "Argument pPointIDs (position 6) is not IDoubleArray");
    
    if (PyErr_Occurred())
      goto ienumlaspoint_nextattrlong_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIEnumLasPoint->NextAttrLong(larraySize, &lpPointCount, &spPoints, &lpAttribute, ippIntensity, ippFileIndices, ippPointIDs);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIEnumLasPoint->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IEnumLasPoint) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IEnumLasPoint.NextAttrLong() returned %ld", (long)hr);
        goto ienumlaspoint_nextattrlong_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for arraySize
    // No teardown for pPointCount
    py_pPoints = PyByteArray_FromStringAndSize((char*)&spPoints, sizeof(WKSPointZ));
    PyObject* RecordWrappPoints = NULL;
    if (g_pRecordMap && (RecordWrappPoints = PyDict_GetItemString(g_pRecordMap, "WKSPointZ")))
    {
        PyObject* NewObj = PyObject_CallFunctionObjArgs(RecordWrappPoints, py_pPoints, NULL);
        if (NewObj)
        {
            Py_XDECREF(py_pPoints);
            py_pPoints = NewObj;
        }
        else
            PyErr_Clear();
    }
    else if (g_pRecordMap && !RecordWrappPoints)
        PyErr_Clear();
    Py_XDECREF(RecordWrappPoints);
    
    if (PyErr_Occurred())
      goto ienumlaspoint_nextattrlong_method_cleanup;
    
    // No teardown for pAttribute
    // No teardown for pIntensity
    // No teardown for pFileIndices
    // No teardown for pPointIDs

    // Initialize output tuple
    return_tuple = Py_BuildValue("lOl",
                                            lpPointCount, py_pPoints, lpAttribute);
    goto ienumlaspoint_nextattrlong_method_cleanup;

    ienumlaspoint_nextattrlong_method_cleanup:
    self->m_HR = hr;
    // No cleanup for arraySize
    // No cleanup for pPointCount
    Py_XDECREF(py_pPoints);
    // No cleanup for pAttribute
    if (ippIntensity)
      ippIntensity->Release();
    if (ippFileIndices)
      ippFileIndices->Release();
    if (ippPointIDs)
      ippPointIDs->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IEnumLasPoint.NextAttrLong");
    return return_tuple;
}

static PyObject*
IEnumLasPointMethod_NextAttrDbl(PyIEnumLasPointObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long larraySize = 0;
    long lpPointCount = 0;
    WKSPointZ spPoints;
    PyObject* py_pPoints = NULL;
    double dpAttribute = 0;
    ILongArray* ippIntensity = NULL;
    PyObject* py_pIntensity;
    ILongArray* ippFileIndices = NULL;
    PyObject* py_pFileIndices;
    IDoubleArray* ippPointIDs = NULL;
    PyObject* py_pPointIDs;

    // Unpack values
    if (!PyArg_ParseTuple(args, "lOOO", &larraySize, &py_pIntensity, &py_pFileIndices, &py_pPointIDs))
      goto ienumlaspoint_nextattrdbl_method_cleanup;

    // Set up initial variable values as needed
    // No setup for arraySize
    // No setup for pPointCount
    // No setup for pPoints
    // No setup for pAttribute
    if (!IFaceFromPyObject(py_pIntensity, &IID_ILongArray, (void**)&ippIntensity))
        PyErr_SetString(PyExc_TypeError, "Argument pIntensity (position 4) is not ILongArray");
    
    if (PyErr_Occurred())
      goto ienumlaspoint_nextattrdbl_method_cleanup;
    
    if (!IFaceFromPyObject(py_pFileIndices, &IID_ILongArray, (void**)&ippFileIndices))
        PyErr_SetString(PyExc_TypeError, "Argument pFileIndices (position 5) is not ILongArray");
    
    if (PyErr_Occurred())
      goto ienumlaspoint_nextattrdbl_method_cleanup;
    
    if (!IFaceFromPyObject(py_pPointIDs, &IID_IDoubleArray, (void**)&ippPointIDs))
        PyErr_SetString(PyExc_TypeError, "Argument pPointIDs (position 6) is not IDoubleArray");
    
    if (PyErr_Occurred())
      goto ienumlaspoint_nextattrdbl_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIEnumLasPoint->NextAttrDbl(larraySize, &lpPointCount, &spPoints, &dpAttribute, ippIntensity, ippFileIndices, ippPointIDs);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIEnumLasPoint->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IEnumLasPoint) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IEnumLasPoint.NextAttrDbl() returned %ld", (long)hr);
        goto ienumlaspoint_nextattrdbl_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for arraySize
    // No teardown for pPointCount
    py_pPoints = PyByteArray_FromStringAndSize((char*)&spPoints, sizeof(WKSPointZ));
    PyObject* RecordWrappPoints = NULL;
    if (g_pRecordMap && (RecordWrappPoints = PyDict_GetItemString(g_pRecordMap, "WKSPointZ")))
    {
        PyObject* NewObj = PyObject_CallFunctionObjArgs(RecordWrappPoints, py_pPoints, NULL);
        if (NewObj)
        {
            Py_XDECREF(py_pPoints);
            py_pPoints = NewObj;
        }
        else
            PyErr_Clear();
    }
    else if (g_pRecordMap && !RecordWrappPoints)
        PyErr_Clear();
    Py_XDECREF(RecordWrappPoints);
    
    if (PyErr_Occurred())
      goto ienumlaspoint_nextattrdbl_method_cleanup;
    
    // No teardown for pAttribute
    // No teardown for pIntensity
    // No teardown for pFileIndices
    // No teardown for pPointIDs

    // Initialize output tuple
    return_tuple = Py_BuildValue("lOd",
                                            lpPointCount, py_pPoints, dpAttribute);
    goto ienumlaspoint_nextattrdbl_method_cleanup;

    ienumlaspoint_nextattrdbl_method_cleanup:
    self->m_HR = hr;
    // No cleanup for arraySize
    // No cleanup for pPointCount
    Py_XDECREF(py_pPoints);
    // No cleanup for pAttribute
    if (ippIntensity)
      ippIntensity->Release();
    if (ippFileIndices)
      ippFileIndices->Release();
    if (ippPointIDs)
      ippPointIDs->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IEnumLasPoint.NextAttrDbl");
    return return_tuple;
}

static PyObject*
IEnumLasPointMethod_NextAttrRGB32(PyIEnumLasPointObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long larraySize = 0;
    long lpPointCount = 0;
    WKSPointZ spPoints;
    PyObject* py_pPoints = NULL;
    RGB32 spAttribute;
    PyObject* py_pAttribute = NULL;
    ILongArray* ippIntensity = NULL;
    PyObject* py_pIntensity;
    ILongArray* ippFileIndices = NULL;
    PyObject* py_pFileIndices;
    IDoubleArray* ippPointIDs = NULL;
    PyObject* py_pPointIDs;

    // Unpack values
    if (!PyArg_ParseTuple(args, "lOOO", &larraySize, &py_pIntensity, &py_pFileIndices, &py_pPointIDs))
      goto ienumlaspoint_nextattrrgb32_method_cleanup;

    // Set up initial variable values as needed
    // No setup for arraySize
    // No setup for pPointCount
    // No setup for pPoints
    // No setup for pAttribute
    if (!IFaceFromPyObject(py_pIntensity, &IID_ILongArray, (void**)&ippIntensity))
        PyErr_SetString(PyExc_TypeError, "Argument pIntensity (position 4) is not ILongArray");
    
    if (PyErr_Occurred())
      goto ienumlaspoint_nextattrrgb32_method_cleanup;
    
    if (!IFaceFromPyObject(py_pFileIndices, &IID_ILongArray, (void**)&ippFileIndices))
        PyErr_SetString(PyExc_TypeError, "Argument pFileIndices (position 5) is not ILongArray");
    
    if (PyErr_Occurred())
      goto ienumlaspoint_nextattrrgb32_method_cleanup;
    
    if (!IFaceFromPyObject(py_pPointIDs, &IID_IDoubleArray, (void**)&ippPointIDs))
        PyErr_SetString(PyExc_TypeError, "Argument pPointIDs (position 6) is not IDoubleArray");
    
    if (PyErr_Occurred())
      goto ienumlaspoint_nextattrrgb32_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIEnumLasPoint->NextAttrRGB32(larraySize, &lpPointCount, &spPoints, &spAttribute, ippIntensity, ippFileIndices, ippPointIDs);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIEnumLasPoint->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IEnumLasPoint) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IEnumLasPoint.NextAttrRGB32() returned %ld", (long)hr);
        goto ienumlaspoint_nextattrrgb32_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for arraySize
    // No teardown for pPointCount
    py_pPoints = PyByteArray_FromStringAndSize((char*)&spPoints, sizeof(WKSPointZ));
    PyObject* RecordWrappPoints = NULL;
    if (g_pRecordMap && (RecordWrappPoints = PyDict_GetItemString(g_pRecordMap, "WKSPointZ")))
    {
        PyObject* NewObj = PyObject_CallFunctionObjArgs(RecordWrappPoints, py_pPoints, NULL);
        if (NewObj)
        {
            Py_XDECREF(py_pPoints);
            py_pPoints = NewObj;
        }
        else
            PyErr_Clear();
    }
    else if (g_pRecordMap && !RecordWrappPoints)
        PyErr_Clear();
    Py_XDECREF(RecordWrappPoints);
    
    if (PyErr_Occurred())
      goto ienumlaspoint_nextattrrgb32_method_cleanup;
    
    py_pAttribute = PyByteArray_FromStringAndSize((char*)&spAttribute, sizeof(RGB32));
    PyObject* RecordWrappAttribute = NULL;
    if (g_pRecordMap && (RecordWrappAttribute = PyDict_GetItemString(g_pRecordMap, "RGB32")))
    {
        PyObject* NewObj = PyObject_CallFunctionObjArgs(RecordWrappAttribute, py_pAttribute, NULL);
        if (NewObj)
        {
            Py_XDECREF(py_pAttribute);
            py_pAttribute = NewObj;
        }
        else
            PyErr_Clear();
    }
    else if (g_pRecordMap && !RecordWrappAttribute)
        PyErr_Clear();
    Py_XDECREF(RecordWrappAttribute);
    
    if (PyErr_Occurred())
      goto ienumlaspoint_nextattrrgb32_method_cleanup;
    
    // No teardown for pIntensity
    // No teardown for pFileIndices
    // No teardown for pPointIDs

    // Initialize output tuple
    return_tuple = Py_BuildValue("lOO",
                                            lpPointCount, py_pPoints, py_pAttribute);
    goto ienumlaspoint_nextattrrgb32_method_cleanup;

    ienumlaspoint_nextattrrgb32_method_cleanup:
    self->m_HR = hr;
    // No cleanup for arraySize
    // No cleanup for pPointCount
    Py_XDECREF(py_pPoints);
    Py_XDECREF(py_pAttribute);
    if (ippIntensity)
      ippIntensity->Release();
    if (ippFileIndices)
      ippFileIndices->Release();
    if (ippPointIDs)
      ippPointIDs->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IEnumLasPoint.NextAttrRGB32");
    return return_tuple;
}

static PyObject*
IEnumLasPointMethod_NextLasInfo(PyIEnumLasPointObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IArray* ippInfo = NULL;
    PyObject* py_pInfo;
    long lpPointCount = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_pInfo))
      goto ienumlaspoint_nextlasinfo_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pInfo, &IID_IArray, (void**)&ippInfo))
        PyErr_SetString(PyExc_TypeError, "Argument pInfo (position 0) is not IArray");
    
    if (PyErr_Occurred())
      goto ienumlaspoint_nextlasinfo_method_cleanup;
    
    // No setup for pPointCount

    // Call method on actual COM interface
    hr = self->m_pIEnumLasPoint->NextLasInfo(ippInfo, &lpPointCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIEnumLasPoint->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IEnumLasPoint) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IEnumLasPoint.NextLasInfo() returned %ld", (long)hr);
        goto ienumlaspoint_nextlasinfo_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pInfo
    // No teardown for pPointCount

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpPointCount);
    goto ienumlaspoint_nextlasinfo_method_cleanup;

    ienumlaspoint_nextlasinfo_method_cleanup:
    self->m_HR = hr;
    if (ippInfo)
      ippInfo->Release();
    // No cleanup for pPointCount
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IEnumLasPoint.NextLasInfo");
    return return_tuple;
}


PyMethodDef PyIEnumLasPointMethods[] = {
    {"supports", (PyCFunction)PyIEnumLasPoint_SupportsInterface, METH_O, ""},
    {"put_Attribute", (PyCFunction)IEnumLasPointMethod_put_Attribute, METH_VARARGS, ""},
    {"get_Attribute", (PyCFunction)IEnumLasPointMethod_get_Attribute, METH_VARARGS, ""},
    {"Reset", (PyCFunction)IEnumLasPointMethod_Reset, METH_NOARGS, ""},
    {"Next", (PyCFunction)IEnumLasPointMethod_Next, METH_VARARGS, ""},
    {"NextAttrLong", (PyCFunction)IEnumLasPointMethod_NextAttrLong, METH_VARARGS, ""},
    {"NextAttrDbl", (PyCFunction)IEnumLasPointMethod_NextAttrDbl, METH_VARARGS, ""},
    {"NextAttrRGB32", (PyCFunction)IEnumLasPointMethod_NextAttrRGB32, METH_VARARGS, ""},
    {"NextLasInfo", (PyCFunction)IEnumLasPointMethod_NextLasInfo, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIEnumLasPointGetSet[] = {
  {"_pUnk", (getter)PyIEnumLasPoint_GetpUnk, NULL, "Get opaque pointer to an Unknown from IEnumLasPoint", NULL},
  {"_pointer", (getter)PyIEnumLasPoint_GetPointer, NULL, "Get memory address for IEnumLasPoint", NULL},
  {"_IID", (getter)PyIEnumLasPoint_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIEnumLasPoint_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIEnumLasPoint_GetIgnoreFailures, (setter)PyIEnumLasPoint_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIEnumLasPointObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.IEnumLasPointObject",                          
                                              /* tp_name */
  sizeof(PyIEnumLasPointObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIEnumLasPointObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIEnumLasPointMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIEnumLasPointGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIEnumLasPointObject_new,                      
                                              /* tp_new */
};

// Interface ILasPointInfo

typedef struct PyILasPointInfoObject {
    PyObject_HEAD
    ILasPointInfo* m_pILasPointInfo;
    HRESULT m_HR;
    int m_ignore_failures;
} PyILasPointInfoObject;

static PyObject*
PyILasPointInfoObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyILasPointInfoObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ILasPointInfo* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ILasPointInfo, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ILasPointInfo with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyILasPointInfoObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ILasPointInfo");
            return NULL;
        }
        self->m_pILasPointInfo = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ILasPointInfo");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ILasPointInfo");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ILasPointInfo* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ILasPointInfo, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ILasPointInfo");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyILasPointInfoObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ILasPointInfo");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pILasPointInfo = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyILasPointInfoObject_dealloc(PyILasPointInfoObject* self)
{
    if (self->m_pILasPointInfo)
        self->m_pILasPointInfo->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyILasPointInfo_GetpUnk(PyILasPointInfoObject* self)
{
    if (!self->m_pILasPointInfo)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pILasPointInfo->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ILasPointInfo to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyILasPointInfo_GetPointer(PyILasPointInfoObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pILasPointInfo);
}

static PyObject*
PyILasPointInfo_GetIID(PyILasPointInfoObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "c4b222f6-c575-4f6b-b7ee-28e34fea446c");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyILasPointInfo_GetHR(PyILasPointInfoObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyILasPointInfo_GetIgnoreFailures(PyILasPointInfoObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyILasPointInfo_SetIgnoreFailures(PyILasPointInfoObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyILasPointInfo_SupportsInterface(PyILasPointInfoObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pILasPointInfo->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ILasPointInfoMethod_put_FileIndex(PyILasPointInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpIndex = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lpIndex))
      goto ilaspointinfo_put_fileindex_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pIndex

    // Call method on actual COM interface
    hr = self->m_pILasPointInfo->put_FileIndex(lpIndex);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasPointInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasPointInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasPointInfo.put_FileIndex() returned %ld", (long)hr);
        goto ilaspointinfo_put_fileindex_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pIndex

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ilaspointinfo_put_fileindex_method_cleanup;

    ilaspointinfo_put_fileindex_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pIndex
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasPointInfo.put_FileIndex");
    return return_tuple;
}

static PyObject*
ILasPointInfoMethod_get_FileIndex(PyILasPointInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpIndex = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pIndex

    // Call method on actual COM interface
    hr = self->m_pILasPointInfo->get_FileIndex(&lpIndex);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasPointInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasPointInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasPointInfo.get_FileIndex() returned %ld", (long)hr);
        goto ilaspointinfo_get_fileindex_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pIndex

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpIndex);
    goto ilaspointinfo_get_fileindex_method_cleanup;

    ilaspointinfo_get_fileindex_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pIndex
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasPointInfo.get_FileIndex");
    return return_tuple;
}

static PyObject*
ILasPointInfoMethod_put_PointID(PyILasPointInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dpID = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "d", &dpID))
      goto ilaspointinfo_put_pointid_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pID

    // Call method on actual COM interface
    hr = self->m_pILasPointInfo->put_PointID(dpID);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasPointInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasPointInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasPointInfo.put_PointID() returned %ld", (long)hr);
        goto ilaspointinfo_put_pointid_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pID

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ilaspointinfo_put_pointid_method_cleanup;

    ilaspointinfo_put_pointid_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pID
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasPointInfo.put_PointID");
    return return_tuple;
}

static PyObject*
ILasPointInfoMethod_get_PointID(PyILasPointInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dpID = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pID

    // Call method on actual COM interface
    hr = self->m_pILasPointInfo->get_PointID(&dpID);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasPointInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasPointInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasPointInfo.get_PointID() returned %ld", (long)hr);
        goto ilaspointinfo_get_pointid_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pID

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dpID);
    goto ilaspointinfo_get_pointid_method_cleanup;

    ilaspointinfo_get_pointid_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pID
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasPointInfo.get_PointID");
    return return_tuple;
}

static PyObject*
ILasPointInfoMethod_put_ReturnNumber(PyILasPointInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    unsigned char cpNumber = 0;
    unsigned char * cppNumber = &cpNumber;
    PyObject* pyarg_pNumber = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyarg_pNumber))
      goto ilaspointinfo_put_returnnumber_method_cleanup;

    // Set up initial variable values as needed
    if (PyNumber_Check(pyarg_pNumber))
        cpNumber = (unsigned char)PyNumber_AsSsize_t(pyarg_pNumber, NULL);
    else if (PyByteArray_Check(pyarg_pNumber))
        cppNumber = (unsigned char *)PyByteArray_AsString(pyarg_pNumber);
    else
        PyErr_SetString(PyExc_ValueError, "Invalid value for argument pNumber at 0");
    
    if (PyErr_Occurred())
      goto ilaspointinfo_put_returnnumber_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pILasPointInfo->put_ReturnNumber(cpNumber);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasPointInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasPointInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasPointInfo.put_ReturnNumber() returned %ld", (long)hr);
        goto ilaspointinfo_put_returnnumber_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pNumber

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ilaspointinfo_put_returnnumber_method_cleanup;

    ilaspointinfo_put_returnnumber_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pNumber
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasPointInfo.put_ReturnNumber");
    return return_tuple;
}

static PyObject*
ILasPointInfoMethod_get_ReturnNumber(PyILasPointInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    unsigned char cpNumber = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pNumber

    // Call method on actual COM interface
    hr = self->m_pILasPointInfo->get_ReturnNumber(&cpNumber);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasPointInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasPointInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasPointInfo.get_ReturnNumber() returned %ld", (long)hr);
        goto ilaspointinfo_get_returnnumber_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pNumber

    // Initialize output tuple
    return_tuple = Py_BuildValue("B",
                                            cpNumber);
    goto ilaspointinfo_get_returnnumber_method_cleanup;

    ilaspointinfo_get_returnnumber_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pNumber
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasPointInfo.get_ReturnNumber");
    return return_tuple;
}

static PyObject*
ILasPointInfoMethod_put_NumberOfReturns(PyILasPointInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    unsigned char cpCount = 0;
    unsigned char * cppCount = &cpCount;
    PyObject* pyarg_pCount = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyarg_pCount))
      goto ilaspointinfo_put_numberofreturns_method_cleanup;

    // Set up initial variable values as needed
    if (PyNumber_Check(pyarg_pCount))
        cpCount = (unsigned char)PyNumber_AsSsize_t(pyarg_pCount, NULL);
    else if (PyByteArray_Check(pyarg_pCount))
        cppCount = (unsigned char *)PyByteArray_AsString(pyarg_pCount);
    else
        PyErr_SetString(PyExc_ValueError, "Invalid value for argument pCount at 0");
    
    if (PyErr_Occurred())
      goto ilaspointinfo_put_numberofreturns_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pILasPointInfo->put_NumberOfReturns(cpCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasPointInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasPointInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasPointInfo.put_NumberOfReturns() returned %ld", (long)hr);
        goto ilaspointinfo_put_numberofreturns_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pCount

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ilaspointinfo_put_numberofreturns_method_cleanup;

    ilaspointinfo_put_numberofreturns_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pCount
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasPointInfo.put_NumberOfReturns");
    return return_tuple;
}

static PyObject*
ILasPointInfoMethod_get_NumberOfReturns(PyILasPointInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    unsigned char cpCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pCount

    // Call method on actual COM interface
    hr = self->m_pILasPointInfo->get_NumberOfReturns(&cpCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasPointInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasPointInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasPointInfo.get_NumberOfReturns() returned %ld", (long)hr);
        goto ilaspointinfo_get_numberofreturns_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pCount

    // Initialize output tuple
    return_tuple = Py_BuildValue("B",
                                            cpCount);
    goto ilaspointinfo_get_numberofreturns_method_cleanup;

    ilaspointinfo_get_numberofreturns_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pCount
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasPointInfo.get_NumberOfReturns");
    return return_tuple;
}

static PyObject*
ILasPointInfoMethod_put_ScanDirectionFlag(PyILasPointInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    unsigned char cpFlag = 0;
    unsigned char * cppFlag = &cpFlag;
    PyObject* pyarg_pFlag = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyarg_pFlag))
      goto ilaspointinfo_put_scandirectionflag_method_cleanup;

    // Set up initial variable values as needed
    if (PyNumber_Check(pyarg_pFlag))
        cpFlag = (unsigned char)PyNumber_AsSsize_t(pyarg_pFlag, NULL);
    else if (PyByteArray_Check(pyarg_pFlag))
        cppFlag = (unsigned char *)PyByteArray_AsString(pyarg_pFlag);
    else
        PyErr_SetString(PyExc_ValueError, "Invalid value for argument pFlag at 0");
    
    if (PyErr_Occurred())
      goto ilaspointinfo_put_scandirectionflag_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pILasPointInfo->put_ScanDirectionFlag(cpFlag);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasPointInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasPointInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasPointInfo.put_ScanDirectionFlag() returned %ld", (long)hr);
        goto ilaspointinfo_put_scandirectionflag_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pFlag

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ilaspointinfo_put_scandirectionflag_method_cleanup;

    ilaspointinfo_put_scandirectionflag_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pFlag
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasPointInfo.put_ScanDirectionFlag");
    return return_tuple;
}

static PyObject*
ILasPointInfoMethod_get_ScanDirectionFlag(PyILasPointInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    unsigned char cpFlag = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pFlag

    // Call method on actual COM interface
    hr = self->m_pILasPointInfo->get_ScanDirectionFlag(&cpFlag);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasPointInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasPointInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasPointInfo.get_ScanDirectionFlag() returned %ld", (long)hr);
        goto ilaspointinfo_get_scandirectionflag_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pFlag

    // Initialize output tuple
    return_tuple = Py_BuildValue("B",
                                            cpFlag);
    goto ilaspointinfo_get_scandirectionflag_method_cleanup;

    ilaspointinfo_get_scandirectionflag_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pFlag
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasPointInfo.get_ScanDirectionFlag");
    return return_tuple;
}

static PyObject*
ILasPointInfoMethod_put_EdgeOfFlightLine(PyILasPointInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    unsigned char cpEdge = 0;
    unsigned char * cppEdge = &cpEdge;
    PyObject* pyarg_pEdge = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyarg_pEdge))
      goto ilaspointinfo_put_edgeofflightline_method_cleanup;

    // Set up initial variable values as needed
    if (PyNumber_Check(pyarg_pEdge))
        cpEdge = (unsigned char)PyNumber_AsSsize_t(pyarg_pEdge, NULL);
    else if (PyByteArray_Check(pyarg_pEdge))
        cppEdge = (unsigned char *)PyByteArray_AsString(pyarg_pEdge);
    else
        PyErr_SetString(PyExc_ValueError, "Invalid value for argument pEdge at 0");
    
    if (PyErr_Occurred())
      goto ilaspointinfo_put_edgeofflightline_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pILasPointInfo->put_EdgeOfFlightLine(cpEdge);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasPointInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasPointInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasPointInfo.put_EdgeOfFlightLine() returned %ld", (long)hr);
        goto ilaspointinfo_put_edgeofflightline_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pEdge

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ilaspointinfo_put_edgeofflightline_method_cleanup;

    ilaspointinfo_put_edgeofflightline_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pEdge
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasPointInfo.put_EdgeOfFlightLine");
    return return_tuple;
}

static PyObject*
ILasPointInfoMethod_get_EdgeOfFlightLine(PyILasPointInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    unsigned char cpEdge = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pEdge

    // Call method on actual COM interface
    hr = self->m_pILasPointInfo->get_EdgeOfFlightLine(&cpEdge);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasPointInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasPointInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasPointInfo.get_EdgeOfFlightLine() returned %ld", (long)hr);
        goto ilaspointinfo_get_edgeofflightline_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pEdge

    // Initialize output tuple
    return_tuple = Py_BuildValue("B",
                                            cpEdge);
    goto ilaspointinfo_get_edgeofflightline_method_cleanup;

    ilaspointinfo_get_edgeofflightline_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pEdge
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasPointInfo.get_EdgeOfFlightLine");
    return return_tuple;
}

static PyObject*
ILasPointInfoMethod_put_ClassCode(PyILasPointInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    unsigned char cpCode = 0;
    unsigned char * cppCode = &cpCode;
    PyObject* pyarg_pCode = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyarg_pCode))
      goto ilaspointinfo_put_classcode_method_cleanup;

    // Set up initial variable values as needed
    if (PyNumber_Check(pyarg_pCode))
        cpCode = (unsigned char)PyNumber_AsSsize_t(pyarg_pCode, NULL);
    else if (PyByteArray_Check(pyarg_pCode))
        cppCode = (unsigned char *)PyByteArray_AsString(pyarg_pCode);
    else
        PyErr_SetString(PyExc_ValueError, "Invalid value for argument pCode at 0");
    
    if (PyErr_Occurred())
      goto ilaspointinfo_put_classcode_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pILasPointInfo->put_ClassCode(cpCode);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasPointInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasPointInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasPointInfo.put_ClassCode() returned %ld", (long)hr);
        goto ilaspointinfo_put_classcode_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pCode

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ilaspointinfo_put_classcode_method_cleanup;

    ilaspointinfo_put_classcode_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pCode
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasPointInfo.put_ClassCode");
    return return_tuple;
}

static PyObject*
ILasPointInfoMethod_get_ClassCode(PyILasPointInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    unsigned char cpCode = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pCode

    // Call method on actual COM interface
    hr = self->m_pILasPointInfo->get_ClassCode(&cpCode);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasPointInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasPointInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasPointInfo.get_ClassCode() returned %ld", (long)hr);
        goto ilaspointinfo_get_classcode_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pCode

    // Initialize output tuple
    return_tuple = Py_BuildValue("B",
                                            cpCode);
    goto ilaspointinfo_get_classcode_method_cleanup;

    ilaspointinfo_get_classcode_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pCode
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasPointInfo.get_ClassCode");
    return return_tuple;
}

static PyObject*
ILasPointInfoMethod_put_IsWithheld(PyILasPointInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pbIsWithheld = VARIANT_FALSE;
    PyObject* pyvar_pbIsWithheld = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pbIsWithheld))
      goto ilaspointinfo_put_iswithheld_method_cleanup;

    // Set up initial variable values as needed
    b_pbIsWithheld = ((PyObject_IsTrue(pyvar_pbIsWithheld) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto ilaspointinfo_put_iswithheld_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pILasPointInfo->put_IsWithheld(b_pbIsWithheld);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasPointInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasPointInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasPointInfo.put_IsWithheld() returned %ld", (long)hr);
        goto ilaspointinfo_put_iswithheld_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pbIsWithheld

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ilaspointinfo_put_iswithheld_method_cleanup;

    ilaspointinfo_put_iswithheld_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pbIsWithheld
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasPointInfo.put_IsWithheld");
    return return_tuple;
}

static PyObject*
ILasPointInfoMethod_get_IsWithheld(PyILasPointInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pbIsWithheld = VARIANT_FALSE;
    PyObject* pyvar_pbIsWithheld = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pbIsWithheld

    // Call method on actual COM interface
    hr = self->m_pILasPointInfo->get_IsWithheld(&b_pbIsWithheld);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasPointInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasPointInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasPointInfo.get_IsWithheld() returned %ld", (long)hr);
        goto ilaspointinfo_get_iswithheld_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pbIsWithheld = ((b_pbIsWithheld == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto ilaspointinfo_get_iswithheld_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pbIsWithheld);
    goto ilaspointinfo_get_iswithheld_method_cleanup;

    ilaspointinfo_get_iswithheld_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pbIsWithheld
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasPointInfo.get_IsWithheld");
    return return_tuple;
}

static PyObject*
ILasPointInfoMethod_put_IsKeyPoint(PyILasPointInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pbIsKey = VARIANT_FALSE;
    PyObject* pyvar_pbIsKey = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pbIsKey))
      goto ilaspointinfo_put_iskeypoint_method_cleanup;

    // Set up initial variable values as needed
    b_pbIsKey = ((PyObject_IsTrue(pyvar_pbIsKey) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto ilaspointinfo_put_iskeypoint_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pILasPointInfo->put_IsKeyPoint(b_pbIsKey);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasPointInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasPointInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasPointInfo.put_IsKeyPoint() returned %ld", (long)hr);
        goto ilaspointinfo_put_iskeypoint_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pbIsKey

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ilaspointinfo_put_iskeypoint_method_cleanup;

    ilaspointinfo_put_iskeypoint_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pbIsKey
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasPointInfo.put_IsKeyPoint");
    return return_tuple;
}

static PyObject*
ILasPointInfoMethod_get_IsKeyPoint(PyILasPointInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pbIsKey = VARIANT_FALSE;
    PyObject* pyvar_pbIsKey = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pbIsKey

    // Call method on actual COM interface
    hr = self->m_pILasPointInfo->get_IsKeyPoint(&b_pbIsKey);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasPointInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasPointInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasPointInfo.get_IsKeyPoint() returned %ld", (long)hr);
        goto ilaspointinfo_get_iskeypoint_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pbIsKey = ((b_pbIsKey == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto ilaspointinfo_get_iskeypoint_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pbIsKey);
    goto ilaspointinfo_get_iskeypoint_method_cleanup;

    ilaspointinfo_get_iskeypoint_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pbIsKey
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasPointInfo.get_IsKeyPoint");
    return return_tuple;
}

static PyObject*
ILasPointInfoMethod_put_IsSyntheticPoint(PyILasPointInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pbIsSynthetic = VARIANT_FALSE;
    PyObject* pyvar_pbIsSynthetic = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pbIsSynthetic))
      goto ilaspointinfo_put_issyntheticpoint_method_cleanup;

    // Set up initial variable values as needed
    b_pbIsSynthetic = ((PyObject_IsTrue(pyvar_pbIsSynthetic) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto ilaspointinfo_put_issyntheticpoint_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pILasPointInfo->put_IsSyntheticPoint(b_pbIsSynthetic);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasPointInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasPointInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasPointInfo.put_IsSyntheticPoint() returned %ld", (long)hr);
        goto ilaspointinfo_put_issyntheticpoint_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pbIsSynthetic

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ilaspointinfo_put_issyntheticpoint_method_cleanup;

    ilaspointinfo_put_issyntheticpoint_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pbIsSynthetic
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasPointInfo.put_IsSyntheticPoint");
    return return_tuple;
}

static PyObject*
ILasPointInfoMethod_get_IsSyntheticPoint(PyILasPointInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pbIsSynthetic = VARIANT_FALSE;
    PyObject* pyvar_pbIsSynthetic = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pbIsSynthetic

    // Call method on actual COM interface
    hr = self->m_pILasPointInfo->get_IsSyntheticPoint(&b_pbIsSynthetic);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasPointInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasPointInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasPointInfo.get_IsSyntheticPoint() returned %ld", (long)hr);
        goto ilaspointinfo_get_issyntheticpoint_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pbIsSynthetic = ((b_pbIsSynthetic == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto ilaspointinfo_get_issyntheticpoint_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pbIsSynthetic);
    goto ilaspointinfo_get_issyntheticpoint_method_cleanup;

    ilaspointinfo_get_issyntheticpoint_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pbIsSynthetic
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasPointInfo.get_IsSyntheticPoint");
    return return_tuple;
}

static PyObject*
ILasPointInfoMethod_put_Intensity(PyILasPointInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpIntensity = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lpIntensity))
      goto ilaspointinfo_put_intensity_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pIntensity

    // Call method on actual COM interface
    hr = self->m_pILasPointInfo->put_Intensity(lpIntensity);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasPointInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasPointInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasPointInfo.put_Intensity() returned %ld", (long)hr);
        goto ilaspointinfo_put_intensity_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pIntensity

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ilaspointinfo_put_intensity_method_cleanup;

    ilaspointinfo_put_intensity_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pIntensity
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasPointInfo.put_Intensity");
    return return_tuple;
}

static PyObject*
ILasPointInfoMethod_get_Intensity(PyILasPointInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpIntensity = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pIntensity

    // Call method on actual COM interface
    hr = self->m_pILasPointInfo->get_Intensity(&lpIntensity);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasPointInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasPointInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasPointInfo.get_Intensity() returned %ld", (long)hr);
        goto ilaspointinfo_get_intensity_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pIntensity

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpIntensity);
    goto ilaspointinfo_get_intensity_method_cleanup;

    ilaspointinfo_get_intensity_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pIntensity
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasPointInfo.get_Intensity");
    return return_tuple;
}

static PyObject*
ILasPointInfoMethod_put_ScanAngleRank(PyILasPointInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    short spAngle = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "h", &spAngle))
      goto ilaspointinfo_put_scananglerank_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pAngle

    // Call method on actual COM interface
    hr = self->m_pILasPointInfo->put_ScanAngleRank(spAngle);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasPointInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasPointInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasPointInfo.put_ScanAngleRank() returned %ld", (long)hr);
        goto ilaspointinfo_put_scananglerank_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pAngle

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ilaspointinfo_put_scananglerank_method_cleanup;

    ilaspointinfo_put_scananglerank_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pAngle
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasPointInfo.put_ScanAngleRank");
    return return_tuple;
}

static PyObject*
ILasPointInfoMethod_get_ScanAngleRank(PyILasPointInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    short spAngle = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pAngle

    // Call method on actual COM interface
    hr = self->m_pILasPointInfo->get_ScanAngleRank(&spAngle);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasPointInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasPointInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasPointInfo.get_ScanAngleRank() returned %ld", (long)hr);
        goto ilaspointinfo_get_scananglerank_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pAngle

    // Initialize output tuple
    return_tuple = Py_BuildValue("h",
                                            spAngle);
    goto ilaspointinfo_get_scananglerank_method_cleanup;

    ilaspointinfo_get_scananglerank_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pAngle
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasPointInfo.get_ScanAngleRank");
    return return_tuple;
}

static PyObject*
ILasPointInfoMethod_put_UserData(PyILasPointInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    short spData = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "h", &spData))
      goto ilaspointinfo_put_userdata_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pData

    // Call method on actual COM interface
    hr = self->m_pILasPointInfo->put_UserData(spData);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasPointInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasPointInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasPointInfo.put_UserData() returned %ld", (long)hr);
        goto ilaspointinfo_put_userdata_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pData

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ilaspointinfo_put_userdata_method_cleanup;

    ilaspointinfo_put_userdata_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pData
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasPointInfo.put_UserData");
    return return_tuple;
}

static PyObject*
ILasPointInfoMethod_get_UserData(PyILasPointInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    short spData = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pData

    // Call method on actual COM interface
    hr = self->m_pILasPointInfo->get_UserData(&spData);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasPointInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasPointInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasPointInfo.get_UserData() returned %ld", (long)hr);
        goto ilaspointinfo_get_userdata_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pData

    // Initialize output tuple
    return_tuple = Py_BuildValue("h",
                                            spData);
    goto ilaspointinfo_get_userdata_method_cleanup;

    ilaspointinfo_get_userdata_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pData
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasPointInfo.get_UserData");
    return return_tuple;
}

static PyObject*
ILasPointInfoMethod_put_PointSourceID(PyILasPointInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpID = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lpID))
      goto ilaspointinfo_put_pointsourceid_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pID

    // Call method on actual COM interface
    hr = self->m_pILasPointInfo->put_PointSourceID(lpID);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasPointInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasPointInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasPointInfo.put_PointSourceID() returned %ld", (long)hr);
        goto ilaspointinfo_put_pointsourceid_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pID

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ilaspointinfo_put_pointsourceid_method_cleanup;

    ilaspointinfo_put_pointsourceid_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pID
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasPointInfo.put_PointSourceID");
    return return_tuple;
}

static PyObject*
ILasPointInfoMethod_get_PointSourceID(PyILasPointInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpID = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pID

    // Call method on actual COM interface
    hr = self->m_pILasPointInfo->get_PointSourceID(&lpID);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasPointInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasPointInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasPointInfo.get_PointSourceID() returned %ld", (long)hr);
        goto ilaspointinfo_get_pointsourceid_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pID

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpID);
    goto ilaspointinfo_get_pointsourceid_method_cleanup;

    ilaspointinfo_get_pointsourceid_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pID
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasPointInfo.get_PointSourceID");
    return return_tuple;
}

static PyObject*
ILasPointInfoMethod_put_GpsTime(PyILasPointInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dpTime = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "d", &dpTime))
      goto ilaspointinfo_put_gpstime_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pTime

    // Call method on actual COM interface
    hr = self->m_pILasPointInfo->put_GpsTime(dpTime);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasPointInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasPointInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasPointInfo.put_GpsTime() returned %ld", (long)hr);
        goto ilaspointinfo_put_gpstime_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pTime

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ilaspointinfo_put_gpstime_method_cleanup;

    ilaspointinfo_put_gpstime_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pTime
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasPointInfo.put_GpsTime");
    return return_tuple;
}

static PyObject*
ILasPointInfoMethod_get_GpsTime(PyILasPointInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dpTime = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pTime

    // Call method on actual COM interface
    hr = self->m_pILasPointInfo->get_GpsTime(&dpTime);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasPointInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasPointInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasPointInfo.get_GpsTime() returned %ld", (long)hr);
        goto ilaspointinfo_get_gpstime_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pTime

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dpTime);
    goto ilaspointinfo_get_gpstime_method_cleanup;

    ilaspointinfo_get_gpstime_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pTime
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasPointInfo.get_GpsTime");
    return return_tuple;
}

static PyObject*
ILasPointInfoMethod_SetColor(PyILasPointInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lRed = 0;
    long lGreen = 0;
    long lBlue = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "lll", &lRed, &lGreen, &lBlue))
      goto ilaspointinfo_setcolor_method_cleanup;

    // Set up initial variable values as needed
    // No setup for Red
    // No setup for Green
    // No setup for Blue

    // Call method on actual COM interface
    hr = self->m_pILasPointInfo->SetColor(lRed, lGreen, lBlue);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasPointInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasPointInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasPointInfo.SetColor() returned %ld", (long)hr);
        goto ilaspointinfo_setcolor_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Red
    // No teardown for Green
    // No teardown for Blue

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ilaspointinfo_setcolor_method_cleanup;

    ilaspointinfo_setcolor_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Red
    // No cleanup for Green
    // No cleanup for Blue
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasPointInfo.SetColor");
    return return_tuple;
}

static PyObject*
ILasPointInfoMethod_GetColor(PyILasPointInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpRed = 0;
    long lpGreen = 0;
    long lpBlue = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pRed
    // No setup for pGreen
    // No setup for pBlue

    // Call method on actual COM interface
    hr = self->m_pILasPointInfo->GetColor(&lpRed, &lpGreen, &lpBlue);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasPointInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasPointInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasPointInfo.GetColor() returned %ld", (long)hr);
        goto ilaspointinfo_getcolor_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pRed
    // No teardown for pGreen
    // No teardown for pBlue

    // Initialize output tuple
    return_tuple = Py_BuildValue("lll",
                                            lpRed, lpGreen, lpBlue);
    goto ilaspointinfo_getcolor_method_cleanup;

    ilaspointinfo_getcolor_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pRed
    // No cleanup for pGreen
    // No cleanup for pBlue
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasPointInfo.GetColor");
    return return_tuple;
}

static PyObject*
ILasPointInfoMethod_put_Location(PyILasPointInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IPoint* ipppPoint = NULL;
    PyObject* py_ppPoint;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_ppPoint))
      goto ilaspointinfo_put_location_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_ppPoint, &IID_IPoint, (void**)&ipppPoint))
        PyErr_SetString(PyExc_TypeError, "Argument ppPoint (position 0) is not IPoint");
    
    if (PyErr_Occurred())
      goto ilaspointinfo_put_location_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pILasPointInfo->put_Location(ipppPoint);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasPointInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasPointInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasPointInfo.put_Location() returned %ld", (long)hr);
        goto ilaspointinfo_put_location_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ppPoint

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ilaspointinfo_put_location_method_cleanup;

    ilaspointinfo_put_location_method_cleanup:
    self->m_HR = hr;
    if (ipppPoint)
      ipppPoint->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasPointInfo.put_Location");
    return return_tuple;
}

static PyObject*
ILasPointInfoMethod_get_Location(PyILasPointInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IPoint* ipppPoint = NULL;
    PyObject* py_ppPoint = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppPoint

    // Call method on actual COM interface
    hr = self->m_pILasPointInfo->get_Location(&ipppPoint);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasPointInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasPointInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasPointInfo.get_Location() returned %ld", (long)hr);
        goto ilaspointinfo_get_location_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppPoint);
    if (ipppPoint)
    {
        IUnknown* pUnk = NULL;
        ipppPoint->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppPoint = IUnknownToPythonIIDObject(pUnk, &IID_IPoint);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppPoint)
    {
        if (py_ppPoint)
           Py_DECREF(py_ppPoint);
        py_ppPoint = Py_None;
        Py_INCREF(py_ppPoint);
    }
    if (PyErr_Occurred())
      goto ilaspointinfo_get_location_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppPoint);
    goto ilaspointinfo_get_location_method_cleanup;

    ilaspointinfo_get_location_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppPoint);
    if (ipppPoint)
      ipppPoint->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasPointInfo.get_Location");
    return return_tuple;
}

static PyObject*
ILasPointInfoMethod_put_WksLocation(PyILasPointInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    WKSPointZ* spPoint = 0;
    PyObject* py_pPoint = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_pPoint))
      goto ilaspointinfo_put_wkslocation_method_cleanup;

    // Set up initial variable values as needed
    if (PyByteArray_Check(py_pPoint))
        Py_INCREF(py_pPoint);
    else
        py_pPoint = PyObject_GetAttrString(py_pPoint, "_bytes");
    if (!py_pPoint || !PyByteArray_Check(py_pPoint) || PyByteArray_Size(py_pPoint) < sizeof(WKSPointZ))
        PyErr_SetString(PyExc_ValueError, "Not a usable WKSPointZ");
    else
        spPoint = (WKSPointZ*)PyByteArray_AsString(py_pPoint);
    
    if (PyErr_Occurred())
      goto ilaspointinfo_put_wkslocation_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pILasPointInfo->put_WksLocation(spPoint);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasPointInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasPointInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasPointInfo.put_WksLocation() returned %ld", (long)hr);
        goto ilaspointinfo_put_wkslocation_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pPoint

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ilaspointinfo_put_wkslocation_method_cleanup;

    ilaspointinfo_put_wkslocation_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_pPoint);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasPointInfo.put_WksLocation");
    return return_tuple;
}

static PyObject*
ILasPointInfoMethod_get_WksLocation(PyILasPointInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    WKSPointZ spPoint;
    PyObject* py_pPoint = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pPoint

    // Call method on actual COM interface
    hr = self->m_pILasPointInfo->get_WksLocation(&spPoint);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasPointInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasPointInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasPointInfo.get_WksLocation() returned %ld", (long)hr);
        goto ilaspointinfo_get_wkslocation_method_cleanup;
    }

    // Set up return values as needed
    py_pPoint = PyByteArray_FromStringAndSize((char*)&spPoint, sizeof(WKSPointZ));
    PyObject* RecordWrappPoint = NULL;
    if (g_pRecordMap && (RecordWrappPoint = PyDict_GetItemString(g_pRecordMap, "WKSPointZ")))
    {
        PyObject* NewObj = PyObject_CallFunctionObjArgs(RecordWrappPoint, py_pPoint, NULL);
        if (NewObj)
        {
            Py_XDECREF(py_pPoint);
            py_pPoint = NewObj;
        }
        else
            PyErr_Clear();
    }
    else if (g_pRecordMap && !RecordWrappPoint)
        PyErr_Clear();
    Py_XDECREF(RecordWrappPoint);
    
    if (PyErr_Occurred())
      goto ilaspointinfo_get_wkslocation_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_pPoint);
    goto ilaspointinfo_get_wkslocation_method_cleanup;

    ilaspointinfo_get_wkslocation_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_pPoint);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasPointInfo.get_WksLocation");
    return return_tuple;
}

static PyObject*
ILasPointInfoMethod_QueryLocation(PyILasPointInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IPoint* ippPoint = NULL;
    PyObject* py_pPoint;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_pPoint))
      goto ilaspointinfo_querylocation_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pPoint, &IID_IPoint, (void**)&ippPoint))
        PyErr_SetString(PyExc_TypeError, "Argument pPoint (position 0) is not IPoint");
    
    if (PyErr_Occurred())
      goto ilaspointinfo_querylocation_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pILasPointInfo->QueryLocation(ippPoint);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasPointInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasPointInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasPointInfo.QueryLocation() returned %ld", (long)hr);
        goto ilaspointinfo_querylocation_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pPoint

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ilaspointinfo_querylocation_method_cleanup;

    ilaspointinfo_querylocation_method_cleanup:
    self->m_HR = hr;
    if (ippPoint)
      ippPoint->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasPointInfo.QueryLocation");
    return return_tuple;
}

static PyObject*
ILasPointInfoMethod_putref_SpatialReference(PyILasPointInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ISpatialReference* ipppSpatialRef = NULL;
    PyObject* py_ppSpatialRef;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_ppSpatialRef))
      goto ilaspointinfo_putref_spatialreference_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_ppSpatialRef, &IID_ISpatialReference, (void**)&ipppSpatialRef))
        PyErr_SetString(PyExc_TypeError, "Argument ppSpatialRef (position 0) is not ISpatialReference");
    
    if (PyErr_Occurred())
      goto ilaspointinfo_putref_spatialreference_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pILasPointInfo->putref_SpatialReference(ipppSpatialRef);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasPointInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasPointInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasPointInfo.putref_SpatialReference() returned %ld", (long)hr);
        goto ilaspointinfo_putref_spatialreference_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ppSpatialRef

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ilaspointinfo_putref_spatialreference_method_cleanup;

    ilaspointinfo_putref_spatialreference_method_cleanup:
    self->m_HR = hr;
    if (ipppSpatialRef)
      ipppSpatialRef->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasPointInfo.putref_SpatialReference");
    return return_tuple;
}

static PyObject*
ILasPointInfoMethod_get_SpatialReference(PyILasPointInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ISpatialReference* ipppSpatialRef = NULL;
    PyObject* py_ppSpatialRef = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppSpatialRef

    // Call method on actual COM interface
    hr = self->m_pILasPointInfo->get_SpatialReference(&ipppSpatialRef);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasPointInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasPointInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasPointInfo.get_SpatialReference() returned %ld", (long)hr);
        goto ilaspointinfo_get_spatialreference_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppSpatialRef);
    if (ipppSpatialRef)
    {
        IUnknown* pUnk = NULL;
        ipppSpatialRef->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppSpatialRef = IUnknownToPythonIIDObject(pUnk, &IID_ISpatialReference);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppSpatialRef)
    {
        if (py_ppSpatialRef)
           Py_DECREF(py_ppSpatialRef);
        py_ppSpatialRef = Py_None;
        Py_INCREF(py_ppSpatialRef);
    }
    if (PyErr_Occurred())
      goto ilaspointinfo_get_spatialreference_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppSpatialRef);
    goto ilaspointinfo_get_spatialreference_method_cleanup;

    ilaspointinfo_get_spatialreference_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppSpatialRef);
    if (ipppSpatialRef)
      ipppSpatialRef->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasPointInfo.get_SpatialReference");
    return return_tuple;
}

static PyObject*
ILasPointInfoMethod_get_AttributeValue(PyILasPointInfoObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriLasAttributeType eAttribute;
    VARIANT vpValue;
    ::VariantInit(&vpValue);
    PyObject* pyvar_pValue = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&eAttribute))
      goto ilaspointinfo_get_attributevalue_method_cleanup;

    // Set up initial variable values as needed
    // No setup for Attribute
    // No setup for pValue

    // Call method on actual COM interface
    hr = self->m_pILasPointInfo->get_AttributeValue(eAttribute, &vpValue);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasPointInfo->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasPointInfo) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasPointInfo.get_AttributeValue() returned %ld", (long)hr);
        goto ilaspointinfo_get_attributevalue_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Attribute
    pyvar_pValue = Variant_AsPyObject(&vpValue);
    if (PyErr_Occurred())
      goto ilaspointinfo_get_attributevalue_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pValue);
    goto ilaspointinfo_get_attributevalue_method_cleanup;

    ilaspointinfo_get_attributevalue_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Attribute
    ::VariantClear(&vpValue);
    Py_XDECREF(pyvar_pValue);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasPointInfo.get_AttributeValue");
    return return_tuple;
}


PyMethodDef PyILasPointInfoMethods[] = {
    {"supports", (PyCFunction)PyILasPointInfo_SupportsInterface, METH_O, ""},
    {"put_FileIndex", (PyCFunction)ILasPointInfoMethod_put_FileIndex, METH_VARARGS, ""},
    {"get_FileIndex", (PyCFunction)ILasPointInfoMethod_get_FileIndex, METH_VARARGS, ""},
    {"put_PointID", (PyCFunction)ILasPointInfoMethod_put_PointID, METH_VARARGS, ""},
    {"get_PointID", (PyCFunction)ILasPointInfoMethod_get_PointID, METH_VARARGS, ""},
    {"put_ReturnNumber", (PyCFunction)ILasPointInfoMethod_put_ReturnNumber, METH_VARARGS, ""},
    {"get_ReturnNumber", (PyCFunction)ILasPointInfoMethod_get_ReturnNumber, METH_VARARGS, ""},
    {"put_NumberOfReturns", (PyCFunction)ILasPointInfoMethod_put_NumberOfReturns, METH_VARARGS, ""},
    {"get_NumberOfReturns", (PyCFunction)ILasPointInfoMethod_get_NumberOfReturns, METH_VARARGS, ""},
    {"put_ScanDirectionFlag", (PyCFunction)ILasPointInfoMethod_put_ScanDirectionFlag, METH_VARARGS, ""},
    {"get_ScanDirectionFlag", (PyCFunction)ILasPointInfoMethod_get_ScanDirectionFlag, METH_VARARGS, ""},
    {"put_EdgeOfFlightLine", (PyCFunction)ILasPointInfoMethod_put_EdgeOfFlightLine, METH_VARARGS, ""},
    {"get_EdgeOfFlightLine", (PyCFunction)ILasPointInfoMethod_get_EdgeOfFlightLine, METH_VARARGS, ""},
    {"put_ClassCode", (PyCFunction)ILasPointInfoMethod_put_ClassCode, METH_VARARGS, ""},
    {"get_ClassCode", (PyCFunction)ILasPointInfoMethod_get_ClassCode, METH_VARARGS, ""},
    {"put_IsWithheld", (PyCFunction)ILasPointInfoMethod_put_IsWithheld, METH_VARARGS, ""},
    {"get_IsWithheld", (PyCFunction)ILasPointInfoMethod_get_IsWithheld, METH_VARARGS, ""},
    {"put_IsKeyPoint", (PyCFunction)ILasPointInfoMethod_put_IsKeyPoint, METH_VARARGS, ""},
    {"get_IsKeyPoint", (PyCFunction)ILasPointInfoMethod_get_IsKeyPoint, METH_VARARGS, ""},
    {"put_IsSyntheticPoint", (PyCFunction)ILasPointInfoMethod_put_IsSyntheticPoint, METH_VARARGS, ""},
    {"get_IsSyntheticPoint", (PyCFunction)ILasPointInfoMethod_get_IsSyntheticPoint, METH_VARARGS, ""},
    {"put_Intensity", (PyCFunction)ILasPointInfoMethod_put_Intensity, METH_VARARGS, ""},
    {"get_Intensity", (PyCFunction)ILasPointInfoMethod_get_Intensity, METH_VARARGS, ""},
    {"put_ScanAngleRank", (PyCFunction)ILasPointInfoMethod_put_ScanAngleRank, METH_VARARGS, ""},
    {"get_ScanAngleRank", (PyCFunction)ILasPointInfoMethod_get_ScanAngleRank, METH_VARARGS, ""},
    {"put_UserData", (PyCFunction)ILasPointInfoMethod_put_UserData, METH_VARARGS, ""},
    {"get_UserData", (PyCFunction)ILasPointInfoMethod_get_UserData, METH_VARARGS, ""},
    {"put_PointSourceID", (PyCFunction)ILasPointInfoMethod_put_PointSourceID, METH_VARARGS, ""},
    {"get_PointSourceID", (PyCFunction)ILasPointInfoMethod_get_PointSourceID, METH_VARARGS, ""},
    {"put_GpsTime", (PyCFunction)ILasPointInfoMethod_put_GpsTime, METH_VARARGS, ""},
    {"get_GpsTime", (PyCFunction)ILasPointInfoMethod_get_GpsTime, METH_VARARGS, ""},
    {"SetColor", (PyCFunction)ILasPointInfoMethod_SetColor, METH_VARARGS, ""},
    {"GetColor", (PyCFunction)ILasPointInfoMethod_GetColor, METH_VARARGS, ""},
    {"put_Location", (PyCFunction)ILasPointInfoMethod_put_Location, METH_VARARGS, ""},
    {"get_Location", (PyCFunction)ILasPointInfoMethod_get_Location, METH_VARARGS, ""},
    {"put_WksLocation", (PyCFunction)ILasPointInfoMethod_put_WksLocation, METH_VARARGS, ""},
    {"get_WksLocation", (PyCFunction)ILasPointInfoMethod_get_WksLocation, METH_VARARGS, ""},
    {"QueryLocation", (PyCFunction)ILasPointInfoMethod_QueryLocation, METH_VARARGS, ""},
    {"putref_SpatialReference", (PyCFunction)ILasPointInfoMethod_putref_SpatialReference, METH_VARARGS, ""},
    {"get_SpatialReference", (PyCFunction)ILasPointInfoMethod_get_SpatialReference, METH_VARARGS, ""},
    {"get_AttributeValue", (PyCFunction)ILasPointInfoMethod_get_AttributeValue, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyILasPointInfoGetSet[] = {
  {"_pUnk", (getter)PyILasPointInfo_GetpUnk, NULL, "Get opaque pointer to an Unknown from ILasPointInfo", NULL},
  {"_pointer", (getter)PyILasPointInfo_GetPointer, NULL, "Get memory address for ILasPointInfo", NULL},
  {"_IID", (getter)PyILasPointInfo_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyILasPointInfo_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyILasPointInfo_GetIgnoreFailures, (setter)PyILasPointInfo_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyILasPointInfoObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.ILasPointInfoObject",                          
                                              /* tp_name */
  sizeof(PyILasPointInfoObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyILasPointInfoObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyILasPointInfoMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyILasPointInfoGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyILasPointInfoObject_new,                      
                                              /* tp_new */
};

// Interface ILasPointCloud

typedef struct PyILasPointCloudObject {
    PyObject_HEAD
    ILasPointCloud* m_pILasPointCloud;
    HRESULT m_HR;
    int m_ignore_failures;
} PyILasPointCloudObject;

static PyObject*
PyILasPointCloudObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyILasPointCloudObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ILasPointCloud* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ILasPointCloud, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ILasPointCloud with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyILasPointCloudObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ILasPointCloud");
            return NULL;
        }
        self->m_pILasPointCloud = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ILasPointCloud");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ILasPointCloud");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ILasPointCloud* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ILasPointCloud, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ILasPointCloud");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyILasPointCloudObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ILasPointCloud");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pILasPointCloud = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyILasPointCloudObject_dealloc(PyILasPointCloudObject* self)
{
    if (self->m_pILasPointCloud)
        self->m_pILasPointCloud->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyILasPointCloud_GetpUnk(PyILasPointCloudObject* self)
{
    if (!self->m_pILasPointCloud)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pILasPointCloud->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ILasPointCloud to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyILasPointCloud_GetPointer(PyILasPointCloudObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pILasPointCloud);
}

static PyObject*
PyILasPointCloud_GetIID(PyILasPointCloudObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "1928009d-9153-4ec0-a75c-4c24008d28d5");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyILasPointCloud_GetHR(PyILasPointCloudObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyILasPointCloud_GetIgnoreFailures(PyILasPointCloudObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyILasPointCloud_SetIgnoreFailures(PyILasPointCloudObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyILasPointCloud_SupportsInterface(PyILasPointCloudObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pILasPointCloud->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ILasPointCloudMethod_EstimatePointCount(PyILasPointCloudObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IGeometry* ippAOI = NULL;
    PyObject* py_pAOI;
    double dpcPoints = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_pAOI))
      goto ilaspointcloud_estimatepointcount_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pAOI, &IID_IGeometry, (void**)&ippAOI))
        PyErr_SetString(PyExc_TypeError, "Argument pAOI (position 0) is not IGeometry");
    
    if (PyErr_Occurred())
      goto ilaspointcloud_estimatepointcount_method_cleanup;
    
    // No setup for pcPoints

    // Call method on actual COM interface
    hr = self->m_pILasPointCloud->EstimatePointCount(ippAOI, &dpcPoints);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasPointCloud->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasPointCloud) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasPointCloud.EstimatePointCount() returned %ld", (long)hr);
        goto ilaspointcloud_estimatepointcount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pAOI
    // No teardown for pcPoints

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dpcPoints);
    goto ilaspointcloud_estimatepointcount_method_cleanup;

    ilaspointcloud_estimatepointcount_method_cleanup:
    self->m_HR = hr;
    if (ippAOI)
      ippAOI->Release();
    // No cleanup for pcPoints
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasPointCloud.EstimatePointCount");
    return return_tuple;
}

static PyObject*
ILasPointCloudMethod_EstimatePointSpacing(PyILasPointCloudObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IEnvelope* ippAOI = NULL;
    PyObject* py_pAOI;
    double dpMinSpacing = 0;
    double dpMaxSpacing = 0;
    double dpMeanSpacing = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_pAOI))
      goto ilaspointcloud_estimatepointspacing_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pAOI, &IID_IEnvelope, (void**)&ippAOI))
        PyErr_SetString(PyExc_TypeError, "Argument pAOI (position 0) is not IEnvelope");
    
    if (PyErr_Occurred())
      goto ilaspointcloud_estimatepointspacing_method_cleanup;
    
    // No setup for pMinSpacing
    // No setup for pMaxSpacing
    // No setup for pMeanSpacing

    // Call method on actual COM interface
    hr = self->m_pILasPointCloud->EstimatePointSpacing(ippAOI, &dpMinSpacing, &dpMaxSpacing, &dpMeanSpacing);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasPointCloud->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasPointCloud) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasPointCloud.EstimatePointSpacing() returned %ld", (long)hr);
        goto ilaspointcloud_estimatepointspacing_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pAOI
    // No teardown for pMinSpacing
    // No teardown for pMaxSpacing
    // No teardown for pMeanSpacing

    // Initialize output tuple
    return_tuple = Py_BuildValue("ddd",
                                            dpMinSpacing, dpMaxSpacing, dpMeanSpacing);
    goto ilaspointcloud_estimatepointspacing_method_cleanup;

    ilaspointcloud_estimatepointspacing_method_cleanup:
    self->m_HR = hr;
    if (ippAOI)
      ippAOI->Release();
    // No cleanup for pMinSpacing
    // No cleanup for pMaxSpacing
    // No cleanup for pMeanSpacing
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasPointCloud.EstimatePointSpacing");
    return return_tuple;
}

static PyObject*
ILasPointCloudMethod_GetLasPoints(PyILasPointCloudObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;
    ILasPointFilter* ippFilter = NULL;
    PyObject* py_pFilter;
    double dthinningFactor = 0;
    double dZFactor = 0;
    IEnumLasPoint* ipppPoints = NULL;
    PyObject* py_ppPoints = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOdd", &py_pTrackCancel, &py_pFilter, &dthinningFactor, &dZFactor))
      goto ilaspointcloud_getlaspoints_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 0) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto ilaspointcloud_getlaspoints_method_cleanup;
    
    if (!IFaceFromPyObject(py_pFilter, &IID_ILasPointFilter, (void**)&ippFilter))
        PyErr_SetString(PyExc_TypeError, "Argument pFilter (position 1) is not ILasPointFilter");
    
    if (PyErr_Occurred())
      goto ilaspointcloud_getlaspoints_method_cleanup;
    
    // No setup for thinningFactor
    // No setup for ZFactor
    // No setup for ppPoints

    // Call method on actual COM interface
    hr = self->m_pILasPointCloud->GetLasPoints(ippTrackCancel, ippFilter, dthinningFactor, dZFactor, &ipppPoints);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasPointCloud->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasPointCloud) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasPointCloud.GetLasPoints() returned %ld", (long)hr);
        goto ilaspointcloud_getlaspoints_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pTrackCancel
    // No teardown for pFilter
    // No teardown for thinningFactor
    // No teardown for ZFactor
    Py_XDECREF(py_ppPoints);
    if (ipppPoints)
    {
        IUnknown* pUnk = NULL;
        ipppPoints->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppPoints = IUnknownToPythonIIDObject(pUnk, &IID_IEnumLasPoint);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppPoints)
    {
        if (py_ppPoints)
           Py_DECREF(py_ppPoints);
        py_ppPoints = Py_None;
        Py_INCREF(py_ppPoints);
    }
    if (PyErr_Occurred())
      goto ilaspointcloud_getlaspoints_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppPoints);
    goto ilaspointcloud_getlaspoints_method_cleanup;

    ilaspointcloud_getlaspoints_method_cleanup:
    self->m_HR = hr;
    if (ippTrackCancel)
      ippTrackCancel->Release();
    if (ippFilter)
      ippFilter->Release();
    // No cleanup for thinningFactor
    // No cleanup for ZFactor
    Py_XDECREF(py_ppPoints);
    if (ipppPoints)
      ipppPoints->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasPointCloud.GetLasPoints");
    return return_tuple;
}

static PyObject*
ILasPointCloudMethod_GetLasPointsByBudget(PyILasPointCloudObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;
    ILasPointFilter* ippFilter = NULL;
    PyObject* py_pFilter;
    double dmaxPointCount = 0;
    double dZFactor = 0;
    IEnumLasPoint* ipppPoints = NULL;
    PyObject* py_ppPoints = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOdd", &py_pTrackCancel, &py_pFilter, &dmaxPointCount, &dZFactor))
      goto ilaspointcloud_getlaspointsbybudget_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 0) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto ilaspointcloud_getlaspointsbybudget_method_cleanup;
    
    if (!IFaceFromPyObject(py_pFilter, &IID_ILasPointFilter, (void**)&ippFilter))
        PyErr_SetString(PyExc_TypeError, "Argument pFilter (position 1) is not ILasPointFilter");
    
    if (PyErr_Occurred())
      goto ilaspointcloud_getlaspointsbybudget_method_cleanup;
    
    // No setup for maxPointCount
    // No setup for ZFactor
    // No setup for ppPoints

    // Call method on actual COM interface
    hr = self->m_pILasPointCloud->GetLasPointsByBudget(ippTrackCancel, ippFilter, dmaxPointCount, dZFactor, &ipppPoints);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasPointCloud->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasPointCloud) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasPointCloud.GetLasPointsByBudget() returned %ld", (long)hr);
        goto ilaspointcloud_getlaspointsbybudget_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pTrackCancel
    // No teardown for pFilter
    // No teardown for maxPointCount
    // No teardown for ZFactor
    Py_XDECREF(py_ppPoints);
    if (ipppPoints)
    {
        IUnknown* pUnk = NULL;
        ipppPoints->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppPoints = IUnknownToPythonIIDObject(pUnk, &IID_IEnumLasPoint);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppPoints)
    {
        if (py_ppPoints)
           Py_DECREF(py_ppPoints);
        py_ppPoints = Py_None;
        Py_INCREF(py_ppPoints);
    }
    if (PyErr_Occurred())
      goto ilaspointcloud_getlaspointsbybudget_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppPoints);
    goto ilaspointcloud_getlaspointsbybudget_method_cleanup;

    ilaspointcloud_getlaspointsbybudget_method_cleanup:
    self->m_HR = hr;
    if (ippTrackCancel)
      ippTrackCancel->Release();
    if (ippFilter)
      ippFilter->Release();
    // No cleanup for maxPointCount
    // No cleanup for ZFactor
    Py_XDECREF(py_ppPoints);
    if (ipppPoints)
      ipppPoints->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasPointCloud.GetLasPointsByBudget");
    return return_tuple;
}

static PyObject*
ILasPointCloudMethod_GetLasPointInfo(PyILasPointCloudObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;
    IGeometry* ippLocation = NULL;
    PyObject* py_pLocation;
    double dPointID = 0;
    IArray* ipppInfo = NULL;
    PyObject* py_ppInfo = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOd", &py_pTrackCancel, &py_pLocation, &dPointID))
      goto ilaspointcloud_getlaspointinfo_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 0) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto ilaspointcloud_getlaspointinfo_method_cleanup;
    
    if (!IFaceFromPyObject(py_pLocation, &IID_IGeometry, (void**)&ippLocation))
        PyErr_SetString(PyExc_TypeError, "Argument pLocation (position 1) is not IGeometry");
    
    if (PyErr_Occurred())
      goto ilaspointcloud_getlaspointinfo_method_cleanup;
    
    // No setup for PointID
    // No setup for ppInfo

    // Call method on actual COM interface
    hr = self->m_pILasPointCloud->GetLasPointInfo(ippTrackCancel, ippLocation, dPointID, &ipppInfo);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasPointCloud->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasPointCloud) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasPointCloud.GetLasPointInfo() returned %ld", (long)hr);
        goto ilaspointcloud_getlaspointinfo_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pTrackCancel
    // No teardown for pLocation
    // No teardown for PointID
    Py_XDECREF(py_ppInfo);
    if (ipppInfo)
    {
        IUnknown* pUnk = NULL;
        ipppInfo->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppInfo = IUnknownToPythonIIDObject(pUnk, &IID_IArray);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppInfo)
    {
        if (py_ppInfo)
           Py_DECREF(py_ppInfo);
        py_ppInfo = Py_None;
        Py_INCREF(py_ppInfo);
    }
    if (PyErr_Occurred())
      goto ilaspointcloud_getlaspointinfo_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppInfo);
    goto ilaspointcloud_getlaspointinfo_method_cleanup;

    ilaspointcloud_getlaspointinfo_method_cleanup:
    self->m_HR = hr;
    if (ippTrackCancel)
      ippTrackCancel->Release();
    if (ippLocation)
      ippLocation->Release();
    // No cleanup for PointID
    Py_XDECREF(py_ppInfo);
    if (ipppInfo)
      ipppInfo->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasPointCloud.GetLasPointInfo");
    return return_tuple;
}

static PyObject*
ILasPointCloudMethod_QueryLasPointInfo(PyILasPointCloudObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lFileIndex = 0;
    double dPointID = 0;
    ILasPointInfo* ippInfo = NULL;
    PyObject* py_pInfo;

    // Unpack values
    if (!PyArg_ParseTuple(args, "ldO", &lFileIndex, &dPointID, &py_pInfo))
      goto ilaspointcloud_querylaspointinfo_method_cleanup;

    // Set up initial variable values as needed
    // No setup for FileIndex
    // No setup for PointID
    if (!IFaceFromPyObject(py_pInfo, &IID_ILasPointInfo, (void**)&ippInfo))
        PyErr_SetString(PyExc_TypeError, "Argument pInfo (position 2) is not ILasPointInfo");
    
    if (PyErr_Occurred())
      goto ilaspointcloud_querylaspointinfo_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pILasPointCloud->QueryLasPointInfo(lFileIndex, dPointID, ippInfo);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasPointCloud->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasPointCloud) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasPointCloud.QueryLasPointInfo() returned %ld", (long)hr);
        goto ilaspointcloud_querylaspointinfo_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for FileIndex
    // No teardown for PointID
    // No teardown for pInfo

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ilaspointcloud_querylaspointinfo_method_cleanup;

    ilaspointcloud_querylaspointinfo_method_cleanup:
    self->m_HR = hr;
    // No cleanup for FileIndex
    // No cleanup for PointID
    if (ippInfo)
      ippInfo->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasPointCloud.QueryLasPointInfo");
    return return_tuple;
}

static PyObject*
ILasPointCloudMethod_LasPointStatsAsRaster(PyILasPointCloudObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;
    ILasPointFilter* ippFilter = NULL;
    PyObject* py_pFilter;
    IRasterDataset* ippDataset = NULL;
    PyObject* py_pDataset;
    esriLasPointStatsType eType;
    esriLasAttributeType eAttribute;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOOii", &py_pTrackCancel, &py_pFilter, &py_pDataset, (int *)&eType, (int *)&eAttribute))
      goto ilaspointcloud_laspointstatsasraster_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 0) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto ilaspointcloud_laspointstatsasraster_method_cleanup;
    
    if (!IFaceFromPyObject(py_pFilter, &IID_ILasPointFilter, (void**)&ippFilter))
        PyErr_SetString(PyExc_TypeError, "Argument pFilter (position 1) is not ILasPointFilter");
    
    if (PyErr_Occurred())
      goto ilaspointcloud_laspointstatsasraster_method_cleanup;
    
    if (!IFaceFromPyObject(py_pDataset, &IID_IRasterDataset, (void**)&ippDataset))
        PyErr_SetString(PyExc_TypeError, "Argument pDataset (position 2) is not IRasterDataset");
    
    if (PyErr_Occurred())
      goto ilaspointcloud_laspointstatsasraster_method_cleanup;
    
    // No setup for Type
    // No setup for Attribute

    // Call method on actual COM interface
    hr = self->m_pILasPointCloud->LasPointStatsAsRaster(ippTrackCancel, ippFilter, ippDataset, eType, eAttribute);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasPointCloud->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasPointCloud) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasPointCloud.LasPointStatsAsRaster() returned %ld", (long)hr);
        goto ilaspointcloud_laspointstatsasraster_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pTrackCancel
    // No teardown for pFilter
    // No teardown for pDataset
    // No teardown for Type
    // No teardown for Attribute

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ilaspointcloud_laspointstatsasraster_method_cleanup;

    ilaspointcloud_laspointstatsasraster_method_cleanup:
    self->m_HR = hr;
    if (ippTrackCancel)
      ippTrackCancel->Release();
    if (ippFilter)
      ippFilter->Release();
    if (ippDataset)
      ippDataset->Release();
    // No cleanup for Type
    // No cleanup for Attribute
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasPointCloud.LasPointStatsAsRaster");
    return return_tuple;
}


PyMethodDef PyILasPointCloudMethods[] = {
    {"supports", (PyCFunction)PyILasPointCloud_SupportsInterface, METH_O, ""},
    {"EstimatePointCount", (PyCFunction)ILasPointCloudMethod_EstimatePointCount, METH_VARARGS, ""},
    {"EstimatePointSpacing", (PyCFunction)ILasPointCloudMethod_EstimatePointSpacing, METH_VARARGS, ""},
    {"GetLasPoints", (PyCFunction)ILasPointCloudMethod_GetLasPoints, METH_VARARGS, ""},
    {"GetLasPointsByBudget", (PyCFunction)ILasPointCloudMethod_GetLasPointsByBudget, METH_VARARGS, ""},
    {"GetLasPointInfo", (PyCFunction)ILasPointCloudMethod_GetLasPointInfo, METH_VARARGS, ""},
    {"QueryLasPointInfo", (PyCFunction)ILasPointCloudMethod_QueryLasPointInfo, METH_VARARGS, ""},
    {"LasPointStatsAsRaster", (PyCFunction)ILasPointCloudMethod_LasPointStatsAsRaster, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyILasPointCloudGetSet[] = {
  {"_pUnk", (getter)PyILasPointCloud_GetpUnk, NULL, "Get opaque pointer to an Unknown from ILasPointCloud", NULL},
  {"_pointer", (getter)PyILasPointCloud_GetPointer, NULL, "Get memory address for ILasPointCloud", NULL},
  {"_IID", (getter)PyILasPointCloud_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyILasPointCloud_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyILasPointCloud_GetIgnoreFailures, (setter)PyILasPointCloud_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyILasPointCloudObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.ILasPointCloudObject",                          
                                              /* tp_name */
  sizeof(PyILasPointCloudObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyILasPointCloudObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyILasPointCloudMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyILasPointCloudGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyILasPointCloudObject_new,                      
                                              /* tp_new */
};

// Interface ILasDatasetWorkspace

typedef struct PyILasDatasetWorkspaceObject {
    PyObject_HEAD
    ILasDatasetWorkspace* m_pILasDatasetWorkspace;
    HRESULT m_HR;
    int m_ignore_failures;
} PyILasDatasetWorkspaceObject;

static PyObject*
PyILasDatasetWorkspaceObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyILasDatasetWorkspaceObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ILasDatasetWorkspace* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ILasDatasetWorkspace, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ILasDatasetWorkspace with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyILasDatasetWorkspaceObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ILasDatasetWorkspace");
            return NULL;
        }
        self->m_pILasDatasetWorkspace = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ILasDatasetWorkspace");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ILasDatasetWorkspace");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ILasDatasetWorkspace* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ILasDatasetWorkspace, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ILasDatasetWorkspace");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyILasDatasetWorkspaceObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ILasDatasetWorkspace");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pILasDatasetWorkspace = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyILasDatasetWorkspaceObject_dealloc(PyILasDatasetWorkspaceObject* self)
{
    if (self->m_pILasDatasetWorkspace)
        self->m_pILasDatasetWorkspace->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyILasDatasetWorkspace_GetpUnk(PyILasDatasetWorkspaceObject* self)
{
    if (!self->m_pILasDatasetWorkspace)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pILasDatasetWorkspace->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ILasDatasetWorkspace to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyILasDatasetWorkspace_GetPointer(PyILasDatasetWorkspaceObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pILasDatasetWorkspace);
}

static PyObject*
PyILasDatasetWorkspace_GetIID(PyILasDatasetWorkspaceObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "eb2e798d-8154-41e9-a70f-53128de11573");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyILasDatasetWorkspace_GetHR(PyILasDatasetWorkspaceObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyILasDatasetWorkspace_GetIgnoreFailures(PyILasDatasetWorkspaceObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyILasDatasetWorkspace_SetIgnoreFailures(PyILasDatasetWorkspaceObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyILasDatasetWorkspace_SupportsInterface(PyILasDatasetWorkspaceObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pILasDatasetWorkspace->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ILasDatasetWorkspaceMethod_get_IsLasDataset(PyILasDatasetWorkspaceObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName = 0;
    PyObject* pyvar_Name;
    PyObject* unicodeName = NULL;
    VARIANT_BOOL b_pbIsDataset = VARIANT_FALSE;
    PyObject* pyvar_pbIsDataset = Py_False;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_Name))
      goto ilasdatasetworkspace_get_islasdataset_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_Name))
        unicodeName = PyUnicode_FromObject(pyvar_Name);
    else if (PyUnicode_Check(pyvar_Name))
    {
        unicodeName = pyvar_Name;
        Py_INCREF(unicodeName);
    }
    else if (pyvar_Name != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Name at index 0");
    if (unicodeName)
        bsName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeName));
    
    if (PyErr_Occurred())
      goto ilasdatasetworkspace_get_islasdataset_method_cleanup;
    
    // No setup for pbIsDataset

    // Call method on actual COM interface
    hr = self->m_pILasDatasetWorkspace->get_IsLasDataset(bsName, &b_pbIsDataset);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasDatasetWorkspace->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasDatasetWorkspace) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasDatasetWorkspace.get_IsLasDataset() returned %ld", (long)hr);
        goto ilasdatasetworkspace_get_islasdataset_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Name
    pyvar_pbIsDataset = ((b_pbIsDataset == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto ilasdatasetworkspace_get_islasdataset_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pbIsDataset);
    goto ilasdatasetworkspace_get_islasdataset_method_cleanup;

    ilasdatasetworkspace_get_islasdataset_method_cleanup:
    self->m_HR = hr;
    if (bsName)
        ::SysFreeString(bsName);
    
    // No cleanup for pbIsDataset
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasDatasetWorkspace.get_IsLasDataset");
    return return_tuple;
}

static PyObject*
ILasDatasetWorkspaceMethod_OpenLasDataset(PyILasDatasetWorkspaceObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName = 0;
    PyObject* pyvar_Name;
    PyObject* unicodeName = NULL;
    ILasDataset* ipppLasDataset = NULL;
    PyObject* py_ppLasDataset = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_Name))
      goto ilasdatasetworkspace_openlasdataset_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_Name))
        unicodeName = PyUnicode_FromObject(pyvar_Name);
    else if (PyUnicode_Check(pyvar_Name))
    {
        unicodeName = pyvar_Name;
        Py_INCREF(unicodeName);
    }
    else if (pyvar_Name != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Name at index 0");
    if (unicodeName)
        bsName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeName));
    
    if (PyErr_Occurred())
      goto ilasdatasetworkspace_openlasdataset_method_cleanup;
    
    // No setup for ppLasDataset

    // Call method on actual COM interface
    hr = self->m_pILasDatasetWorkspace->OpenLasDataset(bsName, &ipppLasDataset);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasDatasetWorkspace->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasDatasetWorkspace) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasDatasetWorkspace.OpenLasDataset() returned %ld", (long)hr);
        goto ilasdatasetworkspace_openlasdataset_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Name
    Py_XDECREF(py_ppLasDataset);
    if (ipppLasDataset)
    {
        IUnknown* pUnk = NULL;
        ipppLasDataset->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppLasDataset = IUnknownToPythonIIDObject(pUnk, &IID_ILasDataset);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppLasDataset)
    {
        if (py_ppLasDataset)
           Py_DECREF(py_ppLasDataset);
        py_ppLasDataset = Py_None;
        Py_INCREF(py_ppLasDataset);
    }
    if (PyErr_Occurred())
      goto ilasdatasetworkspace_openlasdataset_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppLasDataset);
    goto ilasdatasetworkspace_openlasdataset_method_cleanup;

    ilasdatasetworkspace_openlasdataset_method_cleanup:
    self->m_HR = hr;
    if (bsName)
        ::SysFreeString(bsName);
    
    Py_XDECREF(py_ppLasDataset);
    if (ipppLasDataset)
      ipppLasDataset->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasDatasetWorkspace.OpenLasDataset");
    return return_tuple;
}


PyMethodDef PyILasDatasetWorkspaceMethods[] = {
    {"supports", (PyCFunction)PyILasDatasetWorkspace_SupportsInterface, METH_O, ""},
    {"get_IsLasDataset", (PyCFunction)ILasDatasetWorkspaceMethod_get_IsLasDataset, METH_VARARGS, ""},
    {"OpenLasDataset", (PyCFunction)ILasDatasetWorkspaceMethod_OpenLasDataset, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyILasDatasetWorkspaceGetSet[] = {
  {"_pUnk", (getter)PyILasDatasetWorkspace_GetpUnk, NULL, "Get opaque pointer to an Unknown from ILasDatasetWorkspace", NULL},
  {"_pointer", (getter)PyILasDatasetWorkspace_GetPointer, NULL, "Get memory address for ILasDatasetWorkspace", NULL},
  {"_IID", (getter)PyILasDatasetWorkspace_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyILasDatasetWorkspace_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyILasDatasetWorkspace_GetIgnoreFailures, (setter)PyILasDatasetWorkspace_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyILasDatasetWorkspaceObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.ILasDatasetWorkspaceObject",                          
                                              /* tp_name */
  sizeof(PyILasDatasetWorkspaceObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyILasDatasetWorkspaceObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyILasDatasetWorkspaceMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyILasDatasetWorkspaceGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyILasDatasetWorkspaceObject_new,                      
                                              /* tp_new */
};

// Interface ILasDataset2

typedef struct PyILasDataset2Object {
    PyObject_HEAD
    ILasDataset2* m_pILasDataset2;
    HRESULT m_HR;
    int m_ignore_failures;
} PyILasDataset2Object;

static PyObject*
PyILasDataset2Object_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyILasDataset2Object* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ILasDataset2* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ILasDataset2, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ILasDataset2 with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyILasDataset2Object *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ILasDataset2");
            return NULL;
        }
        self->m_pILasDataset2 = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ILasDataset2");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ILasDataset2");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ILasDataset2* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ILasDataset2, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ILasDataset2");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyILasDataset2Object *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ILasDataset2");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pILasDataset2 = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyILasDataset2Object_dealloc(PyILasDataset2Object* self)
{
    if (self->m_pILasDataset2)
        self->m_pILasDataset2->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyILasDataset2_GetpUnk(PyILasDataset2Object* self)
{
    if (!self->m_pILasDataset2)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pILasDataset2->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ILasDataset2 to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyILasDataset2_GetPointer(PyILasDataset2Object* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pILasDataset2);
}

static PyObject*
PyILasDataset2_GetIID(PyILasDataset2Object* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "3af8a856-b6c2-41e4-8b51-8ac0e8777087");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyILasDataset2_GetHR(PyILasDataset2Object* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyILasDataset2_GetIgnoreFailures(PyILasDataset2Object* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyILasDataset2_SetIgnoreFailures(PyILasDataset2Object* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyILasDataset2_SupportsInterface(PyILasDataset2Object* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pILasDataset2->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ILasDataset2Method_Rearrange(PyILasDataset2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;
    long lFileIndex = 0;
    BSTR bsnewFileName = 0;
    PyObject* pyvar_newFileName;
    PyObject* unicodenewFileName = NULL;
    VARIANT_BOOL b_bOverWrite = VARIANT_FALSE;
    PyObject* pyvar_bOverWrite = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OlOO", &py_pTrackCancel, &lFileIndex, &pyvar_newFileName, &pyvar_bOverWrite))
      goto ilasdataset2_rearrange_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 0) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto ilasdataset2_rearrange_method_cleanup;
    
    // No setup for FileIndex
    if (PyString_Check(pyvar_newFileName))
        unicodenewFileName = PyUnicode_FromObject(pyvar_newFileName);
    else if (PyUnicode_Check(pyvar_newFileName))
    {
        unicodenewFileName = pyvar_newFileName;
        Py_INCREF(unicodenewFileName);
    }
    else if (pyvar_newFileName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter newFileName at index 2");
    if (unicodenewFileName)
        bsnewFileName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodenewFileName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodenewFileName));
    
    if (PyErr_Occurred())
      goto ilasdataset2_rearrange_method_cleanup;
    
    b_bOverWrite = ((PyObject_IsTrue(pyvar_bOverWrite) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto ilasdataset2_rearrange_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pILasDataset2->Rearrange(ippTrackCancel, lFileIndex, bsnewFileName, b_bOverWrite);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasDataset2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasDataset2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasDataset2.Rearrange() returned %ld", (long)hr);
        goto ilasdataset2_rearrange_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pTrackCancel
    // No teardown for FileIndex
    // No teardown for newFileName
    // No teardown for bOverWrite

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ilasdataset2_rearrange_method_cleanup;

    ilasdataset2_rearrange_method_cleanup:
    self->m_HR = hr;
    if (ippTrackCancel)
      ippTrackCancel->Release();
    // No cleanup for FileIndex
    if (bsnewFileName)
        ::SysFreeString(bsnewFileName);
    
    // No cleanup for bOverWrite
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasDataset2.Rearrange");
    return return_tuple;
}

static PyObject*
ILasDataset2Method_SetEmpty(PyILasDataset2Object* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pILasDataset2->SetEmpty();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasDataset2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasDataset2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasDataset2.SetEmpty() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}

static PyObject*
ILasDataset2Method_Init(PyILasDataset2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName = 0;
    PyObject* pyvar_Name;
    PyObject* unicodeName = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_Name))
      goto ilasdataset2_init_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_Name))
        unicodeName = PyUnicode_FromObject(pyvar_Name);
    else if (PyUnicode_Check(pyvar_Name))
    {
        unicodeName = pyvar_Name;
        Py_INCREF(unicodeName);
    }
    else if (pyvar_Name != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Name at index 0");
    if (unicodeName)
        bsName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeName));
    
    if (PyErr_Occurred())
      goto ilasdataset2_init_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pILasDataset2->Init(bsName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasDataset2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasDataset2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasDataset2.Init() returned %ld", (long)hr);
        goto ilasdataset2_init_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Name

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ilasdataset2_init_method_cleanup;

    ilasdataset2_init_method_cleanup:
    self->m_HR = hr;
    if (bsName)
        ::SysFreeString(bsName);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasDataset2.Init");
    return return_tuple;
}

static PyObject*
ILasDataset2Method_SaveAs(PyILasDataset2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName = 0;
    PyObject* pyvar_Name;
    PyObject* unicodeName = NULL;
    VARIANT_BOOL b_bOverWrite = VARIANT_FALSE;
    PyObject* pyvar_bOverWrite = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OO", &pyvar_Name, &pyvar_bOverWrite))
      goto ilasdataset2_saveas_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_Name))
        unicodeName = PyUnicode_FromObject(pyvar_Name);
    else if (PyUnicode_Check(pyvar_Name))
    {
        unicodeName = pyvar_Name;
        Py_INCREF(unicodeName);
    }
    else if (pyvar_Name != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Name at index 0");
    if (unicodeName)
        bsName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeName));
    
    if (PyErr_Occurred())
      goto ilasdataset2_saveas_method_cleanup;
    
    b_bOverWrite = ((PyObject_IsTrue(pyvar_bOverWrite) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto ilasdataset2_saveas_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pILasDataset2->SaveAs(bsName, b_bOverWrite);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasDataset2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasDataset2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasDataset2.SaveAs() returned %ld", (long)hr);
        goto ilasdataset2_saveas_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Name
    // No teardown for bOverWrite

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ilasdataset2_saveas_method_cleanup;

    ilasdataset2_saveas_method_cleanup:
    self->m_HR = hr;
    if (bsName)
        ::SysFreeString(bsName);
    
    // No cleanup for bOverWrite
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasDataset2.SaveAs");
    return return_tuple;
}

static PyObject*
ILasDataset2Method_get_Name(PyILasDataset2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspName;
    PyObject* pyvar_pName = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pName

    // Call method on actual COM interface
    hr = self->m_pILasDataset2->get_Name(&bspName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasDataset2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasDataset2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasDataset2.get_Name() returned %ld", (long)hr);
        goto ilasdataset2_get_name_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pName = PyUnicode_FromWideChar(bspName,::SysStringLen(bspName));
    ::SysFreeString(bspName);
    
    if (PyErr_Occurred())
      goto ilasdataset2_get_name_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pName);
    goto ilasdataset2_get_name_method_cleanup;

    ilasdataset2_get_name_method_cleanup:
    self->m_HR = hr;
    if (pyvar_pName != Py_None)
        Py_XDECREF(pyvar_pName);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasDataset2.get_Name");
    return return_tuple;
}

static PyObject*
ILasDataset2Method_get_UsesRelativePath(PyILasDataset2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pbUsesRelativePath = VARIANT_FALSE;
    PyObject* pyvar_pbUsesRelativePath = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pbUsesRelativePath

    // Call method on actual COM interface
    hr = self->m_pILasDataset2->get_UsesRelativePath(&b_pbUsesRelativePath);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasDataset2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasDataset2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasDataset2.get_UsesRelativePath() returned %ld", (long)hr);
        goto ilasdataset2_get_usesrelativepath_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pbUsesRelativePath = ((b_pbUsesRelativePath == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto ilasdataset2_get_usesrelativepath_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pbUsesRelativePath);
    goto ilasdataset2_get_usesrelativepath_method_cleanup;

    ilasdataset2_get_usesrelativepath_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pbUsesRelativePath
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasDataset2.get_UsesRelativePath");
    return return_tuple;
}

static PyObject*
ILasDataset2Method_get_IsDirty(PyILasDataset2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pbIsDirty = VARIANT_FALSE;
    PyObject* pyvar_pbIsDirty = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pbIsDirty

    // Call method on actual COM interface
    hr = self->m_pILasDataset2->get_IsDirty(&b_pbIsDirty);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasDataset2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasDataset2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasDataset2.get_IsDirty() returned %ld", (long)hr);
        goto ilasdataset2_get_isdirty_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pbIsDirty = ((b_pbIsDirty == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto ilasdataset2_get_isdirty_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pbIsDirty);
    goto ilasdataset2_get_isdirty_method_cleanup;

    ilasdataset2_get_isdirty_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pbIsDirty
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasDataset2.get_IsDirty");
    return return_tuple;
}

static PyObject*
ILasDataset2Method_get_SpatialReference(PyILasDataset2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ISpatialReference* ipppSpatialRef = NULL;
    PyObject* py_ppSpatialRef = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppSpatialRef

    // Call method on actual COM interface
    hr = self->m_pILasDataset2->get_SpatialReference(&ipppSpatialRef);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasDataset2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasDataset2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasDataset2.get_SpatialReference() returned %ld", (long)hr);
        goto ilasdataset2_get_spatialreference_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppSpatialRef);
    if (ipppSpatialRef)
    {
        IUnknown* pUnk = NULL;
        ipppSpatialRef->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppSpatialRef = IUnknownToPythonIIDObject(pUnk, &IID_ISpatialReference);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppSpatialRef)
    {
        if (py_ppSpatialRef)
           Py_DECREF(py_ppSpatialRef);
        py_ppSpatialRef = Py_None;
        Py_INCREF(py_ppSpatialRef);
    }
    if (PyErr_Occurred())
      goto ilasdataset2_get_spatialreference_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppSpatialRef);
    goto ilasdataset2_get_spatialreference_method_cleanup;

    ilasdataset2_get_spatialreference_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppSpatialRef);
    if (ipppSpatialRef)
      ipppSpatialRef->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasDataset2.get_SpatialReference");
    return return_tuple;
}

static PyObject*
ILasDataset2Method_get_Extent(PyILasDataset2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IEnvelope* ipppExtent = NULL;
    PyObject* py_ppExtent = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppExtent

    // Call method on actual COM interface
    hr = self->m_pILasDataset2->get_Extent(&ipppExtent);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasDataset2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasDataset2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasDataset2.get_Extent() returned %ld", (long)hr);
        goto ilasdataset2_get_extent_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppExtent);
    if (ipppExtent)
    {
        IUnknown* pUnk = NULL;
        ipppExtent->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppExtent = IUnknownToPythonIIDObject(pUnk, &IID_IEnvelope);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppExtent)
    {
        if (py_ppExtent)
           Py_DECREF(py_ppExtent);
        py_ppExtent = Py_None;
        Py_INCREF(py_ppExtent);
    }
    if (PyErr_Occurred())
      goto ilasdataset2_get_extent_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppExtent);
    goto ilasdataset2_get_extent_method_cleanup;

    ilasdataset2_get_extent_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppExtent);
    if (ipppExtent)
      ipppExtent->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasDataset2.get_Extent");
    return return_tuple;
}

static PyObject*
ILasDataset2Method_get_FileCount(PyILasDataset2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpcFiles = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pcFiles

    // Call method on actual COM interface
    hr = self->m_pILasDataset2->get_FileCount(&lpcFiles);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasDataset2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasDataset2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasDataset2.get_FileCount() returned %ld", (long)hr);
        goto ilasdataset2_get_filecount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pcFiles

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpcFiles);
    goto ilasdataset2_get_filecount_method_cleanup;

    ilasdataset2_get_filecount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pcFiles
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasDataset2.get_FileCount");
    return return_tuple;
}

static PyObject*
ILasDataset2Method_get_File(PyILasDataset2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;
    ILasFile* ipppFile = NULL;
    PyObject* py_ppFile = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lindex))
      goto ilasdataset2_get_file_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index
    // No setup for ppFile

    // Call method on actual COM interface
    hr = self->m_pILasDataset2->get_File(lindex, &ipppFile);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasDataset2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasDataset2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasDataset2.get_File() returned %ld", (long)hr);
        goto ilasdataset2_get_file_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index
    Py_XDECREF(py_ppFile);
    if (ipppFile)
    {
        IUnknown* pUnk = NULL;
        ipppFile->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppFile = IUnknownToPythonIIDObject(pUnk, &IID_ILasFile);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppFile)
    {
        if (py_ppFile)
           Py_DECREF(py_ppFile);
        py_ppFile = Py_None;
        Py_INCREF(py_ppFile);
    }
    if (PyErr_Occurred())
      goto ilasdataset2_get_file_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppFile);
    goto ilasdataset2_get_file_method_cleanup;

    ilasdataset2_get_file_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    Py_XDECREF(py_ppFile);
    if (ipppFile)
      ipppFile->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasDataset2.get_File");
    return return_tuple;
}

static PyObject*
ILasDataset2Method_get_SurfaceConstraintCount(PyILasDataset2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpcConstraints = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pcConstraints

    // Call method on actual COM interface
    hr = self->m_pILasDataset2->get_SurfaceConstraintCount(&lpcConstraints);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasDataset2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasDataset2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasDataset2.get_SurfaceConstraintCount() returned %ld", (long)hr);
        goto ilasdataset2_get_surfaceconstraintcount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pcConstraints

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpcConstraints);
    goto ilasdataset2_get_surfaceconstraintcount_method_cleanup;

    ilasdataset2_get_surfaceconstraintcount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pcConstraints
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasDataset2.get_SurfaceConstraintCount");
    return return_tuple;
}

static PyObject*
ILasDataset2Method_GetSurfaceConstraint(PyILasDataset2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;
    IFeatureClass* ipppClass = NULL;
    PyObject* py_ppClass = NULL;
    IField* ipppHeightField = NULL;
    PyObject* py_ppHeightField = NULL;
    IField* ipppTagField = NULL;
    PyObject* py_ppTagField = NULL;
    esriTinSurfaceType epType;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lindex))
      goto ilasdataset2_getsurfaceconstraint_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index
    // No setup for ppClass
    // No setup for ppHeightField
    // No setup for ppTagField
    // No setup for pType

    // Call method on actual COM interface
    hr = self->m_pILasDataset2->GetSurfaceConstraint(lindex, &ipppClass, &ipppHeightField, &ipppTagField, &epType);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasDataset2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasDataset2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasDataset2.GetSurfaceConstraint() returned %ld", (long)hr);
        goto ilasdataset2_getsurfaceconstraint_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index
    Py_XDECREF(py_ppClass);
    if (ipppClass)
    {
        IUnknown* pUnk = NULL;
        ipppClass->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppClass = IUnknownToPythonIIDObject(pUnk, &IID_IFeatureClass);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppClass)
    {
        if (py_ppClass)
           Py_DECREF(py_ppClass);
        py_ppClass = Py_None;
        Py_INCREF(py_ppClass);
    }
    if (PyErr_Occurred())
      goto ilasdataset2_getsurfaceconstraint_method_cleanup;
    
    Py_XDECREF(py_ppHeightField);
    if (ipppHeightField)
    {
        IUnknown* pUnk = NULL;
        ipppHeightField->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppHeightField = IUnknownToPythonIIDObject(pUnk, &IID_IField);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppHeightField)
    {
        if (py_ppHeightField)
           Py_DECREF(py_ppHeightField);
        py_ppHeightField = Py_None;
        Py_INCREF(py_ppHeightField);
    }
    if (PyErr_Occurred())
      goto ilasdataset2_getsurfaceconstraint_method_cleanup;
    
    Py_XDECREF(py_ppTagField);
    if (ipppTagField)
    {
        IUnknown* pUnk = NULL;
        ipppTagField->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppTagField = IUnknownToPythonIIDObject(pUnk, &IID_IField);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppTagField)
    {
        if (py_ppTagField)
           Py_DECREF(py_ppTagField);
        py_ppTagField = Py_None;
        Py_INCREF(py_ppTagField);
    }
    if (PyErr_Occurred())
      goto ilasdataset2_getsurfaceconstraint_method_cleanup;
    
    // No teardown for pType

    // Initialize output tuple
    return_tuple = Py_BuildValue("OOOi",
                                            py_ppClass, py_ppHeightField, py_ppTagField, (int)epType);
    goto ilasdataset2_getsurfaceconstraint_method_cleanup;

    ilasdataset2_getsurfaceconstraint_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    Py_XDECREF(py_ppClass);
    if (ipppClass)
      ipppClass->Release();
    Py_XDECREF(py_ppHeightField);
    if (ipppHeightField)
      ipppHeightField->Release();
    Py_XDECREF(py_ppTagField);
    if (ipppTagField)
      ipppTagField->Release();
    // No cleanup for pType
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasDataset2.GetSurfaceConstraint");
    return return_tuple;
}

static PyObject*
ILasDataset2Method_GetSurfaceConstraintName(PyILasDataset2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;
    IFeatureClassName* ipppName = NULL;
    PyObject* py_ppName = NULL;
    BSTR bspHeightField;
    PyObject* pyvar_pHeightField = Py_None;
    BSTR bspTagField;
    PyObject* pyvar_pTagField = Py_None;
    esriTinSurfaceType epType;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lindex))
      goto ilasdataset2_getsurfaceconstraintname_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index
    // No setup for ppName
    // No setup for pHeightField
    // No setup for pTagField
    // No setup for pType

    // Call method on actual COM interface
    hr = self->m_pILasDataset2->GetSurfaceConstraintName(lindex, &ipppName, &bspHeightField, &bspTagField, &epType);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasDataset2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasDataset2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasDataset2.GetSurfaceConstraintName() returned %ld", (long)hr);
        goto ilasdataset2_getsurfaceconstraintname_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index
    Py_XDECREF(py_ppName);
    if (ipppName)
    {
        IUnknown* pUnk = NULL;
        ipppName->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppName = IUnknownToPythonIIDObject(pUnk, &IID_IFeatureClassName);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppName)
    {
        if (py_ppName)
           Py_DECREF(py_ppName);
        py_ppName = Py_None;
        Py_INCREF(py_ppName);
    }
    if (PyErr_Occurred())
      goto ilasdataset2_getsurfaceconstraintname_method_cleanup;
    
    pyvar_pHeightField = PyUnicode_FromWideChar(bspHeightField,::SysStringLen(bspHeightField));
    ::SysFreeString(bspHeightField);
    
    if (PyErr_Occurred())
      goto ilasdataset2_getsurfaceconstraintname_method_cleanup;
    
    pyvar_pTagField = PyUnicode_FromWideChar(bspTagField,::SysStringLen(bspTagField));
    ::SysFreeString(bspTagField);
    
    if (PyErr_Occurred())
      goto ilasdataset2_getsurfaceconstraintname_method_cleanup;
    
    // No teardown for pType

    // Initialize output tuple
    return_tuple = Py_BuildValue("OOOi",
                                            py_ppName, pyvar_pHeightField, pyvar_pTagField, (int)epType);
    goto ilasdataset2_getsurfaceconstraintname_method_cleanup;

    ilasdataset2_getsurfaceconstraintname_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    Py_XDECREF(py_ppName);
    if (ipppName)
      ipppName->Release();
    if (pyvar_pHeightField != Py_None)
        Py_XDECREF(pyvar_pHeightField);
    if (pyvar_pTagField != Py_None)
        Py_XDECREF(pyvar_pTagField);
    // No cleanup for pType
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasDataset2.GetSurfaceConstraintName");
    return return_tuple;
}

static PyObject*
ILasDataset2Method_GetSurfaceConstraintID(PyILasDataset2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;
    IUID* ipppGuid = NULL;
    PyObject* py_ppGuid = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lindex))
      goto ilasdataset2_getsurfaceconstraintid_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index
    // No setup for ppGuid

    // Call method on actual COM interface
    hr = self->m_pILasDataset2->GetSurfaceConstraintID(lindex, &ipppGuid);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasDataset2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasDataset2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasDataset2.GetSurfaceConstraintID() returned %ld", (long)hr);
        goto ilasdataset2_getsurfaceconstraintid_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index
    Py_XDECREF(py_ppGuid);
    if (ipppGuid)
    {
        IUnknown* pUnk = NULL;
        ipppGuid->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppGuid = IUnknownToPythonIIDObject(pUnk, &IID_IUID);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppGuid)
    {
        if (py_ppGuid)
           Py_DECREF(py_ppGuid);
        py_ppGuid = Py_None;
        Py_INCREF(py_ppGuid);
    }
    if (PyErr_Occurred())
      goto ilasdataset2_getsurfaceconstraintid_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppGuid);
    goto ilasdataset2_getsurfaceconstraintid_method_cleanup;

    ilasdataset2_getsurfaceconstraintid_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    Py_XDECREF(py_ppGuid);
    if (ipppGuid)
      ipppGuid->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasDataset2.GetSurfaceConstraintID");
    return return_tuple;
}

static PyObject*
ILasDataset2Method_GetSurfaceConstraintIndexFromID(PyILasDataset2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IUID* ippGuid = NULL;
    PyObject* py_pGuid;
    long lpIndex = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_pGuid))
      goto ilasdataset2_getsurfaceconstraintindexfromid_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pGuid, &IID_IUID, (void**)&ippGuid))
        PyErr_SetString(PyExc_TypeError, "Argument pGuid (position 0) is not IUID");
    
    if (PyErr_Occurred())
      goto ilasdataset2_getsurfaceconstraintindexfromid_method_cleanup;
    
    // No setup for pIndex

    // Call method on actual COM interface
    hr = self->m_pILasDataset2->GetSurfaceConstraintIndexFromID(ippGuid, &lpIndex);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasDataset2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasDataset2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasDataset2.GetSurfaceConstraintIndexFromID() returned %ld", (long)hr);
        goto ilasdataset2_getsurfaceconstraintindexfromid_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pGuid
    // No teardown for pIndex

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpIndex);
    goto ilasdataset2_getsurfaceconstraintindexfromid_method_cleanup;

    ilasdataset2_getsurfaceconstraintindexfromid_method_cleanup:
    self->m_HR = hr;
    if (ippGuid)
      ippGuid->Release();
    // No cleanup for pIndex
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasDataset2.GetSurfaceConstraintIndexFromID");
    return return_tuple;
}

static PyObject*
ILasDataset2Method_get_PointCount(PyILasDataset2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dpCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pCount

    // Call method on actual COM interface
    hr = self->m_pILasDataset2->get_PointCount(&dpCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasDataset2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasDataset2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasDataset2.get_PointCount() returned %ld", (long)hr);
        goto ilasdataset2_get_pointcount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pCount

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dpCount);
    goto ilasdataset2_get_pointcount_method_cleanup;

    ilasdataset2_get_pointcount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pCount
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasDataset2.get_PointCount");
    return return_tuple;
}

static PyObject*
ILasDataset2Method_get_SizeInBytes(PyILasDataset2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dpcBytes = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pcBytes

    // Call method on actual COM interface
    hr = self->m_pILasDataset2->get_SizeInBytes(&dpcBytes);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasDataset2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasDataset2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasDataset2.get_SizeInBytes() returned %ld", (long)hr);
        goto ilasdataset2_get_sizeinbytes_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pcBytes

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dpcBytes);
    goto ilasdataset2_get_sizeinbytes_method_cleanup;

    ilasdataset2_get_sizeinbytes_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pcBytes
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasDataset2.get_SizeInBytes");
    return return_tuple;
}

static PyObject*
ILasDataset2Method_get_HasStatistics(PyILasDataset2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pbHasStats = VARIANT_FALSE;
    PyObject* pyvar_pbHasStats = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pbHasStats

    // Call method on actual COM interface
    hr = self->m_pILasDataset2->get_HasStatistics(&b_pbHasStats);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasDataset2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasDataset2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasDataset2.get_HasStatistics() returned %ld", (long)hr);
        goto ilasdataset2_get_hasstatistics_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pbHasStats = ((b_pbHasStats == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto ilasdataset2_get_hasstatistics_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pbHasStats);
    goto ilasdataset2_get_hasstatistics_method_cleanup;

    ilasdataset2_get_hasstatistics_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pbHasStats
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasDataset2.get_HasStatistics");
    return return_tuple;
}

static PyObject*
ILasDataset2Method_get_NeedsUpdateStatistics(PyILasDataset2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pbNeedsUpdate = VARIANT_FALSE;
    PyObject* pyvar_pbNeedsUpdate = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pbNeedsUpdate

    // Call method on actual COM interface
    hr = self->m_pILasDataset2->get_NeedsUpdateStatistics(&b_pbNeedsUpdate);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasDataset2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasDataset2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasDataset2.get_NeedsUpdateStatistics() returned %ld", (long)hr);
        goto ilasdataset2_get_needsupdatestatistics_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pbNeedsUpdate = ((b_pbNeedsUpdate == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto ilasdataset2_get_needsupdatestatistics_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pbNeedsUpdate);
    goto ilasdataset2_get_needsupdatestatistics_method_cleanup;

    ilasdataset2_get_needsupdatestatistics_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pbNeedsUpdate
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasDataset2.get_NeedsUpdateStatistics");
    return return_tuple;
}

static PyObject*
ILasDataset2Method_GetStatistics(PyILasDataset2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ILasStatistics* ipppStatistics = NULL;
    PyObject* py_ppStatistics = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppStatistics

    // Call method on actual COM interface
    hr = self->m_pILasDataset2->GetStatistics(&ipppStatistics);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasDataset2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasDataset2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasDataset2.GetStatistics() returned %ld", (long)hr);
        goto ilasdataset2_getstatistics_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppStatistics);
    if (ipppStatistics)
    {
        IUnknown* pUnk = NULL;
        ipppStatistics->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppStatistics = IUnknownToPythonIIDObject(pUnk, &IID_ILasStatistics);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppStatistics)
    {
        if (py_ppStatistics)
           Py_DECREF(py_ppStatistics);
        py_ppStatistics = Py_None;
        Py_INCREF(py_ppStatistics);
    }
    if (PyErr_Occurred())
      goto ilasdataset2_getstatistics_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppStatistics);
    goto ilasdataset2_getstatistics_method_cleanup;

    ilasdataset2_getstatistics_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppStatistics);
    if (ipppStatistics)
      ipppStatistics->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasDataset2.GetStatistics");
    return return_tuple;
}

static PyObject*
ILasDataset2Method_CreateDynamicSurface(PyILasDataset2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ILasSurface* ipppSurface = NULL;
    PyObject* py_ppSurface = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppSurface

    // Call method on actual COM interface
    hr = self->m_pILasDataset2->CreateDynamicSurface(&ipppSurface);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasDataset2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasDataset2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasDataset2.CreateDynamicSurface() returned %ld", (long)hr);
        goto ilasdataset2_createdynamicsurface_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppSurface);
    if (ipppSurface)
    {
        IUnknown* pUnk = NULL;
        ipppSurface->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppSurface = IUnknownToPythonIIDObject(pUnk, &IID_ILasSurface);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppSurface)
    {
        if (py_ppSurface)
           Py_DECREF(py_ppSurface);
        py_ppSurface = Py_None;
        Py_INCREF(py_ppSurface);
    }
    if (PyErr_Occurred())
      goto ilasdataset2_createdynamicsurface_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppSurface);
    goto ilasdataset2_createdynamicsurface_method_cleanup;

    ilasdataset2_createdynamicsurface_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppSurface);
    if (ipppSurface)
      ipppSurface->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasDataset2.CreateDynamicSurface");
    return return_tuple;
}

static PyObject*
ILasDataset2Method_Export(PyILasDataset2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;
    long lFileIndex = 0;
    ILasPointFilter* ippFilter = NULL;
    PyObject* py_pFilter;
    BSTR bsnewFileName = 0;
    PyObject* pyvar_newFileName;
    PyObject* unicodenewFileName = NULL;
    ISpatialReference* ippNewSpatialReference = NULL;
    PyObject* py_pNewSpatialReference;
    VARIANT_BOOL b_bProject = VARIANT_FALSE;
    PyObject* pyvar_bProject = NULL;
    VARIANT_BOOL b_bDropVLRs = VARIANT_FALSE;
    PyObject* pyvar_bDropVLRs = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OlOOOOO", &py_pTrackCancel, &lFileIndex, &py_pFilter, &pyvar_newFileName, &py_pNewSpatialReference, &pyvar_bProject, &pyvar_bDropVLRs))
      goto ilasdataset2_export_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 0) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto ilasdataset2_export_method_cleanup;
    
    // No setup for FileIndex
    if (!IFaceFromPyObject(py_pFilter, &IID_ILasPointFilter, (void**)&ippFilter))
        PyErr_SetString(PyExc_TypeError, "Argument pFilter (position 2) is not ILasPointFilter");
    
    if (PyErr_Occurred())
      goto ilasdataset2_export_method_cleanup;
    
    if (PyString_Check(pyvar_newFileName))
        unicodenewFileName = PyUnicode_FromObject(pyvar_newFileName);
    else if (PyUnicode_Check(pyvar_newFileName))
    {
        unicodenewFileName = pyvar_newFileName;
        Py_INCREF(unicodenewFileName);
    }
    else if (pyvar_newFileName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter newFileName at index 3");
    if (unicodenewFileName)
        bsnewFileName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodenewFileName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodenewFileName));
    
    if (PyErr_Occurred())
      goto ilasdataset2_export_method_cleanup;
    
    if (!IFaceFromPyObject(py_pNewSpatialReference, &IID_ISpatialReference, (void**)&ippNewSpatialReference))
        PyErr_SetString(PyExc_TypeError, "Argument pNewSpatialReference (position 4) is not ISpatialReference");
    
    if (PyErr_Occurred())
      goto ilasdataset2_export_method_cleanup;
    
    b_bProject = ((PyObject_IsTrue(pyvar_bProject) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto ilasdataset2_export_method_cleanup;
    
    b_bDropVLRs = ((PyObject_IsTrue(pyvar_bDropVLRs) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto ilasdataset2_export_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pILasDataset2->Export(ippTrackCancel, lFileIndex, ippFilter, bsnewFileName, ippNewSpatialReference, b_bProject, b_bDropVLRs);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasDataset2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasDataset2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasDataset2.Export() returned %ld", (long)hr);
        goto ilasdataset2_export_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pTrackCancel
    // No teardown for FileIndex
    // No teardown for pFilter
    // No teardown for newFileName
    // No teardown for pNewSpatialReference
    // No teardown for bProject
    // No teardown for bDropVLRs

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ilasdataset2_export_method_cleanup;

    ilasdataset2_export_method_cleanup:
    self->m_HR = hr;
    if (ippTrackCancel)
      ippTrackCancel->Release();
    // No cleanup for FileIndex
    if (ippFilter)
      ippFilter->Release();
    if (bsnewFileName)
        ::SysFreeString(bsnewFileName);
    
    if (ippNewSpatialReference)
      ippNewSpatialReference->Release();
    // No cleanup for bProject
    // No cleanup for bDropVLRs
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasDataset2.Export");
    return return_tuple;
}


PyMethodDef PyILasDataset2Methods[] = {
    {"supports", (PyCFunction)PyILasDataset2_SupportsInterface, METH_O, ""},
    {"Rearrange", (PyCFunction)ILasDataset2Method_Rearrange, METH_VARARGS, ""},
    {"SetEmpty", (PyCFunction)ILasDataset2Method_SetEmpty, METH_NOARGS, ""},
    {"Init", (PyCFunction)ILasDataset2Method_Init, METH_VARARGS, ""},
    {"SaveAs", (PyCFunction)ILasDataset2Method_SaveAs, METH_VARARGS, ""},
    {"get_Name", (PyCFunction)ILasDataset2Method_get_Name, METH_VARARGS, ""},
    {"get_UsesRelativePath", (PyCFunction)ILasDataset2Method_get_UsesRelativePath, METH_VARARGS, ""},
    {"get_IsDirty", (PyCFunction)ILasDataset2Method_get_IsDirty, METH_VARARGS, ""},
    {"get_SpatialReference", (PyCFunction)ILasDataset2Method_get_SpatialReference, METH_VARARGS, ""},
    {"get_Extent", (PyCFunction)ILasDataset2Method_get_Extent, METH_VARARGS, ""},
    {"get_FileCount", (PyCFunction)ILasDataset2Method_get_FileCount, METH_VARARGS, ""},
    {"get_File", (PyCFunction)ILasDataset2Method_get_File, METH_VARARGS, ""},
    {"get_SurfaceConstraintCount", (PyCFunction)ILasDataset2Method_get_SurfaceConstraintCount, METH_VARARGS, ""},
    {"GetSurfaceConstraint", (PyCFunction)ILasDataset2Method_GetSurfaceConstraint, METH_VARARGS, ""},
    {"GetSurfaceConstraintName", (PyCFunction)ILasDataset2Method_GetSurfaceConstraintName, METH_VARARGS, ""},
    {"GetSurfaceConstraintID", (PyCFunction)ILasDataset2Method_GetSurfaceConstraintID, METH_VARARGS, ""},
    {"GetSurfaceConstraintIndexFromID", (PyCFunction)ILasDataset2Method_GetSurfaceConstraintIndexFromID, METH_VARARGS, ""},
    {"get_PointCount", (PyCFunction)ILasDataset2Method_get_PointCount, METH_VARARGS, ""},
    {"get_SizeInBytes", (PyCFunction)ILasDataset2Method_get_SizeInBytes, METH_VARARGS, ""},
    {"get_HasStatistics", (PyCFunction)ILasDataset2Method_get_HasStatistics, METH_VARARGS, ""},
    {"get_NeedsUpdateStatistics", (PyCFunction)ILasDataset2Method_get_NeedsUpdateStatistics, METH_VARARGS, ""},
    {"GetStatistics", (PyCFunction)ILasDataset2Method_GetStatistics, METH_VARARGS, ""},
    {"CreateDynamicSurface", (PyCFunction)ILasDataset2Method_CreateDynamicSurface, METH_VARARGS, ""},
    {"Export", (PyCFunction)ILasDataset2Method_Export, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyILasDataset2GetSet[] = {
  {"_pUnk", (getter)PyILasDataset2_GetpUnk, NULL, "Get opaque pointer to an Unknown from ILasDataset2", NULL},
  {"_pointer", (getter)PyILasDataset2_GetPointer, NULL, "Get memory address for ILasDataset2", NULL},
  {"_IID", (getter)PyILasDataset2_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyILasDataset2_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyILasDataset2_GetIgnoreFailures, (setter)PyILasDataset2_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyILasDataset2Object_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.ILasDataset2Object",                          
                                              /* tp_name */
  sizeof(PyILasDataset2Object),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyILasDataset2Object_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyILasDataset2Methods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyILasDataset2GetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyILasDataset2Object_new,                      
                                              /* tp_new */
};

// Interface ILasPointEdit

typedef struct PyILasPointEditObject {
    PyObject_HEAD
    ILasPointEdit* m_pILasPointEdit;
    HRESULT m_HR;
    int m_ignore_failures;
} PyILasPointEditObject;

static PyObject*
PyILasPointEditObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyILasPointEditObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ILasPointEdit* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ILasPointEdit, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ILasPointEdit with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyILasPointEditObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ILasPointEdit");
            return NULL;
        }
        self->m_pILasPointEdit = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ILasPointEdit");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ILasPointEdit");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ILasPointEdit* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ILasPointEdit, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ILasPointEdit");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyILasPointEditObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ILasPointEdit");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pILasPointEdit = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyILasPointEditObject_dealloc(PyILasPointEditObject* self)
{
    if (self->m_pILasPointEdit)
        self->m_pILasPointEdit->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyILasPointEdit_GetpUnk(PyILasPointEditObject* self)
{
    if (!self->m_pILasPointEdit)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pILasPointEdit->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ILasPointEdit to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyILasPointEdit_GetPointer(PyILasPointEditObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pILasPointEdit);
}

static PyObject*
PyILasPointEdit_GetIID(PyILasPointEditObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "5ea400dd-3afa-4423-9bc7-4915f4292911");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyILasPointEdit_GetHR(PyILasPointEditObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyILasPointEdit_GetIgnoreFailures(PyILasPointEditObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyILasPointEdit_SetIgnoreFailures(PyILasPointEditObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyILasPointEdit_SupportsInterface(PyILasPointEditObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pILasPointEdit->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ILasPointEditMethod_SetClassFlag(PyILasPointEditObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;
    long lFileIndex = 0;
    IUnknown* ippAOI = NULL;
    PyObject* py_pAOI;
    double dbufferDistance = 0;
    IDoubleArray* ippZRange = NULL;
    PyObject* py_pZRange;
    ILasAttributeFilter* ippFilter = NULL;
    PyObject* py_pFilter;
    long lnewFlags = 0;
    VARIANT_BOOL b_bClear = VARIANT_FALSE;
    PyObject* pyvar_bClear = NULL;
    VARIANT_BOOL b_bCalculateStats = VARIANT_FALSE;
    PyObject* pyvar_bCalculateStats = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OlOdOOlOO", &py_pTrackCancel, &lFileIndex, &py_pAOI, &dbufferDistance, &py_pZRange, &py_pFilter, &lnewFlags, &pyvar_bClear, &pyvar_bCalculateStats))
      goto ilaspointedit_setclassflag_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 0) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto ilaspointedit_setclassflag_method_cleanup;
    
    // No setup for FileIndex
    if (!IFaceFromPyObject(py_pAOI, &IID_IUnknown, (void**)&ippAOI))
        PyErr_SetString(PyExc_TypeError, "Argument pAOI (position 2) is not IUnknown");
    
    if (PyErr_Occurred())
      goto ilaspointedit_setclassflag_method_cleanup;
    
    // No setup for bufferDistance
    if (!IFaceFromPyObject(py_pZRange, &IID_IDoubleArray, (void**)&ippZRange))
        PyErr_SetString(PyExc_TypeError, "Argument pZRange (position 4) is not IDoubleArray");
    
    if (PyErr_Occurred())
      goto ilaspointedit_setclassflag_method_cleanup;
    
    if (!IFaceFromPyObject(py_pFilter, &IID_ILasAttributeFilter, (void**)&ippFilter))
        PyErr_SetString(PyExc_TypeError, "Argument pFilter (position 5) is not ILasAttributeFilter");
    
    if (PyErr_Occurred())
      goto ilaspointedit_setclassflag_method_cleanup;
    
    // No setup for newFlags
    b_bClear = ((PyObject_IsTrue(pyvar_bClear) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto ilaspointedit_setclassflag_method_cleanup;
    
    b_bCalculateStats = ((PyObject_IsTrue(pyvar_bCalculateStats) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto ilaspointedit_setclassflag_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pILasPointEdit->SetClassFlag(ippTrackCancel, lFileIndex, ippAOI, dbufferDistance, ippZRange, ippFilter, lnewFlags, b_bClear, b_bCalculateStats);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasPointEdit->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasPointEdit) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasPointEdit.SetClassFlag() returned %ld", (long)hr);
        goto ilaspointedit_setclassflag_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pTrackCancel
    // No teardown for FileIndex
    // No teardown for pAOI
    // No teardown for bufferDistance
    // No teardown for pZRange
    // No teardown for pFilter
    // No teardown for newFlags
    // No teardown for bClear
    // No teardown for bCalculateStats

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ilaspointedit_setclassflag_method_cleanup;

    ilaspointedit_setclassflag_method_cleanup:
    self->m_HR = hr;
    if (ippTrackCancel)
      ippTrackCancel->Release();
    // No cleanup for FileIndex
    if (ippAOI)
      ippAOI->Release();
    // No cleanup for bufferDistance
    if (ippZRange)
      ippZRange->Release();
    if (ippFilter)
      ippFilter->Release();
    // No cleanup for newFlags
    // No cleanup for bClear
    // No cleanup for bCalculateStats
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasPointEdit.SetClassFlag");
    return return_tuple;
}

static PyObject*
ILasPointEditMethod_SetClassCode(PyILasPointEditObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;
    long lFileIndex = 0;
    IUnknown* ippAOI = NULL;
    PyObject* py_pAOI;
    double dbufferDistance = 0;
    IDoubleArray* ippZRange = NULL;
    PyObject* py_pZRange;
    ILasAttributeFilter* ippFilter = NULL;
    PyObject* py_pFilter;
    long lnewCode = 0;
    VARIANT_BOOL b_bCalculateStats = VARIANT_FALSE;
    PyObject* pyvar_bCalculateStats = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OlOdOOlO", &py_pTrackCancel, &lFileIndex, &py_pAOI, &dbufferDistance, &py_pZRange, &py_pFilter, &lnewCode, &pyvar_bCalculateStats))
      goto ilaspointedit_setclasscode_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 0) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto ilaspointedit_setclasscode_method_cleanup;
    
    // No setup for FileIndex
    if (!IFaceFromPyObject(py_pAOI, &IID_IUnknown, (void**)&ippAOI))
        PyErr_SetString(PyExc_TypeError, "Argument pAOI (position 2) is not IUnknown");
    
    if (PyErr_Occurred())
      goto ilaspointedit_setclasscode_method_cleanup;
    
    // No setup for bufferDistance
    if (!IFaceFromPyObject(py_pZRange, &IID_IDoubleArray, (void**)&ippZRange))
        PyErr_SetString(PyExc_TypeError, "Argument pZRange (position 4) is not IDoubleArray");
    
    if (PyErr_Occurred())
      goto ilaspointedit_setclasscode_method_cleanup;
    
    if (!IFaceFromPyObject(py_pFilter, &IID_ILasAttributeFilter, (void**)&ippFilter))
        PyErr_SetString(PyExc_TypeError, "Argument pFilter (position 5) is not ILasAttributeFilter");
    
    if (PyErr_Occurred())
      goto ilaspointedit_setclasscode_method_cleanup;
    
    // No setup for newCode
    b_bCalculateStats = ((PyObject_IsTrue(pyvar_bCalculateStats) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto ilaspointedit_setclasscode_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pILasPointEdit->SetClassCode(ippTrackCancel, lFileIndex, ippAOI, dbufferDistance, ippZRange, ippFilter, lnewCode, b_bCalculateStats);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasPointEdit->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasPointEdit) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasPointEdit.SetClassCode() returned %ld", (long)hr);
        goto ilaspointedit_setclasscode_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pTrackCancel
    // No teardown for FileIndex
    // No teardown for pAOI
    // No teardown for bufferDistance
    // No teardown for pZRange
    // No teardown for pFilter
    // No teardown for newCode
    // No teardown for bCalculateStats

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ilaspointedit_setclasscode_method_cleanup;

    ilaspointedit_setclasscode_method_cleanup:
    self->m_HR = hr;
    if (ippTrackCancel)
      ippTrackCancel->Release();
    // No cleanup for FileIndex
    if (ippAOI)
      ippAOI->Release();
    // No cleanup for bufferDistance
    if (ippZRange)
      ippZRange->Release();
    if (ippFilter)
      ippFilter->Release();
    // No cleanup for newCode
    // No cleanup for bCalculateStats
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasPointEdit.SetClassCode");
    return return_tuple;
}

static PyObject*
ILasPointEditMethod_ChangeClassCode(PyILasPointEditObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;
    long lFileIndex = 0;
    ILongArray* ippExistingCodes = NULL;
    PyObject* py_pExistingCodes;
    ILongArray* ippNewCodes = NULL;
    PyObject* py_pNewCodes;
    VARIANT_BOOL b_bCalculateStats = VARIANT_FALSE;
    PyObject* pyvar_bCalculateStats = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OlOOO", &py_pTrackCancel, &lFileIndex, &py_pExistingCodes, &py_pNewCodes, &pyvar_bCalculateStats))
      goto ilaspointedit_changeclasscode_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 0) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto ilaspointedit_changeclasscode_method_cleanup;
    
    // No setup for FileIndex
    if (!IFaceFromPyObject(py_pExistingCodes, &IID_ILongArray, (void**)&ippExistingCodes))
        PyErr_SetString(PyExc_TypeError, "Argument pExistingCodes (position 2) is not ILongArray");
    
    if (PyErr_Occurred())
      goto ilaspointedit_changeclasscode_method_cleanup;
    
    if (!IFaceFromPyObject(py_pNewCodes, &IID_ILongArray, (void**)&ippNewCodes))
        PyErr_SetString(PyExc_TypeError, "Argument pNewCodes (position 3) is not ILongArray");
    
    if (PyErr_Occurred())
      goto ilaspointedit_changeclasscode_method_cleanup;
    
    b_bCalculateStats = ((PyObject_IsTrue(pyvar_bCalculateStats) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto ilaspointedit_changeclasscode_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pILasPointEdit->ChangeClassCode(ippTrackCancel, lFileIndex, ippExistingCodes, ippNewCodes, b_bCalculateStats);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasPointEdit->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasPointEdit) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasPointEdit.ChangeClassCode() returned %ld", (long)hr);
        goto ilaspointedit_changeclasscode_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pTrackCancel
    // No teardown for FileIndex
    // No teardown for pExistingCodes
    // No teardown for pNewCodes
    // No teardown for bCalculateStats

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ilaspointedit_changeclasscode_method_cleanup;

    ilaspointedit_changeclasscode_method_cleanup:
    self->m_HR = hr;
    if (ippTrackCancel)
      ippTrackCancel->Release();
    // No cleanup for FileIndex
    if (ippExistingCodes)
      ippExistingCodes->Release();
    if (ippNewCodes)
      ippNewCodes->Release();
    // No cleanup for bCalculateStats
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasPointEdit.ChangeClassCode");
    return return_tuple;
}

static PyObject*
ILasPointEditMethod_EditClassCodeByClass(PyILasPointEditObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lFileIndex = 0;
    IDoubleArray* ippPointIDs = NULL;
    PyObject* py_pPointIDs;
    long lnewCode = 0;
    esriLasClassFlagEditType ewithheldFlag;
    esriLasClassFlagEditType ekeyPointFlag;
    esriLasClassFlagEditType esyntheticFlag;
    VARIANT_BOOL b_pbHasChange = VARIANT_FALSE;
    PyObject* pyvar_pbHasChange = Py_False;

    // Unpack values
    if (!PyArg_ParseTuple(args, "lOliii", &lFileIndex, &py_pPointIDs, &lnewCode, (int *)&ewithheldFlag, (int *)&ekeyPointFlag, (int *)&esyntheticFlag))
      goto ilaspointedit_editclasscodebyclass_method_cleanup;

    // Set up initial variable values as needed
    // No setup for FileIndex
    if (!IFaceFromPyObject(py_pPointIDs, &IID_IDoubleArray, (void**)&ippPointIDs))
        PyErr_SetString(PyExc_TypeError, "Argument pPointIDs (position 1) is not IDoubleArray");
    
    if (PyErr_Occurred())
      goto ilaspointedit_editclasscodebyclass_method_cleanup;
    
    // No setup for newCode
    // No setup for withheldFlag
    // No setup for keyPointFlag
    // No setup for syntheticFlag
    // No setup for pbHasChange

    // Call method on actual COM interface
    hr = self->m_pILasPointEdit->EditClassCodeByClass(lFileIndex, ippPointIDs, lnewCode, ewithheldFlag, ekeyPointFlag, esyntheticFlag, &b_pbHasChange);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasPointEdit->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasPointEdit) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasPointEdit.EditClassCodeByClass() returned %ld", (long)hr);
        goto ilaspointedit_editclasscodebyclass_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for FileIndex
    // No teardown for pPointIDs
    // No teardown for newCode
    // No teardown for withheldFlag
    // No teardown for keyPointFlag
    // No teardown for syntheticFlag
    pyvar_pbHasChange = ((b_pbHasChange == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto ilaspointedit_editclasscodebyclass_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pbHasChange);
    goto ilaspointedit_editclasscodebyclass_method_cleanup;

    ilaspointedit_editclasscodebyclass_method_cleanup:
    self->m_HR = hr;
    // No cleanup for FileIndex
    if (ippPointIDs)
      ippPointIDs->Release();
    // No cleanup for newCode
    // No cleanup for withheldFlag
    // No cleanup for keyPointFlag
    // No cleanup for syntheticFlag
    // No cleanup for pbHasChange
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasPointEdit.EditClassCodeByClass");
    return return_tuple;
}

static PyObject*
ILasPointEditMethod_EditClassCode(PyILasPointEditObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lFileIndex = 0;
    IDoubleArray* ippPointIDs = NULL;
    PyObject* py_pPointIDs;
    ILongArray* ippCodes = NULL;
    PyObject* py_pCodes;
    VARIANT_BOOL b_pbHasChange = VARIANT_FALSE;
    PyObject* pyvar_pbHasChange = Py_False;

    // Unpack values
    if (!PyArg_ParseTuple(args, "lOO", &lFileIndex, &py_pPointIDs, &py_pCodes))
      goto ilaspointedit_editclasscode_method_cleanup;

    // Set up initial variable values as needed
    // No setup for FileIndex
    if (!IFaceFromPyObject(py_pPointIDs, &IID_IDoubleArray, (void**)&ippPointIDs))
        PyErr_SetString(PyExc_TypeError, "Argument pPointIDs (position 1) is not IDoubleArray");
    
    if (PyErr_Occurred())
      goto ilaspointedit_editclasscode_method_cleanup;
    
    if (!IFaceFromPyObject(py_pCodes, &IID_ILongArray, (void**)&ippCodes))
        PyErr_SetString(PyExc_TypeError, "Argument pCodes (position 2) is not ILongArray");
    
    if (PyErr_Occurred())
      goto ilaspointedit_editclasscode_method_cleanup;
    
    // No setup for pbHasChange

    // Call method on actual COM interface
    hr = self->m_pILasPointEdit->EditClassCode(lFileIndex, ippPointIDs, ippCodes, &b_pbHasChange);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILasPointEdit->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILasPointEdit) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILasPointEdit.EditClassCode() returned %ld", (long)hr);
        goto ilaspointedit_editclasscode_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for FileIndex
    // No teardown for pPointIDs
    // No teardown for pCodes
    pyvar_pbHasChange = ((b_pbHasChange == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto ilaspointedit_editclasscode_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pbHasChange);
    goto ilaspointedit_editclasscode_method_cleanup;

    ilaspointedit_editclasscode_method_cleanup:
    self->m_HR = hr;
    // No cleanup for FileIndex
    if (ippPointIDs)
      ippPointIDs->Release();
    if (ippCodes)
      ippCodes->Release();
    // No cleanup for pbHasChange
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILasPointEdit.EditClassCode");
    return return_tuple;
}


PyMethodDef PyILasPointEditMethods[] = {
    {"supports", (PyCFunction)PyILasPointEdit_SupportsInterface, METH_O, ""},
    {"SetClassFlag", (PyCFunction)ILasPointEditMethod_SetClassFlag, METH_VARARGS, ""},
    {"SetClassCode", (PyCFunction)ILasPointEditMethod_SetClassCode, METH_VARARGS, ""},
    {"ChangeClassCode", (PyCFunction)ILasPointEditMethod_ChangeClassCode, METH_VARARGS, ""},
    {"EditClassCodeByClass", (PyCFunction)ILasPointEditMethod_EditClassCodeByClass, METH_VARARGS, ""},
    {"EditClassCode", (PyCFunction)ILasPointEditMethod_EditClassCode, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyILasPointEditGetSet[] = {
  {"_pUnk", (getter)PyILasPointEdit_GetpUnk, NULL, "Get opaque pointer to an Unknown from ILasPointEdit", NULL},
  {"_pointer", (getter)PyILasPointEdit_GetPointer, NULL, "Get memory address for ILasPointEdit", NULL},
  {"_IID", (getter)PyILasPointEdit_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyILasPointEdit_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyILasPointEdit_GetIgnoreFailures, (setter)PyILasPointEdit_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyILasPointEditObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.ILasPointEditObject",                          
                                              /* tp_name */
  sizeof(PyILasPointEditObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyILasPointEditObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyILasPointEditMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyILasPointEditGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyILasPointEditObject_new,                      
                                              /* tp_new */
};

// Interface ICadastralJob

typedef struct PyICadastralJobObject {
    PyObject_HEAD
    ICadastralJob* m_pICadastralJob;
    HRESULT m_HR;
    int m_ignore_failures;
} PyICadastralJobObject;

static PyObject*
PyICadastralJobObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyICadastralJobObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ICadastralJob* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ICadastralJob, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ICadastralJob with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyICadastralJobObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ICadastralJob");
            return NULL;
        }
        self->m_pICadastralJob = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ICadastralJob");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ICadastralJob");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ICadastralJob* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ICadastralJob, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ICadastralJob");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyICadastralJobObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ICadastralJob");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pICadastralJob = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyICadastralJobObject_dealloc(PyICadastralJobObject* self)
{
    if (self->m_pICadastralJob)
        self->m_pICadastralJob->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyICadastralJob_GetpUnk(PyICadastralJobObject* self)
{
    if (!self->m_pICadastralJob)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pICadastralJob->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ICadastralJob to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyICadastralJob_GetPointer(PyICadastralJobObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pICadastralJob);
}

static PyObject*
PyICadastralJob_GetIID(PyICadastralJobObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "b2ac22b9-4234-411e-9524-01d3bf296355");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyICadastralJob_GetHR(PyICadastralJobObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyICadastralJob_GetIgnoreFailures(PyICadastralJobObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyICadastralJob_SetIgnoreFailures(PyICadastralJobObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyICadastralJob_SupportsInterface(PyICadastralJobObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pICadastralJob->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ICadastralJobMethod_get_ID(PyICadastralJobObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lJobID = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for JobID

    // Call method on actual COM interface
    hr = self->m_pICadastralJob->get_ID(&lJobID);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadastralJob->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadastralJob) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadastralJob.get_ID() returned %ld", (long)hr);
        goto icadastraljob_get_id_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for JobID

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lJobID);
    goto icadastraljob_get_id_method_cleanup;

    icadastraljob_get_id_method_cleanup:
    self->m_HR = hr;
    // No cleanup for JobID
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadastralJob.get_ID");
    return return_tuple;
}

static PyObject*
ICadastralJobMethod_get_Description(PyICadastralJobObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsDescription;
    PyObject* pyvar_Description = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Description

    // Call method on actual COM interface
    hr = self->m_pICadastralJob->get_Description(&bsDescription);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadastralJob->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadastralJob) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadastralJob.get_Description() returned %ld", (long)hr);
        goto icadastraljob_get_description_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Description = PyUnicode_FromWideChar(bsDescription,::SysStringLen(bsDescription));
    ::SysFreeString(bsDescription);
    
    if (PyErr_Occurred())
      goto icadastraljob_get_description_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Description);
    goto icadastraljob_get_description_method_cleanup;

    icadastraljob_get_description_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Description != Py_None)
        Py_XDECREF(pyvar_Description);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadastralJob.get_Description");
    return return_tuple;
}

static PyObject*
ICadastralJobMethod_put_Description(PyICadastralJobObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsDescription = 0;
    PyObject* pyvar_Description;
    PyObject* unicodeDescription = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_Description))
      goto icadastraljob_put_description_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_Description))
        unicodeDescription = PyUnicode_FromObject(pyvar_Description);
    else if (PyUnicode_Check(pyvar_Description))
    {
        unicodeDescription = pyvar_Description;
        Py_INCREF(unicodeDescription);
    }
    else if (pyvar_Description != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Description at index 0");
    if (unicodeDescription)
        bsDescription = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeDescription), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeDescription));
    
    if (PyErr_Occurred())
      goto icadastraljob_put_description_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pICadastralJob->put_Description(bsDescription);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadastralJob->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadastralJob) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadastralJob.put_Description() returned %ld", (long)hr);
        goto icadastraljob_put_description_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Description

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icadastraljob_put_description_method_cleanup;

    icadastraljob_put_description_method_cleanup:
    self->m_HR = hr;
    if (bsDescription)
        ::SysFreeString(bsDescription);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadastralJob.put_Description");
    return return_tuple;
}

static PyObject*
ICadastralJobMethod_get_Name(PyICadastralJobObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName;
    PyObject* pyvar_Name = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Name

    // Call method on actual COM interface
    hr = self->m_pICadastralJob->get_Name(&bsName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadastralJob->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadastralJob) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadastralJob.get_Name() returned %ld", (long)hr);
        goto icadastraljob_get_name_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Name = PyUnicode_FromWideChar(bsName,::SysStringLen(bsName));
    ::SysFreeString(bsName);
    
    if (PyErr_Occurred())
      goto icadastraljob_get_name_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Name);
    goto icadastraljob_get_name_method_cleanup;

    icadastraljob_get_name_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Name != Py_None)
        Py_XDECREF(pyvar_Name);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadastralJob.get_Name");
    return return_tuple;
}

static PyObject*
ICadastralJobMethod_put_Name(PyICadastralJobObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName = 0;
    PyObject* pyvar_Name;
    PyObject* unicodeName = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_Name))
      goto icadastraljob_put_name_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_Name))
        unicodeName = PyUnicode_FromObject(pyvar_Name);
    else if (PyUnicode_Check(pyvar_Name))
    {
        unicodeName = pyvar_Name;
        Py_INCREF(unicodeName);
    }
    else if (pyvar_Name != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Name at index 0");
    if (unicodeName)
        bsName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeName));
    
    if (PyErr_Occurred())
      goto icadastraljob_put_name_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pICadastralJob->put_Name(bsName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadastralJob->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadastralJob) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadastralJob.put_Name() returned %ld", (long)hr);
        goto icadastraljob_put_name_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Name

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icadastraljob_put_name_method_cleanup;

    icadastraljob_put_name_method_cleanup:
    self->m_HR = hr;
    if (bsName)
        ::SysFreeString(bsName);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadastralJob.put_Name");
    return return_tuple;
}

static PyObject*
ICadastralJobMethod_get_Status(PyICadastralJobObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lStatus = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Status

    // Call method on actual COM interface
    hr = self->m_pICadastralJob->get_Status(&lStatus);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadastralJob->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadastralJob) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadastralJob.get_Status() returned %ld", (long)hr);
        goto icadastraljob_get_status_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Status

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lStatus);
    goto icadastraljob_get_status_method_cleanup;

    icadastraljob_get_status_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Status
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadastralJob.get_Status");
    return return_tuple;
}

static PyObject*
ICadastralJobMethod_put_Status(PyICadastralJobObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lStatus = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lStatus))
      goto icadastraljob_put_status_method_cleanup;

    // Set up initial variable values as needed
    // No setup for Status

    // Call method on actual COM interface
    hr = self->m_pICadastralJob->put_Status(lStatus);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadastralJob->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadastralJob) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadastralJob.put_Status() returned %ld", (long)hr);
        goto icadastraljob_put_status_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Status

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icadastraljob_put_status_method_cleanup;

    icadastraljob_put_status_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Status
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadastralJob.put_Status");
    return return_tuple;
}

static PyObject*
ICadastralJobMethod_get_Owner(PyICadastralJobObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsOwner;
    PyObject* pyvar_Owner = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Owner

    // Call method on actual COM interface
    hr = self->m_pICadastralJob->get_Owner(&bsOwner);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadastralJob->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadastralJob) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadastralJob.get_Owner() returned %ld", (long)hr);
        goto icadastraljob_get_owner_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Owner = PyUnicode_FromWideChar(bsOwner,::SysStringLen(bsOwner));
    ::SysFreeString(bsOwner);
    
    if (PyErr_Occurred())
      goto icadastraljob_get_owner_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Owner);
    goto icadastraljob_get_owner_method_cleanup;

    icadastraljob_get_owner_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Owner != Py_None)
        Py_XDECREF(pyvar_Owner);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadastralJob.get_Owner");
    return return_tuple;
}

static PyObject*
ICadastralJobMethod_put_Owner(PyICadastralJobObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsOwner = 0;
    PyObject* pyvar_Owner;
    PyObject* unicodeOwner = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_Owner))
      goto icadastraljob_put_owner_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_Owner))
        unicodeOwner = PyUnicode_FromObject(pyvar_Owner);
    else if (PyUnicode_Check(pyvar_Owner))
    {
        unicodeOwner = pyvar_Owner;
        Py_INCREF(unicodeOwner);
    }
    else if (pyvar_Owner != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Owner at index 0");
    if (unicodeOwner)
        bsOwner = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeOwner), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeOwner));
    
    if (PyErr_Occurred())
      goto icadastraljob_put_owner_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pICadastralJob->put_Owner(bsOwner);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadastralJob->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadastralJob) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadastralJob.put_Owner() returned %ld", (long)hr);
        goto icadastraljob_put_owner_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Owner

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icadastraljob_put_owner_method_cleanup;

    icadastraljob_put_owner_method_cleanup:
    self->m_HR = hr;
    if (bsOwner)
        ::SysFreeString(bsOwner);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadastralJob.put_Owner");
    return return_tuple;
}

static PyObject*
ICadastralJobMethod_get_ExtendedAttribute(PyICadastralJobObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lfieldPosition = 0;
    VARIANT vValue;
    ::VariantInit(&vValue);
    PyObject* pyvar_Value = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lfieldPosition))
      goto icadastraljob_get_extendedattribute_method_cleanup;

    // Set up initial variable values as needed
    // No setup for fieldPosition
    // No setup for Value

    // Call method on actual COM interface
    hr = self->m_pICadastralJob->get_ExtendedAttribute(lfieldPosition, &vValue);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadastralJob->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadastralJob) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadastralJob.get_ExtendedAttribute() returned %ld", (long)hr);
        goto icadastraljob_get_extendedattribute_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for fieldPosition
    pyvar_Value = Variant_AsPyObject(&vValue);
    if (PyErr_Occurred())
      goto icadastraljob_get_extendedattribute_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Value);
    goto icadastraljob_get_extendedattribute_method_cleanup;

    icadastraljob_get_extendedattribute_method_cleanup:
    self->m_HR = hr;
    // No cleanup for fieldPosition
    ::VariantClear(&vValue);
    Py_XDECREF(pyvar_Value);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadastralJob.get_ExtendedAttribute");
    return return_tuple;
}

static PyObject*
ICadastralJobMethod_put_ExtendedAttribute(PyICadastralJobObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lfieldPosition = 0;
    VARIANT vValue;
    ::VariantInit(&vValue);
    PyObject* pyvar_Value = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "lO", &lfieldPosition, &pyvar_Value))
      goto icadastraljob_put_extendedattribute_method_cleanup;

    // Set up initial variable values as needed
    // No setup for fieldPosition
    PyObject_AsVariant(pyvar_Value, &vValue);
    
    if (PyErr_Occurred())
      goto icadastraljob_put_extendedattribute_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pICadastralJob->put_ExtendedAttribute(lfieldPosition, vValue);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadastralJob->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadastralJob) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadastralJob.put_ExtendedAttribute() returned %ld", (long)hr);
        goto icadastraljob_put_extendedattribute_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for fieldPosition
    // No teardown for Value

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icadastraljob_put_extendedattribute_method_cleanup;

    icadastraljob_put_extendedattribute_method_cleanup:
    self->m_HR = hr;
    // No cleanup for fieldPosition
    ::VariantClear(&vValue);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadastralJob.put_ExtendedAttribute");
    return return_tuple;
}

static PyObject*
ICadastralJobMethod_get_StartDate(PyICadastralJobObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsDate;
    PyObject* pyvar_Date = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Date

    // Call method on actual COM interface
    hr = self->m_pICadastralJob->get_StartDate(&bsDate);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadastralJob->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadastralJob) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadastralJob.get_StartDate() returned %ld", (long)hr);
        goto icadastraljob_get_startdate_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Date = PyUnicode_FromWideChar(bsDate,::SysStringLen(bsDate));
    ::SysFreeString(bsDate);
    
    if (PyErr_Occurred())
      goto icadastraljob_get_startdate_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Date);
    goto icadastraljob_get_startdate_method_cleanup;

    icadastraljob_get_startdate_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Date != Py_None)
        Py_XDECREF(pyvar_Date);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadastralJob.get_StartDate");
    return return_tuple;
}

static PyObject*
ICadastralJobMethod_get_ModifiedDate(PyICadastralJobObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsDate;
    PyObject* pyvar_Date = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Date

    // Call method on actual COM interface
    hr = self->m_pICadastralJob->get_ModifiedDate(&bsDate);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadastralJob->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadastralJob) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadastralJob.get_ModifiedDate() returned %ld", (long)hr);
        goto icadastraljob_get_modifieddate_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Date = PyUnicode_FromWideChar(bsDate,::SysStringLen(bsDate));
    ::SysFreeString(bsDate);
    
    if (PyErr_Occurred())
      goto icadastraljob_get_modifieddate_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Date);
    goto icadastraljob_get_modifieddate_method_cleanup;

    icadastraljob_get_modifieddate_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Date != Py_None)
        Py_XDECREF(pyvar_Date);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadastralJob.get_ModifiedDate");
    return return_tuple;
}

static PyObject*
ICadastralJobMethod_get_CommitDate(PyICadastralJobObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsDate;
    PyObject* pyvar_Date = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Date

    // Call method on actual COM interface
    hr = self->m_pICadastralJob->get_CommitDate(&bsDate);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadastralJob->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadastralJob) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadastralJob.get_CommitDate() returned %ld", (long)hr);
        goto icadastraljob_get_commitdate_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Date = PyUnicode_FromWideChar(bsDate,::SysStringLen(bsDate));
    ::SysFreeString(bsDate);
    
    if (PyErr_Occurred())
      goto icadastraljob_get_commitdate_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Date);
    goto icadastraljob_get_commitdate_method_cleanup;

    icadastraljob_get_commitdate_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Date != Py_None)
        Py_XDECREF(pyvar_Date);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadastralJob.get_CommitDate");
    return return_tuple;
}

static PyObject*
ICadastralJobMethod_get_EditParcels(PyICadastralJobObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IFIDSet* ipEditParcelIDs = NULL;
    PyObject* py_EditParcelIDs = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for EditParcelIDs

    // Call method on actual COM interface
    hr = self->m_pICadastralJob->get_EditParcels(&ipEditParcelIDs);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadastralJob->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadastralJob) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadastralJob.get_EditParcels() returned %ld", (long)hr);
        goto icadastraljob_get_editparcels_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_EditParcelIDs);
    if (ipEditParcelIDs)
    {
        IUnknown* pUnk = NULL;
        ipEditParcelIDs->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_EditParcelIDs = IUnknownToPythonIIDObject(pUnk, &IID_IFIDSet);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_EditParcelIDs)
    {
        if (py_EditParcelIDs)
           Py_DECREF(py_EditParcelIDs);
        py_EditParcelIDs = Py_None;
        Py_INCREF(py_EditParcelIDs);
    }
    if (PyErr_Occurred())
      goto icadastraljob_get_editparcels_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_EditParcelIDs);
    goto icadastraljob_get_editparcels_method_cleanup;

    icadastraljob_get_editparcels_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_EditParcelIDs);
    if (ipEditParcelIDs)
      ipEditParcelIDs->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadastralJob.get_EditParcels");
    return return_tuple;
}

static PyObject*
ICadastralJobMethod_put_EditParcels(PyICadastralJobObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IFIDSet* ipEditParcelIDs = NULL;
    PyObject* py_EditParcelIDs;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_EditParcelIDs))
      goto icadastraljob_put_editparcels_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_EditParcelIDs, &IID_IFIDSet, (void**)&ipEditParcelIDs))
        PyErr_SetString(PyExc_TypeError, "Argument EditParcelIDs (position 0) is not IFIDSet");
    
    if (PyErr_Occurred())
      goto icadastraljob_put_editparcels_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pICadastralJob->put_EditParcels(ipEditParcelIDs);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadastralJob->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadastralJob) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadastralJob.put_EditParcels() returned %ld", (long)hr);
        goto icadastraljob_put_editparcels_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for EditParcelIDs

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icadastraljob_put_editparcels_method_cleanup;

    icadastraljob_put_editparcels_method_cleanup:
    self->m_HR = hr;
    if (ipEditParcelIDs)
      ipEditParcelIDs->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadastralJob.put_EditParcels");
    return return_tuple;
}

static PyObject*
ICadastralJobMethod_get_AdjustmentAreaParcels(PyICadastralJobObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IFIDSet* ipAdjustmentAreaParcelIDs = NULL;
    PyObject* py_AdjustmentAreaParcelIDs = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for AdjustmentAreaParcelIDs

    // Call method on actual COM interface
    hr = self->m_pICadastralJob->get_AdjustmentAreaParcels(&ipAdjustmentAreaParcelIDs);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadastralJob->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadastralJob) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadastralJob.get_AdjustmentAreaParcels() returned %ld", (long)hr);
        goto icadastraljob_get_adjustmentareaparcels_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_AdjustmentAreaParcelIDs);
    if (ipAdjustmentAreaParcelIDs)
    {
        IUnknown* pUnk = NULL;
        ipAdjustmentAreaParcelIDs->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_AdjustmentAreaParcelIDs = IUnknownToPythonIIDObject(pUnk, &IID_IFIDSet);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_AdjustmentAreaParcelIDs)
    {
        if (py_AdjustmentAreaParcelIDs)
           Py_DECREF(py_AdjustmentAreaParcelIDs);
        py_AdjustmentAreaParcelIDs = Py_None;
        Py_INCREF(py_AdjustmentAreaParcelIDs);
    }
    if (PyErr_Occurred())
      goto icadastraljob_get_adjustmentareaparcels_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_AdjustmentAreaParcelIDs);
    goto icadastraljob_get_adjustmentareaparcels_method_cleanup;

    icadastraljob_get_adjustmentareaparcels_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_AdjustmentAreaParcelIDs);
    if (ipAdjustmentAreaParcelIDs)
      ipAdjustmentAreaParcelIDs->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadastralJob.get_AdjustmentAreaParcels");
    return return_tuple;
}

static PyObject*
ICadastralJobMethod_put_AdjustmentAreaParcels(PyICadastralJobObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IFIDSet* ipAdjustmentAreaParcelIDs = NULL;
    PyObject* py_AdjustmentAreaParcelIDs;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_AdjustmentAreaParcelIDs))
      goto icadastraljob_put_adjustmentareaparcels_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_AdjustmentAreaParcelIDs, &IID_IFIDSet, (void**)&ipAdjustmentAreaParcelIDs))
        PyErr_SetString(PyExc_TypeError, "Argument AdjustmentAreaParcelIDs (position 0) is not IFIDSet");
    
    if (PyErr_Occurred())
      goto icadastraljob_put_adjustmentareaparcels_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pICadastralJob->put_AdjustmentAreaParcels(ipAdjustmentAreaParcelIDs);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadastralJob->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadastralJob) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadastralJob.put_AdjustmentAreaParcels() returned %ld", (long)hr);
        goto icadastraljob_put_adjustmentareaparcels_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for AdjustmentAreaParcelIDs

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icadastraljob_put_adjustmentareaparcels_method_cleanup;

    icadastraljob_put_adjustmentareaparcels_method_cleanup:
    self->m_HR = hr;
    if (ipAdjustmentAreaParcelIDs)
      ipAdjustmentAreaParcelIDs->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadastralJob.put_AdjustmentAreaParcels");
    return return_tuple;
}

static PyObject*
ICadastralJobMethod_get_ControlPoints(PyICadastralJobObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IFIDSet* ipControlPointslIDs = NULL;
    PyObject* py_ControlPointslIDs = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ControlPointslIDs

    // Call method on actual COM interface
    hr = self->m_pICadastralJob->get_ControlPoints(&ipControlPointslIDs);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadastralJob->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadastralJob) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadastralJob.get_ControlPoints() returned %ld", (long)hr);
        goto icadastraljob_get_controlpoints_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ControlPointslIDs);
    if (ipControlPointslIDs)
    {
        IUnknown* pUnk = NULL;
        ipControlPointslIDs->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ControlPointslIDs = IUnknownToPythonIIDObject(pUnk, &IID_IFIDSet);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ControlPointslIDs)
    {
        if (py_ControlPointslIDs)
           Py_DECREF(py_ControlPointslIDs);
        py_ControlPointslIDs = Py_None;
        Py_INCREF(py_ControlPointslIDs);
    }
    if (PyErr_Occurred())
      goto icadastraljob_get_controlpoints_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ControlPointslIDs);
    goto icadastraljob_get_controlpoints_method_cleanup;

    icadastraljob_get_controlpoints_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ControlPointslIDs);
    if (ipControlPointslIDs)
      ipControlPointslIDs->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadastralJob.get_ControlPoints");
    return return_tuple;
}

static PyObject*
ICadastralJobMethod_put_ControlPoints(PyICadastralJobObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IFIDSet* ipControlPointslIDs = NULL;
    PyObject* py_ControlPointslIDs;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_ControlPointslIDs))
      goto icadastraljob_put_controlpoints_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_ControlPointslIDs, &IID_IFIDSet, (void**)&ipControlPointslIDs))
        PyErr_SetString(PyExc_TypeError, "Argument ControlPointslIDs (position 0) is not IFIDSet");
    
    if (PyErr_Occurred())
      goto icadastraljob_put_controlpoints_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pICadastralJob->put_ControlPoints(ipControlPointslIDs);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadastralJob->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadastralJob) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadastralJob.put_ControlPoints() returned %ld", (long)hr);
        goto icadastraljob_put_controlpoints_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ControlPointslIDs

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icadastraljob_put_controlpoints_method_cleanup;

    icadastraljob_put_controlpoints_method_cleanup:
    self->m_HR = hr;
    if (ipControlPointslIDs)
      ipControlPointslIDs->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadastralJob.put_ControlPoints");
    return return_tuple;
}

static PyObject*
ICadastralJobMethod_AddEditParcel(PyICadastralJobObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lParcelID = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lParcelID))
      goto icadastraljob_addeditparcel_method_cleanup;

    // Set up initial variable values as needed
    // No setup for ParcelID

    // Call method on actual COM interface
    hr = self->m_pICadastralJob->AddEditParcel(lParcelID);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadastralJob->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadastralJob) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadastralJob.AddEditParcel() returned %ld", (long)hr);
        goto icadastraljob_addeditparcel_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ParcelID

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icadastraljob_addeditparcel_method_cleanup;

    icadastraljob_addeditparcel_method_cleanup:
    self->m_HR = hr;
    // No cleanup for ParcelID
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadastralJob.AddEditParcel");
    return return_tuple;
}

static PyObject*
ICadastralJobMethod_RemoveEditParcel(PyICadastralJobObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lParcelID = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lParcelID))
      goto icadastraljob_removeeditparcel_method_cleanup;

    // Set up initial variable values as needed
    // No setup for ParcelID

    // Call method on actual COM interface
    hr = self->m_pICadastralJob->RemoveEditParcel(lParcelID);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadastralJob->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadastralJob) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadastralJob.RemoveEditParcel() returned %ld", (long)hr);
        goto icadastraljob_removeeditparcel_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ParcelID

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icadastraljob_removeeditparcel_method_cleanup;

    icadastraljob_removeeditparcel_method_cleanup:
    self->m_HR = hr;
    // No cleanup for ParcelID
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadastralJob.RemoveEditParcel");
    return return_tuple;
}

static PyObject*
ICadastralJobMethod_AddControlPoint(PyICadastralJobObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lPointID = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lPointID))
      goto icadastraljob_addcontrolpoint_method_cleanup;

    // Set up initial variable values as needed
    // No setup for PointID

    // Call method on actual COM interface
    hr = self->m_pICadastralJob->AddControlPoint(lPointID);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadastralJob->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadastralJob) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadastralJob.AddControlPoint() returned %ld", (long)hr);
        goto icadastraljob_addcontrolpoint_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for PointID

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icadastraljob_addcontrolpoint_method_cleanup;

    icadastraljob_addcontrolpoint_method_cleanup:
    self->m_HR = hr;
    // No cleanup for PointID
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadastralJob.AddControlPoint");
    return return_tuple;
}

static PyObject*
ICadastralJobMethod_RemoveControlPoint(PyICadastralJobObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lPointID = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lPointID))
      goto icadastraljob_removecontrolpoint_method_cleanup;

    // Set up initial variable values as needed
    // No setup for PointID

    // Call method on actual COM interface
    hr = self->m_pICadastralJob->RemoveControlPoint(lPointID);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadastralJob->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadastralJob) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadastralJob.RemoveControlPoint() returned %ld", (long)hr);
        goto icadastraljob_removecontrolpoint_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for PointID

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icadastraljob_removecontrolpoint_method_cleanup;

    icadastraljob_removecontrolpoint_method_cleanup:
    self->m_HR = hr;
    // No cleanup for PointID
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadastralJob.RemoveControlPoint");
    return return_tuple;
}

static PyObject*
ICadastralJobMethod_get_JobParcels(PyICadastralJobObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IFIDSet* ipppParcelIDSet = NULL;
    PyObject* py_ppParcelIDSet = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppParcelIDSet

    // Call method on actual COM interface
    hr = self->m_pICadastralJob->get_JobParcels(&ipppParcelIDSet);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadastralJob->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadastralJob) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadastralJob.get_JobParcels() returned %ld", (long)hr);
        goto icadastraljob_get_jobparcels_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppParcelIDSet);
    if (ipppParcelIDSet)
    {
        IUnknown* pUnk = NULL;
        ipppParcelIDSet->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppParcelIDSet = IUnknownToPythonIIDObject(pUnk, &IID_IFIDSet);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppParcelIDSet)
    {
        if (py_ppParcelIDSet)
           Py_DECREF(py_ppParcelIDSet);
        py_ppParcelIDSet = Py_None;
        Py_INCREF(py_ppParcelIDSet);
    }
    if (PyErr_Occurred())
      goto icadastraljob_get_jobparcels_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppParcelIDSet);
    goto icadastraljob_get_jobparcels_method_cleanup;

    icadastraljob_get_jobparcels_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppParcelIDSet);
    if (ipppParcelIDSet)
      ipppParcelIDSet->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadastralJob.get_JobParcels");
    return return_tuple;
}


PyMethodDef PyICadastralJobMethods[] = {
    {"supports", (PyCFunction)PyICadastralJob_SupportsInterface, METH_O, ""},
    {"get_ID", (PyCFunction)ICadastralJobMethod_get_ID, METH_VARARGS, ""},
    {"get_Description", (PyCFunction)ICadastralJobMethod_get_Description, METH_VARARGS, ""},
    {"put_Description", (PyCFunction)ICadastralJobMethod_put_Description, METH_VARARGS, ""},
    {"get_Name", (PyCFunction)ICadastralJobMethod_get_Name, METH_VARARGS, ""},
    {"put_Name", (PyCFunction)ICadastralJobMethod_put_Name, METH_VARARGS, ""},
    {"get_Status", (PyCFunction)ICadastralJobMethod_get_Status, METH_VARARGS, ""},
    {"put_Status", (PyCFunction)ICadastralJobMethod_put_Status, METH_VARARGS, ""},
    {"get_Owner", (PyCFunction)ICadastralJobMethod_get_Owner, METH_VARARGS, ""},
    {"put_Owner", (PyCFunction)ICadastralJobMethod_put_Owner, METH_VARARGS, ""},
    {"get_ExtendedAttribute", (PyCFunction)ICadastralJobMethod_get_ExtendedAttribute, METH_VARARGS, ""},
    {"put_ExtendedAttribute", (PyCFunction)ICadastralJobMethod_put_ExtendedAttribute, METH_VARARGS, ""},
    {"get_StartDate", (PyCFunction)ICadastralJobMethod_get_StartDate, METH_VARARGS, ""},
    {"get_ModifiedDate", (PyCFunction)ICadastralJobMethod_get_ModifiedDate, METH_VARARGS, ""},
    {"get_CommitDate", (PyCFunction)ICadastralJobMethod_get_CommitDate, METH_VARARGS, ""},
    {"get_EditParcels", (PyCFunction)ICadastralJobMethod_get_EditParcels, METH_VARARGS, ""},
    {"put_EditParcels", (PyCFunction)ICadastralJobMethod_put_EditParcels, METH_VARARGS, ""},
    {"get_AdjustmentAreaParcels", (PyCFunction)ICadastralJobMethod_get_AdjustmentAreaParcels, METH_VARARGS, ""},
    {"put_AdjustmentAreaParcels", (PyCFunction)ICadastralJobMethod_put_AdjustmentAreaParcels, METH_VARARGS, ""},
    {"get_ControlPoints", (PyCFunction)ICadastralJobMethod_get_ControlPoints, METH_VARARGS, ""},
    {"put_ControlPoints", (PyCFunction)ICadastralJobMethod_put_ControlPoints, METH_VARARGS, ""},
    {"AddEditParcel", (PyCFunction)ICadastralJobMethod_AddEditParcel, METH_VARARGS, ""},
    {"RemoveEditParcel", (PyCFunction)ICadastralJobMethod_RemoveEditParcel, METH_VARARGS, ""},
    {"AddControlPoint", (PyCFunction)ICadastralJobMethod_AddControlPoint, METH_VARARGS, ""},
    {"RemoveControlPoint", (PyCFunction)ICadastralJobMethod_RemoveControlPoint, METH_VARARGS, ""},
    {"get_JobParcels", (PyCFunction)ICadastralJobMethod_get_JobParcels, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyICadastralJobGetSet[] = {
  {"_pUnk", (getter)PyICadastralJob_GetpUnk, NULL, "Get opaque pointer to an Unknown from ICadastralJob", NULL},
  {"_pointer", (getter)PyICadastralJob_GetPointer, NULL, "Get memory address for ICadastralJob", NULL},
  {"_IID", (getter)PyICadastralJob_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyICadastralJob_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyICadastralJob_GetIgnoreFailures, (setter)PyICadastralJob_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyICadastralJobObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.ICadastralJobObject",                          
                                              /* tp_name */
  sizeof(PyICadastralJobObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyICadastralJobObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyICadastralJobMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyICadastralJobGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyICadastralJobObject_new,                      
                                              /* tp_new */
};

// Interface ICadastralFabric

typedef struct PyICadastralFabricObject {
    PyObject_HEAD
    ICadastralFabric* m_pICadastralFabric;
    HRESULT m_HR;
    int m_ignore_failures;
} PyICadastralFabricObject;

static PyObject*
PyICadastralFabricObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyICadastralFabricObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ICadastralFabric* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ICadastralFabric, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ICadastralFabric with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyICadastralFabricObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ICadastralFabric");
            return NULL;
        }
        self->m_pICadastralFabric = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ICadastralFabric");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ICadastralFabric");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ICadastralFabric* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ICadastralFabric, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ICadastralFabric");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyICadastralFabricObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ICadastralFabric");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pICadastralFabric = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyICadastralFabricObject_dealloc(PyICadastralFabricObject* self)
{
    if (self->m_pICadastralFabric)
        self->m_pICadastralFabric->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyICadastralFabric_GetpUnk(PyICadastralFabricObject* self)
{
    if (!self->m_pICadastralFabric)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pICadastralFabric->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ICadastralFabric to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyICadastralFabric_GetPointer(PyICadastralFabricObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pICadastralFabric);
}

static PyObject*
PyICadastralFabric_GetIID(PyICadastralFabricObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "f9e240b1-d806-4388-afde-b1a5d354171f");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyICadastralFabric_GetHR(PyICadastralFabricObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyICadastralFabric_GetIgnoreFailures(PyICadastralFabricObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyICadastralFabric_SetIgnoreFailures(PyICadastralFabricObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyICadastralFabric_SupportsInterface(PyICadastralFabricObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pICadastralFabric->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ICadastralFabricMethod_CreateJob(PyICadastralFabricObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ICadastralJob* ipJob = NULL;
    PyObject* py_Job;
    long lJobID = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_Job))
      goto icadastralfabric_createjob_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_Job, &IID_ICadastralJob, (void**)&ipJob))
        PyErr_SetString(PyExc_TypeError, "Argument Job (position 0) is not ICadastralJob");
    
    if (PyErr_Occurred())
      goto icadastralfabric_createjob_method_cleanup;
    
    // No setup for JobID

    // Call method on actual COM interface
    hr = self->m_pICadastralFabric->CreateJob(ipJob, &lJobID);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadastralFabric->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadastralFabric) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadastralFabric.CreateJob() returned %ld", (long)hr);
        goto icadastralfabric_createjob_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Job
    // No teardown for JobID

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lJobID);
    goto icadastralfabric_createjob_method_cleanup;

    icadastralfabric_createjob_method_cleanup:
    self->m_HR = hr;
    if (ipJob)
      ipJob->Release();
    // No cleanup for JobID
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadastralFabric.CreateJob");
    return return_tuple;
}

static PyObject*
ICadastralFabricMethod_GetJob(PyICadastralFabricObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName = 0;
    PyObject* pyvar_Name;
    PyObject* unicodeName = NULL;
    ICadastralJob* ipJob = NULL;
    PyObject* py_Job = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_Name))
      goto icadastralfabric_getjob_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_Name))
        unicodeName = PyUnicode_FromObject(pyvar_Name);
    else if (PyUnicode_Check(pyvar_Name))
    {
        unicodeName = pyvar_Name;
        Py_INCREF(unicodeName);
    }
    else if (pyvar_Name != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Name at index 0");
    if (unicodeName)
        bsName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeName));
    
    if (PyErr_Occurred())
      goto icadastralfabric_getjob_method_cleanup;
    
    // No setup for Job

    // Call method on actual COM interface
    hr = self->m_pICadastralFabric->GetJob(bsName, &ipJob);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadastralFabric->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadastralFabric) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadastralFabric.GetJob() returned %ld", (long)hr);
        goto icadastralfabric_getjob_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Name
    Py_XDECREF(py_Job);
    if (ipJob)
    {
        IUnknown* pUnk = NULL;
        ipJob->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_Job = IUnknownToPythonIIDObject(pUnk, &IID_ICadastralJob);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_Job)
    {
        if (py_Job)
           Py_DECREF(py_Job);
        py_Job = Py_None;
        Py_INCREF(py_Job);
    }
    if (PyErr_Occurred())
      goto icadastralfabric_getjob_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_Job);
    goto icadastralfabric_getjob_method_cleanup;

    icadastralfabric_getjob_method_cleanup:
    self->m_HR = hr;
    if (bsName)
        ::SysFreeString(bsName);
    
    Py_XDECREF(py_Job);
    if (ipJob)
      ipJob->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadastralFabric.GetJob");
    return return_tuple;
}

static PyObject*
ICadastralFabricMethod_UpdateJob(PyICadastralFabricObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ICadastralJob* ipJob = NULL;
    PyObject* py_Job;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_Job))
      goto icadastralfabric_updatejob_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_Job, &IID_ICadastralJob, (void**)&ipJob))
        PyErr_SetString(PyExc_TypeError, "Argument Job (position 0) is not ICadastralJob");
    
    if (PyErr_Occurred())
      goto icadastralfabric_updatejob_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pICadastralFabric->UpdateJob(ipJob);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadastralFabric->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadastralFabric) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadastralFabric.UpdateJob() returned %ld", (long)hr);
        goto icadastralfabric_updatejob_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Job

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icadastralfabric_updatejob_method_cleanup;

    icadastralfabric_updatejob_method_cleanup:
    self->m_HR = hr;
    if (ipJob)
      ipJob->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadastralFabric.UpdateJob");
    return return_tuple;
}

static PyObject*
ICadastralFabricMethod_DeleteJob(PyICadastralFabricObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName = 0;
    PyObject* pyvar_Name;
    PyObject* unicodeName = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_Name))
      goto icadastralfabric_deletejob_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_Name))
        unicodeName = PyUnicode_FromObject(pyvar_Name);
    else if (PyUnicode_Check(pyvar_Name))
    {
        unicodeName = pyvar_Name;
        Py_INCREF(unicodeName);
    }
    else if (pyvar_Name != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Name at index 0");
    if (unicodeName)
        bsName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeName));
    
    if (PyErr_Occurred())
      goto icadastralfabric_deletejob_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pICadastralFabric->DeleteJob(bsName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadastralFabric->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadastralFabric) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadastralFabric.DeleteJob() returned %ld", (long)hr);
        goto icadastralfabric_deletejob_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Name

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icadastralfabric_deletejob_method_cleanup;

    icadastralfabric_deletejob_method_cleanup:
    self->m_HR = hr;
    if (bsName)
        ::SysFreeString(bsName);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadastralFabric.DeleteJob");
    return return_tuple;
}

static PyObject*
ICadastralFabricMethod_ExtractCadastralPacket(PyICadastralFabricObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsJobName = 0;
    PyObject* pyvar_JobName;
    PyObject* unicodeJobName = NULL;
    IProjectedCoordinateSystem* ipOutputProjectedCoordSys = NULL;
    PyObject* py_OutputProjectedCoordSys;
    ITrackCancel* ipTrackCancel = NULL;
    PyObject* py_TrackCancel;
    IXMLStream* ipXMLStream = NULL;
    PyObject* py_XMLStream = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOO", &pyvar_JobName, &py_OutputProjectedCoordSys, &py_TrackCancel))
      goto icadastralfabric_extractcadastralpacket_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_JobName))
        unicodeJobName = PyUnicode_FromObject(pyvar_JobName);
    else if (PyUnicode_Check(pyvar_JobName))
    {
        unicodeJobName = pyvar_JobName;
        Py_INCREF(unicodeJobName);
    }
    else if (pyvar_JobName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter JobName at index 0");
    if (unicodeJobName)
        bsJobName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeJobName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeJobName));
    
    if (PyErr_Occurred())
      goto icadastralfabric_extractcadastralpacket_method_cleanup;
    
    if (!IFaceFromPyObject(py_OutputProjectedCoordSys, &IID_IProjectedCoordinateSystem, (void**)&ipOutputProjectedCoordSys))
        PyErr_SetString(PyExc_TypeError, "Argument OutputProjectedCoordSys (position 1) is not IProjectedCoordinateSystem");
    
    if (PyErr_Occurred())
      goto icadastralfabric_extractcadastralpacket_method_cleanup;
    
    if (!IFaceFromPyObject(py_TrackCancel, &IID_ITrackCancel, (void**)&ipTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument TrackCancel (position 2) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto icadastralfabric_extractcadastralpacket_method_cleanup;
    
    // No setup for XMLStream

    // Call method on actual COM interface
    hr = self->m_pICadastralFabric->ExtractCadastralPacket(bsJobName, ipOutputProjectedCoordSys, ipTrackCancel, &ipXMLStream);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadastralFabric->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadastralFabric) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadastralFabric.ExtractCadastralPacket() returned %ld", (long)hr);
        goto icadastralfabric_extractcadastralpacket_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for JobName
    // No teardown for OutputProjectedCoordSys
    // No teardown for TrackCancel
    Py_XDECREF(py_XMLStream);
    if (ipXMLStream)
    {
        IUnknown* pUnk = NULL;
        ipXMLStream->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_XMLStream = IUnknownToPythonIIDObject(pUnk, &IID_IXMLStream);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_XMLStream)
    {
        if (py_XMLStream)
           Py_DECREF(py_XMLStream);
        py_XMLStream = Py_None;
        Py_INCREF(py_XMLStream);
    }
    if (PyErr_Occurred())
      goto icadastralfabric_extractcadastralpacket_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_XMLStream);
    goto icadastralfabric_extractcadastralpacket_method_cleanup;

    icadastralfabric_extractcadastralpacket_method_cleanup:
    self->m_HR = hr;
    if (bsJobName)
        ::SysFreeString(bsJobName);
    
    if (ipOutputProjectedCoordSys)
      ipOutputProjectedCoordSys->Release();
    if (ipTrackCancel)
      ipTrackCancel->Release();
    Py_XDECREF(py_XMLStream);
    if (ipXMLStream)
      ipXMLStream->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadastralFabric.ExtractCadastralPacket");
    return return_tuple;
}

static PyObject*
ICadastralFabricMethod_PostCadastralPacket(PyICadastralFabricObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IXMLStream* ipXMLStream = NULL;
    PyObject* py_XMLStream;
    ITrackCancel* ipCancelTracker = NULL;
    PyObject* py_CancelTracker;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OO", &py_XMLStream, &py_CancelTracker))
      goto icadastralfabric_postcadastralpacket_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_XMLStream, &IID_IXMLStream, (void**)&ipXMLStream))
        PyErr_SetString(PyExc_TypeError, "Argument XMLStream (position 0) is not IXMLStream");
    
    if (PyErr_Occurred())
      goto icadastralfabric_postcadastralpacket_method_cleanup;
    
    if (!IFaceFromPyObject(py_CancelTracker, &IID_ITrackCancel, (void**)&ipCancelTracker))
        PyErr_SetString(PyExc_TypeError, "Argument CancelTracker (position 1) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto icadastralfabric_postcadastralpacket_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pICadastralFabric->PostCadastralPacket(ipXMLStream, ipCancelTracker);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadastralFabric->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadastralFabric) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadastralFabric.PostCadastralPacket() returned %ld", (long)hr);
        goto icadastralfabric_postcadastralpacket_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for XMLStream
    // No teardown for CancelTracker

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icadastralfabric_postcadastralpacket_method_cleanup;

    icadastralfabric_postcadastralpacket_method_cleanup:
    self->m_HR = hr;
    if (ipXMLStream)
      ipXMLStream->Release();
    if (ipCancelTracker)
      ipCancelTracker->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadastralFabric.PostCadastralPacket");
    return return_tuple;
}

static PyObject*
ICadastralFabricMethod_CommitJob(PyICadastralFabricObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsJobName = 0;
    PyObject* pyvar_JobName;
    PyObject* unicodeJobName = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_JobName))
      goto icadastralfabric_commitjob_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_JobName))
        unicodeJobName = PyUnicode_FromObject(pyvar_JobName);
    else if (PyUnicode_Check(pyvar_JobName))
    {
        unicodeJobName = pyvar_JobName;
        Py_INCREF(unicodeJobName);
    }
    else if (pyvar_JobName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter JobName at index 0");
    if (unicodeJobName)
        bsJobName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeJobName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeJobName));
    
    if (PyErr_Occurred())
      goto icadastralfabric_commitjob_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pICadastralFabric->CommitJob(bsJobName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadastralFabric->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadastralFabric) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadastralFabric.CommitJob() returned %ld", (long)hr);
        goto icadastralfabric_commitjob_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for JobName

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icadastralfabric_commitjob_method_cleanup;

    icadastralfabric_commitjob_method_cleanup:
    self->m_HR = hr;
    if (bsJobName)
        ::SysFreeString(bsJobName);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadastralFabric.CommitJob");
    return return_tuple;
}

static PyObject*
ICadastralFabricMethod_get_CadastralJobs(PyICadastralFabricObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriCadastralJob ecadastralJobType;
    IEnumBSTR* ipCadastralJobs = NULL;
    PyObject* py_CadastralJobs = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&ecadastralJobType))
      goto icadastralfabric_get_cadastraljobs_method_cleanup;

    // Set up initial variable values as needed
    // No setup for cadastralJobType
    // No setup for CadastralJobs

    // Call method on actual COM interface
    hr = self->m_pICadastralFabric->get_CadastralJobs(ecadastralJobType, &ipCadastralJobs);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadastralFabric->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadastralFabric) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadastralFabric.get_CadastralJobs() returned %ld", (long)hr);
        goto icadastralfabric_get_cadastraljobs_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for cadastralJobType
    Py_XDECREF(py_CadastralJobs);
    if (ipCadastralJobs)
    {
        IUnknown* pUnk = NULL;
        ipCadastralJobs->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_CadastralJobs = IUnknownToPythonIIDObject(pUnk, &IID_IEnumBSTR);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_CadastralJobs)
    {
        if (py_CadastralJobs)
           Py_DECREF(py_CadastralJobs);
        py_CadastralJobs = Py_None;
        Py_INCREF(py_CadastralJobs);
    }
    if (PyErr_Occurred())
      goto icadastralfabric_get_cadastraljobs_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_CadastralJobs);
    goto icadastralfabric_get_cadastraljobs_method_cleanup;

    icadastralfabric_get_cadastraljobs_method_cleanup:
    self->m_HR = hr;
    // No cleanup for cadastralJobType
    Py_XDECREF(py_CadastralJobs);
    if (ipCadastralJobs)
      ipCadastralJobs->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadastralFabric.get_CadastralJobs");
    return return_tuple;
}

static PyObject*
ICadastralFabricMethod_get_CadastralTable(PyICadastralFabricObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriCadastralFabricTable eTableID;
    ITable* ipTable = NULL;
    PyObject* py_Table = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&eTableID))
      goto icadastralfabric_get_cadastraltable_method_cleanup;

    // Set up initial variable values as needed
    // No setup for TableID
    // No setup for Table

    // Call method on actual COM interface
    hr = self->m_pICadastralFabric->get_CadastralTable(eTableID, &ipTable);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadastralFabric->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadastralFabric) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadastralFabric.get_CadastralTable() returned %ld", (long)hr);
        goto icadastralfabric_get_cadastraltable_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for TableID
    Py_XDECREF(py_Table);
    if (ipTable)
    {
        IUnknown* pUnk = NULL;
        ipTable->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_Table = IUnknownToPythonIIDObject(pUnk, &IID_ITable);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_Table)
    {
        if (py_Table)
           Py_DECREF(py_Table);
        py_Table = Py_None;
        Py_INCREF(py_Table);
    }
    if (PyErr_Occurred())
      goto icadastralfabric_get_cadastraltable_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_Table);
    goto icadastralfabric_get_cadastraltable_method_cleanup;

    icadastralfabric_get_cadastraltable_method_cleanup:
    self->m_HR = hr;
    // No cleanup for TableID
    Py_XDECREF(py_Table);
    if (ipTable)
      ipTable->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadastralFabric.get_CadastralTable");
    return return_tuple;
}


PyMethodDef PyICadastralFabricMethods[] = {
    {"supports", (PyCFunction)PyICadastralFabric_SupportsInterface, METH_O, ""},
    {"CreateJob", (PyCFunction)ICadastralFabricMethod_CreateJob, METH_VARARGS, ""},
    {"GetJob", (PyCFunction)ICadastralFabricMethod_GetJob, METH_VARARGS, ""},
    {"UpdateJob", (PyCFunction)ICadastralFabricMethod_UpdateJob, METH_VARARGS, ""},
    {"DeleteJob", (PyCFunction)ICadastralFabricMethod_DeleteJob, METH_VARARGS, ""},
    {"ExtractCadastralPacket", (PyCFunction)ICadastralFabricMethod_ExtractCadastralPacket, METH_VARARGS, ""},
    {"PostCadastralPacket", (PyCFunction)ICadastralFabricMethod_PostCadastralPacket, METH_VARARGS, ""},
    {"CommitJob", (PyCFunction)ICadastralFabricMethod_CommitJob, METH_VARARGS, ""},
    {"get_CadastralJobs", (PyCFunction)ICadastralFabricMethod_get_CadastralJobs, METH_VARARGS, ""},
    {"get_CadastralTable", (PyCFunction)ICadastralFabricMethod_get_CadastralTable, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyICadastralFabricGetSet[] = {
  {"_pUnk", (getter)PyICadastralFabric_GetpUnk, NULL, "Get opaque pointer to an Unknown from ICadastralFabric", NULL},
  {"_pointer", (getter)PyICadastralFabric_GetPointer, NULL, "Get memory address for ICadastralFabric", NULL},
  {"_IID", (getter)PyICadastralFabric_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyICadastralFabric_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyICadastralFabric_GetIgnoreFailures, (setter)PyICadastralFabric_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyICadastralFabricObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.ICadastralFabricObject",                          
                                              /* tp_name */
  sizeof(PyICadastralFabricObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyICadastralFabricObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyICadastralFabricMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyICadastralFabricGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyICadastralFabricObject_new,                      
                                              /* tp_new */
};

// Interface ICadastralFabric2

typedef struct PyICadastralFabric2Object {
    PyObject_HEAD
    ICadastralFabric2* m_pICadastralFabric2;
    HRESULT m_HR;
    int m_ignore_failures;
} PyICadastralFabric2Object;

static PyObject*
PyICadastralFabric2Object_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyICadastralFabric2Object* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ICadastralFabric2* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ICadastralFabric2, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ICadastralFabric2 with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyICadastralFabric2Object *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ICadastralFabric2");
            return NULL;
        }
        self->m_pICadastralFabric2 = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ICadastralFabric2");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ICadastralFabric2");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ICadastralFabric2* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ICadastralFabric2, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ICadastralFabric2");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyICadastralFabric2Object *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ICadastralFabric2");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pICadastralFabric2 = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyICadastralFabric2Object_dealloc(PyICadastralFabric2Object* self)
{
    if (self->m_pICadastralFabric2)
        self->m_pICadastralFabric2->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyICadastralFabric2_GetpUnk(PyICadastralFabric2Object* self)
{
    if (!self->m_pICadastralFabric2)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pICadastralFabric2->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ICadastralFabric2 to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyICadastralFabric2_GetPointer(PyICadastralFabric2Object* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pICadastralFabric2);
}

static PyObject*
PyICadastralFabric2_GetIID(PyICadastralFabric2Object* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "b6379408-3f07-4836-89f9-67610d2f74ce");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyICadastralFabric2_GetHR(PyICadastralFabric2Object* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyICadastralFabric2_GetIgnoreFailures(PyICadastralFabric2Object* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyICadastralFabric2_SetIgnoreFailures(PyICadastralFabric2Object* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyICadastralFabric2_SupportsInterface(PyICadastralFabric2Object* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pICadastralFabric2->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ICadastralFabric2Method_CreateCadastralPacket(PyICadastralFabric2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IProjectedCoordinateSystem* ipOutputProjectedCoordSys = NULL;
    PyObject* py_OutputProjectedCoordSys;
    IFIDSet* ipPlanIDs = NULL;
    PyObject* py_PlanIDs;
    ITrackCancel* ipTrackCancel = NULL;
    PyObject* py_TrackCancel;
    IXMLStream* ipXMLStream = NULL;
    PyObject* py_XMLStream = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOO", &py_OutputProjectedCoordSys, &py_PlanIDs, &py_TrackCancel))
      goto icadastralfabric2_createcadastralpacket_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_OutputProjectedCoordSys, &IID_IProjectedCoordinateSystem, (void**)&ipOutputProjectedCoordSys))
        PyErr_SetString(PyExc_TypeError, "Argument OutputProjectedCoordSys (position 0) is not IProjectedCoordinateSystem");
    
    if (PyErr_Occurred())
      goto icadastralfabric2_createcadastralpacket_method_cleanup;
    
    if (!IFaceFromPyObject(py_PlanIDs, &IID_IFIDSet, (void**)&ipPlanIDs))
        PyErr_SetString(PyExc_TypeError, "Argument PlanIDs (position 1) is not IFIDSet");
    
    if (PyErr_Occurred())
      goto icadastralfabric2_createcadastralpacket_method_cleanup;
    
    if (!IFaceFromPyObject(py_TrackCancel, &IID_ITrackCancel, (void**)&ipTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument TrackCancel (position 2) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto icadastralfabric2_createcadastralpacket_method_cleanup;
    
    // No setup for XMLStream

    // Call method on actual COM interface
    hr = self->m_pICadastralFabric2->CreateCadastralPacket(ipOutputProjectedCoordSys, ipPlanIDs, ipTrackCancel, &ipXMLStream);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadastralFabric2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadastralFabric2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadastralFabric2.CreateCadastralPacket() returned %ld", (long)hr);
        goto icadastralfabric2_createcadastralpacket_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for OutputProjectedCoordSys
    // No teardown for PlanIDs
    // No teardown for TrackCancel
    Py_XDECREF(py_XMLStream);
    if (ipXMLStream)
    {
        IUnknown* pUnk = NULL;
        ipXMLStream->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_XMLStream = IUnknownToPythonIIDObject(pUnk, &IID_IXMLStream);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_XMLStream)
    {
        if (py_XMLStream)
           Py_DECREF(py_XMLStream);
        py_XMLStream = Py_None;
        Py_INCREF(py_XMLStream);
    }
    if (PyErr_Occurred())
      goto icadastralfabric2_createcadastralpacket_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_XMLStream);
    goto icadastralfabric2_createcadastralpacket_method_cleanup;

    icadastralfabric2_createcadastralpacket_method_cleanup:
    self->m_HR = hr;
    if (ipOutputProjectedCoordSys)
      ipOutputProjectedCoordSys->Release();
    if (ipPlanIDs)
      ipPlanIDs->Release();
    if (ipTrackCancel)
      ipTrackCancel->Release();
    Py_XDECREF(py_XMLStream);
    if (ipXMLStream)
      ipXMLStream->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadastralFabric2.CreateCadastralPacket");
    return return_tuple;
}

static PyObject*
ICadastralFabric2Method_InsertCadastralPacket(PyICadastralFabric2Object* self, PyObject* args)
{
    /* Param types that are unhandleable: 
       INPUT [u'IFIDSet', u'*', u'*']
    */
    PyErr_SetString(PyExc_NotImplementedError, "Wrapper for ICadastralFabric2.InsertCadastralPacket not implemented.");
    return NULL;
}

static PyObject*
ICadastralFabric2Method_ExtractCadastralPacket(PyICadastralFabric2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsJobName = 0;
    PyObject* pyvar_JobName;
    PyObject* unicodeJobName = NULL;
    IProjectedCoordinateSystem* ipOutputProjectedCoordSys = NULL;
    PyObject* py_OutputProjectedCoordSys;
    ITrackCancel* ipTrackCancel = NULL;
    PyObject* py_TrackCancel;
    VARIANT_BOOL b_IncludeWhiteSpace = VARIANT_FALSE;
    PyObject* pyvar_IncludeWhiteSpace = NULL;
    IXMLStream* ipXMLStream = NULL;
    PyObject* py_XMLStream = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOOO", &pyvar_JobName, &py_OutputProjectedCoordSys, &py_TrackCancel, &pyvar_IncludeWhiteSpace))
      goto icadastralfabric2_extractcadastralpacket_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_JobName))
        unicodeJobName = PyUnicode_FromObject(pyvar_JobName);
    else if (PyUnicode_Check(pyvar_JobName))
    {
        unicodeJobName = pyvar_JobName;
        Py_INCREF(unicodeJobName);
    }
    else if (pyvar_JobName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter JobName at index 0");
    if (unicodeJobName)
        bsJobName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeJobName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeJobName));
    
    if (PyErr_Occurred())
      goto icadastralfabric2_extractcadastralpacket_method_cleanup;
    
    if (!IFaceFromPyObject(py_OutputProjectedCoordSys, &IID_IProjectedCoordinateSystem, (void**)&ipOutputProjectedCoordSys))
        PyErr_SetString(PyExc_TypeError, "Argument OutputProjectedCoordSys (position 1) is not IProjectedCoordinateSystem");
    
    if (PyErr_Occurred())
      goto icadastralfabric2_extractcadastralpacket_method_cleanup;
    
    if (!IFaceFromPyObject(py_TrackCancel, &IID_ITrackCancel, (void**)&ipTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument TrackCancel (position 2) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto icadastralfabric2_extractcadastralpacket_method_cleanup;
    
    b_IncludeWhiteSpace = ((PyObject_IsTrue(pyvar_IncludeWhiteSpace) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto icadastralfabric2_extractcadastralpacket_method_cleanup;
    
    // No setup for XMLStream

    // Call method on actual COM interface
    hr = self->m_pICadastralFabric2->ExtractCadastralPacket(bsJobName, ipOutputProjectedCoordSys, ipTrackCancel, b_IncludeWhiteSpace, &ipXMLStream);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadastralFabric2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadastralFabric2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadastralFabric2.ExtractCadastralPacket() returned %ld", (long)hr);
        goto icadastralfabric2_extractcadastralpacket_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for JobName
    // No teardown for OutputProjectedCoordSys
    // No teardown for TrackCancel
    // No teardown for IncludeWhiteSpace
    Py_XDECREF(py_XMLStream);
    if (ipXMLStream)
    {
        IUnknown* pUnk = NULL;
        ipXMLStream->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_XMLStream = IUnknownToPythonIIDObject(pUnk, &IID_IXMLStream);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_XMLStream)
    {
        if (py_XMLStream)
           Py_DECREF(py_XMLStream);
        py_XMLStream = Py_None;
        Py_INCREF(py_XMLStream);
    }
    if (PyErr_Occurred())
      goto icadastralfabric2_extractcadastralpacket_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_XMLStream);
    goto icadastralfabric2_extractcadastralpacket_method_cleanup;

    icadastralfabric2_extractcadastralpacket_method_cleanup:
    self->m_HR = hr;
    if (bsJobName)
        ::SysFreeString(bsJobName);
    
    if (ipOutputProjectedCoordSys)
      ipOutputProjectedCoordSys->Release();
    if (ipTrackCancel)
      ipTrackCancel->Release();
    // No cleanup for IncludeWhiteSpace
    Py_XDECREF(py_XMLStream);
    if (ipXMLStream)
      ipXMLStream->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadastralFabric2.ExtractCadastralPacket");
    return return_tuple;
}

static PyObject*
ICadastralFabric2Method_PostCadastralPacket(PyICadastralFabric2Object* self, PyObject* args)
{
    /* Param types that are unhandleable: 
       INPUT [u'IFIDSet', u'*', u'*']
    */
    PyErr_SetString(PyExc_NotImplementedError, "Wrapper for ICadastralFabric2.PostCadastralPacket not implemented.");
    return NULL;
}


PyMethodDef PyICadastralFabric2Methods[] = {
    {"supports", (PyCFunction)PyICadastralFabric2_SupportsInterface, METH_O, ""},
    {"CreateCadastralPacket", (PyCFunction)ICadastralFabric2Method_CreateCadastralPacket, METH_VARARGS, ""},
    {"InsertCadastralPacket", (PyCFunction)ICadastralFabric2Method_InsertCadastralPacket, METH_VARARGS, ""},
    {"ExtractCadastralPacket", (PyCFunction)ICadastralFabric2Method_ExtractCadastralPacket, METH_VARARGS, ""},
    {"PostCadastralPacket", (PyCFunction)ICadastralFabric2Method_PostCadastralPacket, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyICadastralFabric2GetSet[] = {
  {"_pUnk", (getter)PyICadastralFabric2_GetpUnk, NULL, "Get opaque pointer to an Unknown from ICadastralFabric2", NULL},
  {"_pointer", (getter)PyICadastralFabric2_GetPointer, NULL, "Get memory address for ICadastralFabric2", NULL},
  {"_IID", (getter)PyICadastralFabric2_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyICadastralFabric2_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyICadastralFabric2_GetIgnoreFailures, (setter)PyICadastralFabric2_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyICadastralFabric2Object_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.ICadastralFabric2Object",                          
                                              /* tp_name */
  sizeof(PyICadastralFabric2Object),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyICadastralFabric2Object_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyICadastralFabric2Methods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyICadastralFabric2GetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyICadastralFabric2Object_new,                      
                                              /* tp_new */
};

// Interface ICadastralFabric3

typedef struct PyICadastralFabric3Object {
    PyObject_HEAD
    ICadastralFabric3* m_pICadastralFabric3;
    HRESULT m_HR;
    int m_ignore_failures;
} PyICadastralFabric3Object;

static PyObject*
PyICadastralFabric3Object_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyICadastralFabric3Object* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ICadastralFabric3* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ICadastralFabric3, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ICadastralFabric3 with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyICadastralFabric3Object *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ICadastralFabric3");
            return NULL;
        }
        self->m_pICadastralFabric3 = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ICadastralFabric3");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ICadastralFabric3");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ICadastralFabric3* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ICadastralFabric3, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ICadastralFabric3");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyICadastralFabric3Object *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ICadastralFabric3");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pICadastralFabric3 = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyICadastralFabric3Object_dealloc(PyICadastralFabric3Object* self)
{
    if (self->m_pICadastralFabric3)
        self->m_pICadastralFabric3->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyICadastralFabric3_GetpUnk(PyICadastralFabric3Object* self)
{
    if (!self->m_pICadastralFabric3)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pICadastralFabric3->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ICadastralFabric3 to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyICadastralFabric3_GetPointer(PyICadastralFabric3Object* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pICadastralFabric3);
}

static PyObject*
PyICadastralFabric3_GetIID(PyICadastralFabric3Object* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "5afce645-3c35-4a29-97d6-36c7524ee750");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyICadastralFabric3_GetHR(PyICadastralFabric3Object* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyICadastralFabric3_GetIgnoreFailures(PyICadastralFabric3Object* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyICadastralFabric3_SetIgnoreFailures(PyICadastralFabric3Object* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyICadastralFabric3_SupportsInterface(PyICadastralFabric3Object* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pICadastralFabric3->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ICadastralFabric3Method_CreateCadastralPacket(PyICadastralFabric3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IProjectedCoordinateSystem* ipOutputProjectedCoordSys = NULL;
    PyObject* py_OutputProjectedCoordSys;
    IFIDSet* ipPlanIDs = NULL;
    PyObject* py_PlanIDs;
    ITrackCancel* ipTrackCancel = NULL;
    PyObject* py_TrackCancel;
    IXMLStream* ipXMLStream = NULL;
    PyObject* py_XMLStream = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOO", &py_OutputProjectedCoordSys, &py_PlanIDs, &py_TrackCancel))
      goto icadastralfabric3_createcadastralpacket_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_OutputProjectedCoordSys, &IID_IProjectedCoordinateSystem, (void**)&ipOutputProjectedCoordSys))
        PyErr_SetString(PyExc_TypeError, "Argument OutputProjectedCoordSys (position 0) is not IProjectedCoordinateSystem");
    
    if (PyErr_Occurred())
      goto icadastralfabric3_createcadastralpacket_method_cleanup;
    
    if (!IFaceFromPyObject(py_PlanIDs, &IID_IFIDSet, (void**)&ipPlanIDs))
        PyErr_SetString(PyExc_TypeError, "Argument PlanIDs (position 1) is not IFIDSet");
    
    if (PyErr_Occurred())
      goto icadastralfabric3_createcadastralpacket_method_cleanup;
    
    if (!IFaceFromPyObject(py_TrackCancel, &IID_ITrackCancel, (void**)&ipTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument TrackCancel (position 2) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto icadastralfabric3_createcadastralpacket_method_cleanup;
    
    // No setup for XMLStream

    // Call method on actual COM interface
    hr = self->m_pICadastralFabric3->CreateCadastralPacket(ipOutputProjectedCoordSys, ipPlanIDs, ipTrackCancel, &ipXMLStream);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadastralFabric3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadastralFabric3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadastralFabric3.CreateCadastralPacket() returned %ld", (long)hr);
        goto icadastralfabric3_createcadastralpacket_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for OutputProjectedCoordSys
    // No teardown for PlanIDs
    // No teardown for TrackCancel
    Py_XDECREF(py_XMLStream);
    if (ipXMLStream)
    {
        IUnknown* pUnk = NULL;
        ipXMLStream->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_XMLStream = IUnknownToPythonIIDObject(pUnk, &IID_IXMLStream);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_XMLStream)
    {
        if (py_XMLStream)
           Py_DECREF(py_XMLStream);
        py_XMLStream = Py_None;
        Py_INCREF(py_XMLStream);
    }
    if (PyErr_Occurred())
      goto icadastralfabric3_createcadastralpacket_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_XMLStream);
    goto icadastralfabric3_createcadastralpacket_method_cleanup;

    icadastralfabric3_createcadastralpacket_method_cleanup:
    self->m_HR = hr;
    if (ipOutputProjectedCoordSys)
      ipOutputProjectedCoordSys->Release();
    if (ipPlanIDs)
      ipPlanIDs->Release();
    if (ipTrackCancel)
      ipTrackCancel->Release();
    Py_XDECREF(py_XMLStream);
    if (ipXMLStream)
      ipXMLStream->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadastralFabric3.CreateCadastralPacket");
    return return_tuple;
}

static PyObject*
ICadastralFabric3Method_InsertCadastralPacket(PyICadastralFabric3Object* self, PyObject* args)
{
    /* Param types that are unhandleable: 
       INPUT [u'IFIDSet', u'*', u'*']
    */
    PyErr_SetString(PyExc_NotImplementedError, "Wrapper for ICadastralFabric3.InsertCadastralPacket not implemented.");
    return NULL;
}

static PyObject*
ICadastralFabric3Method_ExtractCadastralPacket(PyICadastralFabric3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsJobName = 0;
    PyObject* pyvar_JobName;
    PyObject* unicodeJobName = NULL;
    IProjectedCoordinateSystem* ipOutputProjectedCoordSys = NULL;
    PyObject* py_OutputProjectedCoordSys;
    ITrackCancel* ipTrackCancel = NULL;
    PyObject* py_TrackCancel;
    VARIANT_BOOL b_IncludeWhiteSpace = VARIANT_FALSE;
    PyObject* pyvar_IncludeWhiteSpace = NULL;
    IXMLStream* ipXMLStream = NULL;
    PyObject* py_XMLStream = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOOO", &pyvar_JobName, &py_OutputProjectedCoordSys, &py_TrackCancel, &pyvar_IncludeWhiteSpace))
      goto icadastralfabric3_extractcadastralpacket_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_JobName))
        unicodeJobName = PyUnicode_FromObject(pyvar_JobName);
    else if (PyUnicode_Check(pyvar_JobName))
    {
        unicodeJobName = pyvar_JobName;
        Py_INCREF(unicodeJobName);
    }
    else if (pyvar_JobName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter JobName at index 0");
    if (unicodeJobName)
        bsJobName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeJobName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeJobName));
    
    if (PyErr_Occurred())
      goto icadastralfabric3_extractcadastralpacket_method_cleanup;
    
    if (!IFaceFromPyObject(py_OutputProjectedCoordSys, &IID_IProjectedCoordinateSystem, (void**)&ipOutputProjectedCoordSys))
        PyErr_SetString(PyExc_TypeError, "Argument OutputProjectedCoordSys (position 1) is not IProjectedCoordinateSystem");
    
    if (PyErr_Occurred())
      goto icadastralfabric3_extractcadastralpacket_method_cleanup;
    
    if (!IFaceFromPyObject(py_TrackCancel, &IID_ITrackCancel, (void**)&ipTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument TrackCancel (position 2) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto icadastralfabric3_extractcadastralpacket_method_cleanup;
    
    b_IncludeWhiteSpace = ((PyObject_IsTrue(pyvar_IncludeWhiteSpace) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto icadastralfabric3_extractcadastralpacket_method_cleanup;
    
    // No setup for XMLStream

    // Call method on actual COM interface
    hr = self->m_pICadastralFabric3->ExtractCadastralPacket(bsJobName, ipOutputProjectedCoordSys, ipTrackCancel, b_IncludeWhiteSpace, &ipXMLStream);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadastralFabric3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadastralFabric3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadastralFabric3.ExtractCadastralPacket() returned %ld", (long)hr);
        goto icadastralfabric3_extractcadastralpacket_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for JobName
    // No teardown for OutputProjectedCoordSys
    // No teardown for TrackCancel
    // No teardown for IncludeWhiteSpace
    Py_XDECREF(py_XMLStream);
    if (ipXMLStream)
    {
        IUnknown* pUnk = NULL;
        ipXMLStream->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_XMLStream = IUnknownToPythonIIDObject(pUnk, &IID_IXMLStream);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_XMLStream)
    {
        if (py_XMLStream)
           Py_DECREF(py_XMLStream);
        py_XMLStream = Py_None;
        Py_INCREF(py_XMLStream);
    }
    if (PyErr_Occurred())
      goto icadastralfabric3_extractcadastralpacket_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_XMLStream);
    goto icadastralfabric3_extractcadastralpacket_method_cleanup;

    icadastralfabric3_extractcadastralpacket_method_cleanup:
    self->m_HR = hr;
    if (bsJobName)
        ::SysFreeString(bsJobName);
    
    if (ipOutputProjectedCoordSys)
      ipOutputProjectedCoordSys->Release();
    if (ipTrackCancel)
      ipTrackCancel->Release();
    // No cleanup for IncludeWhiteSpace
    Py_XDECREF(py_XMLStream);
    if (ipXMLStream)
      ipXMLStream->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadastralFabric3.ExtractCadastralPacket");
    return return_tuple;
}

static PyObject*
ICadastralFabric3Method_PostCadastralPacket(PyICadastralFabric3Object* self, PyObject* args)
{
    /* Param types that are unhandleable: 
       INPUT [u'IFIDSet', u'*', u'*']
    */
    PyErr_SetString(PyExc_NotImplementedError, "Wrapper for ICadastralFabric3.PostCadastralPacket not implemented.");
    return NULL;
}


PyMethodDef PyICadastralFabric3Methods[] = {
    {"supports", (PyCFunction)PyICadastralFabric3_SupportsInterface, METH_O, ""},
    {"CreateCadastralPacket", (PyCFunction)ICadastralFabric3Method_CreateCadastralPacket, METH_VARARGS, ""},
    {"InsertCadastralPacket", (PyCFunction)ICadastralFabric3Method_InsertCadastralPacket, METH_VARARGS, ""},
    {"ExtractCadastralPacket", (PyCFunction)ICadastralFabric3Method_ExtractCadastralPacket, METH_VARARGS, ""},
    {"PostCadastralPacket", (PyCFunction)ICadastralFabric3Method_PostCadastralPacket, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyICadastralFabric3GetSet[] = {
  {"_pUnk", (getter)PyICadastralFabric3_GetpUnk, NULL, "Get opaque pointer to an Unknown from ICadastralFabric3", NULL},
  {"_pointer", (getter)PyICadastralFabric3_GetPointer, NULL, "Get memory address for ICadastralFabric3", NULL},
  {"_IID", (getter)PyICadastralFabric3_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyICadastralFabric3_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyICadastralFabric3_GetIgnoreFailures, (setter)PyICadastralFabric3_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyICadastralFabric3Object_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.ICadastralFabric3Object",                          
                                              /* tp_name */
  sizeof(PyICadastralFabric3Object),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyICadastralFabric3Object_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyICadastralFabric3Methods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyICadastralFabric3GetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyICadastralFabric3Object_new,                      
                                              /* tp_new */
};

// Interface ICadastralFabricName

typedef struct PyICadastralFabricNameObject {
    PyObject_HEAD
    ICadastralFabricName* m_pICadastralFabricName;
    HRESULT m_HR;
    int m_ignore_failures;
} PyICadastralFabricNameObject;

static PyObject*
PyICadastralFabricNameObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyICadastralFabricNameObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ICadastralFabricName* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ICadastralFabricName, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ICadastralFabricName with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyICadastralFabricNameObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ICadastralFabricName");
            return NULL;
        }
        self->m_pICadastralFabricName = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ICadastralFabricName");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ICadastralFabricName");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ICadastralFabricName* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ICadastralFabricName, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ICadastralFabricName");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyICadastralFabricNameObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ICadastralFabricName");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pICadastralFabricName = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyICadastralFabricNameObject_dealloc(PyICadastralFabricNameObject* self)
{
    if (self->m_pICadastralFabricName)
        self->m_pICadastralFabricName->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyICadastralFabricName_GetpUnk(PyICadastralFabricNameObject* self)
{
    if (!self->m_pICadastralFabricName)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pICadastralFabricName->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ICadastralFabricName to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyICadastralFabricName_GetPointer(PyICadastralFabricNameObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pICadastralFabricName);
}

static PyObject*
PyICadastralFabricName_GetIID(PyICadastralFabricNameObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "f7914f56-f87a-4e96-87f8-cbe368da3c61");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyICadastralFabricName_GetHR(PyICadastralFabricNameObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyICadastralFabricName_GetIgnoreFailures(PyICadastralFabricNameObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyICadastralFabricName_SetIgnoreFailures(PyICadastralFabricNameObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyICadastralFabricName_SupportsInterface(PyICadastralFabricNameObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pICadastralFabricName->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ICadastralFabricNameMethod_putref_FeatureDatasetName(PyICadastralFabricNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IDatasetName* ipName = NULL;
    PyObject* py_Name;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_Name))
      goto icadastralfabricname_putref_featuredatasetname_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_Name, &IID_IDatasetName, (void**)&ipName))
        PyErr_SetString(PyExc_TypeError, "Argument Name (position 0) is not IDatasetName");
    
    if (PyErr_Occurred())
      goto icadastralfabricname_putref_featuredatasetname_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pICadastralFabricName->putref_FeatureDatasetName(ipName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadastralFabricName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadastralFabricName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadastralFabricName.putref_FeatureDatasetName() returned %ld", (long)hr);
        goto icadastralfabricname_putref_featuredatasetname_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Name

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icadastralfabricname_putref_featuredatasetname_method_cleanup;

    icadastralfabricname_putref_featuredatasetname_method_cleanup:
    self->m_HR = hr;
    if (ipName)
      ipName->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadastralFabricName.putref_FeatureDatasetName");
    return return_tuple;
}

static PyObject*
ICadastralFabricNameMethod_get_FeatureDatasetName(PyICadastralFabricNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IDatasetName* ipName = NULL;
    PyObject* py_Name = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Name

    // Call method on actual COM interface
    hr = self->m_pICadastralFabricName->get_FeatureDatasetName(&ipName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadastralFabricName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadastralFabricName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadastralFabricName.get_FeatureDatasetName() returned %ld", (long)hr);
        goto icadastralfabricname_get_featuredatasetname_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_Name);
    if (ipName)
    {
        IUnknown* pUnk = NULL;
        ipName->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_Name = IUnknownToPythonIIDObject(pUnk, &IID_IDatasetName);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_Name)
    {
        if (py_Name)
           Py_DECREF(py_Name);
        py_Name = Py_None;
        Py_INCREF(py_Name);
    }
    if (PyErr_Occurred())
      goto icadastralfabricname_get_featuredatasetname_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_Name);
    goto icadastralfabricname_get_featuredatasetname_method_cleanup;

    icadastralfabricname_get_featuredatasetname_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_Name);
    if (ipName)
      ipName->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadastralFabricName.get_FeatureDatasetName");
    return return_tuple;
}


PyMethodDef PyICadastralFabricNameMethods[] = {
    {"supports", (PyCFunction)PyICadastralFabricName_SupportsInterface, METH_O, ""},
    {"putref_FeatureDatasetName", (PyCFunction)ICadastralFabricNameMethod_putref_FeatureDatasetName, METH_VARARGS, ""},
    {"get_FeatureDatasetName", (PyCFunction)ICadastralFabricNameMethod_get_FeatureDatasetName, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyICadastralFabricNameGetSet[] = {
  {"_pUnk", (getter)PyICadastralFabricName_GetpUnk, NULL, "Get opaque pointer to an Unknown from ICadastralFabricName", NULL},
  {"_pointer", (getter)PyICadastralFabricName_GetPointer, NULL, "Get memory address for ICadastralFabricName", NULL},
  {"_IID", (getter)PyICadastralFabricName_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyICadastralFabricName_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyICadastralFabricName_GetIgnoreFailures, (setter)PyICadastralFabricName_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyICadastralFabricNameObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.ICadastralFabricNameObject",                          
                                              /* tp_name */
  sizeof(PyICadastralFabricNameObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyICadastralFabricNameObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyICadastralFabricNameMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyICadastralFabricNameGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyICadastralFabricNameObject_new,                      
                                              /* tp_new */
};

// Interface IDECadastralFabric

typedef struct PyIDECadastralFabricObject {
    PyObject_HEAD
    IDECadastralFabric* m_pIDECadastralFabric;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIDECadastralFabricObject;

static PyObject*
PyIDECadastralFabricObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIDECadastralFabricObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IDECadastralFabric* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IDECadastralFabric, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IDECadastralFabric with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIDECadastralFabricObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IDECadastralFabric");
            return NULL;
        }
        self->m_pIDECadastralFabric = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IDECadastralFabric");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IDECadastralFabric");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IDECadastralFabric* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IDECadastralFabric, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IDECadastralFabric");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIDECadastralFabricObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IDECadastralFabric");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIDECadastralFabric = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIDECadastralFabricObject_dealloc(PyIDECadastralFabricObject* self)
{
    if (self->m_pIDECadastralFabric)
        self->m_pIDECadastralFabric->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIDECadastralFabric_GetpUnk(PyIDECadastralFabricObject* self)
{
    if (!self->m_pIDECadastralFabric)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIDECadastralFabric->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IDECadastralFabric to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIDECadastralFabric_GetPointer(PyIDECadastralFabricObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIDECadastralFabric);
}

static PyObject*
PyIDECadastralFabric_GetIID(PyIDECadastralFabricObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "06c95fa1-8cf2-4563-8038-15fb592374b4");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIDECadastralFabric_GetHR(PyIDECadastralFabricObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIDECadastralFabric_GetIgnoreFailures(PyIDECadastralFabricObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIDECadastralFabric_SetIgnoreFailures(PyIDECadastralFabricObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIDECadastralFabric_SupportsInterface(PyIDECadastralFabricObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIDECadastralFabric->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IDECadastralFabricMethod_get_ConfigurationKeyword(PyIDECadastralFabricObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsconfigKeyword;
    PyObject* pyvar_configKeyword = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for configKeyword

    // Call method on actual COM interface
    hr = self->m_pIDECadastralFabric->get_ConfigurationKeyword(&bsconfigKeyword);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDECadastralFabric->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDECadastralFabric) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDECadastralFabric.get_ConfigurationKeyword() returned %ld", (long)hr);
        goto idecadastralfabric_get_configurationkeyword_method_cleanup;
    }

    // Set up return values as needed
    pyvar_configKeyword = PyUnicode_FromWideChar(bsconfigKeyword,::SysStringLen(bsconfigKeyword));
    ::SysFreeString(bsconfigKeyword);
    
    if (PyErr_Occurred())
      goto idecadastralfabric_get_configurationkeyword_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_configKeyword);
    goto idecadastralfabric_get_configurationkeyword_method_cleanup;

    idecadastralfabric_get_configurationkeyword_method_cleanup:
    self->m_HR = hr;
    if (pyvar_configKeyword != Py_None)
        Py_XDECREF(pyvar_configKeyword);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDECadastralFabric.get_ConfigurationKeyword");
    return return_tuple;
}

static PyObject*
IDECadastralFabricMethod_put_ConfigurationKeyword(PyIDECadastralFabricObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsconfigKeyword = 0;
    PyObject* pyvar_configKeyword;
    PyObject* unicodeconfigKeyword = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_configKeyword))
      goto idecadastralfabric_put_configurationkeyword_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_configKeyword))
        unicodeconfigKeyword = PyUnicode_FromObject(pyvar_configKeyword);
    else if (PyUnicode_Check(pyvar_configKeyword))
    {
        unicodeconfigKeyword = pyvar_configKeyword;
        Py_INCREF(unicodeconfigKeyword);
    }
    else if (pyvar_configKeyword != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter configKeyword at index 0");
    if (unicodeconfigKeyword)
        bsconfigKeyword = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeconfigKeyword), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeconfigKeyword));
    
    if (PyErr_Occurred())
      goto idecadastralfabric_put_configurationkeyword_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIDECadastralFabric->put_ConfigurationKeyword(bsconfigKeyword);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDECadastralFabric->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDECadastralFabric) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDECadastralFabric.put_ConfigurationKeyword() returned %ld", (long)hr);
        goto idecadastralfabric_put_configurationkeyword_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for configKeyword

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idecadastralfabric_put_configurationkeyword_method_cleanup;

    idecadastralfabric_put_configurationkeyword_method_cleanup:
    self->m_HR = hr;
    if (bsconfigKeyword)
        ::SysFreeString(bsconfigKeyword);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDECadastralFabric.put_ConfigurationKeyword");
    return return_tuple;
}

static PyObject*
IDECadastralFabricMethod_get_DefaultAccuracyCategory(PyIDECadastralFabricObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long ldefaultAccuracy = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for defaultAccuracy

    // Call method on actual COM interface
    hr = self->m_pIDECadastralFabric->get_DefaultAccuracyCategory(&ldefaultAccuracy);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDECadastralFabric->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDECadastralFabric) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDECadastralFabric.get_DefaultAccuracyCategory() returned %ld", (long)hr);
        goto idecadastralfabric_get_defaultaccuracycategory_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for defaultAccuracy

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            ldefaultAccuracy);
    goto idecadastralfabric_get_defaultaccuracycategory_method_cleanup;

    idecadastralfabric_get_defaultaccuracycategory_method_cleanup:
    self->m_HR = hr;
    // No cleanup for defaultAccuracy
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDECadastralFabric.get_DefaultAccuracyCategory");
    return return_tuple;
}

static PyObject*
IDECadastralFabricMethod_put_DefaultAccuracyCategory(PyIDECadastralFabricObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long ldefaultAccuracy = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &ldefaultAccuracy))
      goto idecadastralfabric_put_defaultaccuracycategory_method_cleanup;

    // Set up initial variable values as needed
    // No setup for defaultAccuracy

    // Call method on actual COM interface
    hr = self->m_pIDECadastralFabric->put_DefaultAccuracyCategory(ldefaultAccuracy);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDECadastralFabric->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDECadastralFabric) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDECadastralFabric.put_DefaultAccuracyCategory() returned %ld", (long)hr);
        goto idecadastralfabric_put_defaultaccuracycategory_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for defaultAccuracy

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idecadastralfabric_put_defaultaccuracycategory_method_cleanup;

    idecadastralfabric_put_defaultaccuracycategory_method_cleanup:
    self->m_HR = hr;
    // No cleanup for defaultAccuracy
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDECadastralFabric.put_DefaultAccuracyCategory");
    return return_tuple;
}

static PyObject*
IDECadastralFabricMethod_putref_CadastralTableFieldEdits(PyIDECadastralFabricObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IArray* ipCadastralTableFieldEdits = NULL;
    PyObject* py_CadastralTableFieldEdits;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_CadastralTableFieldEdits))
      goto idecadastralfabric_putref_cadastraltablefieldedits_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_CadastralTableFieldEdits, &IID_IArray, (void**)&ipCadastralTableFieldEdits))
        PyErr_SetString(PyExc_TypeError, "Argument CadastralTableFieldEdits (position 0) is not IArray");
    
    if (PyErr_Occurred())
      goto idecadastralfabric_putref_cadastraltablefieldedits_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIDECadastralFabric->putref_CadastralTableFieldEdits(ipCadastralTableFieldEdits);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDECadastralFabric->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDECadastralFabric) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDECadastralFabric.putref_CadastralTableFieldEdits() returned %ld", (long)hr);
        goto idecadastralfabric_putref_cadastraltablefieldedits_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for CadastralTableFieldEdits

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idecadastralfabric_putref_cadastraltablefieldedits_method_cleanup;

    idecadastralfabric_putref_cadastraltablefieldedits_method_cleanup:
    self->m_HR = hr;
    if (ipCadastralTableFieldEdits)
      ipCadastralTableFieldEdits->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDECadastralFabric.putref_CadastralTableFieldEdits");
    return return_tuple;
}

static PyObject*
IDECadastralFabricMethod_get_CadastralTableFieldEdits(PyIDECadastralFabricObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IArray* ipCadastralTableFieldEdits = NULL;
    PyObject* py_CadastralTableFieldEdits = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for CadastralTableFieldEdits

    // Call method on actual COM interface
    hr = self->m_pIDECadastralFabric->get_CadastralTableFieldEdits(&ipCadastralTableFieldEdits);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDECadastralFabric->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDECadastralFabric) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDECadastralFabric.get_CadastralTableFieldEdits() returned %ld", (long)hr);
        goto idecadastralfabric_get_cadastraltablefieldedits_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_CadastralTableFieldEdits);
    if (ipCadastralTableFieldEdits)
    {
        IUnknown* pUnk = NULL;
        ipCadastralTableFieldEdits->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_CadastralTableFieldEdits = IUnknownToPythonIIDObject(pUnk, &IID_IArray);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_CadastralTableFieldEdits)
    {
        if (py_CadastralTableFieldEdits)
           Py_DECREF(py_CadastralTableFieldEdits);
        py_CadastralTableFieldEdits = Py_None;
        Py_INCREF(py_CadastralTableFieldEdits);
    }
    if (PyErr_Occurred())
      goto idecadastralfabric_get_cadastraltablefieldedits_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_CadastralTableFieldEdits);
    goto idecadastralfabric_get_cadastraltablefieldedits_method_cleanup;

    idecadastralfabric_get_cadastraltablefieldedits_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_CadastralTableFieldEdits);
    if (ipCadastralTableFieldEdits)
      ipCadastralTableFieldEdits->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDECadastralFabric.get_CadastralTableFieldEdits");
    return return_tuple;
}


PyMethodDef PyIDECadastralFabricMethods[] = {
    {"supports", (PyCFunction)PyIDECadastralFabric_SupportsInterface, METH_O, ""},
    {"get_ConfigurationKeyword", (PyCFunction)IDECadastralFabricMethod_get_ConfigurationKeyword, METH_VARARGS, ""},
    {"put_ConfigurationKeyword", (PyCFunction)IDECadastralFabricMethod_put_ConfigurationKeyword, METH_VARARGS, ""},
    {"get_DefaultAccuracyCategory", (PyCFunction)IDECadastralFabricMethod_get_DefaultAccuracyCategory, METH_VARARGS, ""},
    {"put_DefaultAccuracyCategory", (PyCFunction)IDECadastralFabricMethod_put_DefaultAccuracyCategory, METH_VARARGS, ""},
    {"putref_CadastralTableFieldEdits", (PyCFunction)IDECadastralFabricMethod_putref_CadastralTableFieldEdits, METH_VARARGS, ""},
    {"get_CadastralTableFieldEdits", (PyCFunction)IDECadastralFabricMethod_get_CadastralTableFieldEdits, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIDECadastralFabricGetSet[] = {
  {"_pUnk", (getter)PyIDECadastralFabric_GetpUnk, NULL, "Get opaque pointer to an Unknown from IDECadastralFabric", NULL},
  {"_pointer", (getter)PyIDECadastralFabric_GetPointer, NULL, "Get memory address for IDECadastralFabric", NULL},
  {"_IID", (getter)PyIDECadastralFabric_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIDECadastralFabric_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIDECadastralFabric_GetIgnoreFailures, (setter)PyIDECadastralFabric_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIDECadastralFabricObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.IDECadastralFabricObject",                          
                                              /* tp_name */
  sizeof(PyIDECadastralFabricObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIDECadastralFabricObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIDECadastralFabricMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIDECadastralFabricGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIDECadastralFabricObject_new,                      
                                              /* tp_new */
};

// Interface ICadastralTransformationData

typedef struct PyICadastralTransformationDataObject {
    PyObject_HEAD
    ICadastralTransformationData* m_pICadastralTransformationData;
    HRESULT m_HR;
    int m_ignore_failures;
} PyICadastralTransformationDataObject;

static PyObject*
PyICadastralTransformationDataObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyICadastralTransformationDataObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ICadastralTransformationData* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ICadastralTransformationData, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ICadastralTransformationData with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyICadastralTransformationDataObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ICadastralTransformationData");
            return NULL;
        }
        self->m_pICadastralTransformationData = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ICadastralTransformationData");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ICadastralTransformationData");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ICadastralTransformationData* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ICadastralTransformationData, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ICadastralTransformationData");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyICadastralTransformationDataObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ICadastralTransformationData");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pICadastralTransformationData = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyICadastralTransformationDataObject_dealloc(PyICadastralTransformationDataObject* self)
{
    if (self->m_pICadastralTransformationData)
        self->m_pICadastralTransformationData->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyICadastralTransformationData_GetpUnk(PyICadastralTransformationDataObject* self)
{
    if (!self->m_pICadastralTransformationData)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pICadastralTransformationData->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ICadastralTransformationData to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyICadastralTransformationData_GetPointer(PyICadastralTransformationDataObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pICadastralTransformationData);
}

static PyObject*
PyICadastralTransformationData_GetIID(PyICadastralTransformationDataObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "e1f5787f-b5e4-4e6c-b84f-86d621792bb8");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyICadastralTransformationData_GetHR(PyICadastralTransformationDataObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyICadastralTransformationData_GetIgnoreFailures(PyICadastralTransformationDataObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyICadastralTransformationData_SetIgnoreFailures(PyICadastralTransformationDataObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyICadastralTransformationData_SupportsInterface(PyICadastralTransformationDataObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pICadastralTransformationData->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ICadastralTransformationDataMethod_AddData(PyICadastralTransformationDataObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IName* ipName = NULL;
    PyObject* py_Name;
    long ladjustmentLevel = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "Ol", &py_Name, &ladjustmentLevel))
      goto icadastraltransformationdata_adddata_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_Name, &IID_IName, (void**)&ipName))
        PyErr_SetString(PyExc_TypeError, "Argument Name (position 0) is not IName");
    
    if (PyErr_Occurred())
      goto icadastraltransformationdata_adddata_method_cleanup;
    
    // No setup for adjustmentLevel

    // Call method on actual COM interface
    hr = self->m_pICadastralTransformationData->AddData(ipName, ladjustmentLevel);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadastralTransformationData->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadastralTransformationData) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadastralTransformationData.AddData() returned %ld", (long)hr);
        goto icadastraltransformationdata_adddata_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Name
    // No teardown for adjustmentLevel

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icadastraltransformationdata_adddata_method_cleanup;

    icadastraltransformationdata_adddata_method_cleanup:
    self->m_HR = hr;
    if (ipName)
      ipName->Release();
    // No cleanup for adjustmentLevel
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadastralTransformationData.AddData");
    return return_tuple;
}

static PyObject*
ICadastralTransformationDataMethod_GetData(PyICadastralTransformationDataObject* self, PyObject* args)
{
    /* Param types that are unhandleable: 
       INPUT [u'IName', u'*', u'*']
       INPUT [u'long', u'*']
    */
    PyErr_SetString(PyExc_NotImplementedError, "Wrapper for ICadastralTransformationData.GetData not implemented.");
    return NULL;
}

static PyObject*
ICadastralTransformationDataMethod_get_TransDataCount(PyICadastralTransformationDataObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Count

    // Call method on actual COM interface
    hr = self->m_pICadastralTransformationData->get_TransDataCount(&lCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadastralTransformationData->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadastralTransformationData) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadastralTransformationData.get_TransDataCount() returned %ld", (long)hr);
        goto icadastraltransformationdata_get_transdatacount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Count

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lCount);
    goto icadastraltransformationdata_get_transdatacount_method_cleanup;

    icadastraltransformationdata_get_transdatacount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Count
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadastralTransformationData.get_TransDataCount");
    return return_tuple;
}

static PyObject*
ICadastralTransformationDataMethod_Clear(PyICadastralTransformationDataObject* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pICadastralTransformationData->Clear();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadastralTransformationData->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadastralTransformationData) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadastralTransformationData.Clear() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}


PyMethodDef PyICadastralTransformationDataMethods[] = {
    {"supports", (PyCFunction)PyICadastralTransformationData_SupportsInterface, METH_O, ""},
    {"AddData", (PyCFunction)ICadastralTransformationDataMethod_AddData, METH_VARARGS, ""},
    {"GetData", (PyCFunction)ICadastralTransformationDataMethod_GetData, METH_VARARGS, ""},
    {"get_TransDataCount", (PyCFunction)ICadastralTransformationDataMethod_get_TransDataCount, METH_VARARGS, ""},
    {"Clear", (PyCFunction)ICadastralTransformationDataMethod_Clear, METH_NOARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyICadastralTransformationDataGetSet[] = {
  {"_pUnk", (getter)PyICadastralTransformationData_GetpUnk, NULL, "Get opaque pointer to an Unknown from ICadastralTransformationData", NULL},
  {"_pointer", (getter)PyICadastralTransformationData_GetPointer, NULL, "Get memory address for ICadastralTransformationData", NULL},
  {"_IID", (getter)PyICadastralTransformationData_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyICadastralTransformationData_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyICadastralTransformationData_GetIgnoreFailures, (setter)PyICadastralTransformationData_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyICadastralTransformationDataObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.ICadastralTransformationDataObject",                          
                                              /* tp_name */
  sizeof(PyICadastralTransformationDataObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyICadastralTransformationDataObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyICadastralTransformationDataMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyICadastralTransformationDataGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyICadastralTransformationDataObject_new,                      
                                              /* tp_new */
};

// Interface ICadastralAdjustmentVectors

typedef struct PyICadastralAdjustmentVectorsObject {
    PyObject_HEAD
    ICadastralAdjustmentVectors* m_pICadastralAdjustmentVectors;
    HRESULT m_HR;
    int m_ignore_failures;
} PyICadastralAdjustmentVectorsObject;

static PyObject*
PyICadastralAdjustmentVectorsObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyICadastralAdjustmentVectorsObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ICadastralAdjustmentVectors* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ICadastralAdjustmentVectors, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ICadastralAdjustmentVectors with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyICadastralAdjustmentVectorsObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ICadastralAdjustmentVectors");
            return NULL;
        }
        self->m_pICadastralAdjustmentVectors = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ICadastralAdjustmentVectors");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ICadastralAdjustmentVectors");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ICadastralAdjustmentVectors* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ICadastralAdjustmentVectors, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ICadastralAdjustmentVectors");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyICadastralAdjustmentVectorsObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ICadastralAdjustmentVectors");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pICadastralAdjustmentVectors = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyICadastralAdjustmentVectorsObject_dealloc(PyICadastralAdjustmentVectorsObject* self)
{
    if (self->m_pICadastralAdjustmentVectors)
        self->m_pICadastralAdjustmentVectors->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyICadastralAdjustmentVectors_GetpUnk(PyICadastralAdjustmentVectorsObject* self)
{
    if (!self->m_pICadastralAdjustmentVectors)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pICadastralAdjustmentVectors->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ICadastralAdjustmentVectors to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyICadastralAdjustmentVectors_GetPointer(PyICadastralAdjustmentVectorsObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pICadastralAdjustmentVectors);
}

static PyObject*
PyICadastralAdjustmentVectors_GetIID(PyICadastralAdjustmentVectorsObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "889a386d-4d81-4f8c-8736-5383423df188");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyICadastralAdjustmentVectors_GetHR(PyICadastralAdjustmentVectorsObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyICadastralAdjustmentVectors_GetIgnoreFailures(PyICadastralAdjustmentVectorsObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyICadastralAdjustmentVectors_SetIgnoreFailures(PyICadastralAdjustmentVectorsObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyICadastralAdjustmentVectors_SupportsInterface(PyICadastralAdjustmentVectorsObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pICadastralAdjustmentVectors->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ICadastralAdjustmentVectorsMethod_AddVector(PyICadastralAdjustmentVectorsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lPointID = 0;
    double dfromX = 0;
    double dfromY = 0;
    double dtoX = 0;
    double dtoY = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "ldddd", &lPointID, &dfromX, &dfromY, &dtoX, &dtoY))
      goto icadastraladjustmentvectors_addvector_method_cleanup;

    // Set up initial variable values as needed
    // No setup for PointID
    // No setup for fromX
    // No setup for fromY
    // No setup for toX
    // No setup for toY

    // Call method on actual COM interface
    hr = self->m_pICadastralAdjustmentVectors->AddVector(lPointID, dfromX, dfromY, dtoX, dtoY);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadastralAdjustmentVectors->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadastralAdjustmentVectors) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadastralAdjustmentVectors.AddVector() returned %ld", (long)hr);
        goto icadastraladjustmentvectors_addvector_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for PointID
    // No teardown for fromX
    // No teardown for fromY
    // No teardown for toX
    // No teardown for toY

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icadastraladjustmentvectors_addvector_method_cleanup;

    icadastraladjustmentvectors_addvector_method_cleanup:
    self->m_HR = hr;
    // No cleanup for PointID
    // No cleanup for fromX
    // No cleanup for fromY
    // No cleanup for toX
    // No cleanup for toY
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadastralAdjustmentVectors.AddVector");
    return return_tuple;
}

static PyObject*
ICadastralAdjustmentVectorsMethod_CreateNewAdjustment(PyICadastralAdjustmentVectorsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpNewAdjustmentLevel = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pNewAdjustmentLevel

    // Call method on actual COM interface
    hr = self->m_pICadastralAdjustmentVectors->CreateNewAdjustment(&lpNewAdjustmentLevel);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadastralAdjustmentVectors->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadastralAdjustmentVectors) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadastralAdjustmentVectors.CreateNewAdjustment() returned %ld", (long)hr);
        goto icadastraladjustmentvectors_createnewadjustment_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pNewAdjustmentLevel

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpNewAdjustmentLevel);
    goto icadastraladjustmentvectors_createnewadjustment_method_cleanup;

    icadastraladjustmentvectors_createnewadjustment_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pNewAdjustmentLevel
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadastralAdjustmentVectors.CreateNewAdjustment");
    return return_tuple;
}

static PyObject*
ICadastralAdjustmentVectorsMethod_ClearVectors(PyICadastralAdjustmentVectorsObject* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pICadastralAdjustmentVectors->ClearVectors();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadastralAdjustmentVectors->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadastralAdjustmentVectors) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadastralAdjustmentVectors.ClearVectors() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}


PyMethodDef PyICadastralAdjustmentVectorsMethods[] = {
    {"supports", (PyCFunction)PyICadastralAdjustmentVectors_SupportsInterface, METH_O, ""},
    {"AddVector", (PyCFunction)ICadastralAdjustmentVectorsMethod_AddVector, METH_VARARGS, ""},
    {"CreateNewAdjustment", (PyCFunction)ICadastralAdjustmentVectorsMethod_CreateNewAdjustment, METH_VARARGS, ""},
    {"ClearVectors", (PyCFunction)ICadastralAdjustmentVectorsMethod_ClearVectors, METH_NOARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyICadastralAdjustmentVectorsGetSet[] = {
  {"_pUnk", (getter)PyICadastralAdjustmentVectors_GetpUnk, NULL, "Get opaque pointer to an Unknown from ICadastralAdjustmentVectors", NULL},
  {"_pointer", (getter)PyICadastralAdjustmentVectors_GetPointer, NULL, "Get memory address for ICadastralAdjustmentVectors", NULL},
  {"_IID", (getter)PyICadastralAdjustmentVectors_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyICadastralAdjustmentVectors_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyICadastralAdjustmentVectors_GetIgnoreFailures, (setter)PyICadastralAdjustmentVectors_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyICadastralAdjustmentVectorsObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.ICadastralAdjustmentVectorsObject",                          
                                              /* tp_name */
  sizeof(PyICadastralAdjustmentVectorsObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyICadastralAdjustmentVectorsObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyICadastralAdjustmentVectorsMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyICadastralAdjustmentVectorsGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyICadastralAdjustmentVectorsObject_new,                      
                                              /* tp_new */
};

// Interface ICadastralFabricLocks

typedef struct PyICadastralFabricLocksObject {
    PyObject_HEAD
    ICadastralFabricLocks* m_pICadastralFabricLocks;
    HRESULT m_HR;
    int m_ignore_failures;
} PyICadastralFabricLocksObject;

static PyObject*
PyICadastralFabricLocksObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyICadastralFabricLocksObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ICadastralFabricLocks* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ICadastralFabricLocks, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ICadastralFabricLocks with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyICadastralFabricLocksObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ICadastralFabricLocks");
            return NULL;
        }
        self->m_pICadastralFabricLocks = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ICadastralFabricLocks");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ICadastralFabricLocks");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ICadastralFabricLocks* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ICadastralFabricLocks, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ICadastralFabricLocks");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyICadastralFabricLocksObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ICadastralFabricLocks");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pICadastralFabricLocks = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyICadastralFabricLocksObject_dealloc(PyICadastralFabricLocksObject* self)
{
    if (self->m_pICadastralFabricLocks)
        self->m_pICadastralFabricLocks->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyICadastralFabricLocks_GetpUnk(PyICadastralFabricLocksObject* self)
{
    if (!self->m_pICadastralFabricLocks)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pICadastralFabricLocks->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ICadastralFabricLocks to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyICadastralFabricLocks_GetPointer(PyICadastralFabricLocksObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pICadastralFabricLocks);
}

static PyObject*
PyICadastralFabricLocks_GetIID(PyICadastralFabricLocksObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "c8be9a26-2fd5-4d41-a70b-7e000b644c41");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyICadastralFabricLocks_GetHR(PyICadastralFabricLocksObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyICadastralFabricLocks_GetIgnoreFailures(PyICadastralFabricLocksObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyICadastralFabricLocks_SetIgnoreFailures(PyICadastralFabricLocksObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyICadastralFabricLocks_SupportsInterface(PyICadastralFabricLocksObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pICadastralFabricLocks->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ICadastralFabricLocksMethod_put_LockingJob(PyICadastralFabricLocksObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bs_arg1 = 0;
    PyObject* pyvar__arg1;
    PyObject* unicode_arg1 = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar__arg1))
      goto icadastralfabriclocks_put_lockingjob_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar__arg1))
        unicode_arg1 = PyUnicode_FromObject(pyvar__arg1);
    else if (PyUnicode_Check(pyvar__arg1))
    {
        unicode_arg1 = pyvar__arg1;
        Py_INCREF(unicode_arg1);
    }
    else if (pyvar__arg1 != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter _arg1 at index 0");
    if (unicode_arg1)
        bs_arg1 = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicode_arg1), 
                                            (UINT)PyUnicode_GET_SIZE(unicode_arg1));
    
    if (PyErr_Occurred())
      goto icadastralfabriclocks_put_lockingjob_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pICadastralFabricLocks->put_LockingJob(bs_arg1);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadastralFabricLocks->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadastralFabricLocks) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadastralFabricLocks.put_LockingJob() returned %ld", (long)hr);
        goto icadastralfabriclocks_put_lockingjob_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for _arg1

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icadastralfabriclocks_put_lockingjob_method_cleanup;

    icadastralfabriclocks_put_lockingjob_method_cleanup:
    self->m_HR = hr;
    if (bs_arg1)
        ::SysFreeString(bs_arg1);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadastralFabricLocks.put_LockingJob");
    return return_tuple;
}

static PyObject*
ICadastralFabricLocksMethod_AcquireLocks(PyICadastralFabricLocksObject* self, PyObject* args)
{
    /* Param types that are unhandleable: 
       INPUT [u'ILongArray', u'*', u'*']
       INPUT [u'ILongArray', u'*', u'*']
    */
    PyErr_SetString(PyExc_NotImplementedError, "Wrapper for ICadastralFabricLocks.AcquireLocks not implemented.");
    return NULL;
}

static PyObject*
ICadastralFabricLocksMethod_UndoLastAcquiredLocks(PyICadastralFabricLocksObject* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pICadastralFabricLocks->UndoLastAcquiredLocks();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadastralFabricLocks->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadastralFabricLocks) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadastralFabricLocks.UndoLastAcquiredLocks() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}

static PyObject*
ICadastralFabricLocksMethod_LockJob(PyICadastralFabricLocksObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_Succeed = VARIANT_FALSE;
    PyObject* pyvar_Succeed = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Succeed

    // Call method on actual COM interface
    hr = self->m_pICadastralFabricLocks->LockJob(&b_Succeed);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadastralFabricLocks->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadastralFabricLocks) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadastralFabricLocks.LockJob() returned %ld", (long)hr);
        goto icadastralfabriclocks_lockjob_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Succeed = ((b_Succeed == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto icadastralfabriclocks_lockjob_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Succeed);
    goto icadastralfabriclocks_lockjob_method_cleanup;

    icadastralfabriclocks_lockjob_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Succeed
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadastralFabricLocks.LockJob");
    return return_tuple;
}

static PyObject*
ICadastralFabricLocksMethod_ReleaseJobLock(PyICadastralFabricLocksObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_ForceRelease = VARIANT_FALSE;
    PyObject* pyvar_ForceRelease = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_ForceRelease))
      goto icadastralfabriclocks_releasejoblock_method_cleanup;

    // Set up initial variable values as needed
    b_ForceRelease = ((PyObject_IsTrue(pyvar_ForceRelease) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto icadastralfabriclocks_releasejoblock_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pICadastralFabricLocks->ReleaseJobLock(b_ForceRelease);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadastralFabricLocks->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadastralFabricLocks) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadastralFabricLocks.ReleaseJobLock() returned %ld", (long)hr);
        goto icadastralfabriclocks_releasejoblock_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ForceRelease

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icadastralfabriclocks_releasejoblock_method_cleanup;

    icadastralfabriclocks_releasejoblock_method_cleanup:
    self->m_HR = hr;
    // No cleanup for ForceRelease
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadastralFabricLocks.ReleaseJobLock");
    return return_tuple;
}

static PyObject*
ICadastralFabricLocksMethod_ValidateJobLock(PyICadastralFabricLocksObject* self, PyObject* args)
{
    /* Param types that are unhandleable: 
       INPUT [u'VARIANT_BOOL', u'*']
       INPUT [u'BSTR', u'*']
       INPUT [u'long', u'*']
    */
    PyErr_SetString(PyExc_NotImplementedError, "Wrapper for ICadastralFabricLocks.ValidateJobLock not implemented.");
    return NULL;
}


PyMethodDef PyICadastralFabricLocksMethods[] = {
    {"supports", (PyCFunction)PyICadastralFabricLocks_SupportsInterface, METH_O, ""},
    {"put_LockingJob", (PyCFunction)ICadastralFabricLocksMethod_put_LockingJob, METH_VARARGS, ""},
    {"AcquireLocks", (PyCFunction)ICadastralFabricLocksMethod_AcquireLocks, METH_VARARGS, ""},
    {"UndoLastAcquiredLocks", (PyCFunction)ICadastralFabricLocksMethod_UndoLastAcquiredLocks, METH_NOARGS, ""},
    {"LockJob", (PyCFunction)ICadastralFabricLocksMethod_LockJob, METH_VARARGS, ""},
    {"ReleaseJobLock", (PyCFunction)ICadastralFabricLocksMethod_ReleaseJobLock, METH_VARARGS, ""},
    {"ValidateJobLock", (PyCFunction)ICadastralFabricLocksMethod_ValidateJobLock, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyICadastralFabricLocksGetSet[] = {
  {"_pUnk", (getter)PyICadastralFabricLocks_GetpUnk, NULL, "Get opaque pointer to an Unknown from ICadastralFabricLocks", NULL},
  {"_pointer", (getter)PyICadastralFabricLocks_GetPointer, NULL, "Get memory address for ICadastralFabricLocks", NULL},
  {"_IID", (getter)PyICadastralFabricLocks_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyICadastralFabricLocks_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyICadastralFabricLocks_GetIgnoreFailures, (setter)PyICadastralFabricLocks_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyICadastralFabricLocksObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.ICadastralFabricLocksObject",                          
                                              /* tp_name */
  sizeof(PyICadastralFabricLocksObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyICadastralFabricLocksObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyICadastralFabricLocksMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyICadastralFabricLocksGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyICadastralFabricLocksObject_new,                      
                                              /* tp_new */
};

// Interface ICadastralFabricLocks2

typedef struct PyICadastralFabricLocks2Object {
    PyObject_HEAD
    ICadastralFabricLocks2* m_pICadastralFabricLocks2;
    HRESULT m_HR;
    int m_ignore_failures;
} PyICadastralFabricLocks2Object;

static PyObject*
PyICadastralFabricLocks2Object_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyICadastralFabricLocks2Object* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ICadastralFabricLocks2* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ICadastralFabricLocks2, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ICadastralFabricLocks2 with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyICadastralFabricLocks2Object *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ICadastralFabricLocks2");
            return NULL;
        }
        self->m_pICadastralFabricLocks2 = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ICadastralFabricLocks2");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ICadastralFabricLocks2");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ICadastralFabricLocks2* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ICadastralFabricLocks2, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ICadastralFabricLocks2");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyICadastralFabricLocks2Object *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ICadastralFabricLocks2");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pICadastralFabricLocks2 = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyICadastralFabricLocks2Object_dealloc(PyICadastralFabricLocks2Object* self)
{
    if (self->m_pICadastralFabricLocks2)
        self->m_pICadastralFabricLocks2->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyICadastralFabricLocks2_GetpUnk(PyICadastralFabricLocks2Object* self)
{
    if (!self->m_pICadastralFabricLocks2)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pICadastralFabricLocks2->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ICadastralFabricLocks2 to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyICadastralFabricLocks2_GetPointer(PyICadastralFabricLocks2Object* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pICadastralFabricLocks2);
}

static PyObject*
PyICadastralFabricLocks2_GetIID(PyICadastralFabricLocks2Object* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "882005e1-945f-46eb-80c8-2b7a3b0afd4a");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyICadastralFabricLocks2_GetHR(PyICadastralFabricLocks2Object* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyICadastralFabricLocks2_GetIgnoreFailures(PyICadastralFabricLocks2Object* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyICadastralFabricLocks2_SetIgnoreFailures(PyICadastralFabricLocks2Object* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyICadastralFabricLocks2_SupportsInterface(PyICadastralFabricLocks2Object* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pICadastralFabricLocks2->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ICadastralFabricLocks2Method_AcquireLocks(PyICadastralFabricLocks2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ILongArray* ippLocks = NULL;
    PyObject* py_pLocks;
    VARIANT_BOOL b_TakeSoftLocks = VARIANT_FALSE;
    PyObject* pyvar_TakeSoftLocks = NULL;
    ILongArray* ippLocksInConflict = NULL;
    PyObject* py_pLocksInConflict;
    ILongArray* ippSoftLocksInConflict = NULL;
    PyObject* py_pSoftLocksInConflict;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOOO", &py_pLocks, &pyvar_TakeSoftLocks, &py_pLocksInConflict, &py_pSoftLocksInConflict))
      goto icadastralfabriclocks2_acquirelocks_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pLocks, &IID_ILongArray, (void**)&ippLocks))
        PyErr_SetString(PyExc_TypeError, "Argument pLocks (position 0) is not ILongArray");
    
    if (PyErr_Occurred())
      goto icadastralfabriclocks2_acquirelocks_method_cleanup;
    
    b_TakeSoftLocks = ((PyObject_IsTrue(pyvar_TakeSoftLocks) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto icadastralfabriclocks2_acquirelocks_method_cleanup;
    
    if (!IFaceFromPyObject(py_pLocksInConflict, &IID_ILongArray, (void**)&ippLocksInConflict))
        PyErr_SetString(PyExc_TypeError, "Argument pLocksInConflict (position 2) is not ILongArray");
    
    if (PyErr_Occurred())
      goto icadastralfabriclocks2_acquirelocks_method_cleanup;
    
    if (!IFaceFromPyObject(py_pSoftLocksInConflict, &IID_ILongArray, (void**)&ippSoftLocksInConflict))
        PyErr_SetString(PyExc_TypeError, "Argument pSoftLocksInConflict (position 3) is not ILongArray");
    
    if (PyErr_Occurred())
      goto icadastralfabriclocks2_acquirelocks_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pICadastralFabricLocks2->AcquireLocks(ippLocks, b_TakeSoftLocks, ippLocksInConflict, ippSoftLocksInConflict);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadastralFabricLocks2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadastralFabricLocks2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadastralFabricLocks2.AcquireLocks() returned %ld", (long)hr);
        goto icadastralfabriclocks2_acquirelocks_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pLocks
    // No teardown for TakeSoftLocks
    // No teardown for pLocksInConflict
    // No teardown for pSoftLocksInConflict

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icadastralfabriclocks2_acquirelocks_method_cleanup;

    icadastralfabriclocks2_acquirelocks_method_cleanup:
    self->m_HR = hr;
    if (ippLocks)
      ippLocks->Release();
    // No cleanup for TakeSoftLocks
    if (ippLocksInConflict)
      ippLocksInConflict->Release();
    if (ippSoftLocksInConflict)
      ippSoftLocksInConflict->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadastralFabricLocks2.AcquireLocks");
    return return_tuple;
}


PyMethodDef PyICadastralFabricLocks2Methods[] = {
    {"supports", (PyCFunction)PyICadastralFabricLocks2_SupportsInterface, METH_O, ""},
    {"AcquireLocks", (PyCFunction)ICadastralFabricLocks2Method_AcquireLocks, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyICadastralFabricLocks2GetSet[] = {
  {"_pUnk", (getter)PyICadastralFabricLocks2_GetpUnk, NULL, "Get opaque pointer to an Unknown from ICadastralFabricLocks2", NULL},
  {"_pointer", (getter)PyICadastralFabricLocks2_GetPointer, NULL, "Get memory address for ICadastralFabricLocks2", NULL},
  {"_IID", (getter)PyICadastralFabricLocks2_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyICadastralFabricLocks2_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyICadastralFabricLocks2_GetIgnoreFailures, (setter)PyICadastralFabricLocks2_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyICadastralFabricLocks2Object_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.ICadastralFabricLocks2Object",                          
                                              /* tp_name */
  sizeof(PyICadastralFabricLocks2Object),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyICadastralFabricLocks2Object_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyICadastralFabricLocks2Methods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyICadastralFabricLocks2GetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyICadastralFabricLocks2Object_new,                      
                                              /* tp_new */
};

// Interface ICadastralFabricSchemaEdit

typedef struct PyICadastralFabricSchemaEditObject {
    PyObject_HEAD
    ICadastralFabricSchemaEdit* m_pICadastralFabricSchemaEdit;
    HRESULT m_HR;
    int m_ignore_failures;
} PyICadastralFabricSchemaEditObject;

static PyObject*
PyICadastralFabricSchemaEditObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyICadastralFabricSchemaEditObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ICadastralFabricSchemaEdit* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ICadastralFabricSchemaEdit, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ICadastralFabricSchemaEdit with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyICadastralFabricSchemaEditObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ICadastralFabricSchemaEdit");
            return NULL;
        }
        self->m_pICadastralFabricSchemaEdit = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ICadastralFabricSchemaEdit");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ICadastralFabricSchemaEdit");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ICadastralFabricSchemaEdit* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ICadastralFabricSchemaEdit, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ICadastralFabricSchemaEdit");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyICadastralFabricSchemaEditObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ICadastralFabricSchemaEdit");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pICadastralFabricSchemaEdit = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyICadastralFabricSchemaEditObject_dealloc(PyICadastralFabricSchemaEditObject* self)
{
    if (self->m_pICadastralFabricSchemaEdit)
        self->m_pICadastralFabricSchemaEdit->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyICadastralFabricSchemaEdit_GetpUnk(PyICadastralFabricSchemaEditObject* self)
{
    if (!self->m_pICadastralFabricSchemaEdit)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pICadastralFabricSchemaEdit->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ICadastralFabricSchemaEdit to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyICadastralFabricSchemaEdit_GetPointer(PyICadastralFabricSchemaEditObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pICadastralFabricSchemaEdit);
}

static PyObject*
PyICadastralFabricSchemaEdit_GetIID(PyICadastralFabricSchemaEditObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "8a932661-07b3-4d2e-b02c-ce6092a1b4af");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyICadastralFabricSchemaEdit_GetHR(PyICadastralFabricSchemaEditObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyICadastralFabricSchemaEdit_GetIgnoreFailures(PyICadastralFabricSchemaEditObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyICadastralFabricSchemaEdit_SetIgnoreFailures(PyICadastralFabricSchemaEditObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyICadastralFabricSchemaEdit_SupportsInterface(PyICadastralFabricSchemaEditObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pICadastralFabricSchemaEdit->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ICadastralFabricSchemaEditMethod_UpdateSchema(PyICadastralFabricSchemaEditObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IDECadastralFabric* ipDataElement = NULL;
    PyObject* py_DataElement;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_DataElement))
      goto icadastralfabricschemaedit_updateschema_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_DataElement, &IID_IDECadastralFabric, (void**)&ipDataElement))
        PyErr_SetString(PyExc_TypeError, "Argument DataElement (position 0) is not IDECadastralFabric");
    
    if (PyErr_Occurred())
      goto icadastralfabricschemaedit_updateschema_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pICadastralFabricSchemaEdit->UpdateSchema(ipDataElement);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadastralFabricSchemaEdit->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadastralFabricSchemaEdit) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadastralFabricSchemaEdit.UpdateSchema() returned %ld", (long)hr);
        goto icadastralfabricschemaedit_updateschema_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for DataElement

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icadastralfabricschemaedit_updateschema_method_cleanup;

    icadastralfabricschemaedit_updateschema_method_cleanup:
    self->m_HR = hr;
    if (ipDataElement)
      ipDataElement->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadastralFabricSchemaEdit.UpdateSchema");
    return return_tuple;
}


PyMethodDef PyICadastralFabricSchemaEditMethods[] = {
    {"supports", (PyCFunction)PyICadastralFabricSchemaEdit_SupportsInterface, METH_O, ""},
    {"UpdateSchema", (PyCFunction)ICadastralFabricSchemaEditMethod_UpdateSchema, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyICadastralFabricSchemaEditGetSet[] = {
  {"_pUnk", (getter)PyICadastralFabricSchemaEdit_GetpUnk, NULL, "Get opaque pointer to an Unknown from ICadastralFabricSchemaEdit", NULL},
  {"_pointer", (getter)PyICadastralFabricSchemaEdit_GetPointer, NULL, "Get memory address for ICadastralFabricSchemaEdit", NULL},
  {"_IID", (getter)PyICadastralFabricSchemaEdit_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyICadastralFabricSchemaEdit_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyICadastralFabricSchemaEdit_GetIgnoreFailures, (setter)PyICadastralFabricSchemaEdit_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyICadastralFabricSchemaEditObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.ICadastralFabricSchemaEditObject",                          
                                              /* tp_name */
  sizeof(PyICadastralFabricSchemaEditObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyICadastralFabricSchemaEditObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyICadastralFabricSchemaEditMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyICadastralFabricSchemaEditGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyICadastralFabricSchemaEditObject_new,                      
                                              /* tp_new */
};

// Interface ICadastralFabricSchemaEdit2

typedef struct PyICadastralFabricSchemaEdit2Object {
    PyObject_HEAD
    ICadastralFabricSchemaEdit2* m_pICadastralFabricSchemaEdit2;
    HRESULT m_HR;
    int m_ignore_failures;
} PyICadastralFabricSchemaEdit2Object;

static PyObject*
PyICadastralFabricSchemaEdit2Object_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyICadastralFabricSchemaEdit2Object* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ICadastralFabricSchemaEdit2* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ICadastralFabricSchemaEdit2, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ICadastralFabricSchemaEdit2 with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyICadastralFabricSchemaEdit2Object *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ICadastralFabricSchemaEdit2");
            return NULL;
        }
        self->m_pICadastralFabricSchemaEdit2 = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ICadastralFabricSchemaEdit2");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ICadastralFabricSchemaEdit2");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ICadastralFabricSchemaEdit2* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ICadastralFabricSchemaEdit2, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ICadastralFabricSchemaEdit2");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyICadastralFabricSchemaEdit2Object *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ICadastralFabricSchemaEdit2");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pICadastralFabricSchemaEdit2 = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyICadastralFabricSchemaEdit2Object_dealloc(PyICadastralFabricSchemaEdit2Object* self)
{
    if (self->m_pICadastralFabricSchemaEdit2)
        self->m_pICadastralFabricSchemaEdit2->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyICadastralFabricSchemaEdit2_GetpUnk(PyICadastralFabricSchemaEdit2Object* self)
{
    if (!self->m_pICadastralFabricSchemaEdit2)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pICadastralFabricSchemaEdit2->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ICadastralFabricSchemaEdit2 to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyICadastralFabricSchemaEdit2_GetPointer(PyICadastralFabricSchemaEdit2Object* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pICadastralFabricSchemaEdit2);
}

static PyObject*
PyICadastralFabricSchemaEdit2_GetIID(PyICadastralFabricSchemaEdit2Object* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "e2930c0e-dd54-4f12-8960-c44e6c08c395");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyICadastralFabricSchemaEdit2_GetHR(PyICadastralFabricSchemaEdit2Object* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyICadastralFabricSchemaEdit2_GetIgnoreFailures(PyICadastralFabricSchemaEdit2Object* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyICadastralFabricSchemaEdit2_SetIgnoreFailures(PyICadastralFabricSchemaEdit2Object* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyICadastralFabricSchemaEdit2_SupportsInterface(PyICadastralFabricSchemaEdit2Object* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pICadastralFabricSchemaEdit2->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ICadastralFabricSchemaEdit2Method_ReleaseReadOnlyFields(PyICadastralFabricSchemaEdit2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ITable* ippTable = NULL;
    PyObject* py_pTable;
    esriCadastralFabricTable eTable;

    // Unpack values
    if (!PyArg_ParseTuple(args, "Oi", &py_pTable, (int *)&eTable))
      goto icadastralfabricschemaedit2_releasereadonlyfields_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pTable, &IID_ITable, (void**)&ippTable))
        PyErr_SetString(PyExc_TypeError, "Argument pTable (position 0) is not ITable");
    
    if (PyErr_Occurred())
      goto icadastralfabricschemaedit2_releasereadonlyfields_method_cleanup;
    
    // No setup for Table

    // Call method on actual COM interface
    hr = self->m_pICadastralFabricSchemaEdit2->ReleaseReadOnlyFields(ippTable, eTable);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadastralFabricSchemaEdit2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadastralFabricSchemaEdit2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadastralFabricSchemaEdit2.ReleaseReadOnlyFields() returned %ld", (long)hr);
        goto icadastralfabricschemaedit2_releasereadonlyfields_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pTable
    // No teardown for Table

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icadastralfabricschemaedit2_releasereadonlyfields_method_cleanup;

    icadastralfabricschemaedit2_releasereadonlyfields_method_cleanup:
    self->m_HR = hr;
    if (ippTable)
      ippTable->Release();
    // No cleanup for Table
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadastralFabricSchemaEdit2.ReleaseReadOnlyFields");
    return return_tuple;
}

static PyObject*
ICadastralFabricSchemaEdit2Method_ResetReadOnlyFields(PyICadastralFabricSchemaEdit2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriCadastralFabricTable eTable;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&eTable))
      goto icadastralfabricschemaedit2_resetreadonlyfields_method_cleanup;

    // Set up initial variable values as needed
    // No setup for Table

    // Call method on actual COM interface
    hr = self->m_pICadastralFabricSchemaEdit2->ResetReadOnlyFields(eTable);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadastralFabricSchemaEdit2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadastralFabricSchemaEdit2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadastralFabricSchemaEdit2.ResetReadOnlyFields() returned %ld", (long)hr);
        goto icadastralfabricschemaedit2_resetreadonlyfields_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Table

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icadastralfabricschemaedit2_resetreadonlyfields_method_cleanup;

    icadastralfabricschemaedit2_resetreadonlyfields_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Table
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadastralFabricSchemaEdit2.ResetReadOnlyFields");
    return return_tuple;
}


PyMethodDef PyICadastralFabricSchemaEdit2Methods[] = {
    {"supports", (PyCFunction)PyICadastralFabricSchemaEdit2_SupportsInterface, METH_O, ""},
    {"ReleaseReadOnlyFields", (PyCFunction)ICadastralFabricSchemaEdit2Method_ReleaseReadOnlyFields, METH_VARARGS, ""},
    {"ResetReadOnlyFields", (PyCFunction)ICadastralFabricSchemaEdit2Method_ResetReadOnlyFields, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyICadastralFabricSchemaEdit2GetSet[] = {
  {"_pUnk", (getter)PyICadastralFabricSchemaEdit2_GetpUnk, NULL, "Get opaque pointer to an Unknown from ICadastralFabricSchemaEdit2", NULL},
  {"_pointer", (getter)PyICadastralFabricSchemaEdit2_GetPointer, NULL, "Get memory address for ICadastralFabricSchemaEdit2", NULL},
  {"_IID", (getter)PyICadastralFabricSchemaEdit2_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyICadastralFabricSchemaEdit2_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyICadastralFabricSchemaEdit2_GetIgnoreFailures, (setter)PyICadastralFabricSchemaEdit2_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyICadastralFabricSchemaEdit2Object_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.ICadastralFabricSchemaEdit2Object",                          
                                              /* tp_name */
  sizeof(PyICadastralFabricSchemaEdit2Object),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyICadastralFabricSchemaEdit2Object_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyICadastralFabricSchemaEdit2Methods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyICadastralFabricSchemaEdit2GetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyICadastralFabricSchemaEdit2Object_new,                      
                                              /* tp_new */
};

// Interface ICadastralTableFieldEdits

typedef struct PyICadastralTableFieldEditsObject {
    PyObject_HEAD
    ICadastralTableFieldEdits* m_pICadastralTableFieldEdits;
    HRESULT m_HR;
    int m_ignore_failures;
} PyICadastralTableFieldEditsObject;

static PyObject*
PyICadastralTableFieldEditsObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyICadastralTableFieldEditsObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ICadastralTableFieldEdits* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ICadastralTableFieldEdits, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ICadastralTableFieldEdits with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyICadastralTableFieldEditsObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ICadastralTableFieldEdits");
            return NULL;
        }
        self->m_pICadastralTableFieldEdits = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ICadastralTableFieldEdits");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ICadastralTableFieldEdits");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ICadastralTableFieldEdits* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ICadastralTableFieldEdits, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ICadastralTableFieldEdits");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyICadastralTableFieldEditsObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ICadastralTableFieldEdits");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pICadastralTableFieldEdits = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyICadastralTableFieldEditsObject_dealloc(PyICadastralTableFieldEditsObject* self)
{
    if (self->m_pICadastralTableFieldEdits)
        self->m_pICadastralTableFieldEdits->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyICadastralTableFieldEdits_GetpUnk(PyICadastralTableFieldEditsObject* self)
{
    if (!self->m_pICadastralTableFieldEdits)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pICadastralTableFieldEdits->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ICadastralTableFieldEdits to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyICadastralTableFieldEdits_GetPointer(PyICadastralTableFieldEditsObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pICadastralTableFieldEdits);
}

static PyObject*
PyICadastralTableFieldEdits_GetIID(PyICadastralTableFieldEditsObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "3327d58a-2994-4fd9-a2fb-1f3a993f27ae");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyICadastralTableFieldEdits_GetHR(PyICadastralTableFieldEditsObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyICadastralTableFieldEdits_GetIgnoreFailures(PyICadastralTableFieldEditsObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyICadastralTableFieldEdits_SetIgnoreFailures(PyICadastralTableFieldEditsObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyICadastralTableFieldEdits_SupportsInterface(PyICadastralTableFieldEditsObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pICadastralTableFieldEdits->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ICadastralTableFieldEditsMethod_get_TableName(PyICadastralTableFieldEditsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName;
    PyObject* pyvar_Name = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Name

    // Call method on actual COM interface
    hr = self->m_pICadastralTableFieldEdits->get_TableName(&bsName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadastralTableFieldEdits->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadastralTableFieldEdits) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadastralTableFieldEdits.get_TableName() returned %ld", (long)hr);
        goto icadastraltablefieldedits_get_tablename_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Name = PyUnicode_FromWideChar(bsName,::SysStringLen(bsName));
    ::SysFreeString(bsName);
    
    if (PyErr_Occurred())
      goto icadastraltablefieldedits_get_tablename_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Name);
    goto icadastraltablefieldedits_get_tablename_method_cleanup;

    icadastraltablefieldedits_get_tablename_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Name != Py_None)
        Py_XDECREF(pyvar_Name);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadastralTableFieldEdits.get_TableName");
    return return_tuple;
}

static PyObject*
ICadastralTableFieldEditsMethod_put_CadastralTable(PyICadastralTableFieldEditsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriCadastralFabricTable eTable;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&eTable))
      goto icadastraltablefieldedits_put_cadastraltable_method_cleanup;

    // Set up initial variable values as needed
    // No setup for Table

    // Call method on actual COM interface
    hr = self->m_pICadastralTableFieldEdits->put_CadastralTable(eTable);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadastralTableFieldEdits->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadastralTableFieldEdits) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadastralTableFieldEdits.put_CadastralTable() returned %ld", (long)hr);
        goto icadastraltablefieldedits_put_cadastraltable_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Table

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icadastraltablefieldedits_put_cadastraltable_method_cleanup;

    icadastraltablefieldedits_put_cadastraltable_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Table
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadastralTableFieldEdits.put_CadastralTable");
    return return_tuple;
}

static PyObject*
ICadastralTableFieldEditsMethod_get_CadastralTable(PyICadastralTableFieldEditsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriCadastralFabricTable eTable;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Table

    // Call method on actual COM interface
    hr = self->m_pICadastralTableFieldEdits->get_CadastralTable(&eTable);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadastralTableFieldEdits->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadastralTableFieldEdits) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadastralTableFieldEdits.get_CadastralTable() returned %ld", (long)hr);
        goto icadastraltablefieldedits_get_cadastraltable_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Table

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)eTable);
    goto icadastraltablefieldedits_get_cadastraltable_method_cleanup;

    icadastraltablefieldedits_get_cadastraltable_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Table
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadastralTableFieldEdits.get_CadastralTable");
    return return_tuple;
}

static PyObject*
ICadastralTableFieldEditsMethod_get_ExtendedAttributeFields(PyICadastralTableFieldEditsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IFields* ipFields = NULL;
    PyObject* py_Fields = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Fields

    // Call method on actual COM interface
    hr = self->m_pICadastralTableFieldEdits->get_ExtendedAttributeFields(&ipFields);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadastralTableFieldEdits->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadastralTableFieldEdits) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadastralTableFieldEdits.get_ExtendedAttributeFields() returned %ld", (long)hr);
        goto icadastraltablefieldedits_get_extendedattributefields_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_Fields);
    if (ipFields)
    {
        IUnknown* pUnk = NULL;
        ipFields->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_Fields = IUnknownToPythonIIDObject(pUnk, &IID_IFields);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_Fields)
    {
        if (py_Fields)
           Py_DECREF(py_Fields);
        py_Fields = Py_None;
        Py_INCREF(py_Fields);
    }
    if (PyErr_Occurred())
      goto icadastraltablefieldedits_get_extendedattributefields_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_Fields);
    goto icadastraltablefieldedits_get_extendedattributefields_method_cleanup;

    icadastraltablefieldedits_get_extendedattributefields_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_Fields);
    if (ipFields)
      ipFields->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadastralTableFieldEdits.get_ExtendedAttributeFields");
    return return_tuple;
}

static PyObject*
ICadastralTableFieldEditsMethod_put_ExtendedAttributeFields(PyICadastralTableFieldEditsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IFields* ipFields = NULL;
    PyObject* py_Fields;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_Fields))
      goto icadastraltablefieldedits_put_extendedattributefields_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_Fields, &IID_IFields, (void**)&ipFields))
        PyErr_SetString(PyExc_TypeError, "Argument Fields (position 0) is not IFields");
    
    if (PyErr_Occurred())
      goto icadastraltablefieldedits_put_extendedattributefields_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pICadastralTableFieldEdits->put_ExtendedAttributeFields(ipFields);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadastralTableFieldEdits->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadastralTableFieldEdits) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadastralTableFieldEdits.put_ExtendedAttributeFields() returned %ld", (long)hr);
        goto icadastraltablefieldedits_put_extendedattributefields_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Fields

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icadastraltablefieldedits_put_extendedattributefields_method_cleanup;

    icadastraltablefieldedits_put_extendedattributefields_method_cleanup:
    self->m_HR = hr;
    if (ipFields)
      ipFields->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadastralTableFieldEdits.put_ExtendedAttributeFields");
    return return_tuple;
}


PyMethodDef PyICadastralTableFieldEditsMethods[] = {
    {"supports", (PyCFunction)PyICadastralTableFieldEdits_SupportsInterface, METH_O, ""},
    {"get_TableName", (PyCFunction)ICadastralTableFieldEditsMethod_get_TableName, METH_VARARGS, ""},
    {"put_CadastralTable", (PyCFunction)ICadastralTableFieldEditsMethod_put_CadastralTable, METH_VARARGS, ""},
    {"get_CadastralTable", (PyCFunction)ICadastralTableFieldEditsMethod_get_CadastralTable, METH_VARARGS, ""},
    {"get_ExtendedAttributeFields", (PyCFunction)ICadastralTableFieldEditsMethod_get_ExtendedAttributeFields, METH_VARARGS, ""},
    {"put_ExtendedAttributeFields", (PyCFunction)ICadastralTableFieldEditsMethod_put_ExtendedAttributeFields, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyICadastralTableFieldEditsGetSet[] = {
  {"_pUnk", (getter)PyICadastralTableFieldEdits_GetpUnk, NULL, "Get opaque pointer to an Unknown from ICadastralTableFieldEdits", NULL},
  {"_pointer", (getter)PyICadastralTableFieldEdits_GetPointer, NULL, "Get memory address for ICadastralTableFieldEdits", NULL},
  {"_IID", (getter)PyICadastralTableFieldEdits_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyICadastralTableFieldEdits_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyICadastralTableFieldEdits_GetIgnoreFailures, (setter)PyICadastralTableFieldEdits_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyICadastralTableFieldEditsObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.ICadastralTableFieldEditsObject",                          
                                              /* tp_name */
  sizeof(PyICadastralTableFieldEditsObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyICadastralTableFieldEditsObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyICadastralTableFieldEditsMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyICadastralTableFieldEditsGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyICadastralTableFieldEditsObject_new,                      
                                              /* tp_new */
};

// Interface IDECadastralFabric2

typedef struct PyIDECadastralFabric2Object {
    PyObject_HEAD
    IDECadastralFabric2* m_pIDECadastralFabric2;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIDECadastralFabric2Object;

static PyObject*
PyIDECadastralFabric2Object_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIDECadastralFabric2Object* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IDECadastralFabric2* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IDECadastralFabric2, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IDECadastralFabric2 with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIDECadastralFabric2Object *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IDECadastralFabric2");
            return NULL;
        }
        self->m_pIDECadastralFabric2 = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IDECadastralFabric2");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IDECadastralFabric2");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IDECadastralFabric2* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IDECadastralFabric2, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IDECadastralFabric2");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIDECadastralFabric2Object *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IDECadastralFabric2");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIDECadastralFabric2 = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIDECadastralFabric2Object_dealloc(PyIDECadastralFabric2Object* self)
{
    if (self->m_pIDECadastralFabric2)
        self->m_pIDECadastralFabric2->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIDECadastralFabric2_GetpUnk(PyIDECadastralFabric2Object* self)
{
    if (!self->m_pIDECadastralFabric2)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIDECadastralFabric2->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IDECadastralFabric2 to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIDECadastralFabric2_GetPointer(PyIDECadastralFabric2Object* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIDECadastralFabric2);
}

static PyObject*
PyIDECadastralFabric2_GetIID(PyIDECadastralFabric2Object* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "5ba64979-96c6-4e16-baa1-aff9e81ccbd3");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIDECadastralFabric2_GetHR(PyIDECadastralFabric2Object* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIDECadastralFabric2_GetIgnoreFailures(PyIDECadastralFabric2Object* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIDECadastralFabric2_SetIgnoreFailures(PyIDECadastralFabric2Object* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIDECadastralFabric2_SupportsInterface(PyIDECadastralFabric2Object* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIDECadastralFabric2->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IDECadastralFabric2Method_get_CompiledAccuracyCategory(PyIDECadastralFabric2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long ldefaultAccuracy = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for defaultAccuracy

    // Call method on actual COM interface
    hr = self->m_pIDECadastralFabric2->get_CompiledAccuracyCategory(&ldefaultAccuracy);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDECadastralFabric2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDECadastralFabric2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDECadastralFabric2.get_CompiledAccuracyCategory() returned %ld", (long)hr);
        goto idecadastralfabric2_get_compiledaccuracycategory_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for defaultAccuracy

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            ldefaultAccuracy);
    goto idecadastralfabric2_get_compiledaccuracycategory_method_cleanup;

    idecadastralfabric2_get_compiledaccuracycategory_method_cleanup:
    self->m_HR = hr;
    // No cleanup for defaultAccuracy
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDECadastralFabric2.get_CompiledAccuracyCategory");
    return return_tuple;
}

static PyObject*
IDECadastralFabric2Method_put_CompiledAccuracyCategory(PyIDECadastralFabric2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long ldefaultAccuracy = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &ldefaultAccuracy))
      goto idecadastralfabric2_put_compiledaccuracycategory_method_cleanup;

    // Set up initial variable values as needed
    // No setup for defaultAccuracy

    // Call method on actual COM interface
    hr = self->m_pIDECadastralFabric2->put_CompiledAccuracyCategory(ldefaultAccuracy);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDECadastralFabric2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDECadastralFabric2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDECadastralFabric2.put_CompiledAccuracyCategory() returned %ld", (long)hr);
        goto idecadastralfabric2_put_compiledaccuracycategory_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for defaultAccuracy

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idecadastralfabric2_put_compiledaccuracycategory_method_cleanup;

    idecadastralfabric2_put_compiledaccuracycategory_method_cleanup:
    self->m_HR = hr;
    // No cleanup for defaultAccuracy
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDECadastralFabric2.put_CompiledAccuracyCategory");
    return return_tuple;
}

static PyObject*
IDECadastralFabric2Method_get_BufferDistanceForAdjustment(PyIDECadastralFabric2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double ddistance = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for distance

    // Call method on actual COM interface
    hr = self->m_pIDECadastralFabric2->get_BufferDistanceForAdjustment(&ddistance);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDECadastralFabric2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDECadastralFabric2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDECadastralFabric2.get_BufferDistanceForAdjustment() returned %ld", (long)hr);
        goto idecadastralfabric2_get_bufferdistanceforadjustment_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for distance

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            ddistance);
    goto idecadastralfabric2_get_bufferdistanceforadjustment_method_cleanup;

    idecadastralfabric2_get_bufferdistanceforadjustment_method_cleanup:
    self->m_HR = hr;
    // No cleanup for distance
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDECadastralFabric2.get_BufferDistanceForAdjustment");
    return return_tuple;
}

static PyObject*
IDECadastralFabric2Method_put_BufferDistanceForAdjustment(PyIDECadastralFabric2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double ddistance = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "d", &ddistance))
      goto idecadastralfabric2_put_bufferdistanceforadjustment_method_cleanup;

    // Set up initial variable values as needed
    // No setup for distance

    // Call method on actual COM interface
    hr = self->m_pIDECadastralFabric2->put_BufferDistanceForAdjustment(ddistance);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDECadastralFabric2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDECadastralFabric2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDECadastralFabric2.put_BufferDistanceForAdjustment() returned %ld", (long)hr);
        goto idecadastralfabric2_put_bufferdistanceforadjustment_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for distance

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idecadastralfabric2_put_bufferdistanceforadjustment_method_cleanup;

    idecadastralfabric2_put_bufferdistanceforadjustment_method_cleanup:
    self->m_HR = hr;
    // No cleanup for distance
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDECadastralFabric2.put_BufferDistanceForAdjustment");
    return return_tuple;
}

static PyObject*
IDECadastralFabric2Method_get_Type(PyIDECadastralFabric2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriCadastralFabricType eType;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Type

    // Call method on actual COM interface
    hr = self->m_pIDECadastralFabric2->get_Type(&eType);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDECadastralFabric2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDECadastralFabric2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDECadastralFabric2.get_Type() returned %ld", (long)hr);
        goto idecadastralfabric2_get_type_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Type

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)eType);
    goto idecadastralfabric2_get_type_method_cleanup;

    idecadastralfabric2_get_type_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Type
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDECadastralFabric2.get_Type");
    return return_tuple;
}

static PyObject*
IDECadastralFabric2Method_put_Type(PyIDECadastralFabric2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriCadastralFabricType eType;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&eType))
      goto idecadastralfabric2_put_type_method_cleanup;

    // Set up initial variable values as needed
    // No setup for Type

    // Call method on actual COM interface
    hr = self->m_pIDECadastralFabric2->put_Type(eType);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDECadastralFabric2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDECadastralFabric2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDECadastralFabric2.put_Type() returned %ld", (long)hr);
        goto idecadastralfabric2_put_type_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Type

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idecadastralfabric2_put_type_method_cleanup;

    idecadastralfabric2_put_type_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Type
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDECadastralFabric2.put_Type");
    return return_tuple;
}

static PyObject*
IDECadastralFabric2Method_get_SurrogateVersion(PyIDECadastralFabric2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bssurrogate;
    PyObject* pyvar_surrogate = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for surrogate

    // Call method on actual COM interface
    hr = self->m_pIDECadastralFabric2->get_SurrogateVersion(&bssurrogate);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDECadastralFabric2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDECadastralFabric2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDECadastralFabric2.get_SurrogateVersion() returned %ld", (long)hr);
        goto idecadastralfabric2_get_surrogateversion_method_cleanup;
    }

    // Set up return values as needed
    pyvar_surrogate = PyUnicode_FromWideChar(bssurrogate,::SysStringLen(bssurrogate));
    ::SysFreeString(bssurrogate);
    
    if (PyErr_Occurred())
      goto idecadastralfabric2_get_surrogateversion_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_surrogate);
    goto idecadastralfabric2_get_surrogateversion_method_cleanup;

    idecadastralfabric2_get_surrogateversion_method_cleanup:
    self->m_HR = hr;
    if (pyvar_surrogate != Py_None)
        Py_XDECREF(pyvar_surrogate);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDECadastralFabric2.get_SurrogateVersion");
    return return_tuple;
}

static PyObject*
IDECadastralFabric2Method_put_SurrogateVersion(PyIDECadastralFabric2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bssurrogate = 0;
    PyObject* pyvar_surrogate;
    PyObject* unicodesurrogate = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_surrogate))
      goto idecadastralfabric2_put_surrogateversion_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_surrogate))
        unicodesurrogate = PyUnicode_FromObject(pyvar_surrogate);
    else if (PyUnicode_Check(pyvar_surrogate))
    {
        unicodesurrogate = pyvar_surrogate;
        Py_INCREF(unicodesurrogate);
    }
    else if (pyvar_surrogate != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter surrogate at index 0");
    if (unicodesurrogate)
        bssurrogate = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodesurrogate), 
                                            (UINT)PyUnicode_GET_SIZE(unicodesurrogate));
    
    if (PyErr_Occurred())
      goto idecadastralfabric2_put_surrogateversion_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIDECadastralFabric2->put_SurrogateVersion(bssurrogate);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDECadastralFabric2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDECadastralFabric2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDECadastralFabric2.put_SurrogateVersion() returned %ld", (long)hr);
        goto idecadastralfabric2_put_surrogateversion_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for surrogate

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idecadastralfabric2_put_surrogateversion_method_cleanup;

    idecadastralfabric2_put_surrogateversion_method_cleanup:
    self->m_HR = hr;
    if (bssurrogate)
        ::SysFreeString(bssurrogate);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDECadastralFabric2.put_SurrogateVersion");
    return return_tuple;
}

static PyObject*
IDECadastralFabric2Method_get_Version(PyIDECadastralFabric2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lVersion = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Version

    // Call method on actual COM interface
    hr = self->m_pIDECadastralFabric2->get_Version(&lVersion);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDECadastralFabric2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDECadastralFabric2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDECadastralFabric2.get_Version() returned %ld", (long)hr);
        goto idecadastralfabric2_get_version_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Version

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lVersion);
    goto idecadastralfabric2_get_version_method_cleanup;

    idecadastralfabric2_get_version_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Version
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDECadastralFabric2.get_Version");
    return return_tuple;
}

static PyObject*
IDECadastralFabric2Method_get_MaximumShiftThreshold(PyIDECadastralFabric2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dThreshold = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Threshold

    // Call method on actual COM interface
    hr = self->m_pIDECadastralFabric2->get_MaximumShiftThreshold(&dThreshold);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDECadastralFabric2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDECadastralFabric2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDECadastralFabric2.get_MaximumShiftThreshold() returned %ld", (long)hr);
        goto idecadastralfabric2_get_maximumshiftthreshold_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Threshold

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dThreshold);
    goto idecadastralfabric2_get_maximumshiftthreshold_method_cleanup;

    idecadastralfabric2_get_maximumshiftthreshold_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Threshold
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDECadastralFabric2.get_MaximumShiftThreshold");
    return return_tuple;
}

static PyObject*
IDECadastralFabric2Method_put_MaximumShiftThreshold(PyIDECadastralFabric2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dThreshold = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "d", &dThreshold))
      goto idecadastralfabric2_put_maximumshiftthreshold_method_cleanup;

    // Set up initial variable values as needed
    // No setup for Threshold

    // Call method on actual COM interface
    hr = self->m_pIDECadastralFabric2->put_MaximumShiftThreshold(dThreshold);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDECadastralFabric2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDECadastralFabric2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDECadastralFabric2.put_MaximumShiftThreshold() returned %ld", (long)hr);
        goto idecadastralfabric2_put_maximumshiftthreshold_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Threshold

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idecadastralfabric2_put_maximumshiftthreshold_method_cleanup;

    idecadastralfabric2_put_maximumshiftthreshold_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Threshold
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDECadastralFabric2.put_MaximumShiftThreshold");
    return return_tuple;
}

static PyObject*
IDECadastralFabric2Method_get_MultiGenerationEditing(PyIDECadastralFabric2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pAllow = VARIANT_FALSE;
    PyObject* pyvar_pAllow = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pAllow

    // Call method on actual COM interface
    hr = self->m_pIDECadastralFabric2->get_MultiGenerationEditing(&b_pAllow);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDECadastralFabric2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDECadastralFabric2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDECadastralFabric2.get_MultiGenerationEditing() returned %ld", (long)hr);
        goto idecadastralfabric2_get_multigenerationediting_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pAllow = ((b_pAllow == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto idecadastralfabric2_get_multigenerationediting_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pAllow);
    goto idecadastralfabric2_get_multigenerationediting_method_cleanup;

    idecadastralfabric2_get_multigenerationediting_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pAllow
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDECadastralFabric2.get_MultiGenerationEditing");
    return return_tuple;
}

static PyObject*
IDECadastralFabric2Method_put_MultiGenerationEditing(PyIDECadastralFabric2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pAllow = VARIANT_FALSE;
    PyObject* pyvar_pAllow = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pAllow))
      goto idecadastralfabric2_put_multigenerationediting_method_cleanup;

    // Set up initial variable values as needed
    b_pAllow = ((PyObject_IsTrue(pyvar_pAllow) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto idecadastralfabric2_put_multigenerationediting_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIDECadastralFabric2->put_MultiGenerationEditing(b_pAllow);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDECadastralFabric2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDECadastralFabric2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDECadastralFabric2.put_MultiGenerationEditing() returned %ld", (long)hr);
        goto idecadastralfabric2_put_multigenerationediting_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pAllow

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idecadastralfabric2_put_multigenerationediting_method_cleanup;

    idecadastralfabric2_put_multigenerationediting_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pAllow
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDECadastralFabric2.put_MultiGenerationEditing");
    return return_tuple;
}

static PyObject*
IDECadastralFabric2Method_get_MultiLevelReconcile(PyIDECadastralFabric2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pAllow = VARIANT_FALSE;
    PyObject* pyvar_pAllow = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pAllow

    // Call method on actual COM interface
    hr = self->m_pIDECadastralFabric2->get_MultiLevelReconcile(&b_pAllow);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDECadastralFabric2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDECadastralFabric2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDECadastralFabric2.get_MultiLevelReconcile() returned %ld", (long)hr);
        goto idecadastralfabric2_get_multilevelreconcile_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pAllow = ((b_pAllow == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto idecadastralfabric2_get_multilevelreconcile_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pAllow);
    goto idecadastralfabric2_get_multilevelreconcile_method_cleanup;

    idecadastralfabric2_get_multilevelreconcile_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pAllow
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDECadastralFabric2.get_MultiLevelReconcile");
    return return_tuple;
}

static PyObject*
IDECadastralFabric2Method_put_MultiLevelReconcile(PyIDECadastralFabric2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pAllow = VARIANT_FALSE;
    PyObject* pyvar_pAllow = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pAllow))
      goto idecadastralfabric2_put_multilevelreconcile_method_cleanup;

    // Set up initial variable values as needed
    b_pAllow = ((PyObject_IsTrue(pyvar_pAllow) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto idecadastralfabric2_put_multilevelreconcile_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIDECadastralFabric2->put_MultiLevelReconcile(b_pAllow);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDECadastralFabric2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDECadastralFabric2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDECadastralFabric2.put_MultiLevelReconcile() returned %ld", (long)hr);
        goto idecadastralfabric2_put_multilevelreconcile_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pAllow

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idecadastralfabric2_put_multilevelreconcile_method_cleanup;

    idecadastralfabric2_put_multilevelreconcile_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pAllow
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDECadastralFabric2.put_MultiLevelReconcile");
    return return_tuple;
}

static PyObject*
IDECadastralFabric2Method_get_PinAdjustmentBoundary(PyIDECadastralFabric2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pPinBoundary = VARIANT_FALSE;
    PyObject* pyvar_pPinBoundary = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pPinBoundary

    // Call method on actual COM interface
    hr = self->m_pIDECadastralFabric2->get_PinAdjustmentBoundary(&b_pPinBoundary);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDECadastralFabric2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDECadastralFabric2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDECadastralFabric2.get_PinAdjustmentBoundary() returned %ld", (long)hr);
        goto idecadastralfabric2_get_pinadjustmentboundary_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pPinBoundary = ((b_pPinBoundary == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto idecadastralfabric2_get_pinadjustmentboundary_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pPinBoundary);
    goto idecadastralfabric2_get_pinadjustmentboundary_method_cleanup;

    idecadastralfabric2_get_pinadjustmentboundary_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pPinBoundary
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDECadastralFabric2.get_PinAdjustmentBoundary");
    return return_tuple;
}

static PyObject*
IDECadastralFabric2Method_put_PinAdjustmentBoundary(PyIDECadastralFabric2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pPinBoundary = VARIANT_FALSE;
    PyObject* pyvar_pPinBoundary = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pPinBoundary))
      goto idecadastralfabric2_put_pinadjustmentboundary_method_cleanup;

    // Set up initial variable values as needed
    b_pPinBoundary = ((PyObject_IsTrue(pyvar_pPinBoundary) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto idecadastralfabric2_put_pinadjustmentboundary_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIDECadastralFabric2->put_PinAdjustmentBoundary(b_pPinBoundary);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDECadastralFabric2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDECadastralFabric2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDECadastralFabric2.put_PinAdjustmentBoundary() returned %ld", (long)hr);
        goto idecadastralfabric2_put_pinadjustmentboundary_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pPinBoundary

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idecadastralfabric2_put_pinadjustmentboundary_method_cleanup;

    idecadastralfabric2_put_pinadjustmentboundary_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pPinBoundary
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDECadastralFabric2.put_PinAdjustmentBoundary");
    return return_tuple;
}

static PyObject*
IDECadastralFabric2Method_get_PinAdjustmentPointsWithinBoundary(PyIDECadastralFabric2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pPinWithinBoundary = VARIANT_FALSE;
    PyObject* pyvar_pPinWithinBoundary = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pPinWithinBoundary

    // Call method on actual COM interface
    hr = self->m_pIDECadastralFabric2->get_PinAdjustmentPointsWithinBoundary(&b_pPinWithinBoundary);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDECadastralFabric2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDECadastralFabric2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDECadastralFabric2.get_PinAdjustmentPointsWithinBoundary() returned %ld", (long)hr);
        goto idecadastralfabric2_get_pinadjustmentpointswithinboundary_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pPinWithinBoundary = ((b_pPinWithinBoundary == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto idecadastralfabric2_get_pinadjustmentpointswithinboundary_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pPinWithinBoundary);
    goto idecadastralfabric2_get_pinadjustmentpointswithinboundary_method_cleanup;

    idecadastralfabric2_get_pinadjustmentpointswithinboundary_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pPinWithinBoundary
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDECadastralFabric2.get_PinAdjustmentPointsWithinBoundary");
    return return_tuple;
}

static PyObject*
IDECadastralFabric2Method_put_PinAdjustmentPointsWithinBoundary(PyIDECadastralFabric2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pPinWithinBoundary = VARIANT_FALSE;
    PyObject* pyvar_pPinWithinBoundary = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pPinWithinBoundary))
      goto idecadastralfabric2_put_pinadjustmentpointswithinboundary_method_cleanup;

    // Set up initial variable values as needed
    b_pPinWithinBoundary = ((PyObject_IsTrue(pyvar_pPinWithinBoundary) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto idecadastralfabric2_put_pinadjustmentpointswithinboundary_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIDECadastralFabric2->put_PinAdjustmentPointsWithinBoundary(b_pPinWithinBoundary);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDECadastralFabric2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDECadastralFabric2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDECadastralFabric2.put_PinAdjustmentPointsWithinBoundary() returned %ld", (long)hr);
        goto idecadastralfabric2_put_pinadjustmentpointswithinboundary_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pPinWithinBoundary

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idecadastralfabric2_put_pinadjustmentpointswithinboundary_method_cleanup;

    idecadastralfabric2_put_pinadjustmentpointswithinboundary_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pPinWithinBoundary
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDECadastralFabric2.put_PinAdjustmentPointsWithinBoundary");
    return return_tuple;
}

static PyObject*
IDECadastralFabric2Method_get_WriteAdjustmentVectors(PyIDECadastralFabric2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pWriteAdjustmentVectors = VARIANT_FALSE;
    PyObject* pyvar_pWriteAdjustmentVectors = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pWriteAdjustmentVectors

    // Call method on actual COM interface
    hr = self->m_pIDECadastralFabric2->get_WriteAdjustmentVectors(&b_pWriteAdjustmentVectors);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDECadastralFabric2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDECadastralFabric2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDECadastralFabric2.get_WriteAdjustmentVectors() returned %ld", (long)hr);
        goto idecadastralfabric2_get_writeadjustmentvectors_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pWriteAdjustmentVectors = ((b_pWriteAdjustmentVectors == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto idecadastralfabric2_get_writeadjustmentvectors_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pWriteAdjustmentVectors);
    goto idecadastralfabric2_get_writeadjustmentvectors_method_cleanup;

    idecadastralfabric2_get_writeadjustmentvectors_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pWriteAdjustmentVectors
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDECadastralFabric2.get_WriteAdjustmentVectors");
    return return_tuple;
}

static PyObject*
IDECadastralFabric2Method_put_WriteAdjustmentVectors(PyIDECadastralFabric2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pWriteAdjustmentVectors = VARIANT_FALSE;
    PyObject* pyvar_pWriteAdjustmentVectors = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pWriteAdjustmentVectors))
      goto idecadastralfabric2_put_writeadjustmentvectors_method_cleanup;

    // Set up initial variable values as needed
    b_pWriteAdjustmentVectors = ((PyObject_IsTrue(pyvar_pWriteAdjustmentVectors) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto idecadastralfabric2_put_writeadjustmentvectors_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIDECadastralFabric2->put_WriteAdjustmentVectors(b_pWriteAdjustmentVectors);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDECadastralFabric2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDECadastralFabric2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDECadastralFabric2.put_WriteAdjustmentVectors() returned %ld", (long)hr);
        goto idecadastralfabric2_put_writeadjustmentvectors_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pWriteAdjustmentVectors

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idecadastralfabric2_put_writeadjustmentvectors_method_cleanup;

    idecadastralfabric2_put_writeadjustmentvectors_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pWriteAdjustmentVectors
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDECadastralFabric2.put_WriteAdjustmentVectors");
    return return_tuple;
}


PyMethodDef PyIDECadastralFabric2Methods[] = {
    {"supports", (PyCFunction)PyIDECadastralFabric2_SupportsInterface, METH_O, ""},
    {"get_CompiledAccuracyCategory", (PyCFunction)IDECadastralFabric2Method_get_CompiledAccuracyCategory, METH_VARARGS, ""},
    {"put_CompiledAccuracyCategory", (PyCFunction)IDECadastralFabric2Method_put_CompiledAccuracyCategory, METH_VARARGS, ""},
    {"get_BufferDistanceForAdjustment", (PyCFunction)IDECadastralFabric2Method_get_BufferDistanceForAdjustment, METH_VARARGS, ""},
    {"put_BufferDistanceForAdjustment", (PyCFunction)IDECadastralFabric2Method_put_BufferDistanceForAdjustment, METH_VARARGS, ""},
    {"get_Type", (PyCFunction)IDECadastralFabric2Method_get_Type, METH_VARARGS, ""},
    {"put_Type", (PyCFunction)IDECadastralFabric2Method_put_Type, METH_VARARGS, ""},
    {"get_SurrogateVersion", (PyCFunction)IDECadastralFabric2Method_get_SurrogateVersion, METH_VARARGS, ""},
    {"put_SurrogateVersion", (PyCFunction)IDECadastralFabric2Method_put_SurrogateVersion, METH_VARARGS, ""},
    {"get_Version", (PyCFunction)IDECadastralFabric2Method_get_Version, METH_VARARGS, ""},
    {"get_MaximumShiftThreshold", (PyCFunction)IDECadastralFabric2Method_get_MaximumShiftThreshold, METH_VARARGS, ""},
    {"put_MaximumShiftThreshold", (PyCFunction)IDECadastralFabric2Method_put_MaximumShiftThreshold, METH_VARARGS, ""},
    {"get_MultiGenerationEditing", (PyCFunction)IDECadastralFabric2Method_get_MultiGenerationEditing, METH_VARARGS, ""},
    {"put_MultiGenerationEditing", (PyCFunction)IDECadastralFabric2Method_put_MultiGenerationEditing, METH_VARARGS, ""},
    {"get_MultiLevelReconcile", (PyCFunction)IDECadastralFabric2Method_get_MultiLevelReconcile, METH_VARARGS, ""},
    {"put_MultiLevelReconcile", (PyCFunction)IDECadastralFabric2Method_put_MultiLevelReconcile, METH_VARARGS, ""},
    {"get_PinAdjustmentBoundary", (PyCFunction)IDECadastralFabric2Method_get_PinAdjustmentBoundary, METH_VARARGS, ""},
    {"put_PinAdjustmentBoundary", (PyCFunction)IDECadastralFabric2Method_put_PinAdjustmentBoundary, METH_VARARGS, ""},
    {"get_PinAdjustmentPointsWithinBoundary", (PyCFunction)IDECadastralFabric2Method_get_PinAdjustmentPointsWithinBoundary, METH_VARARGS, ""},
    {"put_PinAdjustmentPointsWithinBoundary", (PyCFunction)IDECadastralFabric2Method_put_PinAdjustmentPointsWithinBoundary, METH_VARARGS, ""},
    {"get_WriteAdjustmentVectors", (PyCFunction)IDECadastralFabric2Method_get_WriteAdjustmentVectors, METH_VARARGS, ""},
    {"put_WriteAdjustmentVectors", (PyCFunction)IDECadastralFabric2Method_put_WriteAdjustmentVectors, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIDECadastralFabric2GetSet[] = {
  {"_pUnk", (getter)PyIDECadastralFabric2_GetpUnk, NULL, "Get opaque pointer to an Unknown from IDECadastralFabric2", NULL},
  {"_pointer", (getter)PyIDECadastralFabric2_GetPointer, NULL, "Get memory address for IDECadastralFabric2", NULL},
  {"_IID", (getter)PyIDECadastralFabric2_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIDECadastralFabric2_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIDECadastralFabric2_GetIgnoreFailures, (setter)PyIDECadastralFabric2_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIDECadastralFabric2Object_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.IDECadastralFabric2Object",                          
                                              /* tp_name */
  sizeof(PyIDECadastralFabric2Object),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIDECadastralFabric2Object_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIDECadastralFabric2Methods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIDECadastralFabric2GetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIDECadastralFabric2Object_new,                      
                                              /* tp_new */
};

// Interface IDECadastralFabric3

typedef struct PyIDECadastralFabric3Object {
    PyObject_HEAD
    IDECadastralFabric3* m_pIDECadastralFabric3;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIDECadastralFabric3Object;

static PyObject*
PyIDECadastralFabric3Object_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIDECadastralFabric3Object* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IDECadastralFabric3* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IDECadastralFabric3, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IDECadastralFabric3 with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIDECadastralFabric3Object *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IDECadastralFabric3");
            return NULL;
        }
        self->m_pIDECadastralFabric3 = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IDECadastralFabric3");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IDECadastralFabric3");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IDECadastralFabric3* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IDECadastralFabric3, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IDECadastralFabric3");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIDECadastralFabric3Object *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IDECadastralFabric3");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIDECadastralFabric3 = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIDECadastralFabric3Object_dealloc(PyIDECadastralFabric3Object* self)
{
    if (self->m_pIDECadastralFabric3)
        self->m_pIDECadastralFabric3->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIDECadastralFabric3_GetpUnk(PyIDECadastralFabric3Object* self)
{
    if (!self->m_pIDECadastralFabric3)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIDECadastralFabric3->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IDECadastralFabric3 to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIDECadastralFabric3_GetPointer(PyIDECadastralFabric3Object* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIDECadastralFabric3);
}

static PyObject*
PyIDECadastralFabric3_GetIID(PyIDECadastralFabric3Object* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "7620970c-aef2-41ea-85a9-21c3829ea070");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIDECadastralFabric3_GetHR(PyIDECadastralFabric3Object* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIDECadastralFabric3_GetIgnoreFailures(PyIDECadastralFabric3Object* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIDECadastralFabric3_SetIgnoreFailures(PyIDECadastralFabric3Object* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIDECadastralFabric3_SupportsInterface(PyIDECadastralFabric3Object* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIDECadastralFabric3->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IDECadastralFabric3Method_GetPropertySet(PyIDECadastralFabric3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriCadastralPropertySetType eType;
    IPropertySet* ippropertySet = NULL;
    PyObject* py_propertySet = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&eType))
      goto idecadastralfabric3_getpropertyset_method_cleanup;

    // Set up initial variable values as needed
    // No setup for Type
    // No setup for propertySet

    // Call method on actual COM interface
    hr = self->m_pIDECadastralFabric3->GetPropertySet(eType, &ippropertySet);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDECadastralFabric3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDECadastralFabric3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDECadastralFabric3.GetPropertySet() returned %ld", (long)hr);
        goto idecadastralfabric3_getpropertyset_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Type
    Py_XDECREF(py_propertySet);
    if (ippropertySet)
    {
        IUnknown* pUnk = NULL;
        ippropertySet->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_propertySet = IUnknownToPythonIIDObject(pUnk, &IID_IPropertySet);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_propertySet)
    {
        if (py_propertySet)
           Py_DECREF(py_propertySet);
        py_propertySet = Py_None;
        Py_INCREF(py_propertySet);
    }
    if (PyErr_Occurred())
      goto idecadastralfabric3_getpropertyset_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_propertySet);
    goto idecadastralfabric3_getpropertyset_method_cleanup;

    idecadastralfabric3_getpropertyset_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Type
    Py_XDECREF(py_propertySet);
    if (ippropertySet)
      ippropertySet->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDECadastralFabric3.GetPropertySet");
    return return_tuple;
}

static PyObject*
IDECadastralFabric3Method_SetPropertySet(PyIDECadastralFabric3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriCadastralPropertySetType eType;
    IPropertySet* ippropertySet = NULL;
    PyObject* py_propertySet;

    // Unpack values
    if (!PyArg_ParseTuple(args, "iO", (int *)&eType, &py_propertySet))
      goto idecadastralfabric3_setpropertyset_method_cleanup;

    // Set up initial variable values as needed
    // No setup for Type
    if (!IFaceFromPyObject(py_propertySet, &IID_IPropertySet, (void**)&ippropertySet))
        PyErr_SetString(PyExc_TypeError, "Argument propertySet (position 1) is not IPropertySet");
    
    if (PyErr_Occurred())
      goto idecadastralfabric3_setpropertyset_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIDECadastralFabric3->SetPropertySet(eType, ippropertySet);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDECadastralFabric3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDECadastralFabric3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDECadastralFabric3.SetPropertySet() returned %ld", (long)hr);
        goto idecadastralfabric3_setpropertyset_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Type
    // No teardown for propertySet

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idecadastralfabric3_setpropertyset_method_cleanup;

    idecadastralfabric3_setpropertyset_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Type
    if (ippropertySet)
      ippropertySet->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDECadastralFabric3.SetPropertySet");
    return return_tuple;
}


PyMethodDef PyIDECadastralFabric3Methods[] = {
    {"supports", (PyCFunction)PyIDECadastralFabric3_SupportsInterface, METH_O, ""},
    {"GetPropertySet", (PyCFunction)IDECadastralFabric3Method_GetPropertySet, METH_VARARGS, ""},
    {"SetPropertySet", (PyCFunction)IDECadastralFabric3Method_SetPropertySet, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIDECadastralFabric3GetSet[] = {
  {"_pUnk", (getter)PyIDECadastralFabric3_GetpUnk, NULL, "Get opaque pointer to an Unknown from IDECadastralFabric3", NULL},
  {"_pointer", (getter)PyIDECadastralFabric3_GetPointer, NULL, "Get memory address for IDECadastralFabric3", NULL},
  {"_IID", (getter)PyIDECadastralFabric3_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIDECadastralFabric3_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIDECadastralFabric3_GetIgnoreFailures, (setter)PyIDECadastralFabric3_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIDECadastralFabric3Object_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.IDECadastralFabric3Object",                          
                                              /* tp_name */
  sizeof(PyIDECadastralFabric3Object),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIDECadastralFabric3Object_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIDECadastralFabric3Methods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIDECadastralFabric3GetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIDECadastralFabric3Object_new,                      
                                              /* tp_new */
};

// Interface IParcelConstructionData

typedef struct PyIParcelConstructionDataObject {
    PyObject_HEAD
    IParcelConstructionData* m_pIParcelConstructionData;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIParcelConstructionDataObject;

static PyObject*
PyIParcelConstructionDataObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIParcelConstructionDataObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IParcelConstructionData* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IParcelConstructionData, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IParcelConstructionData with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIParcelConstructionDataObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IParcelConstructionData");
            return NULL;
        }
        self->m_pIParcelConstructionData = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IParcelConstructionData");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IParcelConstructionData");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IParcelConstructionData* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IParcelConstructionData, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IParcelConstructionData");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIParcelConstructionDataObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IParcelConstructionData");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIParcelConstructionData = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIParcelConstructionDataObject_dealloc(PyIParcelConstructionDataObject* self)
{
    if (self->m_pIParcelConstructionData)
        self->m_pIParcelConstructionData->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIParcelConstructionData_GetpUnk(PyIParcelConstructionDataObject* self)
{
    if (!self->m_pIParcelConstructionData)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIParcelConstructionData->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IParcelConstructionData to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIParcelConstructionData_GetPointer(PyIParcelConstructionDataObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIParcelConstructionData);
}

static PyObject*
PyIParcelConstructionData_GetIID(PyIParcelConstructionDataObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "fc722d60-d2dc-4dfe-8524-3ac3369bbe68");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIParcelConstructionData_GetHR(PyIParcelConstructionDataObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIParcelConstructionData_GetIgnoreFailures(PyIParcelConstructionDataObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIParcelConstructionData_SetIgnoreFailures(PyIParcelConstructionDataObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIParcelConstructionData_SupportsInterface(PyIParcelConstructionDataObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIParcelConstructionData->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IParcelConstructionDataMethod_get_ParcelNo(PyIParcelConstructionDataObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lParcelNo = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ParcelNo

    // Call method on actual COM interface
    hr = self->m_pIParcelConstructionData->get_ParcelNo(&lParcelNo);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIParcelConstructionData->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IParcelConstructionData) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IParcelConstructionData.get_ParcelNo() returned %ld", (long)hr);
        goto iparcelconstructiondata_get_parcelno_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ParcelNo

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lParcelNo);
    goto iparcelconstructiondata_get_parcelno_method_cleanup;

    iparcelconstructiondata_get_parcelno_method_cleanup:
    self->m_HR = hr;
    // No cleanup for ParcelNo
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IParcelConstructionData.get_ParcelNo");
    return return_tuple;
}

static PyObject*
IParcelConstructionDataMethod_put_ParcelNo(PyIParcelConstructionDataObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lParcelNo = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lParcelNo))
      goto iparcelconstructiondata_put_parcelno_method_cleanup;

    // Set up initial variable values as needed
    // No setup for ParcelNo

    // Call method on actual COM interface
    hr = self->m_pIParcelConstructionData->put_ParcelNo(lParcelNo);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIParcelConstructionData->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IParcelConstructionData) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IParcelConstructionData.put_ParcelNo() returned %ld", (long)hr);
        goto iparcelconstructiondata_put_parcelno_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ParcelNo

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iparcelconstructiondata_put_parcelno_method_cleanup;

    iparcelconstructiondata_put_parcelno_method_cleanup:
    self->m_HR = hr;
    // No cleanup for ParcelNo
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IParcelConstructionData.put_ParcelNo");
    return return_tuple;
}

static PyObject*
IParcelConstructionDataMethod_WriteToXML(PyIParcelConstructionDataObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IUnknown* ippXMLDoc = NULL;
    PyObject* py_pXMLDoc;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_pXMLDoc))
      goto iparcelconstructiondata_writetoxml_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pXMLDoc, &IID_IUnknown, (void**)&ippXMLDoc))
        PyErr_SetString(PyExc_TypeError, "Argument pXMLDoc (position 0) is not IUnknown");
    
    if (PyErr_Occurred())
      goto iparcelconstructiondata_writetoxml_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIParcelConstructionData->WriteToXML(ippXMLDoc);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIParcelConstructionData->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IParcelConstructionData) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IParcelConstructionData.WriteToXML() returned %ld", (long)hr);
        goto iparcelconstructiondata_writetoxml_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pXMLDoc

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iparcelconstructiondata_writetoxml_method_cleanup;

    iparcelconstructiondata_writetoxml_method_cleanup:
    self->m_HR = hr;
    if (ippXMLDoc)
      ippXMLDoc->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IParcelConstructionData.WriteToXML");
    return return_tuple;
}

static PyObject*
IParcelConstructionDataMethod_LoadConstructionDataFromXML(PyIParcelConstructionDataObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IUnknown* ippXMLParcelNode = NULL;
    PyObject* py_pXMLParcelNode;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_pXMLParcelNode))
      goto iparcelconstructiondata_loadconstructiondatafromxml_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pXMLParcelNode, &IID_IUnknown, (void**)&ippXMLParcelNode))
        PyErr_SetString(PyExc_TypeError, "Argument pXMLParcelNode (position 0) is not IUnknown");
    
    if (PyErr_Occurred())
      goto iparcelconstructiondata_loadconstructiondatafromxml_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIParcelConstructionData->LoadConstructionDataFromXML(ippXMLParcelNode);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIParcelConstructionData->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IParcelConstructionData) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IParcelConstructionData.LoadConstructionDataFromXML() returned %ld", (long)hr);
        goto iparcelconstructiondata_loadconstructiondatafromxml_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pXMLParcelNode

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iparcelconstructiondata_loadconstructiondatafromxml_method_cleanup;

    iparcelconstructiondata_loadconstructiondatafromxml_method_cleanup:
    self->m_HR = hr;
    if (ippXMLParcelNode)
      ippXMLParcelNode->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IParcelConstructionData.LoadConstructionDataFromXML");
    return return_tuple;
}

static PyObject*
IParcelConstructionDataMethod_ExportToXMLString(PyIParcelConstructionDataObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsXMLString;
    PyObject* pyvar_XMLString = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for XMLString

    // Call method on actual COM interface
    hr = self->m_pIParcelConstructionData->ExportToXMLString(&bsXMLString);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIParcelConstructionData->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IParcelConstructionData) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IParcelConstructionData.ExportToXMLString() returned %ld", (long)hr);
        goto iparcelconstructiondata_exporttoxmlstring_method_cleanup;
    }

    // Set up return values as needed
    pyvar_XMLString = PyUnicode_FromWideChar(bsXMLString,::SysStringLen(bsXMLString));
    ::SysFreeString(bsXMLString);
    
    if (PyErr_Occurred())
      goto iparcelconstructiondata_exporttoxmlstring_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_XMLString);
    goto iparcelconstructiondata_exporttoxmlstring_method_cleanup;

    iparcelconstructiondata_exporttoxmlstring_method_cleanup:
    self->m_HR = hr;
    if (pyvar_XMLString != Py_None)
        Py_XDECREF(pyvar_XMLString);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IParcelConstructionData.ExportToXMLString");
    return return_tuple;
}

static PyObject*
IParcelConstructionDataMethod_LoadConstructionDataFromXMLString(PyIParcelConstructionDataObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsXMLString = 0;
    PyObject* pyvar_XMLString;
    PyObject* unicodeXMLString = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_XMLString))
      goto iparcelconstructiondata_loadconstructiondatafromxmlstring_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_XMLString))
        unicodeXMLString = PyUnicode_FromObject(pyvar_XMLString);
    else if (PyUnicode_Check(pyvar_XMLString))
    {
        unicodeXMLString = pyvar_XMLString;
        Py_INCREF(unicodeXMLString);
    }
    else if (pyvar_XMLString != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter XMLString at index 0");
    if (unicodeXMLString)
        bsXMLString = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeXMLString), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeXMLString));
    
    if (PyErr_Occurred())
      goto iparcelconstructiondata_loadconstructiondatafromxmlstring_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIParcelConstructionData->LoadConstructionDataFromXMLString(bsXMLString);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIParcelConstructionData->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IParcelConstructionData) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IParcelConstructionData.LoadConstructionDataFromXMLString() returned %ld", (long)hr);
        goto iparcelconstructiondata_loadconstructiondatafromxmlstring_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for XMLString

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iparcelconstructiondata_loadconstructiondatafromxmlstring_method_cleanup;

    iparcelconstructiondata_loadconstructiondatafromxmlstring_method_cleanup:
    self->m_HR = hr;
    if (bsXMLString)
        ::SysFreeString(bsXMLString);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IParcelConstructionData.LoadConstructionDataFromXMLString");
    return return_tuple;
}


PyMethodDef PyIParcelConstructionDataMethods[] = {
    {"supports", (PyCFunction)PyIParcelConstructionData_SupportsInterface, METH_O, ""},
    {"get_ParcelNo", (PyCFunction)IParcelConstructionDataMethod_get_ParcelNo, METH_VARARGS, ""},
    {"put_ParcelNo", (PyCFunction)IParcelConstructionDataMethod_put_ParcelNo, METH_VARARGS, ""},
    {"WriteToXML", (PyCFunction)IParcelConstructionDataMethod_WriteToXML, METH_VARARGS, ""},
    {"LoadConstructionDataFromXML", (PyCFunction)IParcelConstructionDataMethod_LoadConstructionDataFromXML, METH_VARARGS, ""},
    {"ExportToXMLString", (PyCFunction)IParcelConstructionDataMethod_ExportToXMLString, METH_VARARGS, ""},
    {"LoadConstructionDataFromXMLString", (PyCFunction)IParcelConstructionDataMethod_LoadConstructionDataFromXMLString, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIParcelConstructionDataGetSet[] = {
  {"_pUnk", (getter)PyIParcelConstructionData_GetpUnk, NULL, "Get opaque pointer to an Unknown from IParcelConstructionData", NULL},
  {"_pointer", (getter)PyIParcelConstructionData_GetPointer, NULL, "Get memory address for IParcelConstructionData", NULL},
  {"_IID", (getter)PyIParcelConstructionData_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIParcelConstructionData_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIParcelConstructionData_GetIgnoreFailures, (setter)PyIParcelConstructionData_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIParcelConstructionDataObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.IParcelConstructionDataObject",                          
                                              /* tp_name */
  sizeof(PyIParcelConstructionDataObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIParcelConstructionDataObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIParcelConstructionDataMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIParcelConstructionDataGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIParcelConstructionDataObject_new,                      
                                              /* tp_new */
};

// Interface IConstructionParentParcels

typedef struct PyIConstructionParentParcelsObject {
    PyObject_HEAD
    IConstructionParentParcels* m_pIConstructionParentParcels;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIConstructionParentParcelsObject;

static PyObject*
PyIConstructionParentParcelsObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIConstructionParentParcelsObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IConstructionParentParcels* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IConstructionParentParcels, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IConstructionParentParcels with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIConstructionParentParcelsObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IConstructionParentParcels");
            return NULL;
        }
        self->m_pIConstructionParentParcels = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IConstructionParentParcels");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IConstructionParentParcels");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IConstructionParentParcels* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IConstructionParentParcels, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IConstructionParentParcels");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIConstructionParentParcelsObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IConstructionParentParcels");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIConstructionParentParcels = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIConstructionParentParcelsObject_dealloc(PyIConstructionParentParcelsObject* self)
{
    if (self->m_pIConstructionParentParcels)
        self->m_pIConstructionParentParcels->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIConstructionParentParcels_GetpUnk(PyIConstructionParentParcelsObject* self)
{
    if (!self->m_pIConstructionParentParcels)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIConstructionParentParcels->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IConstructionParentParcels to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIConstructionParentParcels_GetPointer(PyIConstructionParentParcelsObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIConstructionParentParcels);
}

static PyObject*
PyIConstructionParentParcels_GetIID(PyIConstructionParentParcelsObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "b6a52380-87e2-4628-9ebd-771c0bdacf23");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIConstructionParentParcels_GetHR(PyIConstructionParentParcelsObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIConstructionParentParcels_GetIgnoreFailures(PyIConstructionParentParcelsObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIConstructionParentParcels_SetIgnoreFailures(PyIConstructionParentParcelsObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIConstructionParentParcels_SupportsInterface(PyIConstructionParentParcelsObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIConstructionParentParcels->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IConstructionParentParcelsMethod_get_ParentParcelCount(PyIConstructionParentParcelsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Count

    // Call method on actual COM interface
    hr = self->m_pIConstructionParentParcels->get_ParentParcelCount(&lCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIConstructionParentParcels->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IConstructionParentParcels) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IConstructionParentParcels.get_ParentParcelCount() returned %ld", (long)hr);
        goto iconstructionparentparcels_get_parentparcelcount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Count

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lCount);
    goto iconstructionparentparcels_get_parentparcelcount_method_cleanup;

    iconstructionparentparcels_get_parentparcelcount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Count
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IConstructionParentParcels.get_ParentParcelCount");
    return return_tuple;
}

static PyObject*
IConstructionParentParcelsMethod_GetParentParcel(PyIConstructionParentParcelsObject* self, PyObject* args)
{
    /* Param types that are unhandleable: 
       INPUT [u'long', u'*']
    */
    PyErr_SetString(PyExc_NotImplementedError, "Wrapper for IConstructionParentParcels.GetParentParcel not implemented.");
    return NULL;
}

static PyObject*
IConstructionParentParcelsMethod_AddParentParcel(PyIConstructionParentParcelsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lParcelNo = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lParcelNo))
      goto iconstructionparentparcels_addparentparcel_method_cleanup;

    // Set up initial variable values as needed
    // No setup for ParcelNo

    // Call method on actual COM interface
    hr = self->m_pIConstructionParentParcels->AddParentParcel(lParcelNo);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIConstructionParentParcels->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IConstructionParentParcels) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IConstructionParentParcels.AddParentParcel() returned %ld", (long)hr);
        goto iconstructionparentparcels_addparentparcel_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ParcelNo

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iconstructionparentparcels_addparentparcel_method_cleanup;

    iconstructionparentparcels_addparentparcel_method_cleanup:
    self->m_HR = hr;
    // No cleanup for ParcelNo
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IConstructionParentParcels.AddParentParcel");
    return return_tuple;
}

static PyObject*
IConstructionParentParcelsMethod_RemoveParentParcel(PyIConstructionParentParcelsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lParcelNo = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lParcelNo))
      goto iconstructionparentparcels_removeparentparcel_method_cleanup;

    // Set up initial variable values as needed
    // No setup for ParcelNo

    // Call method on actual COM interface
    hr = self->m_pIConstructionParentParcels->RemoveParentParcel(lParcelNo);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIConstructionParentParcels->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IConstructionParentParcels) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IConstructionParentParcels.RemoveParentParcel() returned %ld", (long)hr);
        goto iconstructionparentparcels_removeparentparcel_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ParcelNo

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iconstructionparentparcels_removeparentparcel_method_cleanup;

    iconstructionparentparcels_removeparentparcel_method_cleanup:
    self->m_HR = hr;
    // No cleanup for ParcelNo
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IConstructionParentParcels.RemoveParentParcel");
    return return_tuple;
}

static PyObject*
IConstructionParentParcelsMethod_ClearParentParcels(PyIConstructionParentParcelsObject* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pIConstructionParentParcels->ClearParentParcels();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIConstructionParentParcels->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IConstructionParentParcels) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IConstructionParentParcels.ClearParentParcels() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}


PyMethodDef PyIConstructionParentParcelsMethods[] = {
    {"supports", (PyCFunction)PyIConstructionParentParcels_SupportsInterface, METH_O, ""},
    {"get_ParentParcelCount", (PyCFunction)IConstructionParentParcelsMethod_get_ParentParcelCount, METH_VARARGS, ""},
    {"GetParentParcel", (PyCFunction)IConstructionParentParcelsMethod_GetParentParcel, METH_VARARGS, ""},
    {"AddParentParcel", (PyCFunction)IConstructionParentParcelsMethod_AddParentParcel, METH_VARARGS, ""},
    {"RemoveParentParcel", (PyCFunction)IConstructionParentParcelsMethod_RemoveParentParcel, METH_VARARGS, ""},
    {"ClearParentParcels", (PyCFunction)IConstructionParentParcelsMethod_ClearParentParcels, METH_NOARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIConstructionParentParcelsGetSet[] = {
  {"_pUnk", (getter)PyIConstructionParentParcels_GetpUnk, NULL, "Get opaque pointer to an Unknown from IConstructionParentParcels", NULL},
  {"_pointer", (getter)PyIConstructionParentParcels_GetPointer, NULL, "Get memory address for IConstructionParentParcels", NULL},
  {"_IID", (getter)PyIConstructionParentParcels_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIConstructionParentParcels_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIConstructionParentParcels_GetIgnoreFailures, (setter)PyIConstructionParentParcels_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIConstructionParentParcelsObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.IConstructionParentParcelsObject",                          
                                              /* tp_name */
  sizeof(PyIConstructionParentParcelsObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIConstructionParentParcelsObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIConstructionParentParcelsMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIConstructionParentParcelsGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIConstructionParentParcelsObject_new,                      
                                              /* tp_new */
};

// Interface IConstructionBreakPoints

typedef struct PyIConstructionBreakPointsObject {
    PyObject_HEAD
    IConstructionBreakPoints* m_pIConstructionBreakPoints;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIConstructionBreakPointsObject;

static PyObject*
PyIConstructionBreakPointsObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIConstructionBreakPointsObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IConstructionBreakPoints* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IConstructionBreakPoints, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IConstructionBreakPoints with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIConstructionBreakPointsObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IConstructionBreakPoints");
            return NULL;
        }
        self->m_pIConstructionBreakPoints = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IConstructionBreakPoints");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IConstructionBreakPoints");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IConstructionBreakPoints* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IConstructionBreakPoints, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IConstructionBreakPoints");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIConstructionBreakPointsObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IConstructionBreakPoints");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIConstructionBreakPoints = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIConstructionBreakPointsObject_dealloc(PyIConstructionBreakPointsObject* self)
{
    if (self->m_pIConstructionBreakPoints)
        self->m_pIConstructionBreakPoints->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIConstructionBreakPoints_GetpUnk(PyIConstructionBreakPointsObject* self)
{
    if (!self->m_pIConstructionBreakPoints)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIConstructionBreakPoints->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IConstructionBreakPoints to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIConstructionBreakPoints_GetPointer(PyIConstructionBreakPointsObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIConstructionBreakPoints);
}

static PyObject*
PyIConstructionBreakPoints_GetIID(PyIConstructionBreakPointsObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "1c66cb4e-8950-41b1-8896-e75c173870aa");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIConstructionBreakPoints_GetHR(PyIConstructionBreakPointsObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIConstructionBreakPoints_GetIgnoreFailures(PyIConstructionBreakPointsObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIConstructionBreakPoints_SetIgnoreFailures(PyIConstructionBreakPointsObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIConstructionBreakPoints_SupportsInterface(PyIConstructionBreakPointsObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIConstructionBreakPoints->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IConstructionBreakPointsMethod_get_BreakPointCount(PyIConstructionBreakPointsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Count

    // Call method on actual COM interface
    hr = self->m_pIConstructionBreakPoints->get_BreakPointCount(&lCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIConstructionBreakPoints->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IConstructionBreakPoints) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IConstructionBreakPoints.get_BreakPointCount() returned %ld", (long)hr);
        goto iconstructionbreakpoints_get_breakpointcount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Count

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lCount);
    goto iconstructionbreakpoints_get_breakpointcount_method_cleanup;

    iconstructionbreakpoints_get_breakpointcount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Count
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IConstructionBreakPoints.get_BreakPointCount");
    return return_tuple;
}

static PyObject*
IConstructionBreakPointsMethod_GetBreakPoint(PyIConstructionBreakPointsObject* self, PyObject* args)
{
    /* Param types that are unhandleable: 
       INPUT [u'long', u'*']
       INPUT [u'long', u'*']
       INPUT [u'long', u'*']
       INPUT [u'double', u'*']
    */
    PyErr_SetString(PyExc_NotImplementedError, "Wrapper for IConstructionBreakPoints.GetBreakPoint not implemented.");
    return NULL;
}

static PyObject*
IConstructionBreakPointsMethod_FindBreakPoint(PyIConstructionBreakPointsObject* self, PyObject* args)
{
    /* Param types that are unhandleable: 
       INPUT [u'long', u'*']
       INPUT [u'long', u'*']
       INPUT [u'double', u'*']
    */
    PyErr_SetString(PyExc_NotImplementedError, "Wrapper for IConstructionBreakPoints.FindBreakPoint not implemented.");
    return NULL;
}

static PyObject*
IConstructionBreakPointsMethod_AddBreakPoint(PyIConstructionBreakPointsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpointNo = 0;
    long lfromPointNo = 0;
    long ltoPointNo = 0;
    double dratio = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "llld", &lpointNo, &lfromPointNo, &ltoPointNo, &dratio))
      goto iconstructionbreakpoints_addbreakpoint_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pointNo
    // No setup for fromPointNo
    // No setup for toPointNo
    // No setup for ratio

    // Call method on actual COM interface
    hr = self->m_pIConstructionBreakPoints->AddBreakPoint(lpointNo, lfromPointNo, ltoPointNo, dratio);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIConstructionBreakPoints->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IConstructionBreakPoints) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IConstructionBreakPoints.AddBreakPoint() returned %ld", (long)hr);
        goto iconstructionbreakpoints_addbreakpoint_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pointNo
    // No teardown for fromPointNo
    // No teardown for toPointNo
    // No teardown for ratio

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iconstructionbreakpoints_addbreakpoint_method_cleanup;

    iconstructionbreakpoints_addbreakpoint_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pointNo
    // No cleanup for fromPointNo
    // No cleanup for toPointNo
    // No cleanup for ratio
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IConstructionBreakPoints.AddBreakPoint");
    return return_tuple;
}

static PyObject*
IConstructionBreakPointsMethod_RemoveBreakPoint(PyIConstructionBreakPointsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpointNo = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lpointNo))
      goto iconstructionbreakpoints_removebreakpoint_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pointNo

    // Call method on actual COM interface
    hr = self->m_pIConstructionBreakPoints->RemoveBreakPoint(lpointNo);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIConstructionBreakPoints->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IConstructionBreakPoints) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IConstructionBreakPoints.RemoveBreakPoint() returned %ld", (long)hr);
        goto iconstructionbreakpoints_removebreakpoint_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pointNo

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iconstructionbreakpoints_removebreakpoint_method_cleanup;

    iconstructionbreakpoints_removebreakpoint_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pointNo
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IConstructionBreakPoints.RemoveBreakPoint");
    return return_tuple;
}

static PyObject*
IConstructionBreakPointsMethod_ClearBreakPoints(PyIConstructionBreakPointsObject* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pIConstructionBreakPoints->ClearBreakPoints();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIConstructionBreakPoints->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IConstructionBreakPoints) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IConstructionBreakPoints.ClearBreakPoints() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}


PyMethodDef PyIConstructionBreakPointsMethods[] = {
    {"supports", (PyCFunction)PyIConstructionBreakPoints_SupportsInterface, METH_O, ""},
    {"get_BreakPointCount", (PyCFunction)IConstructionBreakPointsMethod_get_BreakPointCount, METH_VARARGS, ""},
    {"GetBreakPoint", (PyCFunction)IConstructionBreakPointsMethod_GetBreakPoint, METH_VARARGS, ""},
    {"FindBreakPoint", (PyCFunction)IConstructionBreakPointsMethod_FindBreakPoint, METH_VARARGS, ""},
    {"AddBreakPoint", (PyCFunction)IConstructionBreakPointsMethod_AddBreakPoint, METH_VARARGS, ""},
    {"RemoveBreakPoint", (PyCFunction)IConstructionBreakPointsMethod_RemoveBreakPoint, METH_VARARGS, ""},
    {"ClearBreakPoints", (PyCFunction)IConstructionBreakPointsMethod_ClearBreakPoints, METH_NOARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIConstructionBreakPointsGetSet[] = {
  {"_pUnk", (getter)PyIConstructionBreakPoints_GetpUnk, NULL, "Get opaque pointer to an Unknown from IConstructionBreakPoints", NULL},
  {"_pointer", (getter)PyIConstructionBreakPoints_GetPointer, NULL, "Get memory address for IConstructionBreakPoints", NULL},
  {"_IID", (getter)PyIConstructionBreakPoints_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIConstructionBreakPoints_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIConstructionBreakPoints_GetIgnoreFailures, (setter)PyIConstructionBreakPoints_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIConstructionBreakPointsObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.IConstructionBreakPointsObject",                          
                                              /* tp_name */
  sizeof(PyIConstructionBreakPointsObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIConstructionBreakPointsObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIConstructionBreakPointsMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIConstructionBreakPointsGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIConstructionBreakPointsObject_new,                      
                                              /* tp_new */
};

// Interface IConstructionBasisOfBearing

typedef struct PyIConstructionBasisOfBearingObject {
    PyObject_HEAD
    IConstructionBasisOfBearing* m_pIConstructionBasisOfBearing;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIConstructionBasisOfBearingObject;

static PyObject*
PyIConstructionBasisOfBearingObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIConstructionBasisOfBearingObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IConstructionBasisOfBearing* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IConstructionBasisOfBearing, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IConstructionBasisOfBearing with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIConstructionBasisOfBearingObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IConstructionBasisOfBearing");
            return NULL;
        }
        self->m_pIConstructionBasisOfBearing = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IConstructionBasisOfBearing");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IConstructionBasisOfBearing");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IConstructionBasisOfBearing* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IConstructionBasisOfBearing, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IConstructionBasisOfBearing");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIConstructionBasisOfBearingObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IConstructionBasisOfBearing");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIConstructionBasisOfBearing = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIConstructionBasisOfBearingObject_dealloc(PyIConstructionBasisOfBearingObject* self)
{
    if (self->m_pIConstructionBasisOfBearing)
        self->m_pIConstructionBasisOfBearing->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIConstructionBasisOfBearing_GetpUnk(PyIConstructionBasisOfBearingObject* self)
{
    if (!self->m_pIConstructionBasisOfBearing)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIConstructionBasisOfBearing->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IConstructionBasisOfBearing to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIConstructionBasisOfBearing_GetPointer(PyIConstructionBasisOfBearingObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIConstructionBasisOfBearing);
}

static PyObject*
PyIConstructionBasisOfBearing_GetIID(PyIConstructionBasisOfBearingObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "2b82ac6e-aa06-43d8-ae70-7b200e07be6b");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIConstructionBasisOfBearing_GetHR(PyIConstructionBasisOfBearingObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIConstructionBasisOfBearing_GetIgnoreFailures(PyIConstructionBasisOfBearingObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIConstructionBasisOfBearing_SetIgnoreFailures(PyIConstructionBasisOfBearingObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIConstructionBasisOfBearing_SupportsInterface(PyIConstructionBasisOfBearingObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIConstructionBasisOfBearing->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IConstructionBasisOfBearingMethod_get_BasisOfBearingOffset(PyIConstructionBasisOfBearingObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dangleOffset = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for angleOffset

    // Call method on actual COM interface
    hr = self->m_pIConstructionBasisOfBearing->get_BasisOfBearingOffset(&dangleOffset);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIConstructionBasisOfBearing->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IConstructionBasisOfBearing) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IConstructionBasisOfBearing.get_BasisOfBearingOffset() returned %ld", (long)hr);
        goto iconstructionbasisofbearing_get_basisofbearingoffset_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for angleOffset

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dangleOffset);
    goto iconstructionbasisofbearing_get_basisofbearingoffset_method_cleanup;

    iconstructionbasisofbearing_get_basisofbearingoffset_method_cleanup:
    self->m_HR = hr;
    // No cleanup for angleOffset
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IConstructionBasisOfBearing.get_BasisOfBearingOffset");
    return return_tuple;
}

static PyObject*
IConstructionBasisOfBearingMethod_put_BasisOfBearingOffset(PyIConstructionBasisOfBearingObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dangleOffset = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "d", &dangleOffset))
      goto iconstructionbasisofbearing_put_basisofbearingoffset_method_cleanup;

    // Set up initial variable values as needed
    // No setup for angleOffset

    // Call method on actual COM interface
    hr = self->m_pIConstructionBasisOfBearing->put_BasisOfBearingOffset(dangleOffset);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIConstructionBasisOfBearing->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IConstructionBasisOfBearing) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IConstructionBasisOfBearing.put_BasisOfBearingOffset() returned %ld", (long)hr);
        goto iconstructionbasisofbearing_put_basisofbearingoffset_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for angleOffset

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iconstructionbasisofbearing_put_basisofbearingoffset_method_cleanup;

    iconstructionbasisofbearing_put_basisofbearingoffset_method_cleanup:
    self->m_HR = hr;
    // No cleanup for angleOffset
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IConstructionBasisOfBearing.put_BasisOfBearingOffset");
    return return_tuple;
}


PyMethodDef PyIConstructionBasisOfBearingMethods[] = {
    {"supports", (PyCFunction)PyIConstructionBasisOfBearing_SupportsInterface, METH_O, ""},
    {"get_BasisOfBearingOffset", (PyCFunction)IConstructionBasisOfBearingMethod_get_BasisOfBearingOffset, METH_VARARGS, ""},
    {"put_BasisOfBearingOffset", (PyCFunction)IConstructionBasisOfBearingMethod_put_BasisOfBearingOffset, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIConstructionBasisOfBearingGetSet[] = {
  {"_pUnk", (getter)PyIConstructionBasisOfBearing_GetpUnk, NULL, "Get opaque pointer to an Unknown from IConstructionBasisOfBearing", NULL},
  {"_pointer", (getter)PyIConstructionBasisOfBearing_GetPointer, NULL, "Get memory address for IConstructionBasisOfBearing", NULL},
  {"_IID", (getter)PyIConstructionBasisOfBearing_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIConstructionBasisOfBearing_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIConstructionBasisOfBearing_GetIgnoreFailures, (setter)PyIConstructionBasisOfBearing_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIConstructionBasisOfBearingObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.IConstructionBasisOfBearingObject",                          
                                              /* tp_name */
  sizeof(PyIConstructionBasisOfBearingObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIConstructionBasisOfBearingObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIConstructionBasisOfBearingMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIConstructionBasisOfBearingGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIConstructionBasisOfBearingObject_new,                      
                                              /* tp_new */
};

// Interface IConstructionJoinLinks

typedef struct PyIConstructionJoinLinksObject {
    PyObject_HEAD
    IConstructionJoinLinks* m_pIConstructionJoinLinks;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIConstructionJoinLinksObject;

static PyObject*
PyIConstructionJoinLinksObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIConstructionJoinLinksObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IConstructionJoinLinks* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IConstructionJoinLinks, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IConstructionJoinLinks with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIConstructionJoinLinksObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IConstructionJoinLinks");
            return NULL;
        }
        self->m_pIConstructionJoinLinks = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IConstructionJoinLinks");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IConstructionJoinLinks");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IConstructionJoinLinks* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IConstructionJoinLinks, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IConstructionJoinLinks");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIConstructionJoinLinksObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IConstructionJoinLinks");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIConstructionJoinLinks = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIConstructionJoinLinksObject_dealloc(PyIConstructionJoinLinksObject* self)
{
    if (self->m_pIConstructionJoinLinks)
        self->m_pIConstructionJoinLinks->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIConstructionJoinLinks_GetpUnk(PyIConstructionJoinLinksObject* self)
{
    if (!self->m_pIConstructionJoinLinks)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIConstructionJoinLinks->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IConstructionJoinLinks to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIConstructionJoinLinks_GetPointer(PyIConstructionJoinLinksObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIConstructionJoinLinks);
}

static PyObject*
PyIConstructionJoinLinks_GetIID(PyIConstructionJoinLinksObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "646fca02-4b1d-4844-a083-9911ef6cfa7b");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIConstructionJoinLinks_GetHR(PyIConstructionJoinLinksObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIConstructionJoinLinks_GetIgnoreFailures(PyIConstructionJoinLinksObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIConstructionJoinLinks_SetIgnoreFailures(PyIConstructionJoinLinksObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIConstructionJoinLinks_SupportsInterface(PyIConstructionJoinLinksObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIConstructionJoinLinks->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IConstructionJoinLinksMethod_get_JoinLinkCount(PyIConstructionJoinLinksObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Count

    // Call method on actual COM interface
    hr = self->m_pIConstructionJoinLinks->get_JoinLinkCount(&lCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIConstructionJoinLinks->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IConstructionJoinLinks) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IConstructionJoinLinks.get_JoinLinkCount() returned %ld", (long)hr);
        goto iconstructionjoinlinks_get_joinlinkcount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Count

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lCount);
    goto iconstructionjoinlinks_get_joinlinkcount_method_cleanup;

    iconstructionjoinlinks_get_joinlinkcount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Count
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IConstructionJoinLinks.get_JoinLinkCount");
    return return_tuple;
}

static PyObject*
IConstructionJoinLinksMethod_AddJoinLink(PyIConstructionJoinLinksObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lJoinedPointNo = 0;
    long lUnjoinedPointNo = 0;
    long lfromPointNo = 0;
    long ltoPointNo = 0;
    long lParcelNo = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "lllll", &lJoinedPointNo, &lUnjoinedPointNo, &lfromPointNo, &ltoPointNo, &lParcelNo))
      goto iconstructionjoinlinks_addjoinlink_method_cleanup;

    // Set up initial variable values as needed
    // No setup for JoinedPointNo
    // No setup for UnjoinedPointNo
    // No setup for fromPointNo
    // No setup for toPointNo
    // No setup for ParcelNo

    // Call method on actual COM interface
    hr = self->m_pIConstructionJoinLinks->AddJoinLink(lJoinedPointNo, lUnjoinedPointNo, lfromPointNo, ltoPointNo, lParcelNo);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIConstructionJoinLinks->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IConstructionJoinLinks) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IConstructionJoinLinks.AddJoinLink() returned %ld", (long)hr);
        goto iconstructionjoinlinks_addjoinlink_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for JoinedPointNo
    // No teardown for UnjoinedPointNo
    // No teardown for fromPointNo
    // No teardown for toPointNo
    // No teardown for ParcelNo

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iconstructionjoinlinks_addjoinlink_method_cleanup;

    iconstructionjoinlinks_addjoinlink_method_cleanup:
    self->m_HR = hr;
    // No cleanup for JoinedPointNo
    // No cleanup for UnjoinedPointNo
    // No cleanup for fromPointNo
    // No cleanup for toPointNo
    // No cleanup for ParcelNo
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IConstructionJoinLinks.AddJoinLink");
    return return_tuple;
}

static PyObject*
IConstructionJoinLinksMethod_GetJoinLink(PyIConstructionJoinLinksObject* self, PyObject* args)
{
    /* Param types that are unhandleable: 
       INPUT [u'long', u'*']
       INPUT [u'long', u'*']
       INPUT [u'long', u'*']
       INPUT [u'long', u'*']
       INPUT [u'long', u'*']
    */
    PyErr_SetString(PyExc_NotImplementedError, "Wrapper for IConstructionJoinLinks.GetJoinLink not implemented.");
    return NULL;
}

static PyObject*
IConstructionJoinLinksMethod_RemoveJoinLink(PyIConstructionJoinLinksObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long li = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &li))
      goto iconstructionjoinlinks_removejoinlink_method_cleanup;

    // Set up initial variable values as needed
    // No setup for i

    // Call method on actual COM interface
    hr = self->m_pIConstructionJoinLinks->RemoveJoinLink(li);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIConstructionJoinLinks->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IConstructionJoinLinks) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IConstructionJoinLinks.RemoveJoinLink() returned %ld", (long)hr);
        goto iconstructionjoinlinks_removejoinlink_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for i

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iconstructionjoinlinks_removejoinlink_method_cleanup;

    iconstructionjoinlinks_removejoinlink_method_cleanup:
    self->m_HR = hr;
    // No cleanup for i
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IConstructionJoinLinks.RemoveJoinLink");
    return return_tuple;
}

static PyObject*
IConstructionJoinLinksMethod_ClearJoinLinks(PyIConstructionJoinLinksObject* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pIConstructionJoinLinks->ClearJoinLinks();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIConstructionJoinLinks->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IConstructionJoinLinks) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IConstructionJoinLinks.ClearJoinLinks() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}


PyMethodDef PyIConstructionJoinLinksMethods[] = {
    {"supports", (PyCFunction)PyIConstructionJoinLinks_SupportsInterface, METH_O, ""},
    {"get_JoinLinkCount", (PyCFunction)IConstructionJoinLinksMethod_get_JoinLinkCount, METH_VARARGS, ""},
    {"AddJoinLink", (PyCFunction)IConstructionJoinLinksMethod_AddJoinLink, METH_VARARGS, ""},
    {"GetJoinLink", (PyCFunction)IConstructionJoinLinksMethod_GetJoinLink, METH_VARARGS, ""},
    {"RemoveJoinLink", (PyCFunction)IConstructionJoinLinksMethod_RemoveJoinLink, METH_VARARGS, ""},
    {"ClearJoinLinks", (PyCFunction)IConstructionJoinLinksMethod_ClearJoinLinks, METH_NOARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIConstructionJoinLinksGetSet[] = {
  {"_pUnk", (getter)PyIConstructionJoinLinks_GetpUnk, NULL, "Get opaque pointer to an Unknown from IConstructionJoinLinks", NULL},
  {"_pointer", (getter)PyIConstructionJoinLinks_GetPointer, NULL, "Get memory address for IConstructionJoinLinks", NULL},
  {"_IID", (getter)PyIConstructionJoinLinks_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIConstructionJoinLinks_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIConstructionJoinLinks_GetIgnoreFailures, (setter)PyIConstructionJoinLinks_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIConstructionJoinLinksObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.IConstructionJoinLinksObject",                          
                                              /* tp_name */
  sizeof(PyIConstructionJoinLinksObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIConstructionJoinLinksObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIConstructionJoinLinksMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIConstructionJoinLinksGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIConstructionJoinLinksObject_new,                      
                                              /* tp_new */
};

// Interface IConstructionUnbuildableLines

typedef struct PyIConstructionUnbuildableLinesObject {
    PyObject_HEAD
    IConstructionUnbuildableLines* m_pIConstructionUnbuildableLines;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIConstructionUnbuildableLinesObject;

static PyObject*
PyIConstructionUnbuildableLinesObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIConstructionUnbuildableLinesObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IConstructionUnbuildableLines* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IConstructionUnbuildableLines, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IConstructionUnbuildableLines with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIConstructionUnbuildableLinesObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IConstructionUnbuildableLines");
            return NULL;
        }
        self->m_pIConstructionUnbuildableLines = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IConstructionUnbuildableLines");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IConstructionUnbuildableLines");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IConstructionUnbuildableLines* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IConstructionUnbuildableLines, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IConstructionUnbuildableLines");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIConstructionUnbuildableLinesObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IConstructionUnbuildableLines");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIConstructionUnbuildableLines = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIConstructionUnbuildableLinesObject_dealloc(PyIConstructionUnbuildableLinesObject* self)
{
    if (self->m_pIConstructionUnbuildableLines)
        self->m_pIConstructionUnbuildableLines->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIConstructionUnbuildableLines_GetpUnk(PyIConstructionUnbuildableLinesObject* self)
{
    if (!self->m_pIConstructionUnbuildableLines)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIConstructionUnbuildableLines->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IConstructionUnbuildableLines to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIConstructionUnbuildableLines_GetPointer(PyIConstructionUnbuildableLinesObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIConstructionUnbuildableLines);
}

static PyObject*
PyIConstructionUnbuildableLines_GetIID(PyIConstructionUnbuildableLinesObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "11ea4990-32f3-4aac-b285-f70ff18c956f");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIConstructionUnbuildableLines_GetHR(PyIConstructionUnbuildableLinesObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIConstructionUnbuildableLines_GetIgnoreFailures(PyIConstructionUnbuildableLinesObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIConstructionUnbuildableLines_SetIgnoreFailures(PyIConstructionUnbuildableLinesObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIConstructionUnbuildableLines_SupportsInterface(PyIConstructionUnbuildableLinesObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIConstructionUnbuildableLines->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IConstructionUnbuildableLinesMethod_AddUnbuildableLine(PyIConstructionUnbuildableLinesObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lparentParcelNo = 0;
    long lfromPointNo = 0;
    long ltoPointNo = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "lll", &lparentParcelNo, &lfromPointNo, &ltoPointNo))
      goto iconstructionunbuildablelines_addunbuildableline_method_cleanup;

    // Set up initial variable values as needed
    // No setup for parentParcelNo
    // No setup for fromPointNo
    // No setup for toPointNo

    // Call method on actual COM interface
    hr = self->m_pIConstructionUnbuildableLines->AddUnbuildableLine(lparentParcelNo, lfromPointNo, ltoPointNo);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIConstructionUnbuildableLines->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IConstructionUnbuildableLines) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IConstructionUnbuildableLines.AddUnbuildableLine() returned %ld", (long)hr);
        goto iconstructionunbuildablelines_addunbuildableline_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for parentParcelNo
    // No teardown for fromPointNo
    // No teardown for toPointNo

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iconstructionunbuildablelines_addunbuildableline_method_cleanup;

    iconstructionunbuildablelines_addunbuildableline_method_cleanup:
    self->m_HR = hr;
    // No cleanup for parentParcelNo
    // No cleanup for fromPointNo
    // No cleanup for toPointNo
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IConstructionUnbuildableLines.AddUnbuildableLine");
    return return_tuple;
}

static PyObject*
IConstructionUnbuildableLinesMethod_RemoveUnbuildableLine(PyIConstructionUnbuildableLinesObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lparentParcelNo = 0;
    long lfromPointNo = 0;
    long ltoPointNo = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "lll", &lparentParcelNo, &lfromPointNo, &ltoPointNo))
      goto iconstructionunbuildablelines_removeunbuildableline_method_cleanup;

    // Set up initial variable values as needed
    // No setup for parentParcelNo
    // No setup for fromPointNo
    // No setup for toPointNo

    // Call method on actual COM interface
    hr = self->m_pIConstructionUnbuildableLines->RemoveUnbuildableLine(lparentParcelNo, lfromPointNo, ltoPointNo);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIConstructionUnbuildableLines->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IConstructionUnbuildableLines) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IConstructionUnbuildableLines.RemoveUnbuildableLine() returned %ld", (long)hr);
        goto iconstructionunbuildablelines_removeunbuildableline_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for parentParcelNo
    // No teardown for fromPointNo
    // No teardown for toPointNo

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iconstructionunbuildablelines_removeunbuildableline_method_cleanup;

    iconstructionunbuildablelines_removeunbuildableline_method_cleanup:
    self->m_HR = hr;
    // No cleanup for parentParcelNo
    // No cleanup for fromPointNo
    // No cleanup for toPointNo
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IConstructionUnbuildableLines.RemoveUnbuildableLine");
    return return_tuple;
}

static PyObject*
IConstructionUnbuildableLinesMethod_SetUnbuildableLines(PyIConstructionUnbuildableLinesObject* self, PyObject* args)
{
    /* Param types that are unhandleable: 
       INPUT [u'long', u'*']
       INPUT [u'long', u'*']
    */
    PyErr_SetString(PyExc_NotImplementedError, "Wrapper for IConstructionUnbuildableLines.SetUnbuildableLines not implemented.");
    return NULL;
}

static PyObject*
IConstructionUnbuildableLinesMethod_GetUnbuildableLines(PyIConstructionUnbuildableLinesObject* self, PyObject* args)
{
    /* Param types that are unhandleable: 
       INPUT [u'long', u'*']
       INPUT [u'long', u'*', u'*']
       INPUT [u'long', u'*', u'*']
    */
    PyErr_SetString(PyExc_NotImplementedError, "Wrapper for IConstructionUnbuildableLines.GetUnbuildableLines not implemented.");
    return NULL;
}

static PyObject*
IConstructionUnbuildableLinesMethod_ClearUnbuildableLines(PyIConstructionUnbuildableLinesObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lparentParcelNo = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lparentParcelNo))
      goto iconstructionunbuildablelines_clearunbuildablelines_method_cleanup;

    // Set up initial variable values as needed
    // No setup for parentParcelNo

    // Call method on actual COM interface
    hr = self->m_pIConstructionUnbuildableLines->ClearUnbuildableLines(lparentParcelNo);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIConstructionUnbuildableLines->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IConstructionUnbuildableLines) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IConstructionUnbuildableLines.ClearUnbuildableLines() returned %ld", (long)hr);
        goto iconstructionunbuildablelines_clearunbuildablelines_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for parentParcelNo

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iconstructionunbuildablelines_clearunbuildablelines_method_cleanup;

    iconstructionunbuildablelines_clearunbuildablelines_method_cleanup:
    self->m_HR = hr;
    // No cleanup for parentParcelNo
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IConstructionUnbuildableLines.ClearUnbuildableLines");
    return return_tuple;
}


PyMethodDef PyIConstructionUnbuildableLinesMethods[] = {
    {"supports", (PyCFunction)PyIConstructionUnbuildableLines_SupportsInterface, METH_O, ""},
    {"AddUnbuildableLine", (PyCFunction)IConstructionUnbuildableLinesMethod_AddUnbuildableLine, METH_VARARGS, ""},
    {"RemoveUnbuildableLine", (PyCFunction)IConstructionUnbuildableLinesMethod_RemoveUnbuildableLine, METH_VARARGS, ""},
    {"SetUnbuildableLines", (PyCFunction)IConstructionUnbuildableLinesMethod_SetUnbuildableLines, METH_VARARGS, ""},
    {"GetUnbuildableLines", (PyCFunction)IConstructionUnbuildableLinesMethod_GetUnbuildableLines, METH_VARARGS, ""},
    {"ClearUnbuildableLines", (PyCFunction)IConstructionUnbuildableLinesMethod_ClearUnbuildableLines, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIConstructionUnbuildableLinesGetSet[] = {
  {"_pUnk", (getter)PyIConstructionUnbuildableLines_GetpUnk, NULL, "Get opaque pointer to an Unknown from IConstructionUnbuildableLines", NULL},
  {"_pointer", (getter)PyIConstructionUnbuildableLines_GetPointer, NULL, "Get memory address for IConstructionUnbuildableLines", NULL},
  {"_IID", (getter)PyIConstructionUnbuildableLines_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIConstructionUnbuildableLines_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIConstructionUnbuildableLines_GetIgnoreFailures, (setter)PyIConstructionUnbuildableLines_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIConstructionUnbuildableLinesObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.IConstructionUnbuildableLinesObject",                          
                                              /* tp_name */
  sizeof(PyIConstructionUnbuildableLinesObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIConstructionUnbuildableLinesObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIConstructionUnbuildableLinesMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIConstructionUnbuildableLinesGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIConstructionUnbuildableLinesObject_new,                      
                                              /* tp_new */
};

// Interface IConstructionPoints

typedef struct PyIConstructionPointsObject {
    PyObject_HEAD
    IConstructionPoints* m_pIConstructionPoints;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIConstructionPointsObject;

static PyObject*
PyIConstructionPointsObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIConstructionPointsObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IConstructionPoints* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IConstructionPoints, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IConstructionPoints with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIConstructionPointsObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IConstructionPoints");
            return NULL;
        }
        self->m_pIConstructionPoints = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IConstructionPoints");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IConstructionPoints");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IConstructionPoints* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IConstructionPoints, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IConstructionPoints");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIConstructionPointsObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IConstructionPoints");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIConstructionPoints = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIConstructionPointsObject_dealloc(PyIConstructionPointsObject* self)
{
    if (self->m_pIConstructionPoints)
        self->m_pIConstructionPoints->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIConstructionPoints_GetpUnk(PyIConstructionPointsObject* self)
{
    if (!self->m_pIConstructionPoints)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIConstructionPoints->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IConstructionPoints to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIConstructionPoints_GetPointer(PyIConstructionPointsObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIConstructionPoints);
}

static PyObject*
PyIConstructionPoints_GetIID(PyIConstructionPointsObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "adc3412a-6ef7-41ac-bdc2-23e911c31280");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIConstructionPoints_GetHR(PyIConstructionPointsObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIConstructionPoints_GetIgnoreFailures(PyIConstructionPointsObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIConstructionPoints_SetIgnoreFailures(PyIConstructionPointsObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIConstructionPoints_SupportsInterface(PyIConstructionPointsObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIConstructionPoints->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IConstructionPointsMethod_get_ConstructionPointCount(PyIConstructionPointsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pCount

    // Call method on actual COM interface
    hr = self->m_pIConstructionPoints->get_ConstructionPointCount(&lpCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIConstructionPoints->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IConstructionPoints) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IConstructionPoints.get_ConstructionPointCount() returned %ld", (long)hr);
        goto iconstructionpoints_get_constructionpointcount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pCount

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpCount);
    goto iconstructionpoints_get_constructionpointcount_method_cleanup;

    iconstructionpoints_get_constructionpointcount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pCount
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IConstructionPoints.get_ConstructionPointCount");
    return return_tuple;
}

static PyObject*
IConstructionPointsMethod_GetConstructionPoint(PyIConstructionPointsObject* self, PyObject* args)
{
    /* Param types that are unhandleable: 
       INPUT [u'long', u'*']
       INPUT [u'double', u'*']
       INPUT [u'double', u'*']
    */
    PyErr_SetString(PyExc_NotImplementedError, "Wrapper for IConstructionPoints.GetConstructionPoint not implemented.");
    return NULL;
}

static PyObject*
IConstructionPointsMethod_AddConstructionPoint(PyIConstructionPointsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lUnjoinedPointNo = 0;
    double dx = 0;
    double dy = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "ldd", &lUnjoinedPointNo, &dx, &dy))
      goto iconstructionpoints_addconstructionpoint_method_cleanup;

    // Set up initial variable values as needed
    // No setup for UnjoinedPointNo
    // No setup for x
    // No setup for y

    // Call method on actual COM interface
    hr = self->m_pIConstructionPoints->AddConstructionPoint(lUnjoinedPointNo, dx, dy);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIConstructionPoints->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IConstructionPoints) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IConstructionPoints.AddConstructionPoint() returned %ld", (long)hr);
        goto iconstructionpoints_addconstructionpoint_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for UnjoinedPointNo
    // No teardown for x
    // No teardown for y

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iconstructionpoints_addconstructionpoint_method_cleanup;

    iconstructionpoints_addconstructionpoint_method_cleanup:
    self->m_HR = hr;
    // No cleanup for UnjoinedPointNo
    // No cleanup for x
    // No cleanup for y
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IConstructionPoints.AddConstructionPoint");
    return return_tuple;
}

static PyObject*
IConstructionPointsMethod_FindConstructionPoint(PyIConstructionPointsObject* self, PyObject* args)
{
    /* Param types that are unhandleable: 
       INPUT [u'double', u'*']
       INPUT [u'double', u'*']
    */
    PyErr_SetString(PyExc_NotImplementedError, "Wrapper for IConstructionPoints.FindConstructionPoint not implemented.");
    return NULL;
}

static PyObject*
IConstructionPointsMethod_RemoveConstructionPoint(PyIConstructionPointsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lUnjoinedPointNo = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lUnjoinedPointNo))
      goto iconstructionpoints_removeconstructionpoint_method_cleanup;

    // Set up initial variable values as needed
    // No setup for UnjoinedPointNo

    // Call method on actual COM interface
    hr = self->m_pIConstructionPoints->RemoveConstructionPoint(lUnjoinedPointNo);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIConstructionPoints->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IConstructionPoints) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IConstructionPoints.RemoveConstructionPoint() returned %ld", (long)hr);
        goto iconstructionpoints_removeconstructionpoint_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for UnjoinedPointNo

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iconstructionpoints_removeconstructionpoint_method_cleanup;

    iconstructionpoints_removeconstructionpoint_method_cleanup:
    self->m_HR = hr;
    // No cleanup for UnjoinedPointNo
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IConstructionPoints.RemoveConstructionPoint");
    return return_tuple;
}

static PyObject*
IConstructionPointsMethod_ClearConstructionPoints(PyIConstructionPointsObject* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pIConstructionPoints->ClearConstructionPoints();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIConstructionPoints->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IConstructionPoints) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IConstructionPoints.ClearConstructionPoints() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}


PyMethodDef PyIConstructionPointsMethods[] = {
    {"supports", (PyCFunction)PyIConstructionPoints_SupportsInterface, METH_O, ""},
    {"get_ConstructionPointCount", (PyCFunction)IConstructionPointsMethod_get_ConstructionPointCount, METH_VARARGS, ""},
    {"GetConstructionPoint", (PyCFunction)IConstructionPointsMethod_GetConstructionPoint, METH_VARARGS, ""},
    {"AddConstructionPoint", (PyCFunction)IConstructionPointsMethod_AddConstructionPoint, METH_VARARGS, ""},
    {"FindConstructionPoint", (PyCFunction)IConstructionPointsMethod_FindConstructionPoint, METH_VARARGS, ""},
    {"RemoveConstructionPoint", (PyCFunction)IConstructionPointsMethod_RemoveConstructionPoint, METH_VARARGS, ""},
    {"ClearConstructionPoints", (PyCFunction)IConstructionPointsMethod_ClearConstructionPoints, METH_NOARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIConstructionPointsGetSet[] = {
  {"_pUnk", (getter)PyIConstructionPoints_GetpUnk, NULL, "Get opaque pointer to an Unknown from IConstructionPoints", NULL},
  {"_pointer", (getter)PyIConstructionPoints_GetPointer, NULL, "Get memory address for IConstructionPoints", NULL},
  {"_IID", (getter)PyIConstructionPoints_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIConstructionPoints_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIConstructionPoints_GetIgnoreFailures, (setter)PyIConstructionPoints_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIConstructionPointsObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.IConstructionPointsObject",                          
                                              /* tp_name */
  sizeof(PyIConstructionPointsObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIConstructionPointsObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIConstructionPointsMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIConstructionPointsGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIConstructionPointsObject_new,                      
                                              /* tp_new */
};

// Interface IConstructionAdjustment

typedef struct PyIConstructionAdjustmentObject {
    PyObject_HEAD
    IConstructionAdjustment* m_pIConstructionAdjustment;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIConstructionAdjustmentObject;

static PyObject*
PyIConstructionAdjustmentObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIConstructionAdjustmentObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IConstructionAdjustment* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IConstructionAdjustment, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IConstructionAdjustment with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIConstructionAdjustmentObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IConstructionAdjustment");
            return NULL;
        }
        self->m_pIConstructionAdjustment = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IConstructionAdjustment");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IConstructionAdjustment");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IConstructionAdjustment* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IConstructionAdjustment, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IConstructionAdjustment");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIConstructionAdjustmentObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IConstructionAdjustment");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIConstructionAdjustment = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIConstructionAdjustmentObject_dealloc(PyIConstructionAdjustmentObject* self)
{
    if (self->m_pIConstructionAdjustment)
        self->m_pIConstructionAdjustment->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIConstructionAdjustment_GetpUnk(PyIConstructionAdjustmentObject* self)
{
    if (!self->m_pIConstructionAdjustment)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIConstructionAdjustment->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IConstructionAdjustment to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIConstructionAdjustment_GetPointer(PyIConstructionAdjustmentObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIConstructionAdjustment);
}

static PyObject*
PyIConstructionAdjustment_GetIID(PyIConstructionAdjustmentObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "cb760247-e82a-4666-a79e-a6f1f6bf2845");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIConstructionAdjustment_GetHR(PyIConstructionAdjustmentObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIConstructionAdjustment_GetIgnoreFailures(PyIConstructionAdjustmentObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIConstructionAdjustment_SetIgnoreFailures(PyIConstructionAdjustmentObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIConstructionAdjustment_SupportsInterface(PyIConstructionAdjustmentObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIConstructionAdjustment->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IConstructionAdjustmentMethod_get_AdjustmentMethod(PyIConstructionAdjustmentObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriParcelAdjustmentType eType;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Type

    // Call method on actual COM interface
    hr = self->m_pIConstructionAdjustment->get_AdjustmentMethod(&eType);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIConstructionAdjustment->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IConstructionAdjustment) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IConstructionAdjustment.get_AdjustmentMethod() returned %ld", (long)hr);
        goto iconstructionadjustment_get_adjustmentmethod_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Type

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)eType);
    goto iconstructionadjustment_get_adjustmentmethod_method_cleanup;

    iconstructionadjustment_get_adjustmentmethod_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Type
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IConstructionAdjustment.get_AdjustmentMethod");
    return return_tuple;
}

static PyObject*
IConstructionAdjustmentMethod_put_AdjustmentMethod(PyIConstructionAdjustmentObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriParcelAdjustmentType eType;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&eType))
      goto iconstructionadjustment_put_adjustmentmethod_method_cleanup;

    // Set up initial variable values as needed
    // No setup for Type

    // Call method on actual COM interface
    hr = self->m_pIConstructionAdjustment->put_AdjustmentMethod(eType);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIConstructionAdjustment->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IConstructionAdjustment) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IConstructionAdjustment.put_AdjustmentMethod() returned %ld", (long)hr);
        goto iconstructionadjustment_put_adjustmentmethod_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Type

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iconstructionadjustment_put_adjustmentmethod_method_cleanup;

    iconstructionadjustment_put_adjustmentmethod_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Type
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IConstructionAdjustment.put_AdjustmentMethod");
    return return_tuple;
}

static PyObject*
IConstructionAdjustmentMethod_GetStartPoint(PyIConstructionAdjustmentObject* self, PyObject* args)
{
    /* Param types that are unhandleable: 
       INPUT [u'long', u'*']
       INPUT [u'double', u'*']
       INPUT [u'double', u'*']
    */
    PyErr_SetString(PyExc_NotImplementedError, "Wrapper for IConstructionAdjustment.GetStartPoint not implemented.");
    return NULL;
}

static PyObject*
IConstructionAdjustmentMethod_GetEndPoint(PyIConstructionAdjustmentObject* self, PyObject* args)
{
    /* Param types that are unhandleable: 
       INPUT [u'long', u'*']
       INPUT [u'double', u'*']
       INPUT [u'double', u'*']
    */
    PyErr_SetString(PyExc_NotImplementedError, "Wrapper for IConstructionAdjustment.GetEndPoint not implemented.");
    return NULL;
}

static PyObject*
IConstructionAdjustmentMethod_SetStartPoint(PyIConstructionAdjustmentObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lUnjoinedPointNo = 0;
    double dx = 0;
    double dy = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "ldd", &lUnjoinedPointNo, &dx, &dy))
      goto iconstructionadjustment_setstartpoint_method_cleanup;

    // Set up initial variable values as needed
    // No setup for UnjoinedPointNo
    // No setup for x
    // No setup for y

    // Call method on actual COM interface
    hr = self->m_pIConstructionAdjustment->SetStartPoint(lUnjoinedPointNo, dx, dy);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIConstructionAdjustment->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IConstructionAdjustment) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IConstructionAdjustment.SetStartPoint() returned %ld", (long)hr);
        goto iconstructionadjustment_setstartpoint_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for UnjoinedPointNo
    // No teardown for x
    // No teardown for y

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iconstructionadjustment_setstartpoint_method_cleanup;

    iconstructionadjustment_setstartpoint_method_cleanup:
    self->m_HR = hr;
    // No cleanup for UnjoinedPointNo
    // No cleanup for x
    // No cleanup for y
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IConstructionAdjustment.SetStartPoint");
    return return_tuple;
}

static PyObject*
IConstructionAdjustmentMethod_SetEndPoint(PyIConstructionAdjustmentObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lUnjoinedPointNo = 0;
    double dx = 0;
    double dy = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "ldd", &lUnjoinedPointNo, &dx, &dy))
      goto iconstructionadjustment_setendpoint_method_cleanup;

    // Set up initial variable values as needed
    // No setup for UnjoinedPointNo
    // No setup for x
    // No setup for y

    // Call method on actual COM interface
    hr = self->m_pIConstructionAdjustment->SetEndPoint(lUnjoinedPointNo, dx, dy);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIConstructionAdjustment->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IConstructionAdjustment) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IConstructionAdjustment.SetEndPoint() returned %ld", (long)hr);
        goto iconstructionadjustment_setendpoint_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for UnjoinedPointNo
    // No teardown for x
    // No teardown for y

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iconstructionadjustment_setendpoint_method_cleanup;

    iconstructionadjustment_setendpoint_method_cleanup:
    self->m_HR = hr;
    // No cleanup for UnjoinedPointNo
    // No cleanup for x
    // No cleanup for y
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IConstructionAdjustment.SetEndPoint");
    return return_tuple;
}


PyMethodDef PyIConstructionAdjustmentMethods[] = {
    {"supports", (PyCFunction)PyIConstructionAdjustment_SupportsInterface, METH_O, ""},
    {"get_AdjustmentMethod", (PyCFunction)IConstructionAdjustmentMethod_get_AdjustmentMethod, METH_VARARGS, ""},
    {"put_AdjustmentMethod", (PyCFunction)IConstructionAdjustmentMethod_put_AdjustmentMethod, METH_VARARGS, ""},
    {"GetStartPoint", (PyCFunction)IConstructionAdjustmentMethod_GetStartPoint, METH_VARARGS, ""},
    {"GetEndPoint", (PyCFunction)IConstructionAdjustmentMethod_GetEndPoint, METH_VARARGS, ""},
    {"SetStartPoint", (PyCFunction)IConstructionAdjustmentMethod_SetStartPoint, METH_VARARGS, ""},
    {"SetEndPoint", (PyCFunction)IConstructionAdjustmentMethod_SetEndPoint, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIConstructionAdjustmentGetSet[] = {
  {"_pUnk", (getter)PyIConstructionAdjustment_GetpUnk, NULL, "Get opaque pointer to an Unknown from IConstructionAdjustment", NULL},
  {"_pointer", (getter)PyIConstructionAdjustment_GetPointer, NULL, "Get memory address for IConstructionAdjustment", NULL},
  {"_IID", (getter)PyIConstructionAdjustment_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIConstructionAdjustment_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIConstructionAdjustment_GetIgnoreFailures, (setter)PyIConstructionAdjustment_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIConstructionAdjustmentObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.IConstructionAdjustmentObject",                          
                                              /* tp_name */
  sizeof(PyIConstructionAdjustmentObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIConstructionAdjustmentObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIConstructionAdjustmentMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIConstructionAdjustmentGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIConstructionAdjustmentObject_new,                      
                                              /* tp_new */
};

// Interface ILineResequencer

typedef struct PyILineResequencerObject {
    PyObject_HEAD
    ILineResequencer* m_pILineResequencer;
    HRESULT m_HR;
    int m_ignore_failures;
} PyILineResequencerObject;

static PyObject*
PyILineResequencerObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyILineResequencerObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ILineResequencer* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ILineResequencer, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ILineResequencer with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyILineResequencerObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ILineResequencer");
            return NULL;
        }
        self->m_pILineResequencer = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ILineResequencer");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ILineResequencer");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ILineResequencer* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ILineResequencer, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ILineResequencer");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyILineResequencerObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ILineResequencer");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pILineResequencer = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyILineResequencerObject_dealloc(PyILineResequencerObject* self)
{
    if (self->m_pILineResequencer)
        self->m_pILineResequencer->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyILineResequencer_GetpUnk(PyILineResequencerObject* self)
{
    if (!self->m_pILineResequencer)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pILineResequencer->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ILineResequencer to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyILineResequencer_GetPointer(PyILineResequencerObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pILineResequencer);
}

static PyObject*
PyILineResequencer_GetIID(PyILineResequencerObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "5d89097e-23de-41aa-ad16-284f362bef9a");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyILineResequencer_GetHR(PyILineResequencerObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyILineResequencer_GetIgnoreFailures(PyILineResequencerObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyILineResequencer_SetIgnoreFailures(PyILineResequencerObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyILineResequencer_SupportsInterface(PyILineResequencerObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pILineResequencer->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ILineResequencerMethod_Empty(PyILineResequencerObject* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pILineResequencer->Empty();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILineResequencer->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILineResequencer) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILineResequencer.Empty() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}

static PyObject*
ILineResequencerMethod_AddLine(PyILineResequencerObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ICurve* ippLine = NULL;
    PyObject* py_pLine;
    long llineID = 0;
    esriCadastralLineCategory eeCategory;

    // Unpack values
    if (!PyArg_ParseTuple(args, "Oli", &py_pLine, &llineID, (int *)&eeCategory))
      goto ilineresequencer_addline_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pLine, &IID_ICurve, (void**)&ippLine))
        PyErr_SetString(PyExc_TypeError, "Argument pLine (position 0) is not ICurve");
    
    if (PyErr_Occurred())
      goto ilineresequencer_addline_method_cleanup;
    
    // No setup for lineID
    // No setup for eCategory

    // Call method on actual COM interface
    hr = self->m_pILineResequencer->AddLine(ippLine, llineID, eeCategory);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILineResequencer->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILineResequencer) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILineResequencer.AddLine() returned %ld", (long)hr);
        goto ilineresequencer_addline_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pLine
    // No teardown for lineID
    // No teardown for eCategory

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ilineresequencer_addline_method_cleanup;

    ilineresequencer_addline_method_cleanup:
    self->m_HR = hr;
    if (ippLine)
      ippLine->Release();
    // No cleanup for lineID
    // No cleanup for eCategory
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILineResequencer.AddLine");
    return return_tuple;
}

static PyObject*
ILineResequencerMethod_Sort(PyILineResequencerObject* self, PyObject* args)
{
    /* Param types that are unhandleable: 
       INPUT [u'ILongArray', u'*', u'*']
       INPUT [u'ILongArray', u'*', u'*']
       INPUT [u'IGeometry', u'*', u'*']
       INPUT [u'VARIANT_BOOL', u'*']
    */
    PyErr_SetString(PyExc_NotImplementedError, "Wrapper for ILineResequencer.Sort not implemented.");
    return NULL;
}


PyMethodDef PyILineResequencerMethods[] = {
    {"supports", (PyCFunction)PyILineResequencer_SupportsInterface, METH_O, ""},
    {"Empty", (PyCFunction)ILineResequencerMethod_Empty, METH_NOARGS, ""},
    {"AddLine", (PyCFunction)ILineResequencerMethod_AddLine, METH_VARARGS, ""},
    {"Sort", (PyCFunction)ILineResequencerMethod_Sort, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyILineResequencerGetSet[] = {
  {"_pUnk", (getter)PyILineResequencer_GetpUnk, NULL, "Get opaque pointer to an Unknown from ILineResequencer", NULL},
  {"_pointer", (getter)PyILineResequencer_GetPointer, NULL, "Get memory address for ILineResequencer", NULL},
  {"_IID", (getter)PyILineResequencer_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyILineResequencer_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyILineResequencer_GetIgnoreFailures, (setter)PyILineResequencer_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyILineResequencerObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.ILineResequencerObject",                          
                                              /* tp_name */
  sizeof(PyILineResequencerObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyILineResequencerObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyILineResequencerMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyILineResequencerGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyILineResequencerObject_new,                      
                                              /* tp_new */
};

// Interface ICadastralFabricRegeneration

typedef struct PyICadastralFabricRegenerationObject {
    PyObject_HEAD
    ICadastralFabricRegeneration* m_pICadastralFabricRegeneration;
    HRESULT m_HR;
    int m_ignore_failures;
} PyICadastralFabricRegenerationObject;

static PyObject*
PyICadastralFabricRegenerationObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyICadastralFabricRegenerationObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ICadastralFabricRegeneration* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ICadastralFabricRegeneration, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ICadastralFabricRegeneration with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyICadastralFabricRegenerationObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ICadastralFabricRegeneration");
            return NULL;
        }
        self->m_pICadastralFabricRegeneration = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ICadastralFabricRegeneration");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ICadastralFabricRegeneration");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ICadastralFabricRegeneration* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ICadastralFabricRegeneration, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ICadastralFabricRegeneration");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyICadastralFabricRegenerationObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ICadastralFabricRegeneration");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pICadastralFabricRegeneration = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyICadastralFabricRegenerationObject_dealloc(PyICadastralFabricRegenerationObject* self)
{
    if (self->m_pICadastralFabricRegeneration)
        self->m_pICadastralFabricRegeneration->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyICadastralFabricRegeneration_GetpUnk(PyICadastralFabricRegenerationObject* self)
{
    if (!self->m_pICadastralFabricRegeneration)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pICadastralFabricRegeneration->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ICadastralFabricRegeneration to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyICadastralFabricRegeneration_GetPointer(PyICadastralFabricRegenerationObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pICadastralFabricRegeneration);
}

static PyObject*
PyICadastralFabricRegeneration_GetIID(PyICadastralFabricRegenerationObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "98319c51-d6cf-45c9-b8e7-0cae17d55476");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyICadastralFabricRegeneration_GetHR(PyICadastralFabricRegenerationObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyICadastralFabricRegeneration_GetIgnoreFailures(PyICadastralFabricRegenerationObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyICadastralFabricRegeneration_SetIgnoreFailures(PyICadastralFabricRegenerationObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyICadastralFabricRegeneration_SupportsInterface(PyICadastralFabricRegenerationObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pICadastralFabricRegeneration->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ICadastralFabricRegenerationMethod_putref_CadastralFabric(PyICadastralFabricRegenerationObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ICadastralFabric* ipppCadastralFabric = NULL;
    PyObject* py_ppCadastralFabric;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_ppCadastralFabric))
      goto icadastralfabricregeneration_putref_cadastralfabric_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_ppCadastralFabric, &IID_ICadastralFabric, (void**)&ipppCadastralFabric))
        PyErr_SetString(PyExc_TypeError, "Argument ppCadastralFabric (position 0) is not ICadastralFabric");
    
    if (PyErr_Occurred())
      goto icadastralfabricregeneration_putref_cadastralfabric_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pICadastralFabricRegeneration->putref_CadastralFabric(ipppCadastralFabric);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadastralFabricRegeneration->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadastralFabricRegeneration) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadastralFabricRegeneration.putref_CadastralFabric() returned %ld", (long)hr);
        goto icadastralfabricregeneration_putref_cadastralfabric_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ppCadastralFabric

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icadastralfabricregeneration_putref_cadastralfabric_method_cleanup;

    icadastralfabricregeneration_putref_cadastralfabric_method_cleanup:
    self->m_HR = hr;
    if (ipppCadastralFabric)
      ipppCadastralFabric->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadastralFabricRegeneration.putref_CadastralFabric");
    return return_tuple;
}

static PyObject*
ICadastralFabricRegenerationMethod_get_CadastralFabric(PyICadastralFabricRegenerationObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ICadastralFabric* ipppCadastralFabric = NULL;
    PyObject* py_ppCadastralFabric = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppCadastralFabric

    // Call method on actual COM interface
    hr = self->m_pICadastralFabricRegeneration->get_CadastralFabric(&ipppCadastralFabric);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadastralFabricRegeneration->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadastralFabricRegeneration) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadastralFabricRegeneration.get_CadastralFabric() returned %ld", (long)hr);
        goto icadastralfabricregeneration_get_cadastralfabric_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppCadastralFabric);
    if (ipppCadastralFabric)
    {
        IUnknown* pUnk = NULL;
        ipppCadastralFabric->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppCadastralFabric = IUnknownToPythonIIDObject(pUnk, &IID_ICadastralFabric);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppCadastralFabric)
    {
        if (py_ppCadastralFabric)
           Py_DECREF(py_ppCadastralFabric);
        py_ppCadastralFabric = Py_None;
        Py_INCREF(py_ppCadastralFabric);
    }
    if (PyErr_Occurred())
      goto icadastralfabricregeneration_get_cadastralfabric_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppCadastralFabric);
    goto icadastralfabricregeneration_get_cadastralfabric_method_cleanup;

    icadastralfabricregeneration_get_cadastralfabric_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppCadastralFabric);
    if (ipppCadastralFabric)
      ipppCadastralFabric->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadastralFabricRegeneration.get_CadastralFabric");
    return return_tuple;
}

static PyObject*
ICadastralFabricRegenerationMethod_put_RegeneratorBitmask(PyICadastralFabricRegenerationObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpRegeneratorBitmask = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lpRegeneratorBitmask))
      goto icadastralfabricregeneration_put_regeneratorbitmask_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pRegeneratorBitmask

    // Call method on actual COM interface
    hr = self->m_pICadastralFabricRegeneration->put_RegeneratorBitmask(lpRegeneratorBitmask);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadastralFabricRegeneration->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadastralFabricRegeneration) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadastralFabricRegeneration.put_RegeneratorBitmask() returned %ld", (long)hr);
        goto icadastralfabricregeneration_put_regeneratorbitmask_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pRegeneratorBitmask

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icadastralfabricregeneration_put_regeneratorbitmask_method_cleanup;

    icadastralfabricregeneration_put_regeneratorbitmask_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pRegeneratorBitmask
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadastralFabricRegeneration.put_RegeneratorBitmask");
    return return_tuple;
}

static PyObject*
ICadastralFabricRegenerationMethod_get_RegeneratorBitmask(PyICadastralFabricRegenerationObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpRegeneratorBitmask = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pRegeneratorBitmask

    // Call method on actual COM interface
    hr = self->m_pICadastralFabricRegeneration->get_RegeneratorBitmask(&lpRegeneratorBitmask);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadastralFabricRegeneration->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadastralFabricRegeneration) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadastralFabricRegeneration.get_RegeneratorBitmask() returned %ld", (long)hr);
        goto icadastralfabricregeneration_get_regeneratorbitmask_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pRegeneratorBitmask

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpRegeneratorBitmask);
    goto icadastralfabricregeneration_get_regeneratorbitmask_method_cleanup;

    icadastralfabricregeneration_get_regeneratorbitmask_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pRegeneratorBitmask
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadastralFabricRegeneration.get_RegeneratorBitmask");
    return return_tuple;
}

static PyObject*
ICadastralFabricRegenerationMethod_RegenerateParcels(PyICadastralFabricRegenerationObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IFIDSet* ippParcelsToRegenerate = NULL;
    PyObject* py_pParcelsToRegenerate;
    VARIANT_BOOL b_regeneratePoints = VARIANT_FALSE;
    PyObject* pyvar_regeneratePoints = NULL;
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOO", &py_pParcelsToRegenerate, &pyvar_regeneratePoints, &py_pTrackCancel))
      goto icadastralfabricregeneration_regenerateparcels_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pParcelsToRegenerate, &IID_IFIDSet, (void**)&ippParcelsToRegenerate))
        PyErr_SetString(PyExc_TypeError, "Argument pParcelsToRegenerate (position 0) is not IFIDSet");
    
    if (PyErr_Occurred())
      goto icadastralfabricregeneration_regenerateparcels_method_cleanup;
    
    b_regeneratePoints = ((PyObject_IsTrue(pyvar_regeneratePoints) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto icadastralfabricregeneration_regenerateparcels_method_cleanup;
    
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 2) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto icadastralfabricregeneration_regenerateparcels_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pICadastralFabricRegeneration->RegenerateParcels(ippParcelsToRegenerate, b_regeneratePoints, ippTrackCancel);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadastralFabricRegeneration->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadastralFabricRegeneration) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadastralFabricRegeneration.RegenerateParcels() returned %ld", (long)hr);
        goto icadastralfabricregeneration_regenerateparcels_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pParcelsToRegenerate
    // No teardown for regeneratePoints
    // No teardown for pTrackCancel

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icadastralfabricregeneration_regenerateparcels_method_cleanup;

    icadastralfabricregeneration_regenerateparcels_method_cleanup:
    self->m_HR = hr;
    if (ippParcelsToRegenerate)
      ippParcelsToRegenerate->Release();
    // No cleanup for regeneratePoints
    if (ippTrackCancel)
      ippTrackCancel->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadastralFabricRegeneration.RegenerateParcels");
    return return_tuple;
}

static PyObject*
ICadastralFabricRegenerationMethod_RegenerateAllParcels(PyICadastralFabricRegenerationObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_regeneratePoints = VARIANT_FALSE;
    PyObject* pyvar_regeneratePoints = NULL;
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OO", &pyvar_regeneratePoints, &py_pTrackCancel))
      goto icadastralfabricregeneration_regenerateallparcels_method_cleanup;

    // Set up initial variable values as needed
    b_regeneratePoints = ((PyObject_IsTrue(pyvar_regeneratePoints) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto icadastralfabricregeneration_regenerateallparcels_method_cleanup;
    
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 1) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto icadastralfabricregeneration_regenerateallparcels_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pICadastralFabricRegeneration->RegenerateAllParcels(b_regeneratePoints, ippTrackCancel);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadastralFabricRegeneration->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadastralFabricRegeneration) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadastralFabricRegeneration.RegenerateAllParcels() returned %ld", (long)hr);
        goto icadastralfabricregeneration_regenerateallparcels_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for regeneratePoints
    // No teardown for pTrackCancel

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icadastralfabricregeneration_regenerateallparcels_method_cleanup;

    icadastralfabricregeneration_regenerateallparcels_method_cleanup:
    self->m_HR = hr;
    // No cleanup for regeneratePoints
    if (ippTrackCancel)
      ippTrackCancel->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadastralFabricRegeneration.RegenerateAllParcels");
    return return_tuple;
}

static PyObject*
ICadastralFabricRegenerationMethod_RegenerateControlPoints(PyICadastralFabricRegenerationObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IFIDSet* ippControlPointsToRegenerate = NULL;
    PyObject* py_pControlPointsToRegenerate;
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OO", &py_pControlPointsToRegenerate, &py_pTrackCancel))
      goto icadastralfabricregeneration_regeneratecontrolpoints_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pControlPointsToRegenerate, &IID_IFIDSet, (void**)&ippControlPointsToRegenerate))
        PyErr_SetString(PyExc_TypeError, "Argument pControlPointsToRegenerate (position 0) is not IFIDSet");
    
    if (PyErr_Occurred())
      goto icadastralfabricregeneration_regeneratecontrolpoints_method_cleanup;
    
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 1) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto icadastralfabricregeneration_regeneratecontrolpoints_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pICadastralFabricRegeneration->RegenerateControlPoints(ippControlPointsToRegenerate, ippTrackCancel);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadastralFabricRegeneration->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadastralFabricRegeneration) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadastralFabricRegeneration.RegenerateControlPoints() returned %ld", (long)hr);
        goto icadastralfabricregeneration_regeneratecontrolpoints_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pControlPointsToRegenerate
    // No teardown for pTrackCancel

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icadastralfabricregeneration_regeneratecontrolpoints_method_cleanup;

    icadastralfabricregeneration_regeneratecontrolpoints_method_cleanup:
    self->m_HR = hr;
    if (ippControlPointsToRegenerate)
      ippControlPointsToRegenerate->Release();
    if (ippTrackCancel)
      ippTrackCancel->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadastralFabricRegeneration.RegenerateControlPoints");
    return return_tuple;
}

static PyObject*
ICadastralFabricRegenerationMethod_RegenerateAllControlPoints(PyICadastralFabricRegenerationObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_pTrackCancel))
      goto icadastralfabricregeneration_regenerateallcontrolpoints_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 0) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto icadastralfabricregeneration_regenerateallcontrolpoints_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pICadastralFabricRegeneration->RegenerateAllControlPoints(ippTrackCancel);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadastralFabricRegeneration->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadastralFabricRegeneration) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadastralFabricRegeneration.RegenerateAllControlPoints() returned %ld", (long)hr);
        goto icadastralfabricregeneration_regenerateallcontrolpoints_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pTrackCancel

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icadastralfabricregeneration_regenerateallcontrolpoints_method_cleanup;

    icadastralfabricregeneration_regenerateallcontrolpoints_method_cleanup:
    self->m_HR = hr;
    if (ippTrackCancel)
      ippTrackCancel->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadastralFabricRegeneration.RegenerateAllControlPoints");
    return return_tuple;
}

static PyObject*
ICadastralFabricRegenerationMethod_RegenerateEntireFabric(PyICadastralFabricRegenerationObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_pTrackCancel))
      goto icadastralfabricregeneration_regenerateentirefabric_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 0) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto icadastralfabricregeneration_regenerateentirefabric_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pICadastralFabricRegeneration->RegenerateEntireFabric(ippTrackCancel);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadastralFabricRegeneration->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadastralFabricRegeneration) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadastralFabricRegeneration.RegenerateEntireFabric() returned %ld", (long)hr);
        goto icadastralfabricregeneration_regenerateentirefabric_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pTrackCancel

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icadastralfabricregeneration_regenerateentirefabric_method_cleanup;

    icadastralfabricregeneration_regenerateentirefabric_method_cleanup:
    self->m_HR = hr;
    if (ippTrackCancel)
      ippTrackCancel->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadastralFabricRegeneration.RegenerateEntireFabric");
    return return_tuple;
}

static PyObject*
ICadastralFabricRegenerationMethod_RegenerateMissingPoints(PyICadastralFabricRegenerationObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_pTrackCancel))
      goto icadastralfabricregeneration_regeneratemissingpoints_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 0) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto icadastralfabricregeneration_regeneratemissingpoints_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pICadastralFabricRegeneration->RegenerateMissingPoints(ippTrackCancel);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadastralFabricRegeneration->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadastralFabricRegeneration) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadastralFabricRegeneration.RegenerateMissingPoints() returned %ld", (long)hr);
        goto icadastralfabricregeneration_regeneratemissingpoints_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pTrackCancel

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icadastralfabricregeneration_regeneratemissingpoints_method_cleanup;

    icadastralfabricregeneration_regeneratemissingpoints_method_cleanup:
    self->m_HR = hr;
    if (ippTrackCancel)
      ippTrackCancel->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadastralFabricRegeneration.RegenerateMissingPoints");
    return return_tuple;
}


PyMethodDef PyICadastralFabricRegenerationMethods[] = {
    {"supports", (PyCFunction)PyICadastralFabricRegeneration_SupportsInterface, METH_O, ""},
    {"putref_CadastralFabric", (PyCFunction)ICadastralFabricRegenerationMethod_putref_CadastralFabric, METH_VARARGS, ""},
    {"get_CadastralFabric", (PyCFunction)ICadastralFabricRegenerationMethod_get_CadastralFabric, METH_VARARGS, ""},
    {"put_RegeneratorBitmask", (PyCFunction)ICadastralFabricRegenerationMethod_put_RegeneratorBitmask, METH_VARARGS, ""},
    {"get_RegeneratorBitmask", (PyCFunction)ICadastralFabricRegenerationMethod_get_RegeneratorBitmask, METH_VARARGS, ""},
    {"RegenerateParcels", (PyCFunction)ICadastralFabricRegenerationMethod_RegenerateParcels, METH_VARARGS, ""},
    {"RegenerateAllParcels", (PyCFunction)ICadastralFabricRegenerationMethod_RegenerateAllParcels, METH_VARARGS, ""},
    {"RegenerateControlPoints", (PyCFunction)ICadastralFabricRegenerationMethod_RegenerateControlPoints, METH_VARARGS, ""},
    {"RegenerateAllControlPoints", (PyCFunction)ICadastralFabricRegenerationMethod_RegenerateAllControlPoints, METH_VARARGS, ""},
    {"RegenerateEntireFabric", (PyCFunction)ICadastralFabricRegenerationMethod_RegenerateEntireFabric, METH_VARARGS, ""},
    {"RegenerateMissingPoints", (PyCFunction)ICadastralFabricRegenerationMethod_RegenerateMissingPoints, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyICadastralFabricRegenerationGetSet[] = {
  {"_pUnk", (getter)PyICadastralFabricRegeneration_GetpUnk, NULL, "Get opaque pointer to an Unknown from ICadastralFabricRegeneration", NULL},
  {"_pointer", (getter)PyICadastralFabricRegeneration_GetPointer, NULL, "Get memory address for ICadastralFabricRegeneration", NULL},
  {"_IID", (getter)PyICadastralFabricRegeneration_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyICadastralFabricRegeneration_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyICadastralFabricRegeneration_GetIgnoreFailures, (setter)PyICadastralFabricRegeneration_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyICadastralFabricRegenerationObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.ICadastralFabricRegenerationObject",                          
                                              /* tp_name */
  sizeof(PyICadastralFabricRegenerationObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyICadastralFabricRegenerationObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyICadastralFabricRegenerationMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyICadastralFabricRegenerationGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyICadastralFabricRegenerationObject_new,                      
                                              /* tp_new */
};

// Interface ICadastralUnitConversion

typedef struct PyICadastralUnitConversionObject {
    PyObject_HEAD
    ICadastralUnitConversion* m_pICadastralUnitConversion;
    HRESULT m_HR;
    int m_ignore_failures;
} PyICadastralUnitConversionObject;

static PyObject*
PyICadastralUnitConversionObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyICadastralUnitConversionObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ICadastralUnitConversion* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ICadastralUnitConversion, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ICadastralUnitConversion with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyICadastralUnitConversionObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ICadastralUnitConversion");
            return NULL;
        }
        self->m_pICadastralUnitConversion = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ICadastralUnitConversion");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ICadastralUnitConversion");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ICadastralUnitConversion* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ICadastralUnitConversion, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ICadastralUnitConversion");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyICadastralUnitConversionObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ICadastralUnitConversion");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pICadastralUnitConversion = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyICadastralUnitConversionObject_dealloc(PyICadastralUnitConversionObject* self)
{
    if (self->m_pICadastralUnitConversion)
        self->m_pICadastralUnitConversion->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyICadastralUnitConversion_GetpUnk(PyICadastralUnitConversionObject* self)
{
    if (!self->m_pICadastralUnitConversion)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pICadastralUnitConversion->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ICadastralUnitConversion to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyICadastralUnitConversion_GetPointer(PyICadastralUnitConversionObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pICadastralUnitConversion);
}

static PyObject*
PyICadastralUnitConversion_GetIID(PyICadastralUnitConversionObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "f8b45123-3fd5-4f0b-bfa0-f81ae0a79df9");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyICadastralUnitConversion_GetHR(PyICadastralUnitConversionObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyICadastralUnitConversion_GetIgnoreFailures(PyICadastralUnitConversionObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyICadastralUnitConversion_SetIgnoreFailures(PyICadastralUnitConversionObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyICadastralUnitConversion_SupportsInterface(PyICadastralUnitConversionObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pICadastralUnitConversion->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ICadastralUnitConversionMethod_get_DistanceUnitType(PyICadastralUnitConversionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ILinearUnit* ippLinearUnit = NULL;
    PyObject* py_pLinearUnit;
    esriCadastralDistanceUnits epDistanceUnit;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_pLinearUnit))
      goto icadastralunitconversion_get_distanceunittype_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pLinearUnit, &IID_ILinearUnit, (void**)&ippLinearUnit))
        PyErr_SetString(PyExc_TypeError, "Argument pLinearUnit (position 0) is not ILinearUnit");
    
    if (PyErr_Occurred())
      goto icadastralunitconversion_get_distanceunittype_method_cleanup;
    
    // No setup for pDistanceUnit

    // Call method on actual COM interface
    hr = self->m_pICadastralUnitConversion->get_DistanceUnitType(ippLinearUnit, &epDistanceUnit);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadastralUnitConversion->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadastralUnitConversion) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadastralUnitConversion.get_DistanceUnitType() returned %ld", (long)hr);
        goto icadastralunitconversion_get_distanceunittype_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pLinearUnit
    // No teardown for pDistanceUnit

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)epDistanceUnit);
    goto icadastralunitconversion_get_distanceunittype_method_cleanup;

    icadastralunitconversion_get_distanceunittype_method_cleanup:
    self->m_HR = hr;
    if (ippLinearUnit)
      ippLinearUnit->Release();
    // No cleanup for pDistanceUnit
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadastralUnitConversion.get_DistanceUnitType");
    return return_tuple;
}

static PyObject*
ICadastralUnitConversionMethod_ConvertString(PyICadastralUnitConversionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsval = 0;
    PyObject* pyvar_val;
    PyObject* unicodeval = NULL;
    esriCadastralDistanceUnits edefaultUnit;
    esriCadastralDistanceUnits eoutputUnit;
    double dpVal = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "Oii", &pyvar_val, (int *)&edefaultUnit, (int *)&eoutputUnit))
      goto icadastralunitconversion_convertstring_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_val))
        unicodeval = PyUnicode_FromObject(pyvar_val);
    else if (PyUnicode_Check(pyvar_val))
    {
        unicodeval = pyvar_val;
        Py_INCREF(unicodeval);
    }
    else if (pyvar_val != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter val at index 0");
    if (unicodeval)
        bsval = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeval), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeval));
    
    if (PyErr_Occurred())
      goto icadastralunitconversion_convertstring_method_cleanup;
    
    // No setup for defaultUnit
    // No setup for outputUnit
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pICadastralUnitConversion->ConvertString(bsval, edefaultUnit, eoutputUnit, &dpVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadastralUnitConversion->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadastralUnitConversion) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadastralUnitConversion.ConvertString() returned %ld", (long)hr);
        goto icadastralunitconversion_convertstring_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for val
    // No teardown for defaultUnit
    // No teardown for outputUnit
    // No teardown for pVal

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dpVal);
    goto icadastralunitconversion_convertstring_method_cleanup;

    icadastralunitconversion_convertstring_method_cleanup:
    self->m_HR = hr;
    if (bsval)
        ::SysFreeString(bsval);
    
    // No cleanup for defaultUnit
    // No cleanup for outputUnit
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadastralUnitConversion.ConvertString");
    return return_tuple;
}

static PyObject*
ICadastralUnitConversionMethod_ConvertDouble(PyICadastralUnitConversionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dval = 0;
    esriCadastralDistanceUnits eunit;
    esriCadastralDistanceUnits eoutputUnit;
    double dpVal = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "dii", &dval, (int *)&eunit, (int *)&eoutputUnit))
      goto icadastralunitconversion_convertdouble_method_cleanup;

    // Set up initial variable values as needed
    // No setup for val
    // No setup for unit
    // No setup for outputUnit
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pICadastralUnitConversion->ConvertDouble(dval, eunit, eoutputUnit, &dpVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadastralUnitConversion->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadastralUnitConversion) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadastralUnitConversion.ConvertDouble() returned %ld", (long)hr);
        goto icadastralunitconversion_convertdouble_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for val
    // No teardown for unit
    // No teardown for outputUnit
    // No teardown for pVal

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dpVal);
    goto icadastralunitconversion_convertdouble_method_cleanup;

    icadastralunitconversion_convertdouble_method_cleanup:
    self->m_HR = hr;
    // No cleanup for val
    // No cleanup for unit
    // No cleanup for outputUnit
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadastralUnitConversion.ConvertDouble");
    return return_tuple;
}


PyMethodDef PyICadastralUnitConversionMethods[] = {
    {"supports", (PyCFunction)PyICadastralUnitConversion_SupportsInterface, METH_O, ""},
    {"get_DistanceUnitType", (PyCFunction)ICadastralUnitConversionMethod_get_DistanceUnitType, METH_VARARGS, ""},
    {"ConvertString", (PyCFunction)ICadastralUnitConversionMethod_ConvertString, METH_VARARGS, ""},
    {"ConvertDouble", (PyCFunction)ICadastralUnitConversionMethod_ConvertDouble, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyICadastralUnitConversionGetSet[] = {
  {"_pUnk", (getter)PyICadastralUnitConversion_GetpUnk, NULL, "Get opaque pointer to an Unknown from ICadastralUnitConversion", NULL},
  {"_pointer", (getter)PyICadastralUnitConversion_GetPointer, NULL, "Get memory address for ICadastralUnitConversion", NULL},
  {"_IID", (getter)PyICadastralUnitConversion_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyICadastralUnitConversion_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyICadastralUnitConversion_GetIgnoreFailures, (setter)PyICadastralUnitConversion_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyICadastralUnitConversionObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.ICadastralUnitConversionObject",                          
                                              /* tp_name */
  sizeof(PyICadastralUnitConversionObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyICadastralUnitConversionObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyICadastralUnitConversionMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyICadastralUnitConversionGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyICadastralUnitConversionObject_new,                      
                                              /* tp_new */
};

// Interface ICadastralGroundToGridTools

typedef struct PyICadastralGroundToGridToolsObject {
    PyObject_HEAD
    ICadastralGroundToGridTools* m_pICadastralGroundToGridTools;
    HRESULT m_HR;
    int m_ignore_failures;
} PyICadastralGroundToGridToolsObject;

static PyObject*
PyICadastralGroundToGridToolsObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyICadastralGroundToGridToolsObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ICadastralGroundToGridTools* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ICadastralGroundToGridTools, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ICadastralGroundToGridTools with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyICadastralGroundToGridToolsObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ICadastralGroundToGridTools");
            return NULL;
        }
        self->m_pICadastralGroundToGridTools = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ICadastralGroundToGridTools");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ICadastralGroundToGridTools");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ICadastralGroundToGridTools* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ICadastralGroundToGridTools, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ICadastralGroundToGridTools");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyICadastralGroundToGridToolsObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ICadastralGroundToGridTools");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pICadastralGroundToGridTools = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyICadastralGroundToGridToolsObject_dealloc(PyICadastralGroundToGridToolsObject* self)
{
    if (self->m_pICadastralGroundToGridTools)
        self->m_pICadastralGroundToGridTools->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyICadastralGroundToGridTools_GetpUnk(PyICadastralGroundToGridToolsObject* self)
{
    if (!self->m_pICadastralGroundToGridTools)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pICadastralGroundToGridTools->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ICadastralGroundToGridTools to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyICadastralGroundToGridTools_GetPointer(PyICadastralGroundToGridToolsObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pICadastralGroundToGridTools);
}

static PyObject*
PyICadastralGroundToGridTools_GetIID(PyICadastralGroundToGridToolsObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "69e2d388-48f1-407c-9f35-fc972034336a");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyICadastralGroundToGridTools_GetHR(PyICadastralGroundToGridToolsObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyICadastralGroundToGridTools_GetIgnoreFailures(PyICadastralGroundToGridToolsObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyICadastralGroundToGridTools_SetIgnoreFailures(PyICadastralGroundToGridToolsObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyICadastralGroundToGridTools_SupportsInterface(PyICadastralGroundToGridToolsObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pICadastralGroundToGridTools->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ICadastralGroundToGridToolsMethod_Inverse3D(PyICadastralGroundToGridToolsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ISpatialReference* ippSR = NULL;
    PyObject* py_pSR;
    VARIANT_BOOL b_argumentsInMeters = VARIANT_FALSE;
    PyObject* pyvar_argumentsInMeters = NULL;
    IPoint* ippPoint1 = NULL;
    PyObject* py_pPoint1;
    IPoint* ippPoint2 = NULL;
    PyObject* py_pPoint2;
    double dpDistance = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOOO", &py_pSR, &pyvar_argumentsInMeters, &py_pPoint1, &py_pPoint2))
      goto icadastralgroundtogridtools_inverse3d_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pSR, &IID_ISpatialReference, (void**)&ippSR))
        PyErr_SetString(PyExc_TypeError, "Argument pSR (position 0) is not ISpatialReference");
    
    if (PyErr_Occurred())
      goto icadastralgroundtogridtools_inverse3d_method_cleanup;
    
    b_argumentsInMeters = ((PyObject_IsTrue(pyvar_argumentsInMeters) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto icadastralgroundtogridtools_inverse3d_method_cleanup;
    
    if (!IFaceFromPyObject(py_pPoint1, &IID_IPoint, (void**)&ippPoint1))
        PyErr_SetString(PyExc_TypeError, "Argument pPoint1 (position 2) is not IPoint");
    
    if (PyErr_Occurred())
      goto icadastralgroundtogridtools_inverse3d_method_cleanup;
    
    if (!IFaceFromPyObject(py_pPoint2, &IID_IPoint, (void**)&ippPoint2))
        PyErr_SetString(PyExc_TypeError, "Argument pPoint2 (position 3) is not IPoint");
    
    if (PyErr_Occurred())
      goto icadastralgroundtogridtools_inverse3d_method_cleanup;
    
    // No setup for pDistance

    // Call method on actual COM interface
    hr = self->m_pICadastralGroundToGridTools->Inverse3D(ippSR, b_argumentsInMeters, ippPoint1, ippPoint2, &dpDistance);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadastralGroundToGridTools->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadastralGroundToGridTools) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadastralGroundToGridTools.Inverse3D() returned %ld", (long)hr);
        goto icadastralgroundtogridtools_inverse3d_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pSR
    // No teardown for argumentsInMeters
    // No teardown for pPoint1
    // No teardown for pPoint2
    // No teardown for pDistance

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dpDistance);
    goto icadastralgroundtogridtools_inverse3d_method_cleanup;

    icadastralgroundtogridtools_inverse3d_method_cleanup:
    self->m_HR = hr;
    if (ippSR)
      ippSR->Release();
    // No cleanup for argumentsInMeters
    if (ippPoint1)
      ippPoint1->Release();
    if (ippPoint2)
      ippPoint2->Release();
    // No cleanup for pDistance
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadastralGroundToGridTools.Inverse3D");
    return return_tuple;
}

static PyObject*
ICadastralGroundToGridToolsMethod_Forward3D(PyICadastralGroundToGridToolsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ISpatialReference* ippSR = NULL;
    PyObject* py_pSR;
    VARIANT_BOOL b_argumentsInMeters = VARIANT_FALSE;
    PyObject* pyvar_argumentsInMeters = NULL;
    IPoint* ippPoint1 = NULL;
    PyObject* py_pPoint1;
    IPoint* ippPoint2Provisional = NULL;
    PyObject* py_pPoint2Provisional;
    double dmarkToMarkDistance = 0;
    IPoint* ipppPoint = NULL;
    PyObject* py_ppPoint = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOOOd", &py_pSR, &pyvar_argumentsInMeters, &py_pPoint1, &py_pPoint2Provisional, &dmarkToMarkDistance))
      goto icadastralgroundtogridtools_forward3d_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pSR, &IID_ISpatialReference, (void**)&ippSR))
        PyErr_SetString(PyExc_TypeError, "Argument pSR (position 0) is not ISpatialReference");
    
    if (PyErr_Occurred())
      goto icadastralgroundtogridtools_forward3d_method_cleanup;
    
    b_argumentsInMeters = ((PyObject_IsTrue(pyvar_argumentsInMeters) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto icadastralgroundtogridtools_forward3d_method_cleanup;
    
    if (!IFaceFromPyObject(py_pPoint1, &IID_IPoint, (void**)&ippPoint1))
        PyErr_SetString(PyExc_TypeError, "Argument pPoint1 (position 2) is not IPoint");
    
    if (PyErr_Occurred())
      goto icadastralgroundtogridtools_forward3d_method_cleanup;
    
    if (!IFaceFromPyObject(py_pPoint2Provisional, &IID_IPoint, (void**)&ippPoint2Provisional))
        PyErr_SetString(PyExc_TypeError, "Argument pPoint2Provisional (position 3) is not IPoint");
    
    if (PyErr_Occurred())
      goto icadastralgroundtogridtools_forward3d_method_cleanup;
    
    // No setup for markToMarkDistance
    // No setup for ppPoint

    // Call method on actual COM interface
    hr = self->m_pICadastralGroundToGridTools->Forward3D(ippSR, b_argumentsInMeters, ippPoint1, ippPoint2Provisional, dmarkToMarkDistance, &ipppPoint);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadastralGroundToGridTools->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadastralGroundToGridTools) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadastralGroundToGridTools.Forward3D() returned %ld", (long)hr);
        goto icadastralgroundtogridtools_forward3d_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pSR
    // No teardown for argumentsInMeters
    // No teardown for pPoint1
    // No teardown for pPoint2Provisional
    // No teardown for markToMarkDistance
    Py_XDECREF(py_ppPoint);
    if (ipppPoint)
    {
        IUnknown* pUnk = NULL;
        ipppPoint->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppPoint = IUnknownToPythonIIDObject(pUnk, &IID_IPoint);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppPoint)
    {
        if (py_ppPoint)
           Py_DECREF(py_ppPoint);
        py_ppPoint = Py_None;
        Py_INCREF(py_ppPoint);
    }
    if (PyErr_Occurred())
      goto icadastralgroundtogridtools_forward3d_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppPoint);
    goto icadastralgroundtogridtools_forward3d_method_cleanup;

    icadastralgroundtogridtools_forward3d_method_cleanup:
    self->m_HR = hr;
    if (ippSR)
      ippSR->Release();
    // No cleanup for argumentsInMeters
    if (ippPoint1)
      ippPoint1->Release();
    if (ippPoint2Provisional)
      ippPoint2Provisional->Release();
    // No cleanup for markToMarkDistance
    Py_XDECREF(py_ppPoint);
    if (ipppPoint)
      ipppPoint->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadastralGroundToGridTools.Forward3D");
    return return_tuple;
}


PyMethodDef PyICadastralGroundToGridToolsMethods[] = {
    {"supports", (PyCFunction)PyICadastralGroundToGridTools_SupportsInterface, METH_O, ""},
    {"Inverse3D", (PyCFunction)ICadastralGroundToGridToolsMethod_Inverse3D, METH_VARARGS, ""},
    {"Forward3D", (PyCFunction)ICadastralGroundToGridToolsMethod_Forward3D, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyICadastralGroundToGridToolsGetSet[] = {
  {"_pUnk", (getter)PyICadastralGroundToGridTools_GetpUnk, NULL, "Get opaque pointer to an Unknown from ICadastralGroundToGridTools", NULL},
  {"_pointer", (getter)PyICadastralGroundToGridTools_GetPointer, NULL, "Get memory address for ICadastralGroundToGridTools", NULL},
  {"_IID", (getter)PyICadastralGroundToGridTools_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyICadastralGroundToGridTools_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyICadastralGroundToGridTools_GetIgnoreFailures, (setter)PyICadastralGroundToGridTools_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyICadastralGroundToGridToolsObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.ICadastralGroundToGridToolsObject",                          
                                              /* tp_name */
  sizeof(PyICadastralGroundToGridToolsObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyICadastralGroundToGridToolsObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyICadastralGroundToGridToolsMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyICadastralGroundToGridToolsGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyICadastralGroundToGridToolsObject_new,                      
                                              /* tp_new */
};

// Interface ICadastralUnitTools

typedef struct PyICadastralUnitToolsObject {
    PyObject_HEAD
    ICadastralUnitTools* m_pICadastralUnitTools;
    HRESULT m_HR;
    int m_ignore_failures;
} PyICadastralUnitToolsObject;

static PyObject*
PyICadastralUnitToolsObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyICadastralUnitToolsObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ICadastralUnitTools* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ICadastralUnitTools, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ICadastralUnitTools with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyICadastralUnitToolsObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ICadastralUnitTools");
            return NULL;
        }
        self->m_pICadastralUnitTools = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ICadastralUnitTools");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ICadastralUnitTools");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ICadastralUnitTools* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ICadastralUnitTools, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ICadastralUnitTools");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyICadastralUnitToolsObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ICadastralUnitTools");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pICadastralUnitTools = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyICadastralUnitToolsObject_dealloc(PyICadastralUnitToolsObject* self)
{
    if (self->m_pICadastralUnitTools)
        self->m_pICadastralUnitTools->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyICadastralUnitTools_GetpUnk(PyICadastralUnitToolsObject* self)
{
    if (!self->m_pICadastralUnitTools)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pICadastralUnitTools->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ICadastralUnitTools to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyICadastralUnitTools_GetPointer(PyICadastralUnitToolsObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pICadastralUnitTools);
}

static PyObject*
PyICadastralUnitTools_GetIID(PyICadastralUnitToolsObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "0dc83354-e621-4c2d-9c2d-bad65c0727d1");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyICadastralUnitTools_GetHR(PyICadastralUnitToolsObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyICadastralUnitTools_GetIgnoreFailures(PyICadastralUnitToolsObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyICadastralUnitTools_SetIgnoreFailures(PyICadastralUnitToolsObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyICadastralUnitTools_SupportsInterface(PyICadastralUnitToolsObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pICadastralUnitTools->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ICadastralUnitToolsMethod_get_FormattedArea(PyICadastralUnitToolsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dareaSQMeters = 0;
    esriCadastralAreaUnits eeOutputAreaTypeDisplay;
    VARIANT_BOOL b_isUSFoot = VARIANT_FALSE;
    PyObject* pyvar_isUSFoot = NULL;
    long ldecimalPlaces = 0;
    BSTR bsformatedArea;
    PyObject* pyvar_formatedArea = Py_None;

    // Unpack values
    if (!PyArg_ParseTuple(args, "diOl", &dareaSQMeters, (int *)&eeOutputAreaTypeDisplay, &pyvar_isUSFoot, &ldecimalPlaces))
      goto icadastralunittools_get_formattedarea_method_cleanup;

    // Set up initial variable values as needed
    // No setup for areaSQMeters
    // No setup for eOutputAreaTypeDisplay
    b_isUSFoot = ((PyObject_IsTrue(pyvar_isUSFoot) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto icadastralunittools_get_formattedarea_method_cleanup;
    
    // No setup for decimalPlaces
    // No setup for formatedArea

    // Call method on actual COM interface
    hr = self->m_pICadastralUnitTools->get_FormattedArea(dareaSQMeters, eeOutputAreaTypeDisplay, b_isUSFoot, ldecimalPlaces, &bsformatedArea);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadastralUnitTools->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadastralUnitTools) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadastralUnitTools.get_FormattedArea() returned %ld", (long)hr);
        goto icadastralunittools_get_formattedarea_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for areaSQMeters
    // No teardown for eOutputAreaTypeDisplay
    // No teardown for isUSFoot
    // No teardown for decimalPlaces
    pyvar_formatedArea = PyUnicode_FromWideChar(bsformatedArea,::SysStringLen(bsformatedArea));
    ::SysFreeString(bsformatedArea);
    
    if (PyErr_Occurred())
      goto icadastralunittools_get_formattedarea_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_formatedArea);
    goto icadastralunittools_get_formattedarea_method_cleanup;

    icadastralunittools_get_formattedarea_method_cleanup:
    self->m_HR = hr;
    // No cleanup for areaSQMeters
    // No cleanup for eOutputAreaTypeDisplay
    // No cleanup for isUSFoot
    // No cleanup for decimalPlaces
    if (pyvar_formatedArea != Py_None)
        Py_XDECREF(pyvar_formatedArea);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadastralUnitTools.get_FormattedArea");
    return return_tuple;
}

static PyObject*
ICadastralUnitToolsMethod_get_ConvertArea(PyICadastralUnitToolsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dareaSQMeters = 0;
    esriCadastralAreaUnits eeOutputAreaType;
    double dpArea = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "di", &dareaSQMeters, (int *)&eeOutputAreaType))
      goto icadastralunittools_get_convertarea_method_cleanup;

    // Set up initial variable values as needed
    // No setup for areaSQMeters
    // No setup for eOutputAreaType
    // No setup for pArea

    // Call method on actual COM interface
    hr = self->m_pICadastralUnitTools->get_ConvertArea(dareaSQMeters, eeOutputAreaType, &dpArea);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadastralUnitTools->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadastralUnitTools) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadastralUnitTools.get_ConvertArea() returned %ld", (long)hr);
        goto icadastralunittools_get_convertarea_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for areaSQMeters
    // No teardown for eOutputAreaType
    // No teardown for pArea

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dpArea);
    goto icadastralunittools_get_convertarea_method_cleanup;

    icadastralunittools_get_convertarea_method_cleanup:
    self->m_HR = hr;
    // No cleanup for areaSQMeters
    // No cleanup for eOutputAreaType
    // No cleanup for pArea
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadastralUnitTools.get_ConvertArea");
    return return_tuple;
}

static PyObject*
ICadastralUnitToolsMethod_get_DirectionType(PyICadastralUnitToolsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriDirectionType eeDirType;
    BSTR bsdirType;
    PyObject* pyvar_dirType = Py_None;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&eeDirType))
      goto icadastralunittools_get_directiontype_method_cleanup;

    // Set up initial variable values as needed
    // No setup for eDirType
    // No setup for dirType

    // Call method on actual COM interface
    hr = self->m_pICadastralUnitTools->get_DirectionType(eeDirType, &bsdirType);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadastralUnitTools->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadastralUnitTools) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadastralUnitTools.get_DirectionType() returned %ld", (long)hr);
        goto icadastralunittools_get_directiontype_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for eDirType
    pyvar_dirType = PyUnicode_FromWideChar(bsdirType,::SysStringLen(bsdirType));
    ::SysFreeString(bsdirType);
    
    if (PyErr_Occurred())
      goto icadastralunittools_get_directiontype_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_dirType);
    goto icadastralunittools_get_directiontype_method_cleanup;

    icadastralunittools_get_directiontype_method_cleanup:
    self->m_HR = hr;
    // No cleanup for eDirType
    if (pyvar_dirType != Py_None)
        Py_XDECREF(pyvar_dirType);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadastralUnitTools.get_DirectionType");
    return return_tuple;
}

static PyObject*
ICadastralUnitToolsMethod_get_DirectionUnit(PyICadastralUnitToolsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriDirectionUnits eeDirUnit;
    BSTR bsdirUnit;
    PyObject* pyvar_dirUnit = Py_None;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&eeDirUnit))
      goto icadastralunittools_get_directionunit_method_cleanup;

    // Set up initial variable values as needed
    // No setup for eDirUnit
    // No setup for dirUnit

    // Call method on actual COM interface
    hr = self->m_pICadastralUnitTools->get_DirectionUnit(eeDirUnit, &bsdirUnit);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadastralUnitTools->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadastralUnitTools) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadastralUnitTools.get_DirectionUnit() returned %ld", (long)hr);
        goto icadastralunittools_get_directionunit_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for eDirUnit
    pyvar_dirUnit = PyUnicode_FromWideChar(bsdirUnit,::SysStringLen(bsdirUnit));
    ::SysFreeString(bsdirUnit);
    
    if (PyErr_Occurred())
      goto icadastralunittools_get_directionunit_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_dirUnit);
    goto icadastralunittools_get_directionunit_method_cleanup;

    icadastralunittools_get_directionunit_method_cleanup:
    self->m_HR = hr;
    // No cleanup for eDirUnit
    if (pyvar_dirUnit != Py_None)
        Py_XDECREF(pyvar_dirUnit);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadastralUnitTools.get_DirectionUnit");
    return return_tuple;
}

static PyObject*
ICadastralUnitToolsMethod_get_DistanceUnit(PyICadastralUnitToolsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriCadastralDistanceUnits eeDistanceType;
    VARIANT_BOOL b_shortNotation = VARIANT_FALSE;
    PyObject* pyvar_shortNotation = NULL;
    BSTR bsdistUnit;
    PyObject* pyvar_distUnit = Py_None;

    // Unpack values
    if (!PyArg_ParseTuple(args, "iO", (int *)&eeDistanceType, &pyvar_shortNotation))
      goto icadastralunittools_get_distanceunit_method_cleanup;

    // Set up initial variable values as needed
    // No setup for eDistanceType
    b_shortNotation = ((PyObject_IsTrue(pyvar_shortNotation) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto icadastralunittools_get_distanceunit_method_cleanup;
    
    // No setup for distUnit

    // Call method on actual COM interface
    hr = self->m_pICadastralUnitTools->get_DistanceUnit(eeDistanceType, b_shortNotation, &bsdistUnit);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadastralUnitTools->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadastralUnitTools) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadastralUnitTools.get_DistanceUnit() returned %ld", (long)hr);
        goto icadastralunittools_get_distanceunit_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for eDistanceType
    // No teardown for shortNotation
    pyvar_distUnit = PyUnicode_FromWideChar(bsdistUnit,::SysStringLen(bsdistUnit));
    ::SysFreeString(bsdistUnit);
    
    if (PyErr_Occurred())
      goto icadastralunittools_get_distanceunit_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_distUnit);
    goto icadastralunittools_get_distanceunit_method_cleanup;

    icadastralunittools_get_distanceunit_method_cleanup:
    self->m_HR = hr;
    // No cleanup for eDistanceType
    // No cleanup for shortNotation
    if (pyvar_distUnit != Py_None)
        Py_XDECREF(pyvar_distUnit);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadastralUnitTools.get_DistanceUnit");
    return return_tuple;
}

static PyObject*
ICadastralUnitToolsMethod_get_AreaUnit(PyICadastralUnitToolsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriCadastralAreaUnits eeAreaType;
    VARIANT_BOOL b_shortNotation = VARIANT_FALSE;
    PyObject* pyvar_shortNotation = NULL;
    BSTR bsarea;
    PyObject* pyvar_area = Py_None;

    // Unpack values
    if (!PyArg_ParseTuple(args, "iO", (int *)&eeAreaType, &pyvar_shortNotation))
      goto icadastralunittools_get_areaunit_method_cleanup;

    // Set up initial variable values as needed
    // No setup for eAreaType
    b_shortNotation = ((PyObject_IsTrue(pyvar_shortNotation) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto icadastralunittools_get_areaunit_method_cleanup;
    
    // No setup for area

    // Call method on actual COM interface
    hr = self->m_pICadastralUnitTools->get_AreaUnit(eeAreaType, b_shortNotation, &bsarea);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadastralUnitTools->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadastralUnitTools) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadastralUnitTools.get_AreaUnit() returned %ld", (long)hr);
        goto icadastralunittools_get_areaunit_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for eAreaType
    // No teardown for shortNotation
    pyvar_area = PyUnicode_FromWideChar(bsarea,::SysStringLen(bsarea));
    ::SysFreeString(bsarea);
    
    if (PyErr_Occurred())
      goto icadastralunittools_get_areaunit_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_area);
    goto icadastralunittools_get_areaunit_method_cleanup;

    icadastralunittools_get_areaunit_method_cleanup:
    self->m_HR = hr;
    // No cleanup for eAreaType
    // No cleanup for shortNotation
    if (pyvar_area != Py_None)
        Py_XDECREF(pyvar_area);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICadastralUnitTools.get_AreaUnit");
    return return_tuple;
}


PyMethodDef PyICadastralUnitToolsMethods[] = {
    {"supports", (PyCFunction)PyICadastralUnitTools_SupportsInterface, METH_O, ""},
    {"get_FormattedArea", (PyCFunction)ICadastralUnitToolsMethod_get_FormattedArea, METH_VARARGS, ""},
    {"get_ConvertArea", (PyCFunction)ICadastralUnitToolsMethod_get_ConvertArea, METH_VARARGS, ""},
    {"get_DirectionType", (PyCFunction)ICadastralUnitToolsMethod_get_DirectionType, METH_VARARGS, ""},
    {"get_DirectionUnit", (PyCFunction)ICadastralUnitToolsMethod_get_DirectionUnit, METH_VARARGS, ""},
    {"get_DistanceUnit", (PyCFunction)ICadastralUnitToolsMethod_get_DistanceUnit, METH_VARARGS, ""},
    {"get_AreaUnit", (PyCFunction)ICadastralUnitToolsMethod_get_AreaUnit, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyICadastralUnitToolsGetSet[] = {
  {"_pUnk", (getter)PyICadastralUnitTools_GetpUnk, NULL, "Get opaque pointer to an Unknown from ICadastralUnitTools", NULL},
  {"_pointer", (getter)PyICadastralUnitTools_GetPointer, NULL, "Get memory address for ICadastralUnitTools", NULL},
  {"_IID", (getter)PyICadastralUnitTools_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyICadastralUnitTools_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyICadastralUnitTools_GetIgnoreFailures, (setter)PyICadastralUnitTools_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyICadastralUnitToolsObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.ICadastralUnitToolsObject",                          
                                              /* tp_name */
  sizeof(PyICadastralUnitToolsObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyICadastralUnitToolsObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyICadastralUnitToolsMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyICadastralUnitToolsGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyICadastralUnitToolsObject_new,                      
                                              /* tp_new */
};

// Interface ICadastralFabricEditControl

typedef struct PyICadastralFabricEditControlObject {
    PyObject_HEAD
    ICadastralFabricEditControl* m_pICadastralFabricEditControl;
    HRESULT m_HR;
    int m_ignore_failures;
} PyICadastralFabricEditControlObject;

static PyObject*
PyICadastralFabricEditControlObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyICadastralFabricEditControlObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ICadastralFabricEditControl* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ICadastralFabricEditControl, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ICadastralFabricEditControl with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyICadastralFabricEditControlObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ICadastralFabricEditControl");
            return NULL;
        }
        self->m_pICadastralFabricEditControl = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ICadastralFabricEditControl");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ICadastralFabricEditControl");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ICadastralFabricEditControl* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ICadastralFabricEditControl, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ICadastralFabricEditControl");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyICadastralFabricEditControlObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ICadastralFabricEditControl");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pICadastralFabricEditControl = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyICadastralFabricEditControlObject_dealloc(PyICadastralFabricEditControlObject* self)
{
    if (self->m_pICadastralFabricEditControl)
        self->m_pICadastralFabricEditControl->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyICadastralFabricEditControl_GetpUnk(PyICadastralFabricEditControlObject* self)
{
    if (!self->m_pICadastralFabricEditControl)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pICadastralFabricEditControl->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ICadastralFabricEditControl to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyICadastralFabricEditControl_GetPointer(PyICadastralFabricEditControlObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pICadastralFabricEditControl);
}

static PyObject*
PyICadastralFabricEditControl_GetIID(PyICadastralFabricEditControlObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "a56b04a1-1748-40ab-bb7e-dfe95b34dd48");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyICadastralFabricEditControl_GetHR(PyICadastralFabricEditControlObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyICadastralFabricEditControl_GetIgnoreFailures(PyICadastralFabricEditControlObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyICadastralFabricEditControl_SetIgnoreFailures(PyICadastralFabricEditControlObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyICadastralFabricEditControl_SupportsInterface(PyICadastralFabricEditControlObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pICadastralFabricEditControl->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ICadastralFabricEditControlMethod_SetStoreEventsRequired(PyICadastralFabricEditControlObject* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pICadastralFabricEditControl->SetStoreEventsRequired();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICadastralFabricEditControl->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICadastralFabricEditControl) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICadastralFabricEditControl.SetStoreEventsRequired() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}


PyMethodDef PyICadastralFabricEditControlMethods[] = {
    {"supports", (PyCFunction)PyICadastralFabricEditControl_SupportsInterface, METH_O, ""},
    {"SetStoreEventsRequired", (PyCFunction)ICadastralFabricEditControlMethod_SetStoreEventsRequired, METH_NOARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyICadastralFabricEditControlGetSet[] = {
  {"_pUnk", (getter)PyICadastralFabricEditControl_GetpUnk, NULL, "Get opaque pointer to an Unknown from ICadastralFabricEditControl", NULL},
  {"_pointer", (getter)PyICadastralFabricEditControl_GetPointer, NULL, "Get memory address for ICadastralFabricEditControl", NULL},
  {"_IID", (getter)PyICadastralFabricEditControl_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyICadastralFabricEditControl_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyICadastralFabricEditControl_GetIgnoreFailures, (setter)PyICadastralFabricEditControl_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyICadastralFabricEditControlObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.ICadastralFabricEditControlObject",                          
                                              /* tp_name */
  sizeof(PyICadastralFabricEditControlObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyICadastralFabricEditControlObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyICadastralFabricEditControlMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyICadastralFabricEditControlGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyICadastralFabricEditControlObject_new,                      
                                              /* tp_new */
};

// Interface IDataMessage

typedef struct PyIDataMessageObject {
    PyObject_HEAD
    IDataMessage* m_pIDataMessage;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIDataMessageObject;

static PyObject*
PyIDataMessageObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIDataMessageObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IDataMessage* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IDataMessage, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IDataMessage with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIDataMessageObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IDataMessage");
            return NULL;
        }
        self->m_pIDataMessage = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IDataMessage");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IDataMessage");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IDataMessage* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IDataMessage, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IDataMessage");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIDataMessageObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IDataMessage");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIDataMessage = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIDataMessageObject_dealloc(PyIDataMessageObject* self)
{
    if (self->m_pIDataMessage)
        self->m_pIDataMessage->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIDataMessage_GetpUnk(PyIDataMessageObject* self)
{
    if (!self->m_pIDataMessage)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIDataMessage->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IDataMessage to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIDataMessage_GetPointer(PyIDataMessageObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIDataMessage);
}

static PyObject*
PyIDataMessage_GetIID(PyIDataMessageObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "cc018a04-24fb-11d4-b34c-00104ba2abcc");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIDataMessage_GetHR(PyIDataMessageObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIDataMessage_GetIgnoreFailures(PyIDataMessageObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIDataMessage_SetIgnoreFailures(PyIDataMessageObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIDataMessage_SupportsInterface(PyIDataMessageObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIDataMessage->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IDataMessageMethod_get_CreationDate(PyIDataMessageObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT vpVal;
    ::VariantInit(&vpVal);
    PyObject* pyvar_pVal = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pIDataMessage->get_CreationDate(&vpVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDataMessage->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDataMessage) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDataMessage.get_CreationDate() returned %ld", (long)hr);
        goto idatamessage_get_creationdate_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pVal = Variant_AsPyObject(&vpVal);
    if (PyErr_Occurred())
      goto idatamessage_get_creationdate_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pVal);
    goto idatamessage_get_creationdate_method_cleanup;

    idatamessage_get_creationdate_method_cleanup:
    self->m_HR = hr;
    ::VariantClear(&vpVal);
    Py_XDECREF(pyvar_pVal);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDataMessage.get_CreationDate");
    return return_tuple;
}

static PyObject*
IDataMessageMethod_get_ID(PyIDataMessageObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspVal;
    PyObject* pyvar_pVal = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pIDataMessage->get_ID(&bspVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDataMessage->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDataMessage) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDataMessage.get_ID() returned %ld", (long)hr);
        goto idatamessage_get_id_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pVal = PyUnicode_FromWideChar(bspVal,::SysStringLen(bspVal));
    ::SysFreeString(bspVal);
    
    if (PyErr_Occurred())
      goto idatamessage_get_id_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pVal);
    goto idatamessage_get_id_method_cleanup;

    idatamessage_get_id_method_cleanup:
    self->m_HR = hr;
    if (pyvar_pVal != Py_None)
        Py_XDECREF(pyvar_pVal);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDataMessage.get_ID");
    return return_tuple;
}

static PyObject*
IDataMessageMethod_get_MessageType(PyIDataMessageObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    enumMessageType epVal;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pIDataMessage->get_MessageType(&epVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDataMessage->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDataMessage) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDataMessage.get_MessageType() returned %ld", (long)hr);
        goto idatamessage_get_messagetype_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)epVal);
    goto idatamessage_get_messagetype_method_cleanup;

    idatamessage_get_messagetype_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDataMessage.get_MessageType");
    return return_tuple;
}

static PyObject*
IDataMessageMethod_get_Priority(PyIDataMessageObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    int ipVal = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pIDataMessage->get_Priority(&ipVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDataMessage->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDataMessage) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDataMessage.get_Priority() returned %ld", (long)hr);
        goto idatamessage_get_priority_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            ipVal);
    goto idatamessage_get_priority_method_cleanup;

    idatamessage_get_priority_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDataMessage.get_Priority");
    return return_tuple;
}

static PyObject*
IDataMessageMethod_put_Priority(PyIDataMessageObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    int ipVal = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", &ipVal))
      goto idatamessage_put_priority_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pIDataMessage->put_Priority(ipVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDataMessage->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDataMessage) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDataMessage.put_Priority() returned %ld", (long)hr);
        goto idatamessage_put_priority_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idatamessage_put_priority_method_cleanup;

    idatamessage_put_priority_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDataMessage.put_Priority");
    return return_tuple;
}

static PyObject*
IDataMessageMethod_get_Destination(PyIDataMessageObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspVal;
    PyObject* pyvar_pVal = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pIDataMessage->get_Destination(&bspVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDataMessage->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDataMessage) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDataMessage.get_Destination() returned %ld", (long)hr);
        goto idatamessage_get_destination_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pVal = PyUnicode_FromWideChar(bspVal,::SysStringLen(bspVal));
    ::SysFreeString(bspVal);
    
    if (PyErr_Occurred())
      goto idatamessage_get_destination_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pVal);
    goto idatamessage_get_destination_method_cleanup;

    idatamessage_get_destination_method_cleanup:
    self->m_HR = hr;
    if (pyvar_pVal != Py_None)
        Py_XDECREF(pyvar_pVal);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDataMessage.get_Destination");
    return return_tuple;
}

static PyObject*
IDataMessageMethod_put_Destination(PyIDataMessageObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspVal = 0;
    PyObject* pyvar_pVal;
    PyObject* unicodepVal = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pVal))
      goto idatamessage_put_destination_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_pVal))
        unicodepVal = PyUnicode_FromObject(pyvar_pVal);
    else if (PyUnicode_Check(pyvar_pVal))
    {
        unicodepVal = pyvar_pVal;
        Py_INCREF(unicodepVal);
    }
    else if (pyvar_pVal != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter pVal at index 0");
    if (unicodepVal)
        bspVal = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodepVal), 
                                            (UINT)PyUnicode_GET_SIZE(unicodepVal));
    
    if (PyErr_Occurred())
      goto idatamessage_put_destination_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIDataMessage->put_Destination(bspVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDataMessage->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDataMessage) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDataMessage.put_Destination() returned %ld", (long)hr);
        goto idatamessage_put_destination_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idatamessage_put_destination_method_cleanup;

    idatamessage_put_destination_method_cleanup:
    self->m_HR = hr;
    if (bspVal)
        ::SysFreeString(bspVal);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDataMessage.put_Destination");
    return return_tuple;
}

static PyObject*
IDataMessageMethod_get_ArgumentCount(PyIDataMessageObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    int ipVal = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pIDataMessage->get_ArgumentCount(&ipVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDataMessage->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDataMessage) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDataMessage.get_ArgumentCount() returned %ld", (long)hr);
        goto idatamessage_get_argumentcount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            ipVal);
    goto idatamessage_get_argumentcount_method_cleanup;

    idatamessage_get_argumentcount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDataMessage.get_ArgumentCount");
    return return_tuple;
}

static PyObject*
IDataMessageMethod_setArgument(PyIDataMessageObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    int inIndex = 0;
    VARIANT vpValue;
    ::VariantInit(&vpValue);
    PyObject* pyvar_pValue = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "iO", &inIndex, &pyvar_pValue))
      goto idatamessage_setargument_method_cleanup;

    // Set up initial variable values as needed
    // No setup for nIndex
    PyObject_AsVariant(pyvar_pValue, &vpValue);
    
    if (PyErr_Occurred())
      goto idatamessage_setargument_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIDataMessage->setArgument(inIndex, &vpValue);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDataMessage->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDataMessage) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDataMessage.setArgument() returned %ld", (long)hr);
        goto idatamessage_setargument_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for nIndex
    // No teardown for pValue

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idatamessage_setargument_method_cleanup;

    idatamessage_setargument_method_cleanup:
    self->m_HR = hr;
    // No cleanup for nIndex
    ::VariantClear(&vpValue);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDataMessage.setArgument");
    return return_tuple;
}

static PyObject*
IDataMessageMethod_addArgument(PyIDataMessageObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT vpValue;
    ::VariantInit(&vpValue);
    PyObject* pyvar_pValue = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pValue))
      goto idatamessage_addargument_method_cleanup;

    // Set up initial variable values as needed
    PyObject_AsVariant(pyvar_pValue, &vpValue);
    
    if (PyErr_Occurred())
      goto idatamessage_addargument_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIDataMessage->addArgument(&vpValue);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDataMessage->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDataMessage) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDataMessage.addArgument() returned %ld", (long)hr);
        goto idatamessage_addargument_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pValue

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idatamessage_addargument_method_cleanup;

    idatamessage_addargument_method_cleanup:
    self->m_HR = hr;
    ::VariantClear(&vpValue);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDataMessage.addArgument");
    return return_tuple;
}

static PyObject*
IDataMessageMethod_removeArgument(PyIDataMessageObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    int inIndex = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", &inIndex))
      goto idatamessage_removeargument_method_cleanup;

    // Set up initial variable values as needed
    // No setup for nIndex

    // Call method on actual COM interface
    hr = self->m_pIDataMessage->removeArgument(inIndex);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDataMessage->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDataMessage) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDataMessage.removeArgument() returned %ld", (long)hr);
        goto idatamessage_removeargument_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for nIndex

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idatamessage_removeargument_method_cleanup;

    idatamessage_removeargument_method_cleanup:
    self->m_HR = hr;
    // No cleanup for nIndex
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDataMessage.removeArgument");
    return return_tuple;
}

static PyObject*
IDataMessageMethod_getArgument(PyIDataMessageObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    int inIndex = 0;
    VARIANT vpValue;
    ::VariantInit(&vpValue);
    PyObject* pyvar_pValue = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", &inIndex))
      goto idatamessage_getargument_method_cleanup;

    // Set up initial variable values as needed
    // No setup for nIndex
    // No setup for pValue

    // Call method on actual COM interface
    hr = self->m_pIDataMessage->getArgument(inIndex, &vpValue);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDataMessage->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDataMessage) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDataMessage.getArgument() returned %ld", (long)hr);
        goto idatamessage_getargument_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for nIndex
    pyvar_pValue = Variant_AsPyObject(&vpValue);
    if (PyErr_Occurred())
      goto idatamessage_getargument_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pValue);
    goto idatamessage_getargument_method_cleanup;

    idatamessage_getargument_method_cleanup:
    self->m_HR = hr;
    // No cleanup for nIndex
    ::VariantClear(&vpValue);
    Py_XDECREF(pyvar_pValue);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDataMessage.getArgument");
    return return_tuple;
}

static PyObject*
IDataMessageMethod_get_DataDefinitionID(PyIDataMessageObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspVal;
    PyObject* pyvar_pVal = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pIDataMessage->get_DataDefinitionID(&bspVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDataMessage->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDataMessage) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDataMessage.get_DataDefinitionID() returned %ld", (long)hr);
        goto idatamessage_get_datadefinitionid_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pVal = PyUnicode_FromWideChar(bspVal,::SysStringLen(bspVal));
    ::SysFreeString(bspVal);
    
    if (PyErr_Occurred())
      goto idatamessage_get_datadefinitionid_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pVal);
    goto idatamessage_get_datadefinitionid_method_cleanup;

    idatamessage_get_datadefinitionid_method_cleanup:
    self->m_HR = hr;
    if (pyvar_pVal != Py_None)
        Py_XDECREF(pyvar_pVal);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDataMessage.get_DataDefinitionID");
    return return_tuple;
}

static PyObject*
IDataMessageMethod_put_DataDefinitionID(PyIDataMessageObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspVal = 0;
    PyObject* pyvar_pVal;
    PyObject* unicodepVal = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pVal))
      goto idatamessage_put_datadefinitionid_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_pVal))
        unicodepVal = PyUnicode_FromObject(pyvar_pVal);
    else if (PyUnicode_Check(pyvar_pVal))
    {
        unicodepVal = pyvar_pVal;
        Py_INCREF(unicodepVal);
    }
    else if (pyvar_pVal != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter pVal at index 0");
    if (unicodepVal)
        bspVal = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodepVal), 
                                            (UINT)PyUnicode_GET_SIZE(unicodepVal));
    
    if (PyErr_Occurred())
      goto idatamessage_put_datadefinitionid_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIDataMessage->put_DataDefinitionID(bspVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDataMessage->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDataMessage) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDataMessage.put_DataDefinitionID() returned %ld", (long)hr);
        goto idatamessage_put_datadefinitionid_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idatamessage_put_datadefinitionid_method_cleanup;

    idatamessage_put_datadefinitionid_method_cleanup:
    self->m_HR = hr;
    if (bspVal)
        ::SysFreeString(bspVal);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDataMessage.put_DataDefinitionID");
    return return_tuple;
}

static PyObject*
IDataMessageMethod_get_ColumnCount(PyIDataMessageObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    int ipVal = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pIDataMessage->get_ColumnCount(&ipVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDataMessage->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDataMessage) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDataMessage.get_ColumnCount() returned %ld", (long)hr);
        goto idatamessage_get_columncount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            ipVal);
    goto idatamessage_get_columncount_method_cleanup;

    idatamessage_get_columncount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDataMessage.get_ColumnCount");
    return return_tuple;
}

static PyObject*
IDataMessageMethod_setColumn(PyIDataMessageObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    int inIndex = 0;
    VARIANT vpValue;
    ::VariantInit(&vpValue);
    PyObject* pyvar_pValue = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "iO", &inIndex, &pyvar_pValue))
      goto idatamessage_setcolumn_method_cleanup;

    // Set up initial variable values as needed
    // No setup for nIndex
    PyObject_AsVariant(pyvar_pValue, &vpValue);
    
    if (PyErr_Occurred())
      goto idatamessage_setcolumn_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIDataMessage->setColumn(inIndex, &vpValue);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDataMessage->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDataMessage) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDataMessage.setColumn() returned %ld", (long)hr);
        goto idatamessage_setcolumn_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for nIndex
    // No teardown for pValue

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idatamessage_setcolumn_method_cleanup;

    idatamessage_setcolumn_method_cleanup:
    self->m_HR = hr;
    // No cleanup for nIndex
    ::VariantClear(&vpValue);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDataMessage.setColumn");
    return return_tuple;
}

static PyObject*
IDataMessageMethod_addColumn(PyIDataMessageObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT vpValue;
    ::VariantInit(&vpValue);
    PyObject* pyvar_pValue = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pValue))
      goto idatamessage_addcolumn_method_cleanup;

    // Set up initial variable values as needed
    PyObject_AsVariant(pyvar_pValue, &vpValue);
    
    if (PyErr_Occurred())
      goto idatamessage_addcolumn_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIDataMessage->addColumn(&vpValue);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDataMessage->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDataMessage) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDataMessage.addColumn() returned %ld", (long)hr);
        goto idatamessage_addcolumn_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pValue

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idatamessage_addcolumn_method_cleanup;

    idatamessage_addcolumn_method_cleanup:
    self->m_HR = hr;
    ::VariantClear(&vpValue);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDataMessage.addColumn");
    return return_tuple;
}

static PyObject*
IDataMessageMethod_removeColumn(PyIDataMessageObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    int inIndex = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", &inIndex))
      goto idatamessage_removecolumn_method_cleanup;

    // Set up initial variable values as needed
    // No setup for nIndex

    // Call method on actual COM interface
    hr = self->m_pIDataMessage->removeColumn(inIndex);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDataMessage->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDataMessage) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDataMessage.removeColumn() returned %ld", (long)hr);
        goto idatamessage_removecolumn_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for nIndex

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idatamessage_removecolumn_method_cleanup;

    idatamessage_removecolumn_method_cleanup:
    self->m_HR = hr;
    // No cleanup for nIndex
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDataMessage.removeColumn");
    return return_tuple;
}

static PyObject*
IDataMessageMethod_getColumn(PyIDataMessageObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    int inIndex = 0;
    VARIANT vpValue;
    ::VariantInit(&vpValue);
    PyObject* pyvar_pValue = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", &inIndex))
      goto idatamessage_getcolumn_method_cleanup;

    // Set up initial variable values as needed
    // No setup for nIndex
    // No setup for pValue

    // Call method on actual COM interface
    hr = self->m_pIDataMessage->getColumn(inIndex, &vpValue);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDataMessage->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDataMessage) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDataMessage.getColumn() returned %ld", (long)hr);
        goto idatamessage_getcolumn_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for nIndex
    pyvar_pValue = Variant_AsPyObject(&vpValue);
    if (PyErr_Occurred())
      goto idatamessage_getcolumn_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pValue);
    goto idatamessage_getcolumn_method_cleanup;

    idatamessage_getcolumn_method_cleanup:
    self->m_HR = hr;
    // No cleanup for nIndex
    ::VariantClear(&vpValue);
    Py_XDECREF(pyvar_pValue);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDataMessage.getColumn");
    return return_tuple;
}

static PyObject*
IDataMessageMethod_getRawColumn(PyIDataMessageObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    int inIndex = 0;
    VARIANT vpValue;
    ::VariantInit(&vpValue);
    PyObject* pyvar_pValue = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", &inIndex))
      goto idatamessage_getrawcolumn_method_cleanup;

    // Set up initial variable values as needed
    // No setup for nIndex
    // No setup for pValue

    // Call method on actual COM interface
    hr = self->m_pIDataMessage->getRawColumn(inIndex, &vpValue);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDataMessage->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDataMessage) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDataMessage.getRawColumn() returned %ld", (long)hr);
        goto idatamessage_getrawcolumn_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for nIndex
    pyvar_pValue = Variant_AsPyObject(&vpValue);
    if (PyErr_Occurred())
      goto idatamessage_getrawcolumn_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pValue);
    goto idatamessage_getrawcolumn_method_cleanup;

    idatamessage_getrawcolumn_method_cleanup:
    self->m_HR = hr;
    // No cleanup for nIndex
    ::VariantClear(&vpValue);
    Py_XDECREF(pyvar_pValue);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDataMessage.getRawColumn");
    return return_tuple;
}


PyMethodDef PyIDataMessageMethods[] = {
    {"supports", (PyCFunction)PyIDataMessage_SupportsInterface, METH_O, ""},
    {"get_CreationDate", (PyCFunction)IDataMessageMethod_get_CreationDate, METH_VARARGS, ""},
    {"get_ID", (PyCFunction)IDataMessageMethod_get_ID, METH_VARARGS, ""},
    {"get_MessageType", (PyCFunction)IDataMessageMethod_get_MessageType, METH_VARARGS, ""},
    {"get_Priority", (PyCFunction)IDataMessageMethod_get_Priority, METH_VARARGS, ""},
    {"put_Priority", (PyCFunction)IDataMessageMethod_put_Priority, METH_VARARGS, ""},
    {"get_Destination", (PyCFunction)IDataMessageMethod_get_Destination, METH_VARARGS, ""},
    {"put_Destination", (PyCFunction)IDataMessageMethod_put_Destination, METH_VARARGS, ""},
    {"get_ArgumentCount", (PyCFunction)IDataMessageMethod_get_ArgumentCount, METH_VARARGS, ""},
    {"setArgument", (PyCFunction)IDataMessageMethod_setArgument, METH_VARARGS, ""},
    {"addArgument", (PyCFunction)IDataMessageMethod_addArgument, METH_VARARGS, ""},
    {"removeArgument", (PyCFunction)IDataMessageMethod_removeArgument, METH_VARARGS, ""},
    {"getArgument", (PyCFunction)IDataMessageMethod_getArgument, METH_VARARGS, ""},
    {"get_DataDefinitionID", (PyCFunction)IDataMessageMethod_get_DataDefinitionID, METH_VARARGS, ""},
    {"put_DataDefinitionID", (PyCFunction)IDataMessageMethod_put_DataDefinitionID, METH_VARARGS, ""},
    {"get_ColumnCount", (PyCFunction)IDataMessageMethod_get_ColumnCount, METH_VARARGS, ""},
    {"setColumn", (PyCFunction)IDataMessageMethod_setColumn, METH_VARARGS, ""},
    {"addColumn", (PyCFunction)IDataMessageMethod_addColumn, METH_VARARGS, ""},
    {"removeColumn", (PyCFunction)IDataMessageMethod_removeColumn, METH_VARARGS, ""},
    {"getColumn", (PyCFunction)IDataMessageMethod_getColumn, METH_VARARGS, ""},
    {"getRawColumn", (PyCFunction)IDataMessageMethod_getRawColumn, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIDataMessageGetSet[] = {
  {"_pUnk", (getter)PyIDataMessage_GetpUnk, NULL, "Get opaque pointer to an Unknown from IDataMessage", NULL},
  {"_pointer", (getter)PyIDataMessage_GetPointer, NULL, "Get memory address for IDataMessage", NULL},
  {"_IID", (getter)PyIDataMessage_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIDataMessage_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIDataMessage_GetIgnoreFailures, (setter)PyIDataMessage_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIDataMessageObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.IDataMessageObject",                          
                                              /* tp_name */
  sizeof(PyIDataMessageObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIDataMessageObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIDataMessageMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIDataMessageGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIDataMessageObject_new,                      
                                              /* tp_new */
};

// Interface ITemporalOperator

typedef struct PyITemporalOperatorObject {
    PyObject_HEAD
    ITemporalOperator* m_pITemporalOperator;
    HRESULT m_HR;
    int m_ignore_failures;
} PyITemporalOperatorObject;

static PyObject*
PyITemporalOperatorObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyITemporalOperatorObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ITemporalOperator* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ITemporalOperator, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ITemporalOperator with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyITemporalOperatorObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ITemporalOperator");
            return NULL;
        }
        self->m_pITemporalOperator = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ITemporalOperator");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ITemporalOperator");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ITemporalOperator* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ITemporalOperator, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ITemporalOperator");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyITemporalOperatorObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ITemporalOperator");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pITemporalOperator = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyITemporalOperatorObject_dealloc(PyITemporalOperatorObject* self)
{
    if (self->m_pITemporalOperator)
        self->m_pITemporalOperator->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyITemporalOperator_GetpUnk(PyITemporalOperatorObject* self)
{
    if (!self->m_pITemporalOperator)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pITemporalOperator->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ITemporalOperator to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyITemporalOperator_GetPointer(PyITemporalOperatorObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pITemporalOperator);
}

static PyObject*
PyITemporalOperator_GetIID(PyITemporalOperatorObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "56ae7150-7bfc-11d6-b84d-00010265adc5");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyITemporalOperator_GetHR(PyITemporalOperatorObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyITemporalOperator_GetIgnoreFailures(PyITemporalOperatorObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyITemporalOperator_SetIgnoreFailures(PyITemporalOperatorObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyITemporalOperator_SupportsInterface(PyITemporalOperatorObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pITemporalOperator->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ITemporalOperatorMethod_SetDateTime(PyITemporalOperatorObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long llYear = 0;
    short slMonth = 0;
    short slDayOfMonth = 0;
    short slHour = 0;
    short slMinute = 0;
    short slSecond = 0;
    short slMillisecond = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "lhhhhhh", &llYear, &slMonth, &slDayOfMonth, &slHour, &slMinute, &slSecond, &slMillisecond))
      goto itemporaloperator_setdatetime_method_cleanup;

    // Set up initial variable values as needed
    // No setup for lYear
    // No setup for lMonth
    // No setup for lDayOfMonth
    // No setup for lHour
    // No setup for lMinute
    // No setup for lSecond
    // No setup for lMillisecond

    // Call method on actual COM interface
    hr = self->m_pITemporalOperator->SetDateTime(llYear, slMonth, slDayOfMonth, slHour, slMinute, slSecond, slMillisecond);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalOperator->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalOperator) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalOperator.SetDateTime() returned %ld", (long)hr);
        goto itemporaloperator_setdatetime_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for lYear
    // No teardown for lMonth
    // No teardown for lDayOfMonth
    // No teardown for lHour
    // No teardown for lMinute
    // No teardown for lSecond
    // No teardown for lMillisecond

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto itemporaloperator_setdatetime_method_cleanup;

    itemporaloperator_setdatetime_method_cleanup:
    self->m_HR = hr;
    // No cleanup for lYear
    // No cleanup for lMonth
    // No cleanup for lDayOfMonth
    // No cleanup for lHour
    // No cleanup for lMinute
    // No cleanup for lSecond
    // No cleanup for lMillisecond
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalOperator.SetDateTime");
    return return_tuple;
}

static PyObject*
ITemporalOperatorMethod_SetInterval(PyITemporalOperatorObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double ddQuantity = 0;
    enumTemporalOperatorUnits eenumUnits;

    // Unpack values
    if (!PyArg_ParseTuple(args, "di", &ddQuantity, (int *)&eenumUnits))
      goto itemporaloperator_setinterval_method_cleanup;

    // Set up initial variable values as needed
    // No setup for dQuantity
    // No setup for enumUnits

    // Call method on actual COM interface
    hr = self->m_pITemporalOperator->SetInterval(ddQuantity, eenumUnits);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalOperator->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalOperator) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalOperator.SetInterval() returned %ld", (long)hr);
        goto itemporaloperator_setinterval_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for dQuantity
    // No teardown for enumUnits

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto itemporaloperator_setinterval_method_cleanup;

    itemporaloperator_setinterval_method_cleanup:
    self->m_HR = hr;
    // No cleanup for dQuantity
    // No cleanup for enumUnits
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalOperator.SetInterval");
    return return_tuple;
}

static PyObject*
ITemporalOperatorMethod_get_Type(PyITemporalOperatorObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    enumTemporalOperatorType epVal;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pITemporalOperator->get_Type(&epVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalOperator->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalOperator) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalOperator.get_Type() returned %ld", (long)hr);
        goto itemporaloperator_get_type_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)epVal);
    goto itemporaloperator_get_type_method_cleanup;

    itemporaloperator_get_type_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalOperator.get_Type");
    return return_tuple;
}

static PyObject*
ITemporalOperatorMethod_Reset(PyITemporalOperatorObject* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pITemporalOperator->Reset();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalOperator->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalOperator) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalOperator.Reset() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}

static PyObject*
ITemporalOperatorMethod_Add(PyITemporalOperatorObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ITemporalOperator* ippiOtherOperator = NULL;
    PyObject* py_piOtherOperator;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_piOtherOperator))
      goto itemporaloperator_add_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_piOtherOperator, &IID_ITemporalOperator, (void**)&ippiOtherOperator))
        PyErr_SetString(PyExc_TypeError, "Argument piOtherOperator (position 0) is not ITemporalOperator");
    
    if (PyErr_Occurred())
      goto itemporaloperator_add_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITemporalOperator->Add(ippiOtherOperator);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalOperator->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalOperator) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalOperator.Add() returned %ld", (long)hr);
        goto itemporaloperator_add_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for piOtherOperator

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto itemporaloperator_add_method_cleanup;

    itemporaloperator_add_method_cleanup:
    self->m_HR = hr;
    if (ippiOtherOperator)
      ippiOtherOperator->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalOperator.Add");
    return return_tuple;
}

static PyObject*
ITemporalOperatorMethod_Subtract(PyITemporalOperatorObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ITemporalOperator* ippiOtherOperator = NULL;
    PyObject* py_piOtherOperator;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_piOtherOperator))
      goto itemporaloperator_subtract_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_piOtherOperator, &IID_ITemporalOperator, (void**)&ippiOtherOperator))
        PyErr_SetString(PyExc_TypeError, "Argument piOtherOperator (position 0) is not ITemporalOperator");
    
    if (PyErr_Occurred())
      goto itemporaloperator_subtract_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITemporalOperator->Subtract(ippiOtherOperator);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalOperator->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalOperator) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalOperator.Subtract() returned %ld", (long)hr);
        goto itemporaloperator_subtract_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for piOtherOperator

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto itemporaloperator_subtract_method_cleanup;

    itemporaloperator_subtract_method_cleanup:
    self->m_HR = hr;
    if (ippiOtherOperator)
      ippiOtherOperator->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalOperator.Subtract");
    return return_tuple;
}

static PyObject*
ITemporalOperatorMethod_get_AsString(PyITemporalOperatorObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsbstrFormat = 0;
    PyObject* pyvar_bstrFormat;
    PyObject* unicodebstrFormat = NULL;
    BSTR bspVal;
    PyObject* pyvar_pVal = Py_None;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_bstrFormat))
      goto itemporaloperator_get_asstring_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_bstrFormat))
        unicodebstrFormat = PyUnicode_FromObject(pyvar_bstrFormat);
    else if (PyUnicode_Check(pyvar_bstrFormat))
    {
        unicodebstrFormat = pyvar_bstrFormat;
        Py_INCREF(unicodebstrFormat);
    }
    else if (pyvar_bstrFormat != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter bstrFormat at index 0");
    if (unicodebstrFormat)
        bsbstrFormat = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodebstrFormat), 
                                            (UINT)PyUnicode_GET_SIZE(unicodebstrFormat));
    
    if (PyErr_Occurred())
      goto itemporaloperator_get_asstring_method_cleanup;
    
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pITemporalOperator->get_AsString(bsbstrFormat, &bspVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalOperator->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalOperator) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalOperator.get_AsString() returned %ld", (long)hr);
        goto itemporaloperator_get_asstring_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for bstrFormat
    pyvar_pVal = PyUnicode_FromWideChar(bspVal,::SysStringLen(bspVal));
    ::SysFreeString(bspVal);
    
    if (PyErr_Occurred())
      goto itemporaloperator_get_asstring_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pVal);
    goto itemporaloperator_get_asstring_method_cleanup;

    itemporaloperator_get_asstring_method_cleanup:
    self->m_HR = hr;
    if (bsbstrFormat)
        ::SysFreeString(bsbstrFormat);
    
    if (pyvar_pVal != Py_None)
        Py_XDECREF(pyvar_pVal);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalOperator.get_AsString");
    return return_tuple;
}

static PyObject*
ITemporalOperatorMethod_get_AsDate(PyITemporalOperatorObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT vpVal;
    ::VariantInit(&vpVal);
    PyObject* pyvar_pVal = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pITemporalOperator->get_AsDate(&vpVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalOperator->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalOperator) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalOperator.get_AsDate() returned %ld", (long)hr);
        goto itemporaloperator_get_asdate_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pVal = Variant_AsPyObject(&vpVal);
    if (PyErr_Occurred())
      goto itemporaloperator_get_asdate_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pVal);
    goto itemporaloperator_get_asdate_method_cleanup;

    itemporaloperator_get_asdate_method_cleanup:
    self->m_HR = hr;
    ::VariantClear(&vpVal);
    Py_XDECREF(pyvar_pVal);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalOperator.get_AsDate");
    return return_tuple;
}

static PyObject*
ITemporalOperatorMethod_get_AsInterval(PyITemporalOperatorObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    enumTemporalOperatorUnits eenumUnits;
    VARIANT vpVal;
    ::VariantInit(&vpVal);
    PyObject* pyvar_pVal = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&eenumUnits))
      goto itemporaloperator_get_asinterval_method_cleanup;

    // Set up initial variable values as needed
    // No setup for enumUnits
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pITemporalOperator->get_AsInterval(eenumUnits, &vpVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalOperator->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalOperator) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalOperator.get_AsInterval() returned %ld", (long)hr);
        goto itemporaloperator_get_asinterval_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for enumUnits
    pyvar_pVal = Variant_AsPyObject(&vpVal);
    if (PyErr_Occurred())
      goto itemporaloperator_get_asinterval_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pVal);
    goto itemporaloperator_get_asinterval_method_cleanup;

    itemporaloperator_get_asinterval_method_cleanup:
    self->m_HR = hr;
    // No cleanup for enumUnits
    ::VariantClear(&vpVal);
    Py_XDECREF(pyvar_pVal);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalOperator.get_AsInterval");
    return return_tuple;
}

static PyObject*
ITemporalOperatorMethod_get_Value(PyITemporalOperatorObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT vpVal;
    ::VariantInit(&vpVal);
    PyObject* pyvar_pVal = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pITemporalOperator->get_Value(&vpVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalOperator->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalOperator) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalOperator.get_Value() returned %ld", (long)hr);
        goto itemporaloperator_get_value_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pVal = Variant_AsPyObject(&vpVal);
    if (PyErr_Occurred())
      goto itemporaloperator_get_value_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pVal);
    goto itemporaloperator_get_value_method_cleanup;

    itemporaloperator_get_value_method_cleanup:
    self->m_HR = hr;
    ::VariantClear(&vpVal);
    Py_XDECREF(pyvar_pVal);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalOperator.get_Value");
    return return_tuple;
}

static PyObject*
ITemporalOperatorMethod_get_IntervalQuantity(PyITemporalOperatorObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dpVal = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pITemporalOperator->get_IntervalQuantity(&dpVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalOperator->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalOperator) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalOperator.get_IntervalQuantity() returned %ld", (long)hr);
        goto itemporaloperator_get_intervalquantity_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dpVal);
    goto itemporaloperator_get_intervalquantity_method_cleanup;

    itemporaloperator_get_intervalquantity_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalOperator.get_IntervalQuantity");
    return return_tuple;
}

static PyObject*
ITemporalOperatorMethod_get_IntervalUnits(PyITemporalOperatorObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    enumTemporalOperatorUnits epVal;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pITemporalOperator->get_IntervalUnits(&epVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalOperator->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalOperator) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalOperator.get_IntervalUnits() returned %ld", (long)hr);
        goto itemporaloperator_get_intervalunits_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)epVal);
    goto itemporaloperator_get_intervalunits_method_cleanup;

    itemporaloperator_get_intervalunits_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalOperator.get_IntervalUnits");
    return return_tuple;
}


PyMethodDef PyITemporalOperatorMethods[] = {
    {"supports", (PyCFunction)PyITemporalOperator_SupportsInterface, METH_O, ""},
    {"SetDateTime", (PyCFunction)ITemporalOperatorMethod_SetDateTime, METH_VARARGS, ""},
    {"SetInterval", (PyCFunction)ITemporalOperatorMethod_SetInterval, METH_VARARGS, ""},
    {"get_Type", (PyCFunction)ITemporalOperatorMethod_get_Type, METH_VARARGS, ""},
    {"Reset", (PyCFunction)ITemporalOperatorMethod_Reset, METH_NOARGS, ""},
    {"Add", (PyCFunction)ITemporalOperatorMethod_Add, METH_VARARGS, ""},
    {"Subtract", (PyCFunction)ITemporalOperatorMethod_Subtract, METH_VARARGS, ""},
    {"get_AsString", (PyCFunction)ITemporalOperatorMethod_get_AsString, METH_VARARGS, ""},
    {"get_AsDate", (PyCFunction)ITemporalOperatorMethod_get_AsDate, METH_VARARGS, ""},
    {"get_AsInterval", (PyCFunction)ITemporalOperatorMethod_get_AsInterval, METH_VARARGS, ""},
    {"get_Value", (PyCFunction)ITemporalOperatorMethod_get_Value, METH_VARARGS, ""},
    {"get_IntervalQuantity", (PyCFunction)ITemporalOperatorMethod_get_IntervalQuantity, METH_VARARGS, ""},
    {"get_IntervalUnits", (PyCFunction)ITemporalOperatorMethod_get_IntervalUnits, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyITemporalOperatorGetSet[] = {
  {"_pUnk", (getter)PyITemporalOperator_GetpUnk, NULL, "Get opaque pointer to an Unknown from ITemporalOperator", NULL},
  {"_pointer", (getter)PyITemporalOperator_GetPointer, NULL, "Get memory address for ITemporalOperator", NULL},
  {"_IID", (getter)PyITemporalOperator_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyITemporalOperator_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyITemporalOperator_GetIgnoreFailures, (setter)PyITemporalOperator_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyITemporalOperatorObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.ITemporalOperatorObject",                          
                                              /* tp_name */
  sizeof(PyITemporalOperatorObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyITemporalOperatorObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyITemporalOperatorMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyITemporalOperatorGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyITemporalOperatorObject_new,                      
                                              /* tp_new */
};

// Interface ITrackingServiceDef

typedef struct PyITrackingServiceDefObject {
    PyObject_HEAD
    ITrackingServiceDef* m_pITrackingServiceDef;
    HRESULT m_HR;
    int m_ignore_failures;
} PyITrackingServiceDefObject;

static PyObject*
PyITrackingServiceDefObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyITrackingServiceDefObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ITrackingServiceDef* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ITrackingServiceDef, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ITrackingServiceDef with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyITrackingServiceDefObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ITrackingServiceDef");
            return NULL;
        }
        self->m_pITrackingServiceDef = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ITrackingServiceDef");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ITrackingServiceDef");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ITrackingServiceDef* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ITrackingServiceDef, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ITrackingServiceDef");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyITrackingServiceDefObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ITrackingServiceDef");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pITrackingServiceDef = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyITrackingServiceDefObject_dealloc(PyITrackingServiceDefObject* self)
{
    if (self->m_pITrackingServiceDef)
        self->m_pITrackingServiceDef->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyITrackingServiceDef_GetpUnk(PyITrackingServiceDefObject* self)
{
    if (!self->m_pITrackingServiceDef)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pITrackingServiceDef->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ITrackingServiceDef to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyITrackingServiceDef_GetPointer(PyITrackingServiceDefObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pITrackingServiceDef);
}

static PyObject*
PyITrackingServiceDef_GetIID(PyITrackingServiceDefObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "1b9c2538-3b1d-11d5-b7e4-00010265adc5");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyITrackingServiceDef_GetHR(PyITrackingServiceDefObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyITrackingServiceDef_GetIgnoreFailures(PyITrackingServiceDefObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyITrackingServiceDef_SetIgnoreFailures(PyITrackingServiceDefObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyITrackingServiceDef_SupportsInterface(PyITrackingServiceDefObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pITrackingServiceDef->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ITrackingServiceDefMethod_get_Name(PyITrackingServiceDefObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspVal;
    PyObject* pyvar_pVal = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pITrackingServiceDef->get_Name(&bspVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITrackingServiceDef->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITrackingServiceDef) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITrackingServiceDef.get_Name() returned %ld", (long)hr);
        goto itrackingservicedef_get_name_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pVal = PyUnicode_FromWideChar(bspVal,::SysStringLen(bspVal));
    ::SysFreeString(bspVal);
    
    if (PyErr_Occurred())
      goto itrackingservicedef_get_name_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pVal);
    goto itrackingservicedef_get_name_method_cleanup;

    itrackingservicedef_get_name_method_cleanup:
    self->m_HR = hr;
    if (pyvar_pVal != Py_None)
        Py_XDECREF(pyvar_pVal);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITrackingServiceDef.get_Name");
    return return_tuple;
}

static PyObject*
ITrackingServiceDefMethod_put_Name(PyITrackingServiceDefObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspVal = 0;
    PyObject* pyvar_pVal;
    PyObject* unicodepVal = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pVal))
      goto itrackingservicedef_put_name_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_pVal))
        unicodepVal = PyUnicode_FromObject(pyvar_pVal);
    else if (PyUnicode_Check(pyvar_pVal))
    {
        unicodepVal = pyvar_pVal;
        Py_INCREF(unicodepVal);
    }
    else if (pyvar_pVal != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter pVal at index 0");
    if (unicodepVal)
        bspVal = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodepVal), 
                                            (UINT)PyUnicode_GET_SIZE(unicodepVal));
    
    if (PyErr_Occurred())
      goto itrackingservicedef_put_name_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITrackingServiceDef->put_Name(bspVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITrackingServiceDef->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITrackingServiceDef) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITrackingServiceDef.put_Name() returned %ld", (long)hr);
        goto itrackingservicedef_put_name_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto itrackingservicedef_put_name_method_cleanup;

    itrackingservicedef_put_name_method_cleanup:
    self->m_HR = hr;
    if (bspVal)
        ::SysFreeString(bspVal);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITrackingServiceDef.put_Name");
    return return_tuple;
}

static PyObject*
ITrackingServiceDefMethod_get_MetaData(PyITrackingServiceDefObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspVal;
    PyObject* pyvar_pVal = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pITrackingServiceDef->get_MetaData(&bspVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITrackingServiceDef->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITrackingServiceDef) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITrackingServiceDef.get_MetaData() returned %ld", (long)hr);
        goto itrackingservicedef_get_metadata_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pVal = PyUnicode_FromWideChar(bspVal,::SysStringLen(bspVal));
    ::SysFreeString(bspVal);
    
    if (PyErr_Occurred())
      goto itrackingservicedef_get_metadata_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pVal);
    goto itrackingservicedef_get_metadata_method_cleanup;

    itrackingservicedef_get_metadata_method_cleanup:
    self->m_HR = hr;
    if (pyvar_pVal != Py_None)
        Py_XDECREF(pyvar_pVal);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITrackingServiceDef.get_MetaData");
    return return_tuple;
}

static PyObject*
ITrackingServiceDefMethod_put_MetaData(PyITrackingServiceDefObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspVal = 0;
    PyObject* pyvar_pVal;
    PyObject* unicodepVal = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pVal))
      goto itrackingservicedef_put_metadata_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_pVal))
        unicodepVal = PyUnicode_FromObject(pyvar_pVal);
    else if (PyUnicode_Check(pyvar_pVal))
    {
        unicodepVal = pyvar_pVal;
        Py_INCREF(unicodepVal);
    }
    else if (pyvar_pVal != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter pVal at index 0");
    if (unicodepVal)
        bspVal = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodepVal), 
                                            (UINT)PyUnicode_GET_SIZE(unicodepVal));
    
    if (PyErr_Occurred())
      goto itrackingservicedef_put_metadata_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITrackingServiceDef->put_MetaData(bspVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITrackingServiceDef->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITrackingServiceDef) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITrackingServiceDef.put_MetaData() returned %ld", (long)hr);
        goto itrackingservicedef_put_metadata_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto itrackingservicedef_put_metadata_method_cleanup;

    itrackingservicedef_put_metadata_method_cleanup:
    self->m_HR = hr;
    if (bspVal)
        ::SysFreeString(bspVal);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITrackingServiceDef.put_MetaData");
    return return_tuple;
}

static PyObject*
ITrackingServiceDefMethod_get_ObjectDefinitionName(PyITrackingServiceDefObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspVal;
    PyObject* pyvar_pVal = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pITrackingServiceDef->get_ObjectDefinitionName(&bspVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITrackingServiceDef->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITrackingServiceDef) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITrackingServiceDef.get_ObjectDefinitionName() returned %ld", (long)hr);
        goto itrackingservicedef_get_objectdefinitionname_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pVal = PyUnicode_FromWideChar(bspVal,::SysStringLen(bspVal));
    ::SysFreeString(bspVal);
    
    if (PyErr_Occurred())
      goto itrackingservicedef_get_objectdefinitionname_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pVal);
    goto itrackingservicedef_get_objectdefinitionname_method_cleanup;

    itrackingservicedef_get_objectdefinitionname_method_cleanup:
    self->m_HR = hr;
    if (pyvar_pVal != Py_None)
        Py_XDECREF(pyvar_pVal);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITrackingServiceDef.get_ObjectDefinitionName");
    return return_tuple;
}

static PyObject*
ITrackingServiceDefMethod_put_ObjectDefinitionName(PyITrackingServiceDefObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspVal = 0;
    PyObject* pyvar_pVal;
    PyObject* unicodepVal = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pVal))
      goto itrackingservicedef_put_objectdefinitionname_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_pVal))
        unicodepVal = PyUnicode_FromObject(pyvar_pVal);
    else if (PyUnicode_Check(pyvar_pVal))
    {
        unicodepVal = pyvar_pVal;
        Py_INCREF(unicodepVal);
    }
    else if (pyvar_pVal != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter pVal at index 0");
    if (unicodepVal)
        bspVal = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodepVal), 
                                            (UINT)PyUnicode_GET_SIZE(unicodepVal));
    
    if (PyErr_Occurred())
      goto itrackingservicedef_put_objectdefinitionname_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITrackingServiceDef->put_ObjectDefinitionName(bspVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITrackingServiceDef->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITrackingServiceDef) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITrackingServiceDef.put_ObjectDefinitionName() returned %ld", (long)hr);
        goto itrackingservicedef_put_objectdefinitionname_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto itrackingservicedef_put_objectdefinitionname_method_cleanup;

    itrackingservicedef_put_objectdefinitionname_method_cleanup:
    self->m_HR = hr;
    if (bspVal)
        ::SysFreeString(bspVal);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITrackingServiceDef.put_ObjectDefinitionName");
    return return_tuple;
}

static PyObject*
ITrackingServiceDefMethod_get_ObservationDefinitionName(PyITrackingServiceDefObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspVal;
    PyObject* pyvar_pVal = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pITrackingServiceDef->get_ObservationDefinitionName(&bspVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITrackingServiceDef->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITrackingServiceDef) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITrackingServiceDef.get_ObservationDefinitionName() returned %ld", (long)hr);
        goto itrackingservicedef_get_observationdefinitionname_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pVal = PyUnicode_FromWideChar(bspVal,::SysStringLen(bspVal));
    ::SysFreeString(bspVal);
    
    if (PyErr_Occurred())
      goto itrackingservicedef_get_observationdefinitionname_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pVal);
    goto itrackingservicedef_get_observationdefinitionname_method_cleanup;

    itrackingservicedef_get_observationdefinitionname_method_cleanup:
    self->m_HR = hr;
    if (pyvar_pVal != Py_None)
        Py_XDECREF(pyvar_pVal);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITrackingServiceDef.get_ObservationDefinitionName");
    return return_tuple;
}

static PyObject*
ITrackingServiceDefMethod_put_ObservationDefinitionName(PyITrackingServiceDefObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspVal = 0;
    PyObject* pyvar_pVal;
    PyObject* unicodepVal = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pVal))
      goto itrackingservicedef_put_observationdefinitionname_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_pVal))
        unicodepVal = PyUnicode_FromObject(pyvar_pVal);
    else if (PyUnicode_Check(pyvar_pVal))
    {
        unicodepVal = pyvar_pVal;
        Py_INCREF(unicodepVal);
    }
    else if (pyvar_pVal != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter pVal at index 0");
    if (unicodepVal)
        bspVal = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodepVal), 
                                            (UINT)PyUnicode_GET_SIZE(unicodepVal));
    
    if (PyErr_Occurred())
      goto itrackingservicedef_put_observationdefinitionname_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITrackingServiceDef->put_ObservationDefinitionName(bspVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITrackingServiceDef->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITrackingServiceDef) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITrackingServiceDef.put_ObservationDefinitionName() returned %ld", (long)hr);
        goto itrackingservicedef_put_observationdefinitionname_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto itrackingservicedef_put_observationdefinitionname_method_cleanup;

    itrackingservicedef_put_observationdefinitionname_method_cleanup:
    self->m_HR = hr;
    if (bspVal)
        ::SysFreeString(bspVal);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITrackingServiceDef.put_ObservationDefinitionName");
    return return_tuple;
}

static PyObject*
ITrackingServiceDefMethod_get_ObjectSource(PyITrackingServiceDefObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    enumObjectSource epVal;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pITrackingServiceDef->get_ObjectSource(&epVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITrackingServiceDef->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITrackingServiceDef) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITrackingServiceDef.get_ObjectSource() returned %ld", (long)hr);
        goto itrackingservicedef_get_objectsource_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)epVal);
    goto itrackingservicedef_get_objectsource_method_cleanup;

    itrackingservicedef_get_objectsource_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITrackingServiceDef.get_ObjectSource");
    return return_tuple;
}

static PyObject*
ITrackingServiceDefMethod_put_ObjectSource(PyITrackingServiceDefObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    enumObjectSource epVal;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&epVal))
      goto itrackingservicedef_put_objectsource_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pITrackingServiceDef->put_ObjectSource(epVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITrackingServiceDef->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITrackingServiceDef) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITrackingServiceDef.put_ObjectSource() returned %ld", (long)hr);
        goto itrackingservicedef_put_objectsource_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto itrackingservicedef_put_objectsource_method_cleanup;

    itrackingservicedef_put_objectsource_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITrackingServiceDef.put_ObjectSource");
    return return_tuple;
}

static PyObject*
ITrackingServiceDefMethod_get_ObjectSourceConnectionString(PyITrackingServiceDefObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspVal;
    PyObject* pyvar_pVal = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pITrackingServiceDef->get_ObjectSourceConnectionString(&bspVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITrackingServiceDef->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITrackingServiceDef) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITrackingServiceDef.get_ObjectSourceConnectionString() returned %ld", (long)hr);
        goto itrackingservicedef_get_objectsourceconnectionstring_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pVal = PyUnicode_FromWideChar(bspVal,::SysStringLen(bspVal));
    ::SysFreeString(bspVal);
    
    if (PyErr_Occurred())
      goto itrackingservicedef_get_objectsourceconnectionstring_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pVal);
    goto itrackingservicedef_get_objectsourceconnectionstring_method_cleanup;

    itrackingservicedef_get_objectsourceconnectionstring_method_cleanup:
    self->m_HR = hr;
    if (pyvar_pVal != Py_None)
        Py_XDECREF(pyvar_pVal);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITrackingServiceDef.get_ObjectSourceConnectionString");
    return return_tuple;
}

static PyObject*
ITrackingServiceDefMethod_put_ObjectSourceConnectionString(PyITrackingServiceDefObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspVal = 0;
    PyObject* pyvar_pVal;
    PyObject* unicodepVal = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pVal))
      goto itrackingservicedef_put_objectsourceconnectionstring_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_pVal))
        unicodepVal = PyUnicode_FromObject(pyvar_pVal);
    else if (PyUnicode_Check(pyvar_pVal))
    {
        unicodepVal = pyvar_pVal;
        Py_INCREF(unicodepVal);
    }
    else if (pyvar_pVal != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter pVal at index 0");
    if (unicodepVal)
        bspVal = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodepVal), 
                                            (UINT)PyUnicode_GET_SIZE(unicodepVal));
    
    if (PyErr_Occurred())
      goto itrackingservicedef_put_objectsourceconnectionstring_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITrackingServiceDef->put_ObjectSourceConnectionString(bspVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITrackingServiceDef->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITrackingServiceDef) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITrackingServiceDef.put_ObjectSourceConnectionString() returned %ld", (long)hr);
        goto itrackingservicedef_put_objectsourceconnectionstring_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto itrackingservicedef_put_objectsourceconnectionstring_method_cleanup;

    itrackingservicedef_put_objectsourceconnectionstring_method_cleanup:
    self->m_HR = hr;
    if (bspVal)
        ::SysFreeString(bspVal);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITrackingServiceDef.put_ObjectSourceConnectionString");
    return return_tuple;
}

static PyObject*
ITrackingServiceDefMethod_get_SourceOfGeometry(PyITrackingServiceDefObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    enumShapeSource epVal;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pITrackingServiceDef->get_SourceOfGeometry(&epVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITrackingServiceDef->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITrackingServiceDef) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITrackingServiceDef.get_SourceOfGeometry() returned %ld", (long)hr);
        goto itrackingservicedef_get_sourceofgeometry_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)epVal);
    goto itrackingservicedef_get_sourceofgeometry_method_cleanup;

    itrackingservicedef_get_sourceofgeometry_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITrackingServiceDef.get_SourceOfGeometry");
    return return_tuple;
}

static PyObject*
ITrackingServiceDefMethod_put_SourceOfGeometry(PyITrackingServiceDefObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    enumShapeSource epVal;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&epVal))
      goto itrackingservicedef_put_sourceofgeometry_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pITrackingServiceDef->put_SourceOfGeometry(epVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITrackingServiceDef->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITrackingServiceDef) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITrackingServiceDef.put_SourceOfGeometry() returned %ld", (long)hr);
        goto itrackingservicedef_put_sourceofgeometry_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto itrackingservicedef_put_sourceofgeometry_method_cleanup;

    itrackingservicedef_put_sourceofgeometry_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITrackingServiceDef.put_SourceOfGeometry");
    return return_tuple;
}


PyMethodDef PyITrackingServiceDefMethods[] = {
    {"supports", (PyCFunction)PyITrackingServiceDef_SupportsInterface, METH_O, ""},
    {"get_Name", (PyCFunction)ITrackingServiceDefMethod_get_Name, METH_VARARGS, ""},
    {"put_Name", (PyCFunction)ITrackingServiceDefMethod_put_Name, METH_VARARGS, ""},
    {"get_MetaData", (PyCFunction)ITrackingServiceDefMethod_get_MetaData, METH_VARARGS, ""},
    {"put_MetaData", (PyCFunction)ITrackingServiceDefMethod_put_MetaData, METH_VARARGS, ""},
    {"get_ObjectDefinitionName", (PyCFunction)ITrackingServiceDefMethod_get_ObjectDefinitionName, METH_VARARGS, ""},
    {"put_ObjectDefinitionName", (PyCFunction)ITrackingServiceDefMethod_put_ObjectDefinitionName, METH_VARARGS, ""},
    {"get_ObservationDefinitionName", (PyCFunction)ITrackingServiceDefMethod_get_ObservationDefinitionName, METH_VARARGS, ""},
    {"put_ObservationDefinitionName", (PyCFunction)ITrackingServiceDefMethod_put_ObservationDefinitionName, METH_VARARGS, ""},
    {"get_ObjectSource", (PyCFunction)ITrackingServiceDefMethod_get_ObjectSource, METH_VARARGS, ""},
    {"put_ObjectSource", (PyCFunction)ITrackingServiceDefMethod_put_ObjectSource, METH_VARARGS, ""},
    {"get_ObjectSourceConnectionString", (PyCFunction)ITrackingServiceDefMethod_get_ObjectSourceConnectionString, METH_VARARGS, ""},
    {"put_ObjectSourceConnectionString", (PyCFunction)ITrackingServiceDefMethod_put_ObjectSourceConnectionString, METH_VARARGS, ""},
    {"get_SourceOfGeometry", (PyCFunction)ITrackingServiceDefMethod_get_SourceOfGeometry, METH_VARARGS, ""},
    {"put_SourceOfGeometry", (PyCFunction)ITrackingServiceDefMethod_put_SourceOfGeometry, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyITrackingServiceDefGetSet[] = {
  {"_pUnk", (getter)PyITrackingServiceDef_GetpUnk, NULL, "Get opaque pointer to an Unknown from ITrackingServiceDef", NULL},
  {"_pointer", (getter)PyITrackingServiceDef_GetPointer, NULL, "Get memory address for ITrackingServiceDef", NULL},
  {"_IID", (getter)PyITrackingServiceDef_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyITrackingServiceDef_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyITrackingServiceDef_GetIgnoreFailures, (setter)PyITrackingServiceDef_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyITrackingServiceDefObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.ITrackingServiceDefObject",                          
                                              /* tp_name */
  sizeof(PyITrackingServiceDefObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyITrackingServiceDefObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyITrackingServiceDefMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyITrackingServiceDefGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyITrackingServiceDefObject_new,                      
                                              /* tp_new */
};

// Interface _ITemporalFeatureClassEvents

typedef struct Py_ITemporalFeatureClassEventsObject {
    PyObject_HEAD
    _ITemporalFeatureClassEvents* m_p_ITemporalFeatureClassEvents;
    HRESULT m_HR;
    int m_ignore_failures;
} Py_ITemporalFeatureClassEventsObject;

static PyObject*
Py_ITemporalFeatureClassEventsObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    Py_ITemporalFeatureClassEventsObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        _ITemporalFeatureClassEvents* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID__ITemporalFeatureClassEvents, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate _ITemporalFeatureClassEvents with provided CLSID");
            return NULL;
        }
        if (!(self = ((Py_ITemporalFeatureClassEventsObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate _ITemporalFeatureClassEvents");
            return NULL;
        }
        self->m_p_ITemporalFeatureClassEvents = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for _ITemporalFeatureClassEvents");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to _ITemporalFeatureClassEvents");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    _ITemporalFeatureClassEvents* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID__ITemporalFeatureClassEvents, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to _ITemporalFeatureClassEvents");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((Py_ITemporalFeatureClassEventsObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate _ITemporalFeatureClassEvents");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_p_ITemporalFeatureClassEvents = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
Py_ITemporalFeatureClassEventsObject_dealloc(Py_ITemporalFeatureClassEventsObject* self)
{
    if (self->m_p_ITemporalFeatureClassEvents)
        self->m_p_ITemporalFeatureClassEvents->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
Py_ITemporalFeatureClassEvents_GetpUnk(Py_ITemporalFeatureClassEventsObject* self)
{
    if (!self->m_p_ITemporalFeatureClassEvents)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_p_ITemporalFeatureClassEvents->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI _ITemporalFeatureClassEvents to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
Py_ITemporalFeatureClassEvents_GetPointer(Py_ITemporalFeatureClassEventsObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_p_ITemporalFeatureClassEvents);
}

static PyObject*
Py_ITemporalFeatureClassEvents_GetIID(Py_ITemporalFeatureClassEventsObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "cc018a65-24fb-11d4-b34c-00104ba2abcc");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
Py_ITemporalFeatureClassEvents_GetHR(Py_ITemporalFeatureClassEventsObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
Py_ITemporalFeatureClassEvents_GetIgnoreFailures(Py_ITemporalFeatureClassEventsObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
Py_ITemporalFeatureClassEvents_SetIgnoreFailures(Py_ITemporalFeatureClassEventsObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
Py_ITemporalFeatureClassEvents_SupportsInterface(Py_ITemporalFeatureClassEventsObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_p_ITemporalFeatureClassEvents->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
_ITemporalFeatureClassEventsMethod_OnAddData(Py_ITemporalFeatureClassEventsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IEnvelope* ippiEnvelope = NULL;
    PyObject* py_piEnvelope;
    IFeatureClass* ippiFeatureClass = NULL;
    PyObject* py_piFeatureClass;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OO", &py_piEnvelope, &py_piFeatureClass))
      goto _itemporalfeatureclassevents_onadddata_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_piEnvelope, &IID_IEnvelope, (void**)&ippiEnvelope))
        PyErr_SetString(PyExc_TypeError, "Argument piEnvelope (position 0) is not IEnvelope");
    
    if (PyErr_Occurred())
      goto _itemporalfeatureclassevents_onadddata_method_cleanup;
    
    if (!IFaceFromPyObject(py_piFeatureClass, &IID_IFeatureClass, (void**)&ippiFeatureClass))
        PyErr_SetString(PyExc_TypeError, "Argument piFeatureClass (position 1) is not IFeatureClass");
    
    if (PyErr_Occurred())
      goto _itemporalfeatureclassevents_onadddata_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_p_ITemporalFeatureClassEvents->OnAddData(ippiEnvelope, ippiFeatureClass);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_p_ITemporalFeatureClassEvents->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID__ITemporalFeatureClassEvents) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: _ITemporalFeatureClassEvents.OnAddData() returned %ld", (long)hr);
        goto _itemporalfeatureclassevents_onadddata_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for piEnvelope
    // No teardown for piFeatureClass

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto _itemporalfeatureclassevents_onadddata_method_cleanup;

    _itemporalfeatureclassevents_onadddata_method_cleanup:
    self->m_HR = hr;
    if (ippiEnvelope)
      ippiEnvelope->Release();
    if (ippiFeatureClass)
      ippiFeatureClass->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in _ITemporalFeatureClassEvents.OnAddData");
    return return_tuple;
}

static PyObject*
_ITemporalFeatureClassEventsMethod_OnRemoveData(Py_ITemporalFeatureClassEventsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IEnvelope* ippiEnvelope = NULL;
    PyObject* py_piEnvelope;
    IFeatureClass* ippiFeatureClass = NULL;
    PyObject* py_piFeatureClass;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OO", &py_piEnvelope, &py_piFeatureClass))
      goto _itemporalfeatureclassevents_onremovedata_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_piEnvelope, &IID_IEnvelope, (void**)&ippiEnvelope))
        PyErr_SetString(PyExc_TypeError, "Argument piEnvelope (position 0) is not IEnvelope");
    
    if (PyErr_Occurred())
      goto _itemporalfeatureclassevents_onremovedata_method_cleanup;
    
    if (!IFaceFromPyObject(py_piFeatureClass, &IID_IFeatureClass, (void**)&ippiFeatureClass))
        PyErr_SetString(PyExc_TypeError, "Argument piFeatureClass (position 1) is not IFeatureClass");
    
    if (PyErr_Occurred())
      goto _itemporalfeatureclassevents_onremovedata_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_p_ITemporalFeatureClassEvents->OnRemoveData(ippiEnvelope, ippiFeatureClass);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_p_ITemporalFeatureClassEvents->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID__ITemporalFeatureClassEvents) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: _ITemporalFeatureClassEvents.OnRemoveData() returned %ld", (long)hr);
        goto _itemporalfeatureclassevents_onremovedata_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for piEnvelope
    // No teardown for piFeatureClass

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto _itemporalfeatureclassevents_onremovedata_method_cleanup;

    _itemporalfeatureclassevents_onremovedata_method_cleanup:
    self->m_HR = hr;
    if (ippiEnvelope)
      ippiEnvelope->Release();
    if (ippiFeatureClass)
      ippiFeatureClass->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in _ITemporalFeatureClassEvents.OnRemoveData");
    return return_tuple;
}


PyMethodDef Py_ITemporalFeatureClassEventsMethods[] = {
    {"supports", (PyCFunction)Py_ITemporalFeatureClassEvents_SupportsInterface, METH_O, ""},
    {"OnAddData", (PyCFunction)_ITemporalFeatureClassEventsMethod_OnAddData, METH_VARARGS, ""},
    {"OnRemoveData", (PyCFunction)_ITemporalFeatureClassEventsMethod_OnRemoveData, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef Py_ITemporalFeatureClassEventsGetSet[] = {
  {"_pUnk", (getter)Py_ITemporalFeatureClassEvents_GetpUnk, NULL, "Get opaque pointer to an Unknown from _ITemporalFeatureClassEvents", NULL},
  {"_pointer", (getter)Py_ITemporalFeatureClassEvents_GetPointer, NULL, "Get memory address for _ITemporalFeatureClassEvents", NULL},
  {"_IID", (getter)Py_ITemporalFeatureClassEvents_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)Py_ITemporalFeatureClassEvents_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)Py_ITemporalFeatureClassEvents_GetIgnoreFailures, (setter)Py_ITemporalFeatureClassEvents_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject Py_ITemporalFeatureClassEventsObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions._ITemporalFeatureClassEventsObject",                          
                                              /* tp_name */
  sizeof(Py_ITemporalFeatureClassEventsObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)Py_ITemporalFeatureClassEventsObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  Py_ITemporalFeatureClassEventsMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  Py_ITemporalFeatureClassEventsGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  Py_ITemporalFeatureClassEventsObject_new,                      
                                              /* tp_new */
};

// Interface ITemporalFeatureClass2

typedef struct PyITemporalFeatureClass2Object {
    PyObject_HEAD
    ITemporalFeatureClass2* m_pITemporalFeatureClass2;
    HRESULT m_HR;
    int m_ignore_failures;
} PyITemporalFeatureClass2Object;

static PyObject*
PyITemporalFeatureClass2Object_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyITemporalFeatureClass2Object* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ITemporalFeatureClass2* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ITemporalFeatureClass2, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ITemporalFeatureClass2 with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyITemporalFeatureClass2Object *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ITemporalFeatureClass2");
            return NULL;
        }
        self->m_pITemporalFeatureClass2 = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ITemporalFeatureClass2");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ITemporalFeatureClass2");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ITemporalFeatureClass2* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ITemporalFeatureClass2, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ITemporalFeatureClass2");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyITemporalFeatureClass2Object *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ITemporalFeatureClass2");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pITemporalFeatureClass2 = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyITemporalFeatureClass2Object_dealloc(PyITemporalFeatureClass2Object* self)
{
    if (self->m_pITemporalFeatureClass2)
        self->m_pITemporalFeatureClass2->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyITemporalFeatureClass2_GetpUnk(PyITemporalFeatureClass2Object* self)
{
    if (!self->m_pITemporalFeatureClass2)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pITemporalFeatureClass2->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ITemporalFeatureClass2 to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyITemporalFeatureClass2_GetPointer(PyITemporalFeatureClass2Object* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pITemporalFeatureClass2);
}

static PyObject*
PyITemporalFeatureClass2_GetIID(PyITemporalFeatureClass2Object* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "4b026c0c-7189-4edf-9ea0-568c9d092257");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyITemporalFeatureClass2_GetHR(PyITemporalFeatureClass2Object* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyITemporalFeatureClass2_GetIgnoreFailures(PyITemporalFeatureClass2Object* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyITemporalFeatureClass2_SetIgnoreFailures(PyITemporalFeatureClass2Object* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyITemporalFeatureClass2_SupportsInterface(PyITemporalFeatureClass2Object* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pITemporalFeatureClass2->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ITemporalFeatureClass2Method_get_ServerName(PyITemporalFeatureClass2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName;
    PyObject* pyvar_Name = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Name

    // Call method on actual COM interface
    hr = self->m_pITemporalFeatureClass2->get_ServerName(&bsName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalFeatureClass2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalFeatureClass2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalFeatureClass2.get_ServerName() returned %ld", (long)hr);
        goto itemporalfeatureclass2_get_servername_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Name = PyUnicode_FromWideChar(bsName,::SysStringLen(bsName));
    ::SysFreeString(bsName);
    
    if (PyErr_Occurred())
      goto itemporalfeatureclass2_get_servername_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Name);
    goto itemporalfeatureclass2_get_servername_method_cleanup;

    itemporalfeatureclass2_get_servername_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Name != Py_None)
        Py_XDECREF(pyvar_Name);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalFeatureClass2.get_ServerName");
    return return_tuple;
}

static PyObject*
ITemporalFeatureClass2Method_get_ConnectionName(PyITemporalFeatureClass2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName;
    PyObject* pyvar_Name = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Name

    // Call method on actual COM interface
    hr = self->m_pITemporalFeatureClass2->get_ConnectionName(&bsName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalFeatureClass2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalFeatureClass2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalFeatureClass2.get_ConnectionName() returned %ld", (long)hr);
        goto itemporalfeatureclass2_get_connectionname_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Name = PyUnicode_FromWideChar(bsName,::SysStringLen(bsName));
    ::SysFreeString(bsName);
    
    if (PyErr_Occurred())
      goto itemporalfeatureclass2_get_connectionname_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Name);
    goto itemporalfeatureclass2_get_connectionname_method_cleanup;

    itemporalfeatureclass2_get_connectionname_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Name != Py_None)
        Py_XDECREF(pyvar_Name);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalFeatureClass2.get_ConnectionName");
    return return_tuple;
}


PyMethodDef PyITemporalFeatureClass2Methods[] = {
    {"supports", (PyCFunction)PyITemporalFeatureClass2_SupportsInterface, METH_O, ""},
    {"get_ServerName", (PyCFunction)ITemporalFeatureClass2Method_get_ServerName, METH_VARARGS, ""},
    {"get_ConnectionName", (PyCFunction)ITemporalFeatureClass2Method_get_ConnectionName, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyITemporalFeatureClass2GetSet[] = {
  {"_pUnk", (getter)PyITemporalFeatureClass2_GetpUnk, NULL, "Get opaque pointer to an Unknown from ITemporalFeatureClass2", NULL},
  {"_pointer", (getter)PyITemporalFeatureClass2_GetPointer, NULL, "Get memory address for ITemporalFeatureClass2", NULL},
  {"_IID", (getter)PyITemporalFeatureClass2_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyITemporalFeatureClass2_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyITemporalFeatureClass2_GetIgnoreFailures, (setter)PyITemporalFeatureClass2_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyITemporalFeatureClass2Object_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.ITemporalFeatureClass2Object",                          
                                              /* tp_name */
  sizeof(PyITemporalFeatureClass2Object),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyITemporalFeatureClass2Object_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyITemporalFeatureClass2Methods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyITemporalFeatureClass2GetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyITemporalFeatureClass2Object_new,                      
                                              /* tp_new */
};

// Interface ITemporalTable

typedef struct PyITemporalTableObject {
    PyObject_HEAD
    ITemporalTable* m_pITemporalTable;
    HRESULT m_HR;
    int m_ignore_failures;
} PyITemporalTableObject;

static PyObject*
PyITemporalTableObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyITemporalTableObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ITemporalTable* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ITemporalTable, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ITemporalTable with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyITemporalTableObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ITemporalTable");
            return NULL;
        }
        self->m_pITemporalTable = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ITemporalTable");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ITemporalTable");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ITemporalTable* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ITemporalTable, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ITemporalTable");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyITemporalTableObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ITemporalTable");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pITemporalTable = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyITemporalTableObject_dealloc(PyITemporalTableObject* self)
{
    if (self->m_pITemporalTable)
        self->m_pITemporalTable->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyITemporalTable_GetpUnk(PyITemporalTableObject* self)
{
    if (!self->m_pITemporalTable)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pITemporalTable->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ITemporalTable to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyITemporalTable_GetPointer(PyITemporalTableObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pITemporalTable);
}

static PyObject*
PyITemporalTable_GetIID(PyITemporalTableObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "18fb46e0-461a-11d5-b7e5-00010265adc5");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyITemporalTable_GetHR(PyITemporalTableObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyITemporalTable_GetIgnoreFailures(PyITemporalTableObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyITemporalTable_SetIgnoreFailures(PyITemporalTableObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyITemporalTable_SupportsInterface(PyITemporalTableObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pITemporalTable->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ITemporalTableMethod_FindField(PyITemporalTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName = 0;
    PyObject* pyvar_Name;
    PyObject* unicodeName = NULL;
    long lFieldIndex = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_Name))
      goto itemporaltable_findfield_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_Name))
        unicodeName = PyUnicode_FromObject(pyvar_Name);
    else if (PyUnicode_Check(pyvar_Name))
    {
        unicodeName = pyvar_Name;
        Py_INCREF(unicodeName);
    }
    else if (pyvar_Name != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Name at index 0");
    if (unicodeName)
        bsName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeName));
    
    if (PyErr_Occurred())
      goto itemporaltable_findfield_method_cleanup;
    
    // No setup for FieldIndex

    // Call method on actual COM interface
    hr = self->m_pITemporalTable->FindField(bsName, &lFieldIndex);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalTable.FindField() returned %ld", (long)hr);
        goto itemporaltable_findfield_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Name
    // No teardown for FieldIndex

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lFieldIndex);
    goto itemporaltable_findfield_method_cleanup;

    itemporaltable_findfield_method_cleanup:
    self->m_HR = hr;
    if (bsName)
        ::SysFreeString(bsName);
    
    // No cleanup for FieldIndex
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalTable.FindField");
    return return_tuple;
}

static PyObject*
ITemporalTableMethod_get_Fields(PyITemporalTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IFields* ipFields = NULL;
    PyObject* py_Fields = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Fields

    // Call method on actual COM interface
    hr = self->m_pITemporalTable->get_Fields(&ipFields);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalTable.get_Fields() returned %ld", (long)hr);
        goto itemporaltable_get_fields_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_Fields);
    if (ipFields)
    {
        IUnknown* pUnk = NULL;
        ipFields->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_Fields = IUnknownToPythonIIDObject(pUnk, &IID_IFields);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_Fields)
    {
        if (py_Fields)
           Py_DECREF(py_Fields);
        py_Fields = Py_None;
        Py_INCREF(py_Fields);
    }
    if (PyErr_Occurred())
      goto itemporaltable_get_fields_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_Fields);
    goto itemporaltable_get_fields_method_cleanup;

    itemporaltable_get_fields_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_Fields);
    if (ipFields)
      ipFields->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalTable.get_Fields");
    return return_tuple;
}

static PyObject*
ITemporalTableMethod_AddField(PyITemporalTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IField* ipField = NULL;
    PyObject* py_Field;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_Field))
      goto itemporaltable_addfield_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_Field, &IID_IField, (void**)&ipField))
        PyErr_SetString(PyExc_TypeError, "Argument Field (position 0) is not IField");
    
    if (PyErr_Occurred())
      goto itemporaltable_addfield_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITemporalTable->AddField(ipField);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalTable.AddField() returned %ld", (long)hr);
        goto itemporaltable_addfield_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Field

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto itemporaltable_addfield_method_cleanup;

    itemporaltable_addfield_method_cleanup:
    self->m_HR = hr;
    if (ipField)
      ipField->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalTable.AddField");
    return return_tuple;
}

static PyObject*
ITemporalTableMethod_DeleteField(PyITemporalTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IField* ipField = NULL;
    PyObject* py_Field;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_Field))
      goto itemporaltable_deletefield_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_Field, &IID_IField, (void**)&ipField))
        PyErr_SetString(PyExc_TypeError, "Argument Field (position 0) is not IField");
    
    if (PyErr_Occurred())
      goto itemporaltable_deletefield_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITemporalTable->DeleteField(ipField);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalTable.DeleteField() returned %ld", (long)hr);
        goto itemporaltable_deletefield_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Field

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto itemporaltable_deletefield_method_cleanup;

    itemporaltable_deletefield_method_cleanup:
    self->m_HR = hr;
    if (ipField)
      ipField->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalTable.DeleteField");
    return return_tuple;
}

static PyObject*
ITemporalTableMethod_CreateRow(PyITemporalTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IRow* ipRow = NULL;
    PyObject* py_Row = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Row

    // Call method on actual COM interface
    hr = self->m_pITemporalTable->CreateRow(&ipRow);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalTable.CreateRow() returned %ld", (long)hr);
        goto itemporaltable_createrow_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_Row);
    if (ipRow)
    {
        IUnknown* pUnk = NULL;
        ipRow->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_Row = IUnknownToPythonIIDObject(pUnk, &IID_IRow);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_Row)
    {
        if (py_Row)
           Py_DECREF(py_Row);
        py_Row = Py_None;
        Py_INCREF(py_Row);
    }
    if (PyErr_Occurred())
      goto itemporaltable_createrow_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_Row);
    goto itemporaltable_createrow_method_cleanup;

    itemporaltable_createrow_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_Row);
    if (ipRow)
      ipRow->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalTable.CreateRow");
    return return_tuple;
}

static PyObject*
ITemporalTableMethod_GetRow(PyITemporalTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lOID = 0;
    IRow* ipRow = NULL;
    PyObject* py_Row = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lOID))
      goto itemporaltable_getrow_method_cleanup;

    // Set up initial variable values as needed
    // No setup for OID
    // No setup for Row

    // Call method on actual COM interface
    hr = self->m_pITemporalTable->GetRow(lOID, &ipRow);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalTable.GetRow() returned %ld", (long)hr);
        goto itemporaltable_getrow_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for OID
    Py_XDECREF(py_Row);
    if (ipRow)
    {
        IUnknown* pUnk = NULL;
        ipRow->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_Row = IUnknownToPythonIIDObject(pUnk, &IID_IRow);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_Row)
    {
        if (py_Row)
           Py_DECREF(py_Row);
        py_Row = Py_None;
        Py_INCREF(py_Row);
    }
    if (PyErr_Occurred())
      goto itemporaltable_getrow_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_Row);
    goto itemporaltable_getrow_method_cleanup;

    itemporaltable_getrow_method_cleanup:
    self->m_HR = hr;
    // No cleanup for OID
    Py_XDECREF(py_Row);
    if (ipRow)
      ipRow->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalTable.GetRow");
    return return_tuple;
}

static PyObject*
ITemporalTableMethod_CreateRowBuffer(PyITemporalTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IRowBuffer* ipBuffer = NULL;
    PyObject* py_Buffer = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Buffer

    // Call method on actual COM interface
    hr = self->m_pITemporalTable->CreateRowBuffer(&ipBuffer);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalTable.CreateRowBuffer() returned %ld", (long)hr);
        goto itemporaltable_createrowbuffer_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_Buffer);
    if (ipBuffer)
    {
        IUnknown* pUnk = NULL;
        ipBuffer->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_Buffer = IUnknownToPythonIIDObject(pUnk, &IID_IRowBuffer);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_Buffer)
    {
        if (py_Buffer)
           Py_DECREF(py_Buffer);
        py_Buffer = Py_None;
        Py_INCREF(py_Buffer);
    }
    if (PyErr_Occurred())
      goto itemporaltable_createrowbuffer_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_Buffer);
    goto itemporaltable_createrowbuffer_method_cleanup;

    itemporaltable_createrowbuffer_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_Buffer);
    if (ipBuffer)
      ipBuffer->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalTable.CreateRowBuffer");
    return return_tuple;
}

static PyObject*
ITemporalTableMethod_RowCount(PyITemporalTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IQueryFilter* ipQueryFilter = NULL;
    PyObject* py_QueryFilter;
    long lNumRows = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_QueryFilter))
      goto itemporaltable_rowcount_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_QueryFilter, &IID_IQueryFilter, (void**)&ipQueryFilter))
        PyErr_SetString(PyExc_TypeError, "Argument QueryFilter (position 0) is not IQueryFilter");
    
    if (PyErr_Occurred())
      goto itemporaltable_rowcount_method_cleanup;
    
    // No setup for NumRows

    // Call method on actual COM interface
    hr = self->m_pITemporalTable->RowCount(ipQueryFilter, &lNumRows);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalTable.RowCount() returned %ld", (long)hr);
        goto itemporaltable_rowcount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for QueryFilter
    // No teardown for NumRows

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lNumRows);
    goto itemporaltable_rowcount_method_cleanup;

    itemporaltable_rowcount_method_cleanup:
    self->m_HR = hr;
    if (ipQueryFilter)
      ipQueryFilter->Release();
    // No cleanup for NumRows
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalTable.RowCount");
    return return_tuple;
}

static PyObject*
ITemporalTableMethod_Search(PyITemporalTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IQueryFilter* ipQueryFilter = NULL;
    PyObject* py_QueryFilter;
    VARIANT_BOOL b_Recycling = VARIANT_FALSE;
    PyObject* pyvar_Recycling = NULL;
    ICursor* ipCursor = NULL;
    PyObject* py_Cursor = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OO", &py_QueryFilter, &pyvar_Recycling))
      goto itemporaltable_search_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_QueryFilter, &IID_IQueryFilter, (void**)&ipQueryFilter))
        PyErr_SetString(PyExc_TypeError, "Argument QueryFilter (position 0) is not IQueryFilter");
    
    if (PyErr_Occurred())
      goto itemporaltable_search_method_cleanup;
    
    b_Recycling = ((PyObject_IsTrue(pyvar_Recycling) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto itemporaltable_search_method_cleanup;
    
    // No setup for Cursor

    // Call method on actual COM interface
    hr = self->m_pITemporalTable->Search(ipQueryFilter, b_Recycling, &ipCursor);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalTable.Search() returned %ld", (long)hr);
        goto itemporaltable_search_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for QueryFilter
    // No teardown for Recycling
    Py_XDECREF(py_Cursor);
    if (ipCursor)
    {
        IUnknown* pUnk = NULL;
        ipCursor->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_Cursor = IUnknownToPythonIIDObject(pUnk, &IID_ICursor);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_Cursor)
    {
        if (py_Cursor)
           Py_DECREF(py_Cursor);
        py_Cursor = Py_None;
        Py_INCREF(py_Cursor);
    }
    if (PyErr_Occurred())
      goto itemporaltable_search_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_Cursor);
    goto itemporaltable_search_method_cleanup;

    itemporaltable_search_method_cleanup:
    self->m_HR = hr;
    if (ipQueryFilter)
      ipQueryFilter->Release();
    // No cleanup for Recycling
    Py_XDECREF(py_Cursor);
    if (ipCursor)
      ipCursor->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalTable.Search");
    return return_tuple;
}

static PyObject*
ITemporalTableMethod_Update(PyITemporalTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IQueryFilter* ipQueryFilter = NULL;
    PyObject* py_QueryFilter;
    VARIANT_BOOL b_Recycling = VARIANT_FALSE;
    PyObject* pyvar_Recycling = NULL;
    ICursor* ipCursor = NULL;
    PyObject* py_Cursor = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OO", &py_QueryFilter, &pyvar_Recycling))
      goto itemporaltable_update_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_QueryFilter, &IID_IQueryFilter, (void**)&ipQueryFilter))
        PyErr_SetString(PyExc_TypeError, "Argument QueryFilter (position 0) is not IQueryFilter");
    
    if (PyErr_Occurred())
      goto itemporaltable_update_method_cleanup;
    
    b_Recycling = ((PyObject_IsTrue(pyvar_Recycling) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto itemporaltable_update_method_cleanup;
    
    // No setup for Cursor

    // Call method on actual COM interface
    hr = self->m_pITemporalTable->Update(ipQueryFilter, b_Recycling, &ipCursor);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalTable.Update() returned %ld", (long)hr);
        goto itemporaltable_update_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for QueryFilter
    // No teardown for Recycling
    Py_XDECREF(py_Cursor);
    if (ipCursor)
    {
        IUnknown* pUnk = NULL;
        ipCursor->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_Cursor = IUnknownToPythonIIDObject(pUnk, &IID_ICursor);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_Cursor)
    {
        if (py_Cursor)
           Py_DECREF(py_Cursor);
        py_Cursor = Py_None;
        Py_INCREF(py_Cursor);
    }
    if (PyErr_Occurred())
      goto itemporaltable_update_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_Cursor);
    goto itemporaltable_update_method_cleanup;

    itemporaltable_update_method_cleanup:
    self->m_HR = hr;
    if (ipQueryFilter)
      ipQueryFilter->Release();
    // No cleanup for Recycling
    Py_XDECREF(py_Cursor);
    if (ipCursor)
      ipCursor->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalTable.Update");
    return return_tuple;
}

static PyObject*
ITemporalTableMethod_Insert(PyITemporalTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_useBuffering = VARIANT_FALSE;
    PyObject* pyvar_useBuffering = NULL;
    ICursor* ipCursor = NULL;
    PyObject* py_Cursor = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_useBuffering))
      goto itemporaltable_insert_method_cleanup;

    // Set up initial variable values as needed
    b_useBuffering = ((PyObject_IsTrue(pyvar_useBuffering) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto itemporaltable_insert_method_cleanup;
    
    // No setup for Cursor

    // Call method on actual COM interface
    hr = self->m_pITemporalTable->Insert(b_useBuffering, &ipCursor);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalTable.Insert() returned %ld", (long)hr);
        goto itemporaltable_insert_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for useBuffering
    Py_XDECREF(py_Cursor);
    if (ipCursor)
    {
        IUnknown* pUnk = NULL;
        ipCursor->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_Cursor = IUnknownToPythonIIDObject(pUnk, &IID_ICursor);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_Cursor)
    {
        if (py_Cursor)
           Py_DECREF(py_Cursor);
        py_Cursor = Py_None;
        Py_INCREF(py_Cursor);
    }
    if (PyErr_Occurred())
      goto itemporaltable_insert_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_Cursor);
    goto itemporaltable_insert_method_cleanup;

    itemporaltable_insert_method_cleanup:
    self->m_HR = hr;
    // No cleanup for useBuffering
    Py_XDECREF(py_Cursor);
    if (ipCursor)
      ipCursor->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalTable.Insert");
    return return_tuple;
}

static PyObject*
ITemporalTableMethod_Select(PyITemporalTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IQueryFilter* ipQueryFilter = NULL;
    PyObject* py_QueryFilter;
    esriSelectionType eselType;
    esriSelectionOption eselOption;
    IWorkspace* ipselectionContainer = NULL;
    PyObject* py_selectionContainer;
    ISelectionSet* ipppSelectionSet = NULL;
    PyObject* py_ppSelectionSet = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OiiO", &py_QueryFilter, (int *)&eselType, (int *)&eselOption, &py_selectionContainer))
      goto itemporaltable_select_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_QueryFilter, &IID_IQueryFilter, (void**)&ipQueryFilter))
        PyErr_SetString(PyExc_TypeError, "Argument QueryFilter (position 0) is not IQueryFilter");
    
    if (PyErr_Occurred())
      goto itemporaltable_select_method_cleanup;
    
    // No setup for selType
    // No setup for selOption
    if (!IFaceFromPyObject(py_selectionContainer, &IID_IWorkspace, (void**)&ipselectionContainer))
        PyErr_SetString(PyExc_TypeError, "Argument selectionContainer (position 3) is not IWorkspace");
    
    if (PyErr_Occurred())
      goto itemporaltable_select_method_cleanup;
    
    // No setup for ppSelectionSet

    // Call method on actual COM interface
    hr = self->m_pITemporalTable->Select(ipQueryFilter, eselType, eselOption, ipselectionContainer, &ipppSelectionSet);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalTable.Select() returned %ld", (long)hr);
        goto itemporaltable_select_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for QueryFilter
    // No teardown for selType
    // No teardown for selOption
    // No teardown for selectionContainer
    Py_XDECREF(py_ppSelectionSet);
    if (ipppSelectionSet)
    {
        IUnknown* pUnk = NULL;
        ipppSelectionSet->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppSelectionSet = IUnknownToPythonIIDObject(pUnk, &IID_ISelectionSet);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppSelectionSet)
    {
        if (py_ppSelectionSet)
           Py_DECREF(py_ppSelectionSet);
        py_ppSelectionSet = Py_None;
        Py_INCREF(py_ppSelectionSet);
    }
    if (PyErr_Occurred())
      goto itemporaltable_select_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppSelectionSet);
    goto itemporaltable_select_method_cleanup;

    itemporaltable_select_method_cleanup:
    self->m_HR = hr;
    if (ipQueryFilter)
      ipQueryFilter->Release();
    // No cleanup for selType
    // No cleanup for selOption
    if (ipselectionContainer)
      ipselectionContainer->Release();
    Py_XDECREF(py_ppSelectionSet);
    if (ipppSelectionSet)
      ipppSelectionSet->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalTable.Select");
    return return_tuple;
}

static PyObject*
ITemporalTableMethod_get_HasGeometry(PyITemporalTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pVal = VARIANT_FALSE;
    PyObject* pyvar_pVal = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pITemporalTable->get_HasGeometry(&b_pVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalTable.get_HasGeometry() returned %ld", (long)hr);
        goto itemporaltable_get_hasgeometry_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pVal = ((b_pVal == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto itemporaltable_get_hasgeometry_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pVal);
    goto itemporaltable_get_hasgeometry_method_cleanup;

    itemporaltable_get_hasgeometry_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalTable.get_HasGeometry");
    return return_tuple;
}

static PyObject*
ITemporalTableMethod_get_GeometryColumnName(PyITemporalTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspbstrColumnName;
    PyObject* pyvar_pbstrColumnName = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pbstrColumnName

    // Call method on actual COM interface
    hr = self->m_pITemporalTable->get_GeometryColumnName(&bspbstrColumnName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalTable.get_GeometryColumnName() returned %ld", (long)hr);
        goto itemporaltable_get_geometrycolumnname_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pbstrColumnName = PyUnicode_FromWideChar(bspbstrColumnName,::SysStringLen(bspbstrColumnName));
    ::SysFreeString(bspbstrColumnName);
    
    if (PyErr_Occurred())
      goto itemporaltable_get_geometrycolumnname_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pbstrColumnName);
    goto itemporaltable_get_geometrycolumnname_method_cleanup;

    itemporaltable_get_geometrycolumnname_method_cleanup:
    self->m_HR = hr;
    if (pyvar_pbstrColumnName != Py_None)
        Py_XDECREF(pyvar_pbstrColumnName);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalTable.get_GeometryColumnName");
    return return_tuple;
}

static PyObject*
ITemporalTableMethod_put_GeometryColumnName(PyITemporalTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspbstrColumnName = 0;
    PyObject* pyvar_pbstrColumnName;
    PyObject* unicodepbstrColumnName = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pbstrColumnName))
      goto itemporaltable_put_geometrycolumnname_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_pbstrColumnName))
        unicodepbstrColumnName = PyUnicode_FromObject(pyvar_pbstrColumnName);
    else if (PyUnicode_Check(pyvar_pbstrColumnName))
    {
        unicodepbstrColumnName = pyvar_pbstrColumnName;
        Py_INCREF(unicodepbstrColumnName);
    }
    else if (pyvar_pbstrColumnName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter pbstrColumnName at index 0");
    if (unicodepbstrColumnName)
        bspbstrColumnName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodepbstrColumnName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodepbstrColumnName));
    
    if (PyErr_Occurred())
      goto itemporaltable_put_geometrycolumnname_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITemporalTable->put_GeometryColumnName(bspbstrColumnName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalTable.put_GeometryColumnName() returned %ld", (long)hr);
        goto itemporaltable_put_geometrycolumnname_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pbstrColumnName

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto itemporaltable_put_geometrycolumnname_method_cleanup;

    itemporaltable_put_geometrycolumnname_method_cleanup:
    self->m_HR = hr;
    if (bspbstrColumnName)
        ::SysFreeString(bspbstrColumnName);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalTable.put_GeometryColumnName");
    return return_tuple;
}


PyMethodDef PyITemporalTableMethods[] = {
    {"supports", (PyCFunction)PyITemporalTable_SupportsInterface, METH_O, ""},
    {"FindField", (PyCFunction)ITemporalTableMethod_FindField, METH_VARARGS, ""},
    {"get_Fields", (PyCFunction)ITemporalTableMethod_get_Fields, METH_VARARGS, ""},
    {"AddField", (PyCFunction)ITemporalTableMethod_AddField, METH_VARARGS, ""},
    {"DeleteField", (PyCFunction)ITemporalTableMethod_DeleteField, METH_VARARGS, ""},
    {"CreateRow", (PyCFunction)ITemporalTableMethod_CreateRow, METH_VARARGS, ""},
    {"GetRow", (PyCFunction)ITemporalTableMethod_GetRow, METH_VARARGS, ""},
    {"CreateRowBuffer", (PyCFunction)ITemporalTableMethod_CreateRowBuffer, METH_VARARGS, ""},
    {"RowCount", (PyCFunction)ITemporalTableMethod_RowCount, METH_VARARGS, ""},
    {"Search", (PyCFunction)ITemporalTableMethod_Search, METH_VARARGS, ""},
    {"Update", (PyCFunction)ITemporalTableMethod_Update, METH_VARARGS, ""},
    {"Insert", (PyCFunction)ITemporalTableMethod_Insert, METH_VARARGS, ""},
    {"Select", (PyCFunction)ITemporalTableMethod_Select, METH_VARARGS, ""},
    {"get_HasGeometry", (PyCFunction)ITemporalTableMethod_get_HasGeometry, METH_VARARGS, ""},
    {"get_GeometryColumnName", (PyCFunction)ITemporalTableMethod_get_GeometryColumnName, METH_VARARGS, ""},
    {"put_GeometryColumnName", (PyCFunction)ITemporalTableMethod_put_GeometryColumnName, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyITemporalTableGetSet[] = {
  {"_pUnk", (getter)PyITemporalTable_GetpUnk, NULL, "Get opaque pointer to an Unknown from ITemporalTable", NULL},
  {"_pointer", (getter)PyITemporalTable_GetPointer, NULL, "Get memory address for ITemporalTable", NULL},
  {"_IID", (getter)PyITemporalTable_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyITemporalTable_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyITemporalTable_GetIgnoreFailures, (setter)PyITemporalTable_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyITemporalTableObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.ITemporalTableObject",                          
                                              /* tp_name */
  sizeof(PyITemporalTableObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyITemporalTableObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyITemporalTableMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyITemporalTableGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyITemporalTableObject_new,                      
                                              /* tp_new */
};

// Interface IInternalTable

typedef struct PyIInternalTableObject {
    PyObject_HEAD
    IInternalTable* m_pIInternalTable;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIInternalTableObject;

static PyObject*
PyIInternalTableObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIInternalTableObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IInternalTable* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IInternalTable, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IInternalTable with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIInternalTableObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IInternalTable");
            return NULL;
        }
        self->m_pIInternalTable = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IInternalTable");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IInternalTable");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IInternalTable* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IInternalTable, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IInternalTable");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIInternalTableObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IInternalTable");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIInternalTable = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIInternalTableObject_dealloc(PyIInternalTableObject* self)
{
    if (self->m_pIInternalTable)
        self->m_pIInternalTable->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIInternalTable_GetpUnk(PyIInternalTableObject* self)
{
    if (!self->m_pIInternalTable)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIInternalTable->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IInternalTable to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIInternalTable_GetPointer(PyIInternalTableObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIInternalTable);
}

static PyObject*
PyIInternalTable_GetIID(PyIInternalTableObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "a677ab63-2fb8-11d5-b7e2-00010265adc5");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIInternalTable_GetHR(PyIInternalTableObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIInternalTable_GetIgnoreFailures(PyIInternalTableObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIInternalTable_SetIgnoreFailures(PyIInternalTableObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIInternalTable_SupportsInterface(PyIInternalTableObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIInternalTable->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IInternalTableMethod_AddRow(PyIInternalTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IDataMessage* ippiDataMessage = NULL;
    PyObject* py_piDataMessage;
    long lplRowID = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_piDataMessage))
      goto iinternaltable_addrow_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_piDataMessage, &IID_IDataMessage, (void**)&ippiDataMessage))
        PyErr_SetString(PyExc_TypeError, "Argument piDataMessage (position 0) is not IDataMessage");
    
    if (PyErr_Occurred())
      goto iinternaltable_addrow_method_cleanup;
    
    // No setup for plRowID

    // Call method on actual COM interface
    hr = self->m_pIInternalTable->AddRow(ippiDataMessage, &lplRowID);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIInternalTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IInternalTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IInternalTable.AddRow() returned %ld", (long)hr);
        goto iinternaltable_addrow_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for piDataMessage
    // No teardown for plRowID

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lplRowID);
    goto iinternaltable_addrow_method_cleanup;

    iinternaltable_addrow_method_cleanup:
    self->m_HR = hr;
    if (ippiDataMessage)
      ippiDataMessage->Release();
    // No cleanup for plRowID
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IInternalTable.AddRow");
    return return_tuple;
}

static PyObject*
IInternalTableMethod_FindField(PyIInternalTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName = 0;
    PyObject* pyvar_Name;
    PyObject* unicodeName = NULL;
    long lFieldIndex = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_Name))
      goto iinternaltable_findfield_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_Name))
        unicodeName = PyUnicode_FromObject(pyvar_Name);
    else if (PyUnicode_Check(pyvar_Name))
    {
        unicodeName = pyvar_Name;
        Py_INCREF(unicodeName);
    }
    else if (pyvar_Name != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Name at index 0");
    if (unicodeName)
        bsName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeName));
    
    if (PyErr_Occurred())
      goto iinternaltable_findfield_method_cleanup;
    
    // No setup for FieldIndex

    // Call method on actual COM interface
    hr = self->m_pIInternalTable->FindField(bsName, &lFieldIndex);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIInternalTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IInternalTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IInternalTable.FindField() returned %ld", (long)hr);
        goto iinternaltable_findfield_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Name
    // No teardown for FieldIndex

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lFieldIndex);
    goto iinternaltable_findfield_method_cleanup;

    iinternaltable_findfield_method_cleanup:
    self->m_HR = hr;
    if (bsName)
        ::SysFreeString(bsName);
    
    // No cleanup for FieldIndex
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IInternalTable.FindField");
    return return_tuple;
}

static PyObject*
IInternalTableMethod_get_Fields(PyIInternalTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IFields* ipFields = NULL;
    PyObject* py_Fields = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Fields

    // Call method on actual COM interface
    hr = self->m_pIInternalTable->get_Fields(&ipFields);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIInternalTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IInternalTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IInternalTable.get_Fields() returned %ld", (long)hr);
        goto iinternaltable_get_fields_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_Fields);
    if (ipFields)
    {
        IUnknown* pUnk = NULL;
        ipFields->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_Fields = IUnknownToPythonIIDObject(pUnk, &IID_IFields);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_Fields)
    {
        if (py_Fields)
           Py_DECREF(py_Fields);
        py_Fields = Py_None;
        Py_INCREF(py_Fields);
    }
    if (PyErr_Occurred())
      goto iinternaltable_get_fields_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_Fields);
    goto iinternaltable_get_fields_method_cleanup;

    iinternaltable_get_fields_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_Fields);
    if (ipFields)
      ipFields->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IInternalTable.get_Fields");
    return return_tuple;
}

static PyObject*
IInternalTableMethod_AddField(PyIInternalTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IField* ipField = NULL;
    PyObject* py_Field;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_Field))
      goto iinternaltable_addfield_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_Field, &IID_IField, (void**)&ipField))
        PyErr_SetString(PyExc_TypeError, "Argument Field (position 0) is not IField");
    
    if (PyErr_Occurred())
      goto iinternaltable_addfield_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIInternalTable->AddField(ipField);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIInternalTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IInternalTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IInternalTable.AddField() returned %ld", (long)hr);
        goto iinternaltable_addfield_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Field

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iinternaltable_addfield_method_cleanup;

    iinternaltable_addfield_method_cleanup:
    self->m_HR = hr;
    if (ipField)
      ipField->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IInternalTable.AddField");
    return return_tuple;
}

static PyObject*
IInternalTableMethod_DeleteField(PyIInternalTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IField* ipField = NULL;
    PyObject* py_Field;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_Field))
      goto iinternaltable_deletefield_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_Field, &IID_IField, (void**)&ipField))
        PyErr_SetString(PyExc_TypeError, "Argument Field (position 0) is not IField");
    
    if (PyErr_Occurred())
      goto iinternaltable_deletefield_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIInternalTable->DeleteField(ipField);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIInternalTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IInternalTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IInternalTable.DeleteField() returned %ld", (long)hr);
        goto iinternaltable_deletefield_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Field

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iinternaltable_deletefield_method_cleanup;

    iinternaltable_deletefield_method_cleanup:
    self->m_HR = hr;
    if (ipField)
      ipField->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IInternalTable.DeleteField");
    return return_tuple;
}

static PyObject*
IInternalTableMethod_CreateRow(PyIInternalTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IRow* ipRow = NULL;
    PyObject* py_Row = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Row

    // Call method on actual COM interface
    hr = self->m_pIInternalTable->CreateRow(&ipRow);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIInternalTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IInternalTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IInternalTable.CreateRow() returned %ld", (long)hr);
        goto iinternaltable_createrow_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_Row);
    if (ipRow)
    {
        IUnknown* pUnk = NULL;
        ipRow->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_Row = IUnknownToPythonIIDObject(pUnk, &IID_IRow);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_Row)
    {
        if (py_Row)
           Py_DECREF(py_Row);
        py_Row = Py_None;
        Py_INCREF(py_Row);
    }
    if (PyErr_Occurred())
      goto iinternaltable_createrow_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_Row);
    goto iinternaltable_createrow_method_cleanup;

    iinternaltable_createrow_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_Row);
    if (ipRow)
      ipRow->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IInternalTable.CreateRow");
    return return_tuple;
}

static PyObject*
IInternalTableMethod_GetRow(PyIInternalTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lOID = 0;
    IRow* ipRow = NULL;
    PyObject* py_Row = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lOID))
      goto iinternaltable_getrow_method_cleanup;

    // Set up initial variable values as needed
    // No setup for OID
    // No setup for Row

    // Call method on actual COM interface
    hr = self->m_pIInternalTable->GetRow(lOID, &ipRow);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIInternalTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IInternalTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IInternalTable.GetRow() returned %ld", (long)hr);
        goto iinternaltable_getrow_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for OID
    Py_XDECREF(py_Row);
    if (ipRow)
    {
        IUnknown* pUnk = NULL;
        ipRow->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_Row = IUnknownToPythonIIDObject(pUnk, &IID_IRow);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_Row)
    {
        if (py_Row)
           Py_DECREF(py_Row);
        py_Row = Py_None;
        Py_INCREF(py_Row);
    }
    if (PyErr_Occurred())
      goto iinternaltable_getrow_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_Row);
    goto iinternaltable_getrow_method_cleanup;

    iinternaltable_getrow_method_cleanup:
    self->m_HR = hr;
    // No cleanup for OID
    Py_XDECREF(py_Row);
    if (ipRow)
      ipRow->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IInternalTable.GetRow");
    return return_tuple;
}

static PyObject*
IInternalTableMethod_CreateRowBuffer(PyIInternalTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IRowBuffer* ipBuffer = NULL;
    PyObject* py_Buffer = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Buffer

    // Call method on actual COM interface
    hr = self->m_pIInternalTable->CreateRowBuffer(&ipBuffer);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIInternalTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IInternalTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IInternalTable.CreateRowBuffer() returned %ld", (long)hr);
        goto iinternaltable_createrowbuffer_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_Buffer);
    if (ipBuffer)
    {
        IUnknown* pUnk = NULL;
        ipBuffer->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_Buffer = IUnknownToPythonIIDObject(pUnk, &IID_IRowBuffer);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_Buffer)
    {
        if (py_Buffer)
           Py_DECREF(py_Buffer);
        py_Buffer = Py_None;
        Py_INCREF(py_Buffer);
    }
    if (PyErr_Occurred())
      goto iinternaltable_createrowbuffer_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_Buffer);
    goto iinternaltable_createrowbuffer_method_cleanup;

    iinternaltable_createrowbuffer_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_Buffer);
    if (ipBuffer)
      ipBuffer->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IInternalTable.CreateRowBuffer");
    return return_tuple;
}

static PyObject*
IInternalTableMethod_RowCount(PyIInternalTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IQueryFilter* ipQueryFilter = NULL;
    PyObject* py_QueryFilter;
    long lNumRows = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_QueryFilter))
      goto iinternaltable_rowcount_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_QueryFilter, &IID_IQueryFilter, (void**)&ipQueryFilter))
        PyErr_SetString(PyExc_TypeError, "Argument QueryFilter (position 0) is not IQueryFilter");
    
    if (PyErr_Occurred())
      goto iinternaltable_rowcount_method_cleanup;
    
    // No setup for NumRows

    // Call method on actual COM interface
    hr = self->m_pIInternalTable->RowCount(ipQueryFilter, &lNumRows);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIInternalTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IInternalTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IInternalTable.RowCount() returned %ld", (long)hr);
        goto iinternaltable_rowcount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for QueryFilter
    // No teardown for NumRows

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lNumRows);
    goto iinternaltable_rowcount_method_cleanup;

    iinternaltable_rowcount_method_cleanup:
    self->m_HR = hr;
    if (ipQueryFilter)
      ipQueryFilter->Release();
    // No cleanup for NumRows
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IInternalTable.RowCount");
    return return_tuple;
}

static PyObject*
IInternalTableMethod_Search(PyIInternalTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IQueryFilter* ipQueryFilter = NULL;
    PyObject* py_QueryFilter;
    VARIANT_BOOL b_Recycling = VARIANT_FALSE;
    PyObject* pyvar_Recycling = NULL;
    ICursor* ipCursor = NULL;
    PyObject* py_Cursor = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OO", &py_QueryFilter, &pyvar_Recycling))
      goto iinternaltable_search_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_QueryFilter, &IID_IQueryFilter, (void**)&ipQueryFilter))
        PyErr_SetString(PyExc_TypeError, "Argument QueryFilter (position 0) is not IQueryFilter");
    
    if (PyErr_Occurred())
      goto iinternaltable_search_method_cleanup;
    
    b_Recycling = ((PyObject_IsTrue(pyvar_Recycling) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iinternaltable_search_method_cleanup;
    
    // No setup for Cursor

    // Call method on actual COM interface
    hr = self->m_pIInternalTable->Search(ipQueryFilter, b_Recycling, &ipCursor);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIInternalTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IInternalTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IInternalTable.Search() returned %ld", (long)hr);
        goto iinternaltable_search_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for QueryFilter
    // No teardown for Recycling
    Py_XDECREF(py_Cursor);
    if (ipCursor)
    {
        IUnknown* pUnk = NULL;
        ipCursor->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_Cursor = IUnknownToPythonIIDObject(pUnk, &IID_ICursor);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_Cursor)
    {
        if (py_Cursor)
           Py_DECREF(py_Cursor);
        py_Cursor = Py_None;
        Py_INCREF(py_Cursor);
    }
    if (PyErr_Occurred())
      goto iinternaltable_search_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_Cursor);
    goto iinternaltable_search_method_cleanup;

    iinternaltable_search_method_cleanup:
    self->m_HR = hr;
    if (ipQueryFilter)
      ipQueryFilter->Release();
    // No cleanup for Recycling
    Py_XDECREF(py_Cursor);
    if (ipCursor)
      ipCursor->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IInternalTable.Search");
    return return_tuple;
}

static PyObject*
IInternalTableMethod_Update(PyIInternalTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IQueryFilter* ipQueryFilter = NULL;
    PyObject* py_QueryFilter;
    VARIANT_BOOL b_Recycling = VARIANT_FALSE;
    PyObject* pyvar_Recycling = NULL;
    ICursor* ipCursor = NULL;
    PyObject* py_Cursor = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OO", &py_QueryFilter, &pyvar_Recycling))
      goto iinternaltable_update_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_QueryFilter, &IID_IQueryFilter, (void**)&ipQueryFilter))
        PyErr_SetString(PyExc_TypeError, "Argument QueryFilter (position 0) is not IQueryFilter");
    
    if (PyErr_Occurred())
      goto iinternaltable_update_method_cleanup;
    
    b_Recycling = ((PyObject_IsTrue(pyvar_Recycling) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iinternaltable_update_method_cleanup;
    
    // No setup for Cursor

    // Call method on actual COM interface
    hr = self->m_pIInternalTable->Update(ipQueryFilter, b_Recycling, &ipCursor);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIInternalTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IInternalTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IInternalTable.Update() returned %ld", (long)hr);
        goto iinternaltable_update_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for QueryFilter
    // No teardown for Recycling
    Py_XDECREF(py_Cursor);
    if (ipCursor)
    {
        IUnknown* pUnk = NULL;
        ipCursor->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_Cursor = IUnknownToPythonIIDObject(pUnk, &IID_ICursor);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_Cursor)
    {
        if (py_Cursor)
           Py_DECREF(py_Cursor);
        py_Cursor = Py_None;
        Py_INCREF(py_Cursor);
    }
    if (PyErr_Occurred())
      goto iinternaltable_update_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_Cursor);
    goto iinternaltable_update_method_cleanup;

    iinternaltable_update_method_cleanup:
    self->m_HR = hr;
    if (ipQueryFilter)
      ipQueryFilter->Release();
    // No cleanup for Recycling
    Py_XDECREF(py_Cursor);
    if (ipCursor)
      ipCursor->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IInternalTable.Update");
    return return_tuple;
}

static PyObject*
IInternalTableMethod_Insert(PyIInternalTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_useBuffering = VARIANT_FALSE;
    PyObject* pyvar_useBuffering = NULL;
    ICursor* ipCursor = NULL;
    PyObject* py_Cursor = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_useBuffering))
      goto iinternaltable_insert_method_cleanup;

    // Set up initial variable values as needed
    b_useBuffering = ((PyObject_IsTrue(pyvar_useBuffering) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iinternaltable_insert_method_cleanup;
    
    // No setup for Cursor

    // Call method on actual COM interface
    hr = self->m_pIInternalTable->Insert(b_useBuffering, &ipCursor);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIInternalTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IInternalTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IInternalTable.Insert() returned %ld", (long)hr);
        goto iinternaltable_insert_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for useBuffering
    Py_XDECREF(py_Cursor);
    if (ipCursor)
    {
        IUnknown* pUnk = NULL;
        ipCursor->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_Cursor = IUnknownToPythonIIDObject(pUnk, &IID_ICursor);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_Cursor)
    {
        if (py_Cursor)
           Py_DECREF(py_Cursor);
        py_Cursor = Py_None;
        Py_INCREF(py_Cursor);
    }
    if (PyErr_Occurred())
      goto iinternaltable_insert_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_Cursor);
    goto iinternaltable_insert_method_cleanup;

    iinternaltable_insert_method_cleanup:
    self->m_HR = hr;
    // No cleanup for useBuffering
    Py_XDECREF(py_Cursor);
    if (ipCursor)
      ipCursor->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IInternalTable.Insert");
    return return_tuple;
}

static PyObject*
IInternalTableMethod_Select(PyIInternalTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IQueryFilter* ipQueryFilter = NULL;
    PyObject* py_QueryFilter;
    esriSelectionType eselType;
    esriSelectionOption eselOption;
    IWorkspace* ipselectionContainer = NULL;
    PyObject* py_selectionContainer;
    ISelectionSet* ipppSelectionSet = NULL;
    PyObject* py_ppSelectionSet = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OiiO", &py_QueryFilter, (int *)&eselType, (int *)&eselOption, &py_selectionContainer))
      goto iinternaltable_select_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_QueryFilter, &IID_IQueryFilter, (void**)&ipQueryFilter))
        PyErr_SetString(PyExc_TypeError, "Argument QueryFilter (position 0) is not IQueryFilter");
    
    if (PyErr_Occurred())
      goto iinternaltable_select_method_cleanup;
    
    // No setup for selType
    // No setup for selOption
    if (!IFaceFromPyObject(py_selectionContainer, &IID_IWorkspace, (void**)&ipselectionContainer))
        PyErr_SetString(PyExc_TypeError, "Argument selectionContainer (position 3) is not IWorkspace");
    
    if (PyErr_Occurred())
      goto iinternaltable_select_method_cleanup;
    
    // No setup for ppSelectionSet

    // Call method on actual COM interface
    hr = self->m_pIInternalTable->Select(ipQueryFilter, eselType, eselOption, ipselectionContainer, &ipppSelectionSet);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIInternalTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IInternalTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IInternalTable.Select() returned %ld", (long)hr);
        goto iinternaltable_select_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for QueryFilter
    // No teardown for selType
    // No teardown for selOption
    // No teardown for selectionContainer
    Py_XDECREF(py_ppSelectionSet);
    if (ipppSelectionSet)
    {
        IUnknown* pUnk = NULL;
        ipppSelectionSet->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppSelectionSet = IUnknownToPythonIIDObject(pUnk, &IID_ISelectionSet);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppSelectionSet)
    {
        if (py_ppSelectionSet)
           Py_DECREF(py_ppSelectionSet);
        py_ppSelectionSet = Py_None;
        Py_INCREF(py_ppSelectionSet);
    }
    if (PyErr_Occurred())
      goto iinternaltable_select_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppSelectionSet);
    goto iinternaltable_select_method_cleanup;

    iinternaltable_select_method_cleanup:
    self->m_HR = hr;
    if (ipQueryFilter)
      ipQueryFilter->Release();
    // No cleanup for selType
    // No cleanup for selOption
    if (ipselectionContainer)
      ipselectionContainer->Release();
    Py_XDECREF(py_ppSelectionSet);
    if (ipppSelectionSet)
      ipppSelectionSet->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IInternalTable.Select");
    return return_tuple;
}

static PyObject*
IInternalTableMethod_get_HasGeometry(PyIInternalTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pVal = VARIANT_FALSE;
    PyObject* pyvar_pVal = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pIInternalTable->get_HasGeometry(&b_pVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIInternalTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IInternalTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IInternalTable.get_HasGeometry() returned %ld", (long)hr);
        goto iinternaltable_get_hasgeometry_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pVal = ((b_pVal == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto iinternaltable_get_hasgeometry_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pVal);
    goto iinternaltable_get_hasgeometry_method_cleanup;

    iinternaltable_get_hasgeometry_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IInternalTable.get_HasGeometry");
    return return_tuple;
}

static PyObject*
IInternalTableMethod_get_GeometryColumnName(PyIInternalTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspbstrColumnName;
    PyObject* pyvar_pbstrColumnName = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pbstrColumnName

    // Call method on actual COM interface
    hr = self->m_pIInternalTable->get_GeometryColumnName(&bspbstrColumnName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIInternalTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IInternalTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IInternalTable.get_GeometryColumnName() returned %ld", (long)hr);
        goto iinternaltable_get_geometrycolumnname_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pbstrColumnName = PyUnicode_FromWideChar(bspbstrColumnName,::SysStringLen(bspbstrColumnName));
    ::SysFreeString(bspbstrColumnName);
    
    if (PyErr_Occurred())
      goto iinternaltable_get_geometrycolumnname_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pbstrColumnName);
    goto iinternaltable_get_geometrycolumnname_method_cleanup;

    iinternaltable_get_geometrycolumnname_method_cleanup:
    self->m_HR = hr;
    if (pyvar_pbstrColumnName != Py_None)
        Py_XDECREF(pyvar_pbstrColumnName);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IInternalTable.get_GeometryColumnName");
    return return_tuple;
}

static PyObject*
IInternalTableMethod_put_GeometryColumnName(PyIInternalTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspbstrColumnName = 0;
    PyObject* pyvar_pbstrColumnName;
    PyObject* unicodepbstrColumnName = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pbstrColumnName))
      goto iinternaltable_put_geometrycolumnname_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_pbstrColumnName))
        unicodepbstrColumnName = PyUnicode_FromObject(pyvar_pbstrColumnName);
    else if (PyUnicode_Check(pyvar_pbstrColumnName))
    {
        unicodepbstrColumnName = pyvar_pbstrColumnName;
        Py_INCREF(unicodepbstrColumnName);
    }
    else if (pyvar_pbstrColumnName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter pbstrColumnName at index 0");
    if (unicodepbstrColumnName)
        bspbstrColumnName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodepbstrColumnName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodepbstrColumnName));
    
    if (PyErr_Occurred())
      goto iinternaltable_put_geometrycolumnname_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIInternalTable->put_GeometryColumnName(bspbstrColumnName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIInternalTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IInternalTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IInternalTable.put_GeometryColumnName() returned %ld", (long)hr);
        goto iinternaltable_put_geometrycolumnname_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pbstrColumnName

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iinternaltable_put_geometrycolumnname_method_cleanup;

    iinternaltable_put_geometrycolumnname_method_cleanup:
    self->m_HR = hr;
    if (bspbstrColumnName)
        ::SysFreeString(bspbstrColumnName);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IInternalTable.put_GeometryColumnName");
    return return_tuple;
}


PyMethodDef PyIInternalTableMethods[] = {
    {"supports", (PyCFunction)PyIInternalTable_SupportsInterface, METH_O, ""},
    {"AddRow", (PyCFunction)IInternalTableMethod_AddRow, METH_VARARGS, ""},
    {"FindField", (PyCFunction)IInternalTableMethod_FindField, METH_VARARGS, ""},
    {"get_Fields", (PyCFunction)IInternalTableMethod_get_Fields, METH_VARARGS, ""},
    {"AddField", (PyCFunction)IInternalTableMethod_AddField, METH_VARARGS, ""},
    {"DeleteField", (PyCFunction)IInternalTableMethod_DeleteField, METH_VARARGS, ""},
    {"CreateRow", (PyCFunction)IInternalTableMethod_CreateRow, METH_VARARGS, ""},
    {"GetRow", (PyCFunction)IInternalTableMethod_GetRow, METH_VARARGS, ""},
    {"CreateRowBuffer", (PyCFunction)IInternalTableMethod_CreateRowBuffer, METH_VARARGS, ""},
    {"RowCount", (PyCFunction)IInternalTableMethod_RowCount, METH_VARARGS, ""},
    {"Search", (PyCFunction)IInternalTableMethod_Search, METH_VARARGS, ""},
    {"Update", (PyCFunction)IInternalTableMethod_Update, METH_VARARGS, ""},
    {"Insert", (PyCFunction)IInternalTableMethod_Insert, METH_VARARGS, ""},
    {"Select", (PyCFunction)IInternalTableMethod_Select, METH_VARARGS, ""},
    {"get_HasGeometry", (PyCFunction)IInternalTableMethod_get_HasGeometry, METH_VARARGS, ""},
    {"get_GeometryColumnName", (PyCFunction)IInternalTableMethod_get_GeometryColumnName, METH_VARARGS, ""},
    {"put_GeometryColumnName", (PyCFunction)IInternalTableMethod_put_GeometryColumnName, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIInternalTableGetSet[] = {
  {"_pUnk", (getter)PyIInternalTable_GetpUnk, NULL, "Get opaque pointer to an Unknown from IInternalTable", NULL},
  {"_pointer", (getter)PyIInternalTable_GetPointer, NULL, "Get memory address for IInternalTable", NULL},
  {"_IID", (getter)PyIInternalTable_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIInternalTable_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIInternalTable_GetIgnoreFailures, (setter)PyIInternalTable_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIInternalTableObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.IInternalTableObject",                          
                                              /* tp_name */
  sizeof(PyIInternalTableObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIInternalTableObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIInternalTableMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIInternalTableGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIInternalTableObject_new,                      
                                              /* tp_new */
};

// Interface ITemporalObservationsTable

typedef struct PyITemporalObservationsTableObject {
    PyObject_HEAD
    ITemporalObservationsTable* m_pITemporalObservationsTable;
    HRESULT m_HR;
    int m_ignore_failures;
} PyITemporalObservationsTableObject;

static PyObject*
PyITemporalObservationsTableObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyITemporalObservationsTableObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ITemporalObservationsTable* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ITemporalObservationsTable, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ITemporalObservationsTable with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyITemporalObservationsTableObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ITemporalObservationsTable");
            return NULL;
        }
        self->m_pITemporalObservationsTable = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ITemporalObservationsTable");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ITemporalObservationsTable");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ITemporalObservationsTable* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ITemporalObservationsTable, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ITemporalObservationsTable");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyITemporalObservationsTableObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ITemporalObservationsTable");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pITemporalObservationsTable = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyITemporalObservationsTableObject_dealloc(PyITemporalObservationsTableObject* self)
{
    if (self->m_pITemporalObservationsTable)
        self->m_pITemporalObservationsTable->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyITemporalObservationsTable_GetpUnk(PyITemporalObservationsTableObject* self)
{
    if (!self->m_pITemporalObservationsTable)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pITemporalObservationsTable->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ITemporalObservationsTable to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyITemporalObservationsTable_GetPointer(PyITemporalObservationsTableObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pITemporalObservationsTable);
}

static PyObject*
PyITemporalObservationsTable_GetIID(PyITemporalObservationsTableObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "a677ab5f-2fb8-11d5-b7e2-00010265adc5");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyITemporalObservationsTable_GetHR(PyITemporalObservationsTableObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyITemporalObservationsTable_GetIgnoreFailures(PyITemporalObservationsTableObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyITemporalObservationsTable_SetIgnoreFailures(PyITemporalObservationsTableObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyITemporalObservationsTable_SupportsInterface(PyITemporalObservationsTableObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pITemporalObservationsTable->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ITemporalObservationsTableMethod_get_AutoPurge(PyITemporalObservationsTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pVal = VARIANT_FALSE;
    PyObject* pyvar_pVal = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pITemporalObservationsTable->get_AutoPurge(&b_pVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalObservationsTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalObservationsTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalObservationsTable.get_AutoPurge() returned %ld", (long)hr);
        goto itemporalobservationstable_get_autopurge_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pVal = ((b_pVal == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto itemporalobservationstable_get_autopurge_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pVal);
    goto itemporalobservationstable_get_autopurge_method_cleanup;

    itemporalobservationstable_get_autopurge_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalObservationsTable.get_AutoPurge");
    return return_tuple;
}

static PyObject*
ITemporalObservationsTableMethod_put_AutoPurge(PyITemporalObservationsTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pVal = VARIANT_FALSE;
    PyObject* pyvar_pVal = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pVal))
      goto itemporalobservationstable_put_autopurge_method_cleanup;

    // Set up initial variable values as needed
    b_pVal = ((PyObject_IsTrue(pyvar_pVal) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto itemporalobservationstable_put_autopurge_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITemporalObservationsTable->put_AutoPurge(b_pVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalObservationsTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalObservationsTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalObservationsTable.put_AutoPurge() returned %ld", (long)hr);
        goto itemporalobservationstable_put_autopurge_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto itemporalobservationstable_put_autopurge_method_cleanup;

    itemporalobservationstable_put_autopurge_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalObservationsTable.put_AutoPurge");
    return return_tuple;
}

static PyObject*
ITemporalObservationsTableMethod_get_Threshold(PyITemporalObservationsTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT vpvarVal;
    ::VariantInit(&vpvarVal);
    PyObject* pyvar_pvarVal = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pvarVal

    // Call method on actual COM interface
    hr = self->m_pITemporalObservationsTable->get_Threshold(&vpvarVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalObservationsTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalObservationsTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalObservationsTable.get_Threshold() returned %ld", (long)hr);
        goto itemporalobservationstable_get_threshold_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pvarVal = Variant_AsPyObject(&vpvarVal);
    if (PyErr_Occurred())
      goto itemporalobservationstable_get_threshold_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pvarVal);
    goto itemporalobservationstable_get_threshold_method_cleanup;

    itemporalobservationstable_get_threshold_method_cleanup:
    self->m_HR = hr;
    ::VariantClear(&vpvarVal);
    Py_XDECREF(pyvar_pvarVal);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalObservationsTable.get_Threshold");
    return return_tuple;
}

static PyObject*
ITemporalObservationsTableMethod_put_Threshold(PyITemporalObservationsTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT vpvarVal;
    ::VariantInit(&vpvarVal);
    PyObject* pyvar_pvarVal = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pvarVal))
      goto itemporalobservationstable_put_threshold_method_cleanup;

    // Set up initial variable values as needed
    PyObject_AsVariant(pyvar_pvarVal, &vpvarVal);
    
    if (PyErr_Occurred())
      goto itemporalobservationstable_put_threshold_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITemporalObservationsTable->put_Threshold(vpvarVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalObservationsTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalObservationsTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalObservationsTable.put_Threshold() returned %ld", (long)hr);
        goto itemporalobservationstable_put_threshold_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pvarVal

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto itemporalobservationstable_put_threshold_method_cleanup;

    itemporalobservationstable_put_threshold_method_cleanup:
    self->m_HR = hr;
    ::VariantClear(&vpvarVal);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalObservationsTable.put_Threshold");
    return return_tuple;
}

static PyObject*
ITemporalObservationsTableMethod_get_PurgePercentage(PyITemporalObservationsTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dpVal = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pITemporalObservationsTable->get_PurgePercentage(&dpVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalObservationsTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalObservationsTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalObservationsTable.get_PurgePercentage() returned %ld", (long)hr);
        goto itemporalobservationstable_get_purgepercentage_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dpVal);
    goto itemporalobservationstable_get_purgepercentage_method_cleanup;

    itemporalobservationstable_get_purgepercentage_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalObservationsTable.get_PurgePercentage");
    return return_tuple;
}

static PyObject*
ITemporalObservationsTableMethod_put_PurgePercentage(PyITemporalObservationsTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dpVal = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "d", &dpVal))
      goto itemporalobservationstable_put_purgepercentage_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pITemporalObservationsTable->put_PurgePercentage(dpVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalObservationsTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalObservationsTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalObservationsTable.put_PurgePercentage() returned %ld", (long)hr);
        goto itemporalobservationstable_put_purgepercentage_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto itemporalobservationstable_put_purgepercentage_method_cleanup;

    itemporalobservationstable_put_purgepercentage_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalObservationsTable.put_PurgePercentage");
    return return_tuple;
}

static PyObject*
ITemporalObservationsTableMethod_get_Persistant(PyITemporalObservationsTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pVal = VARIANT_FALSE;
    PyObject* pyvar_pVal = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pITemporalObservationsTable->get_Persistant(&b_pVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalObservationsTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalObservationsTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalObservationsTable.get_Persistant() returned %ld", (long)hr);
        goto itemporalobservationstable_get_persistant_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pVal = ((b_pVal == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto itemporalobservationstable_get_persistant_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pVal);
    goto itemporalobservationstable_get_persistant_method_cleanup;

    itemporalobservationstable_get_persistant_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalObservationsTable.get_Persistant");
    return return_tuple;
}

static PyObject*
ITemporalObservationsTableMethod_put_Persistant(PyITemporalObservationsTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pVal = VARIANT_FALSE;
    PyObject* pyvar_pVal = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pVal))
      goto itemporalobservationstable_put_persistant_method_cleanup;

    // Set up initial variable values as needed
    b_pVal = ((PyObject_IsTrue(pyvar_pVal) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto itemporalobservationstable_put_persistant_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITemporalObservationsTable->put_Persistant(b_pVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalObservationsTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalObservationsTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalObservationsTable.put_Persistant() returned %ld", (long)hr);
        goto itemporalobservationstable_put_persistant_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto itemporalobservationstable_put_persistant_method_cleanup;

    itemporalobservationstable_put_persistant_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalObservationsTable.put_Persistant");
    return return_tuple;
}

static PyObject*
ITemporalObservationsTableMethod_get_TemporalColumnName(PyITemporalObservationsTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspVal;
    PyObject* pyvar_pVal = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pITemporalObservationsTable->get_TemporalColumnName(&bspVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalObservationsTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalObservationsTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalObservationsTable.get_TemporalColumnName() returned %ld", (long)hr);
        goto itemporalobservationstable_get_temporalcolumnname_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pVal = PyUnicode_FromWideChar(bspVal,::SysStringLen(bspVal));
    ::SysFreeString(bspVal);
    
    if (PyErr_Occurred())
      goto itemporalobservationstable_get_temporalcolumnname_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pVal);
    goto itemporalobservationstable_get_temporalcolumnname_method_cleanup;

    itemporalobservationstable_get_temporalcolumnname_method_cleanup:
    self->m_HR = hr;
    if (pyvar_pVal != Py_None)
        Py_XDECREF(pyvar_pVal);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalObservationsTable.get_TemporalColumnName");
    return return_tuple;
}

static PyObject*
ITemporalObservationsTableMethod_put_TemporalColumnName(PyITemporalObservationsTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspVal = 0;
    PyObject* pyvar_pVal;
    PyObject* unicodepVal = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pVal))
      goto itemporalobservationstable_put_temporalcolumnname_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_pVal))
        unicodepVal = PyUnicode_FromObject(pyvar_pVal);
    else if (PyUnicode_Check(pyvar_pVal))
    {
        unicodepVal = pyvar_pVal;
        Py_INCREF(unicodepVal);
    }
    else if (pyvar_pVal != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter pVal at index 0");
    if (unicodepVal)
        bspVal = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodepVal), 
                                            (UINT)PyUnicode_GET_SIZE(unicodepVal));
    
    if (PyErr_Occurred())
      goto itemporalobservationstable_put_temporalcolumnname_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITemporalObservationsTable->put_TemporalColumnName(bspVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalObservationsTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalObservationsTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalObservationsTable.put_TemporalColumnName() returned %ld", (long)hr);
        goto itemporalobservationstable_put_temporalcolumnname_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto itemporalobservationstable_put_temporalcolumnname_method_cleanup;

    itemporalobservationstable_put_temporalcolumnname_method_cleanup:
    self->m_HR = hr;
    if (bspVal)
        ::SysFreeString(bspVal);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalObservationsTable.put_TemporalColumnName");
    return return_tuple;
}

static PyObject*
ITemporalObservationsTableMethod_get_PurgeRule(PyITemporalObservationsTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    enumPurgeRule epVal;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pITemporalObservationsTable->get_PurgeRule(&epVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalObservationsTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalObservationsTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalObservationsTable.get_PurgeRule() returned %ld", (long)hr);
        goto itemporalobservationstable_get_purgerule_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)epVal);
    goto itemporalobservationstable_get_purgerule_method_cleanup;

    itemporalobservationstable_get_purgerule_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalObservationsTable.get_PurgeRule");
    return return_tuple;
}

static PyObject*
ITemporalObservationsTableMethod_put_PurgeRule(PyITemporalObservationsTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    enumPurgeRule epVal;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&epVal))
      goto itemporalobservationstable_put_purgerule_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pITemporalObservationsTable->put_PurgeRule(epVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalObservationsTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalObservationsTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalObservationsTable.put_PurgeRule() returned %ld", (long)hr);
        goto itemporalobservationstable_put_purgerule_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto itemporalobservationstable_put_purgerule_method_cleanup;

    itemporalobservationstable_put_purgerule_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalObservationsTable.put_PurgeRule");
    return return_tuple;
}

static PyObject*
ITemporalObservationsTableMethod_PruneTable(PyITemporalObservationsTableObject* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pITemporalObservationsTable->PruneTable();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalObservationsTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalObservationsTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalObservationsTable.PruneTable() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}

static PyObject*
ITemporalObservationsTableMethod_QueryTemporalExtent(PyITemporalObservationsTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT vpvarStartTime;
    ::VariantInit(&vpvarStartTime);
    PyObject* pyvar_pvarStartTime = NULL;
    VARIANT vpvarEndTime;
    ::VariantInit(&vpvarEndTime);
    PyObject* pyvar_pvarEndTime = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pvarStartTime
    // No setup for pvarEndTime

    // Call method on actual COM interface
    hr = self->m_pITemporalObservationsTable->QueryTemporalExtent(&vpvarStartTime, &vpvarEndTime);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalObservationsTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalObservationsTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalObservationsTable.QueryTemporalExtent() returned %ld", (long)hr);
        goto itemporalobservationstable_querytemporalextent_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pvarStartTime = Variant_AsPyObject(&vpvarStartTime);
    if (PyErr_Occurred())
      goto itemporalobservationstable_querytemporalextent_method_cleanup;
    
    pyvar_pvarEndTime = Variant_AsPyObject(&vpvarEndTime);
    if (PyErr_Occurred())
      goto itemporalobservationstable_querytemporalextent_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("OO",
                                            pyvar_pvarStartTime, pyvar_pvarEndTime);
    goto itemporalobservationstable_querytemporalextent_method_cleanup;

    itemporalobservationstable_querytemporalextent_method_cleanup:
    self->m_HR = hr;
    ::VariantClear(&vpvarStartTime);
    Py_XDECREF(pyvar_pvarStartTime);
    ::VariantClear(&vpvarEndTime);
    Py_XDECREF(pyvar_pvarEndTime);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalObservationsTable.QueryTemporalExtent");
    return return_tuple;
}

static PyObject*
ITemporalObservationsTableMethod_FindField(PyITemporalObservationsTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName = 0;
    PyObject* pyvar_Name;
    PyObject* unicodeName = NULL;
    long lFieldIndex = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_Name))
      goto itemporalobservationstable_findfield_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_Name))
        unicodeName = PyUnicode_FromObject(pyvar_Name);
    else if (PyUnicode_Check(pyvar_Name))
    {
        unicodeName = pyvar_Name;
        Py_INCREF(unicodeName);
    }
    else if (pyvar_Name != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Name at index 0");
    if (unicodeName)
        bsName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeName));
    
    if (PyErr_Occurred())
      goto itemporalobservationstable_findfield_method_cleanup;
    
    // No setup for FieldIndex

    // Call method on actual COM interface
    hr = self->m_pITemporalObservationsTable->FindField(bsName, &lFieldIndex);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalObservationsTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalObservationsTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalObservationsTable.FindField() returned %ld", (long)hr);
        goto itemporalobservationstable_findfield_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Name
    // No teardown for FieldIndex

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lFieldIndex);
    goto itemporalobservationstable_findfield_method_cleanup;

    itemporalobservationstable_findfield_method_cleanup:
    self->m_HR = hr;
    if (bsName)
        ::SysFreeString(bsName);
    
    // No cleanup for FieldIndex
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalObservationsTable.FindField");
    return return_tuple;
}

static PyObject*
ITemporalObservationsTableMethod_get_Fields(PyITemporalObservationsTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IFields* ipFields = NULL;
    PyObject* py_Fields = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Fields

    // Call method on actual COM interface
    hr = self->m_pITemporalObservationsTable->get_Fields(&ipFields);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalObservationsTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalObservationsTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalObservationsTable.get_Fields() returned %ld", (long)hr);
        goto itemporalobservationstable_get_fields_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_Fields);
    if (ipFields)
    {
        IUnknown* pUnk = NULL;
        ipFields->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_Fields = IUnknownToPythonIIDObject(pUnk, &IID_IFields);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_Fields)
    {
        if (py_Fields)
           Py_DECREF(py_Fields);
        py_Fields = Py_None;
        Py_INCREF(py_Fields);
    }
    if (PyErr_Occurred())
      goto itemporalobservationstable_get_fields_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_Fields);
    goto itemporalobservationstable_get_fields_method_cleanup;

    itemporalobservationstable_get_fields_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_Fields);
    if (ipFields)
      ipFields->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalObservationsTable.get_Fields");
    return return_tuple;
}

static PyObject*
ITemporalObservationsTableMethod_AddField(PyITemporalObservationsTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IField* ipField = NULL;
    PyObject* py_Field;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_Field))
      goto itemporalobservationstable_addfield_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_Field, &IID_IField, (void**)&ipField))
        PyErr_SetString(PyExc_TypeError, "Argument Field (position 0) is not IField");
    
    if (PyErr_Occurred())
      goto itemporalobservationstable_addfield_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITemporalObservationsTable->AddField(ipField);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalObservationsTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalObservationsTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalObservationsTable.AddField() returned %ld", (long)hr);
        goto itemporalobservationstable_addfield_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Field

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto itemporalobservationstable_addfield_method_cleanup;

    itemporalobservationstable_addfield_method_cleanup:
    self->m_HR = hr;
    if (ipField)
      ipField->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalObservationsTable.AddField");
    return return_tuple;
}

static PyObject*
ITemporalObservationsTableMethod_DeleteField(PyITemporalObservationsTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IField* ipField = NULL;
    PyObject* py_Field;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_Field))
      goto itemporalobservationstable_deletefield_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_Field, &IID_IField, (void**)&ipField))
        PyErr_SetString(PyExc_TypeError, "Argument Field (position 0) is not IField");
    
    if (PyErr_Occurred())
      goto itemporalobservationstable_deletefield_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITemporalObservationsTable->DeleteField(ipField);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalObservationsTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalObservationsTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalObservationsTable.DeleteField() returned %ld", (long)hr);
        goto itemporalobservationstable_deletefield_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Field

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto itemporalobservationstable_deletefield_method_cleanup;

    itemporalobservationstable_deletefield_method_cleanup:
    self->m_HR = hr;
    if (ipField)
      ipField->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalObservationsTable.DeleteField");
    return return_tuple;
}

static PyObject*
ITemporalObservationsTableMethod_CreateRow(PyITemporalObservationsTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IRow* ipRow = NULL;
    PyObject* py_Row = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Row

    // Call method on actual COM interface
    hr = self->m_pITemporalObservationsTable->CreateRow(&ipRow);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalObservationsTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalObservationsTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalObservationsTable.CreateRow() returned %ld", (long)hr);
        goto itemporalobservationstable_createrow_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_Row);
    if (ipRow)
    {
        IUnknown* pUnk = NULL;
        ipRow->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_Row = IUnknownToPythonIIDObject(pUnk, &IID_IRow);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_Row)
    {
        if (py_Row)
           Py_DECREF(py_Row);
        py_Row = Py_None;
        Py_INCREF(py_Row);
    }
    if (PyErr_Occurred())
      goto itemporalobservationstable_createrow_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_Row);
    goto itemporalobservationstable_createrow_method_cleanup;

    itemporalobservationstable_createrow_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_Row);
    if (ipRow)
      ipRow->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalObservationsTable.CreateRow");
    return return_tuple;
}

static PyObject*
ITemporalObservationsTableMethod_GetRow(PyITemporalObservationsTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lOID = 0;
    IRow* ipRow = NULL;
    PyObject* py_Row = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lOID))
      goto itemporalobservationstable_getrow_method_cleanup;

    // Set up initial variable values as needed
    // No setup for OID
    // No setup for Row

    // Call method on actual COM interface
    hr = self->m_pITemporalObservationsTable->GetRow(lOID, &ipRow);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalObservationsTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalObservationsTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalObservationsTable.GetRow() returned %ld", (long)hr);
        goto itemporalobservationstable_getrow_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for OID
    Py_XDECREF(py_Row);
    if (ipRow)
    {
        IUnknown* pUnk = NULL;
        ipRow->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_Row = IUnknownToPythonIIDObject(pUnk, &IID_IRow);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_Row)
    {
        if (py_Row)
           Py_DECREF(py_Row);
        py_Row = Py_None;
        Py_INCREF(py_Row);
    }
    if (PyErr_Occurred())
      goto itemporalobservationstable_getrow_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_Row);
    goto itemporalobservationstable_getrow_method_cleanup;

    itemporalobservationstable_getrow_method_cleanup:
    self->m_HR = hr;
    // No cleanup for OID
    Py_XDECREF(py_Row);
    if (ipRow)
      ipRow->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalObservationsTable.GetRow");
    return return_tuple;
}

static PyObject*
ITemporalObservationsTableMethod_CreateRowBuffer(PyITemporalObservationsTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IRowBuffer* ipBuffer = NULL;
    PyObject* py_Buffer = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Buffer

    // Call method on actual COM interface
    hr = self->m_pITemporalObservationsTable->CreateRowBuffer(&ipBuffer);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalObservationsTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalObservationsTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalObservationsTable.CreateRowBuffer() returned %ld", (long)hr);
        goto itemporalobservationstable_createrowbuffer_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_Buffer);
    if (ipBuffer)
    {
        IUnknown* pUnk = NULL;
        ipBuffer->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_Buffer = IUnknownToPythonIIDObject(pUnk, &IID_IRowBuffer);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_Buffer)
    {
        if (py_Buffer)
           Py_DECREF(py_Buffer);
        py_Buffer = Py_None;
        Py_INCREF(py_Buffer);
    }
    if (PyErr_Occurred())
      goto itemporalobservationstable_createrowbuffer_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_Buffer);
    goto itemporalobservationstable_createrowbuffer_method_cleanup;

    itemporalobservationstable_createrowbuffer_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_Buffer);
    if (ipBuffer)
      ipBuffer->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalObservationsTable.CreateRowBuffer");
    return return_tuple;
}

static PyObject*
ITemporalObservationsTableMethod_RowCount(PyITemporalObservationsTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IQueryFilter* ipQueryFilter = NULL;
    PyObject* py_QueryFilter;
    long lNumRows = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_QueryFilter))
      goto itemporalobservationstable_rowcount_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_QueryFilter, &IID_IQueryFilter, (void**)&ipQueryFilter))
        PyErr_SetString(PyExc_TypeError, "Argument QueryFilter (position 0) is not IQueryFilter");
    
    if (PyErr_Occurred())
      goto itemporalobservationstable_rowcount_method_cleanup;
    
    // No setup for NumRows

    // Call method on actual COM interface
    hr = self->m_pITemporalObservationsTable->RowCount(ipQueryFilter, &lNumRows);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalObservationsTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalObservationsTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalObservationsTable.RowCount() returned %ld", (long)hr);
        goto itemporalobservationstable_rowcount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for QueryFilter
    // No teardown for NumRows

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lNumRows);
    goto itemporalobservationstable_rowcount_method_cleanup;

    itemporalobservationstable_rowcount_method_cleanup:
    self->m_HR = hr;
    if (ipQueryFilter)
      ipQueryFilter->Release();
    // No cleanup for NumRows
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalObservationsTable.RowCount");
    return return_tuple;
}

static PyObject*
ITemporalObservationsTableMethod_Search(PyITemporalObservationsTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IQueryFilter* ipQueryFilter = NULL;
    PyObject* py_QueryFilter;
    VARIANT_BOOL b_Recycling = VARIANT_FALSE;
    PyObject* pyvar_Recycling = NULL;
    ICursor* ipCursor = NULL;
    PyObject* py_Cursor = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OO", &py_QueryFilter, &pyvar_Recycling))
      goto itemporalobservationstable_search_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_QueryFilter, &IID_IQueryFilter, (void**)&ipQueryFilter))
        PyErr_SetString(PyExc_TypeError, "Argument QueryFilter (position 0) is not IQueryFilter");
    
    if (PyErr_Occurred())
      goto itemporalobservationstable_search_method_cleanup;
    
    b_Recycling = ((PyObject_IsTrue(pyvar_Recycling) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto itemporalobservationstable_search_method_cleanup;
    
    // No setup for Cursor

    // Call method on actual COM interface
    hr = self->m_pITemporalObservationsTable->Search(ipQueryFilter, b_Recycling, &ipCursor);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalObservationsTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalObservationsTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalObservationsTable.Search() returned %ld", (long)hr);
        goto itemporalobservationstable_search_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for QueryFilter
    // No teardown for Recycling
    Py_XDECREF(py_Cursor);
    if (ipCursor)
    {
        IUnknown* pUnk = NULL;
        ipCursor->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_Cursor = IUnknownToPythonIIDObject(pUnk, &IID_ICursor);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_Cursor)
    {
        if (py_Cursor)
           Py_DECREF(py_Cursor);
        py_Cursor = Py_None;
        Py_INCREF(py_Cursor);
    }
    if (PyErr_Occurred())
      goto itemporalobservationstable_search_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_Cursor);
    goto itemporalobservationstable_search_method_cleanup;

    itemporalobservationstable_search_method_cleanup:
    self->m_HR = hr;
    if (ipQueryFilter)
      ipQueryFilter->Release();
    // No cleanup for Recycling
    Py_XDECREF(py_Cursor);
    if (ipCursor)
      ipCursor->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalObservationsTable.Search");
    return return_tuple;
}

static PyObject*
ITemporalObservationsTableMethod_Update(PyITemporalObservationsTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IQueryFilter* ipQueryFilter = NULL;
    PyObject* py_QueryFilter;
    VARIANT_BOOL b_Recycling = VARIANT_FALSE;
    PyObject* pyvar_Recycling = NULL;
    ICursor* ipCursor = NULL;
    PyObject* py_Cursor = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OO", &py_QueryFilter, &pyvar_Recycling))
      goto itemporalobservationstable_update_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_QueryFilter, &IID_IQueryFilter, (void**)&ipQueryFilter))
        PyErr_SetString(PyExc_TypeError, "Argument QueryFilter (position 0) is not IQueryFilter");
    
    if (PyErr_Occurred())
      goto itemporalobservationstable_update_method_cleanup;
    
    b_Recycling = ((PyObject_IsTrue(pyvar_Recycling) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto itemporalobservationstable_update_method_cleanup;
    
    // No setup for Cursor

    // Call method on actual COM interface
    hr = self->m_pITemporalObservationsTable->Update(ipQueryFilter, b_Recycling, &ipCursor);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalObservationsTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalObservationsTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalObservationsTable.Update() returned %ld", (long)hr);
        goto itemporalobservationstable_update_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for QueryFilter
    // No teardown for Recycling
    Py_XDECREF(py_Cursor);
    if (ipCursor)
    {
        IUnknown* pUnk = NULL;
        ipCursor->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_Cursor = IUnknownToPythonIIDObject(pUnk, &IID_ICursor);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_Cursor)
    {
        if (py_Cursor)
           Py_DECREF(py_Cursor);
        py_Cursor = Py_None;
        Py_INCREF(py_Cursor);
    }
    if (PyErr_Occurred())
      goto itemporalobservationstable_update_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_Cursor);
    goto itemporalobservationstable_update_method_cleanup;

    itemporalobservationstable_update_method_cleanup:
    self->m_HR = hr;
    if (ipQueryFilter)
      ipQueryFilter->Release();
    // No cleanup for Recycling
    Py_XDECREF(py_Cursor);
    if (ipCursor)
      ipCursor->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalObservationsTable.Update");
    return return_tuple;
}

static PyObject*
ITemporalObservationsTableMethod_Insert(PyITemporalObservationsTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_useBuffering = VARIANT_FALSE;
    PyObject* pyvar_useBuffering = NULL;
    ICursor* ipCursor = NULL;
    PyObject* py_Cursor = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_useBuffering))
      goto itemporalobservationstable_insert_method_cleanup;

    // Set up initial variable values as needed
    b_useBuffering = ((PyObject_IsTrue(pyvar_useBuffering) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto itemporalobservationstable_insert_method_cleanup;
    
    // No setup for Cursor

    // Call method on actual COM interface
    hr = self->m_pITemporalObservationsTable->Insert(b_useBuffering, &ipCursor);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalObservationsTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalObservationsTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalObservationsTable.Insert() returned %ld", (long)hr);
        goto itemporalobservationstable_insert_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for useBuffering
    Py_XDECREF(py_Cursor);
    if (ipCursor)
    {
        IUnknown* pUnk = NULL;
        ipCursor->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_Cursor = IUnknownToPythonIIDObject(pUnk, &IID_ICursor);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_Cursor)
    {
        if (py_Cursor)
           Py_DECREF(py_Cursor);
        py_Cursor = Py_None;
        Py_INCREF(py_Cursor);
    }
    if (PyErr_Occurred())
      goto itemporalobservationstable_insert_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_Cursor);
    goto itemporalobservationstable_insert_method_cleanup;

    itemporalobservationstable_insert_method_cleanup:
    self->m_HR = hr;
    // No cleanup for useBuffering
    Py_XDECREF(py_Cursor);
    if (ipCursor)
      ipCursor->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalObservationsTable.Insert");
    return return_tuple;
}

static PyObject*
ITemporalObservationsTableMethod_Select(PyITemporalObservationsTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IQueryFilter* ipQueryFilter = NULL;
    PyObject* py_QueryFilter;
    esriSelectionType eselType;
    esriSelectionOption eselOption;
    IWorkspace* ipselectionContainer = NULL;
    PyObject* py_selectionContainer;
    ISelectionSet* ipppSelectionSet = NULL;
    PyObject* py_ppSelectionSet = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OiiO", &py_QueryFilter, (int *)&eselType, (int *)&eselOption, &py_selectionContainer))
      goto itemporalobservationstable_select_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_QueryFilter, &IID_IQueryFilter, (void**)&ipQueryFilter))
        PyErr_SetString(PyExc_TypeError, "Argument QueryFilter (position 0) is not IQueryFilter");
    
    if (PyErr_Occurred())
      goto itemporalobservationstable_select_method_cleanup;
    
    // No setup for selType
    // No setup for selOption
    if (!IFaceFromPyObject(py_selectionContainer, &IID_IWorkspace, (void**)&ipselectionContainer))
        PyErr_SetString(PyExc_TypeError, "Argument selectionContainer (position 3) is not IWorkspace");
    
    if (PyErr_Occurred())
      goto itemporalobservationstable_select_method_cleanup;
    
    // No setup for ppSelectionSet

    // Call method on actual COM interface
    hr = self->m_pITemporalObservationsTable->Select(ipQueryFilter, eselType, eselOption, ipselectionContainer, &ipppSelectionSet);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalObservationsTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalObservationsTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalObservationsTable.Select() returned %ld", (long)hr);
        goto itemporalobservationstable_select_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for QueryFilter
    // No teardown for selType
    // No teardown for selOption
    // No teardown for selectionContainer
    Py_XDECREF(py_ppSelectionSet);
    if (ipppSelectionSet)
    {
        IUnknown* pUnk = NULL;
        ipppSelectionSet->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppSelectionSet = IUnknownToPythonIIDObject(pUnk, &IID_ISelectionSet);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppSelectionSet)
    {
        if (py_ppSelectionSet)
           Py_DECREF(py_ppSelectionSet);
        py_ppSelectionSet = Py_None;
        Py_INCREF(py_ppSelectionSet);
    }
    if (PyErr_Occurred())
      goto itemporalobservationstable_select_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppSelectionSet);
    goto itemporalobservationstable_select_method_cleanup;

    itemporalobservationstable_select_method_cleanup:
    self->m_HR = hr;
    if (ipQueryFilter)
      ipQueryFilter->Release();
    // No cleanup for selType
    // No cleanup for selOption
    if (ipselectionContainer)
      ipselectionContainer->Release();
    Py_XDECREF(py_ppSelectionSet);
    if (ipppSelectionSet)
      ipppSelectionSet->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalObservationsTable.Select");
    return return_tuple;
}

static PyObject*
ITemporalObservationsTableMethod_get_HasGeometry(PyITemporalObservationsTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pVal = VARIANT_FALSE;
    PyObject* pyvar_pVal = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pITemporalObservationsTable->get_HasGeometry(&b_pVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalObservationsTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalObservationsTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalObservationsTable.get_HasGeometry() returned %ld", (long)hr);
        goto itemporalobservationstable_get_hasgeometry_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pVal = ((b_pVal == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto itemporalobservationstable_get_hasgeometry_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pVal);
    goto itemporalobservationstable_get_hasgeometry_method_cleanup;

    itemporalobservationstable_get_hasgeometry_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalObservationsTable.get_HasGeometry");
    return return_tuple;
}

static PyObject*
ITemporalObservationsTableMethod_get_GeometryColumnName(PyITemporalObservationsTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspbstrColumnName;
    PyObject* pyvar_pbstrColumnName = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pbstrColumnName

    // Call method on actual COM interface
    hr = self->m_pITemporalObservationsTable->get_GeometryColumnName(&bspbstrColumnName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalObservationsTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalObservationsTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalObservationsTable.get_GeometryColumnName() returned %ld", (long)hr);
        goto itemporalobservationstable_get_geometrycolumnname_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pbstrColumnName = PyUnicode_FromWideChar(bspbstrColumnName,::SysStringLen(bspbstrColumnName));
    ::SysFreeString(bspbstrColumnName);
    
    if (PyErr_Occurred())
      goto itemporalobservationstable_get_geometrycolumnname_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pbstrColumnName);
    goto itemporalobservationstable_get_geometrycolumnname_method_cleanup;

    itemporalobservationstable_get_geometrycolumnname_method_cleanup:
    self->m_HR = hr;
    if (pyvar_pbstrColumnName != Py_None)
        Py_XDECREF(pyvar_pbstrColumnName);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalObservationsTable.get_GeometryColumnName");
    return return_tuple;
}

static PyObject*
ITemporalObservationsTableMethod_put_GeometryColumnName(PyITemporalObservationsTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspbstrColumnName = 0;
    PyObject* pyvar_pbstrColumnName;
    PyObject* unicodepbstrColumnName = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pbstrColumnName))
      goto itemporalobservationstable_put_geometrycolumnname_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_pbstrColumnName))
        unicodepbstrColumnName = PyUnicode_FromObject(pyvar_pbstrColumnName);
    else if (PyUnicode_Check(pyvar_pbstrColumnName))
    {
        unicodepbstrColumnName = pyvar_pbstrColumnName;
        Py_INCREF(unicodepbstrColumnName);
    }
    else if (pyvar_pbstrColumnName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter pbstrColumnName at index 0");
    if (unicodepbstrColumnName)
        bspbstrColumnName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodepbstrColumnName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodepbstrColumnName));
    
    if (PyErr_Occurred())
      goto itemporalobservationstable_put_geometrycolumnname_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITemporalObservationsTable->put_GeometryColumnName(bspbstrColumnName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalObservationsTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalObservationsTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalObservationsTable.put_GeometryColumnName() returned %ld", (long)hr);
        goto itemporalobservationstable_put_geometrycolumnname_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pbstrColumnName

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto itemporalobservationstable_put_geometrycolumnname_method_cleanup;

    itemporalobservationstable_put_geometrycolumnname_method_cleanup:
    self->m_HR = hr;
    if (bspbstrColumnName)
        ::SysFreeString(bspbstrColumnName);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalObservationsTable.put_GeometryColumnName");
    return return_tuple;
}


PyMethodDef PyITemporalObservationsTableMethods[] = {
    {"supports", (PyCFunction)PyITemporalObservationsTable_SupportsInterface, METH_O, ""},
    {"get_AutoPurge", (PyCFunction)ITemporalObservationsTableMethod_get_AutoPurge, METH_VARARGS, ""},
    {"put_AutoPurge", (PyCFunction)ITemporalObservationsTableMethod_put_AutoPurge, METH_VARARGS, ""},
    {"get_Threshold", (PyCFunction)ITemporalObservationsTableMethod_get_Threshold, METH_VARARGS, ""},
    {"put_Threshold", (PyCFunction)ITemporalObservationsTableMethod_put_Threshold, METH_VARARGS, ""},
    {"get_PurgePercentage", (PyCFunction)ITemporalObservationsTableMethod_get_PurgePercentage, METH_VARARGS, ""},
    {"put_PurgePercentage", (PyCFunction)ITemporalObservationsTableMethod_put_PurgePercentage, METH_VARARGS, ""},
    {"get_Persistant", (PyCFunction)ITemporalObservationsTableMethod_get_Persistant, METH_VARARGS, ""},
    {"put_Persistant", (PyCFunction)ITemporalObservationsTableMethod_put_Persistant, METH_VARARGS, ""},
    {"get_TemporalColumnName", (PyCFunction)ITemporalObservationsTableMethod_get_TemporalColumnName, METH_VARARGS, ""},
    {"put_TemporalColumnName", (PyCFunction)ITemporalObservationsTableMethod_put_TemporalColumnName, METH_VARARGS, ""},
    {"get_PurgeRule", (PyCFunction)ITemporalObservationsTableMethod_get_PurgeRule, METH_VARARGS, ""},
    {"put_PurgeRule", (PyCFunction)ITemporalObservationsTableMethod_put_PurgeRule, METH_VARARGS, ""},
    {"PruneTable", (PyCFunction)ITemporalObservationsTableMethod_PruneTable, METH_NOARGS, ""},
    {"QueryTemporalExtent", (PyCFunction)ITemporalObservationsTableMethod_QueryTemporalExtent, METH_VARARGS, ""},
    {"FindField", (PyCFunction)ITemporalObservationsTableMethod_FindField, METH_VARARGS, ""},
    {"get_Fields", (PyCFunction)ITemporalObservationsTableMethod_get_Fields, METH_VARARGS, ""},
    {"AddField", (PyCFunction)ITemporalObservationsTableMethod_AddField, METH_VARARGS, ""},
    {"DeleteField", (PyCFunction)ITemporalObservationsTableMethod_DeleteField, METH_VARARGS, ""},
    {"CreateRow", (PyCFunction)ITemporalObservationsTableMethod_CreateRow, METH_VARARGS, ""},
    {"GetRow", (PyCFunction)ITemporalObservationsTableMethod_GetRow, METH_VARARGS, ""},
    {"CreateRowBuffer", (PyCFunction)ITemporalObservationsTableMethod_CreateRowBuffer, METH_VARARGS, ""},
    {"RowCount", (PyCFunction)ITemporalObservationsTableMethod_RowCount, METH_VARARGS, ""},
    {"Search", (PyCFunction)ITemporalObservationsTableMethod_Search, METH_VARARGS, ""},
    {"Update", (PyCFunction)ITemporalObservationsTableMethod_Update, METH_VARARGS, ""},
    {"Insert", (PyCFunction)ITemporalObservationsTableMethod_Insert, METH_VARARGS, ""},
    {"Select", (PyCFunction)ITemporalObservationsTableMethod_Select, METH_VARARGS, ""},
    {"get_HasGeometry", (PyCFunction)ITemporalObservationsTableMethod_get_HasGeometry, METH_VARARGS, ""},
    {"get_GeometryColumnName", (PyCFunction)ITemporalObservationsTableMethod_get_GeometryColumnName, METH_VARARGS, ""},
    {"put_GeometryColumnName", (PyCFunction)ITemporalObservationsTableMethod_put_GeometryColumnName, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyITemporalObservationsTableGetSet[] = {
  {"_pUnk", (getter)PyITemporalObservationsTable_GetpUnk, NULL, "Get opaque pointer to an Unknown from ITemporalObservationsTable", NULL},
  {"_pointer", (getter)PyITemporalObservationsTable_GetPointer, NULL, "Get memory address for ITemporalObservationsTable", NULL},
  {"_IID", (getter)PyITemporalObservationsTable_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyITemporalObservationsTable_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyITemporalObservationsTable_GetIgnoreFailures, (setter)PyITemporalObservationsTable_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyITemporalObservationsTableObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.ITemporalObservationsTableObject",                          
                                              /* tp_name */
  sizeof(PyITemporalObservationsTableObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyITemporalObservationsTableObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyITemporalObservationsTableMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyITemporalObservationsTableGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyITemporalObservationsTableObject_new,                      
                                              /* tp_new */
};

// Interface ITemporalObjectTable

typedef struct PyITemporalObjectTableObject {
    PyObject_HEAD
    ITemporalObjectTable* m_pITemporalObjectTable;
    HRESULT m_HR;
    int m_ignore_failures;
} PyITemporalObjectTableObject;

static PyObject*
PyITemporalObjectTableObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyITemporalObjectTableObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ITemporalObjectTable* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ITemporalObjectTable, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ITemporalObjectTable with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyITemporalObjectTableObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ITemporalObjectTable");
            return NULL;
        }
        self->m_pITemporalObjectTable = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ITemporalObjectTable");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ITemporalObjectTable");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ITemporalObjectTable* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ITemporalObjectTable, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ITemporalObjectTable");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyITemporalObjectTableObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ITemporalObjectTable");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pITemporalObjectTable = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyITemporalObjectTableObject_dealloc(PyITemporalObjectTableObject* self)
{
    if (self->m_pITemporalObjectTable)
        self->m_pITemporalObjectTable->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyITemporalObjectTable_GetpUnk(PyITemporalObjectTableObject* self)
{
    if (!self->m_pITemporalObjectTable)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pITemporalObjectTable->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ITemporalObjectTable to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyITemporalObjectTable_GetPointer(PyITemporalObjectTableObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pITemporalObjectTable);
}

static PyObject*
PyITemporalObjectTable_GetIID(PyITemporalObjectTableObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "a677ab60-2fb8-11d5-b7e2-00010265adc5");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyITemporalObjectTable_GetHR(PyITemporalObjectTableObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyITemporalObjectTable_GetIgnoreFailures(PyITemporalObjectTableObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyITemporalObjectTable_SetIgnoreFailures(PyITemporalObjectTableObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyITemporalObjectTable_SupportsInterface(PyITemporalObjectTableObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pITemporalObjectTable->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ITemporalObjectTableMethod_get_TrackingColumnName(PyITemporalObjectTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspbstrColumnName;
    PyObject* pyvar_pbstrColumnName = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pbstrColumnName

    // Call method on actual COM interface
    hr = self->m_pITemporalObjectTable->get_TrackingColumnName(&bspbstrColumnName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalObjectTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalObjectTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalObjectTable.get_TrackingColumnName() returned %ld", (long)hr);
        goto itemporalobjecttable_get_trackingcolumnname_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pbstrColumnName = PyUnicode_FromWideChar(bspbstrColumnName,::SysStringLen(bspbstrColumnName));
    ::SysFreeString(bspbstrColumnName);
    
    if (PyErr_Occurred())
      goto itemporalobjecttable_get_trackingcolumnname_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pbstrColumnName);
    goto itemporalobjecttable_get_trackingcolumnname_method_cleanup;

    itemporalobjecttable_get_trackingcolumnname_method_cleanup:
    self->m_HR = hr;
    if (pyvar_pbstrColumnName != Py_None)
        Py_XDECREF(pyvar_pbstrColumnName);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalObjectTable.get_TrackingColumnName");
    return return_tuple;
}

static PyObject*
ITemporalObjectTableMethod_FindField(PyITemporalObjectTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName = 0;
    PyObject* pyvar_Name;
    PyObject* unicodeName = NULL;
    long lFieldIndex = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_Name))
      goto itemporalobjecttable_findfield_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_Name))
        unicodeName = PyUnicode_FromObject(pyvar_Name);
    else if (PyUnicode_Check(pyvar_Name))
    {
        unicodeName = pyvar_Name;
        Py_INCREF(unicodeName);
    }
    else if (pyvar_Name != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Name at index 0");
    if (unicodeName)
        bsName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeName));
    
    if (PyErr_Occurred())
      goto itemporalobjecttable_findfield_method_cleanup;
    
    // No setup for FieldIndex

    // Call method on actual COM interface
    hr = self->m_pITemporalObjectTable->FindField(bsName, &lFieldIndex);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalObjectTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalObjectTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalObjectTable.FindField() returned %ld", (long)hr);
        goto itemporalobjecttable_findfield_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Name
    // No teardown for FieldIndex

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lFieldIndex);
    goto itemporalobjecttable_findfield_method_cleanup;

    itemporalobjecttable_findfield_method_cleanup:
    self->m_HR = hr;
    if (bsName)
        ::SysFreeString(bsName);
    
    // No cleanup for FieldIndex
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalObjectTable.FindField");
    return return_tuple;
}

static PyObject*
ITemporalObjectTableMethod_get_Fields(PyITemporalObjectTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IFields* ipFields = NULL;
    PyObject* py_Fields = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Fields

    // Call method on actual COM interface
    hr = self->m_pITemporalObjectTable->get_Fields(&ipFields);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalObjectTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalObjectTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalObjectTable.get_Fields() returned %ld", (long)hr);
        goto itemporalobjecttable_get_fields_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_Fields);
    if (ipFields)
    {
        IUnknown* pUnk = NULL;
        ipFields->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_Fields = IUnknownToPythonIIDObject(pUnk, &IID_IFields);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_Fields)
    {
        if (py_Fields)
           Py_DECREF(py_Fields);
        py_Fields = Py_None;
        Py_INCREF(py_Fields);
    }
    if (PyErr_Occurred())
      goto itemporalobjecttable_get_fields_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_Fields);
    goto itemporalobjecttable_get_fields_method_cleanup;

    itemporalobjecttable_get_fields_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_Fields);
    if (ipFields)
      ipFields->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalObjectTable.get_Fields");
    return return_tuple;
}

static PyObject*
ITemporalObjectTableMethod_AddField(PyITemporalObjectTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IField* ipField = NULL;
    PyObject* py_Field;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_Field))
      goto itemporalobjecttable_addfield_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_Field, &IID_IField, (void**)&ipField))
        PyErr_SetString(PyExc_TypeError, "Argument Field (position 0) is not IField");
    
    if (PyErr_Occurred())
      goto itemporalobjecttable_addfield_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITemporalObjectTable->AddField(ipField);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalObjectTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalObjectTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalObjectTable.AddField() returned %ld", (long)hr);
        goto itemporalobjecttable_addfield_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Field

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto itemporalobjecttable_addfield_method_cleanup;

    itemporalobjecttable_addfield_method_cleanup:
    self->m_HR = hr;
    if (ipField)
      ipField->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalObjectTable.AddField");
    return return_tuple;
}

static PyObject*
ITemporalObjectTableMethod_DeleteField(PyITemporalObjectTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IField* ipField = NULL;
    PyObject* py_Field;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_Field))
      goto itemporalobjecttable_deletefield_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_Field, &IID_IField, (void**)&ipField))
        PyErr_SetString(PyExc_TypeError, "Argument Field (position 0) is not IField");
    
    if (PyErr_Occurred())
      goto itemporalobjecttable_deletefield_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITemporalObjectTable->DeleteField(ipField);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalObjectTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalObjectTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalObjectTable.DeleteField() returned %ld", (long)hr);
        goto itemporalobjecttable_deletefield_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Field

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto itemporalobjecttable_deletefield_method_cleanup;

    itemporalobjecttable_deletefield_method_cleanup:
    self->m_HR = hr;
    if (ipField)
      ipField->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalObjectTable.DeleteField");
    return return_tuple;
}

static PyObject*
ITemporalObjectTableMethod_CreateRow(PyITemporalObjectTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IRow* ipRow = NULL;
    PyObject* py_Row = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Row

    // Call method on actual COM interface
    hr = self->m_pITemporalObjectTable->CreateRow(&ipRow);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalObjectTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalObjectTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalObjectTable.CreateRow() returned %ld", (long)hr);
        goto itemporalobjecttable_createrow_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_Row);
    if (ipRow)
    {
        IUnknown* pUnk = NULL;
        ipRow->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_Row = IUnknownToPythonIIDObject(pUnk, &IID_IRow);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_Row)
    {
        if (py_Row)
           Py_DECREF(py_Row);
        py_Row = Py_None;
        Py_INCREF(py_Row);
    }
    if (PyErr_Occurred())
      goto itemporalobjecttable_createrow_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_Row);
    goto itemporalobjecttable_createrow_method_cleanup;

    itemporalobjecttable_createrow_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_Row);
    if (ipRow)
      ipRow->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalObjectTable.CreateRow");
    return return_tuple;
}

static PyObject*
ITemporalObjectTableMethod_GetRow(PyITemporalObjectTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lOID = 0;
    IRow* ipRow = NULL;
    PyObject* py_Row = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lOID))
      goto itemporalobjecttable_getrow_method_cleanup;

    // Set up initial variable values as needed
    // No setup for OID
    // No setup for Row

    // Call method on actual COM interface
    hr = self->m_pITemporalObjectTable->GetRow(lOID, &ipRow);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalObjectTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalObjectTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalObjectTable.GetRow() returned %ld", (long)hr);
        goto itemporalobjecttable_getrow_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for OID
    Py_XDECREF(py_Row);
    if (ipRow)
    {
        IUnknown* pUnk = NULL;
        ipRow->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_Row = IUnknownToPythonIIDObject(pUnk, &IID_IRow);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_Row)
    {
        if (py_Row)
           Py_DECREF(py_Row);
        py_Row = Py_None;
        Py_INCREF(py_Row);
    }
    if (PyErr_Occurred())
      goto itemporalobjecttable_getrow_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_Row);
    goto itemporalobjecttable_getrow_method_cleanup;

    itemporalobjecttable_getrow_method_cleanup:
    self->m_HR = hr;
    // No cleanup for OID
    Py_XDECREF(py_Row);
    if (ipRow)
      ipRow->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalObjectTable.GetRow");
    return return_tuple;
}

static PyObject*
ITemporalObjectTableMethod_CreateRowBuffer(PyITemporalObjectTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IRowBuffer* ipBuffer = NULL;
    PyObject* py_Buffer = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Buffer

    // Call method on actual COM interface
    hr = self->m_pITemporalObjectTable->CreateRowBuffer(&ipBuffer);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalObjectTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalObjectTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalObjectTable.CreateRowBuffer() returned %ld", (long)hr);
        goto itemporalobjecttable_createrowbuffer_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_Buffer);
    if (ipBuffer)
    {
        IUnknown* pUnk = NULL;
        ipBuffer->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_Buffer = IUnknownToPythonIIDObject(pUnk, &IID_IRowBuffer);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_Buffer)
    {
        if (py_Buffer)
           Py_DECREF(py_Buffer);
        py_Buffer = Py_None;
        Py_INCREF(py_Buffer);
    }
    if (PyErr_Occurred())
      goto itemporalobjecttable_createrowbuffer_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_Buffer);
    goto itemporalobjecttable_createrowbuffer_method_cleanup;

    itemporalobjecttable_createrowbuffer_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_Buffer);
    if (ipBuffer)
      ipBuffer->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalObjectTable.CreateRowBuffer");
    return return_tuple;
}

static PyObject*
ITemporalObjectTableMethod_RowCount(PyITemporalObjectTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IQueryFilter* ipQueryFilter = NULL;
    PyObject* py_QueryFilter;
    long lNumRows = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_QueryFilter))
      goto itemporalobjecttable_rowcount_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_QueryFilter, &IID_IQueryFilter, (void**)&ipQueryFilter))
        PyErr_SetString(PyExc_TypeError, "Argument QueryFilter (position 0) is not IQueryFilter");
    
    if (PyErr_Occurred())
      goto itemporalobjecttable_rowcount_method_cleanup;
    
    // No setup for NumRows

    // Call method on actual COM interface
    hr = self->m_pITemporalObjectTable->RowCount(ipQueryFilter, &lNumRows);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalObjectTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalObjectTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalObjectTable.RowCount() returned %ld", (long)hr);
        goto itemporalobjecttable_rowcount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for QueryFilter
    // No teardown for NumRows

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lNumRows);
    goto itemporalobjecttable_rowcount_method_cleanup;

    itemporalobjecttable_rowcount_method_cleanup:
    self->m_HR = hr;
    if (ipQueryFilter)
      ipQueryFilter->Release();
    // No cleanup for NumRows
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalObjectTable.RowCount");
    return return_tuple;
}

static PyObject*
ITemporalObjectTableMethod_Search(PyITemporalObjectTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IQueryFilter* ipQueryFilter = NULL;
    PyObject* py_QueryFilter;
    VARIANT_BOOL b_Recycling = VARIANT_FALSE;
    PyObject* pyvar_Recycling = NULL;
    ICursor* ipCursor = NULL;
    PyObject* py_Cursor = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OO", &py_QueryFilter, &pyvar_Recycling))
      goto itemporalobjecttable_search_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_QueryFilter, &IID_IQueryFilter, (void**)&ipQueryFilter))
        PyErr_SetString(PyExc_TypeError, "Argument QueryFilter (position 0) is not IQueryFilter");
    
    if (PyErr_Occurred())
      goto itemporalobjecttable_search_method_cleanup;
    
    b_Recycling = ((PyObject_IsTrue(pyvar_Recycling) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto itemporalobjecttable_search_method_cleanup;
    
    // No setup for Cursor

    // Call method on actual COM interface
    hr = self->m_pITemporalObjectTable->Search(ipQueryFilter, b_Recycling, &ipCursor);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalObjectTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalObjectTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalObjectTable.Search() returned %ld", (long)hr);
        goto itemporalobjecttable_search_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for QueryFilter
    // No teardown for Recycling
    Py_XDECREF(py_Cursor);
    if (ipCursor)
    {
        IUnknown* pUnk = NULL;
        ipCursor->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_Cursor = IUnknownToPythonIIDObject(pUnk, &IID_ICursor);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_Cursor)
    {
        if (py_Cursor)
           Py_DECREF(py_Cursor);
        py_Cursor = Py_None;
        Py_INCREF(py_Cursor);
    }
    if (PyErr_Occurred())
      goto itemporalobjecttable_search_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_Cursor);
    goto itemporalobjecttable_search_method_cleanup;

    itemporalobjecttable_search_method_cleanup:
    self->m_HR = hr;
    if (ipQueryFilter)
      ipQueryFilter->Release();
    // No cleanup for Recycling
    Py_XDECREF(py_Cursor);
    if (ipCursor)
      ipCursor->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalObjectTable.Search");
    return return_tuple;
}

static PyObject*
ITemporalObjectTableMethod_Update(PyITemporalObjectTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IQueryFilter* ipQueryFilter = NULL;
    PyObject* py_QueryFilter;
    VARIANT_BOOL b_Recycling = VARIANT_FALSE;
    PyObject* pyvar_Recycling = NULL;
    ICursor* ipCursor = NULL;
    PyObject* py_Cursor = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OO", &py_QueryFilter, &pyvar_Recycling))
      goto itemporalobjecttable_update_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_QueryFilter, &IID_IQueryFilter, (void**)&ipQueryFilter))
        PyErr_SetString(PyExc_TypeError, "Argument QueryFilter (position 0) is not IQueryFilter");
    
    if (PyErr_Occurred())
      goto itemporalobjecttable_update_method_cleanup;
    
    b_Recycling = ((PyObject_IsTrue(pyvar_Recycling) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto itemporalobjecttable_update_method_cleanup;
    
    // No setup for Cursor

    // Call method on actual COM interface
    hr = self->m_pITemporalObjectTable->Update(ipQueryFilter, b_Recycling, &ipCursor);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalObjectTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalObjectTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalObjectTable.Update() returned %ld", (long)hr);
        goto itemporalobjecttable_update_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for QueryFilter
    // No teardown for Recycling
    Py_XDECREF(py_Cursor);
    if (ipCursor)
    {
        IUnknown* pUnk = NULL;
        ipCursor->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_Cursor = IUnknownToPythonIIDObject(pUnk, &IID_ICursor);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_Cursor)
    {
        if (py_Cursor)
           Py_DECREF(py_Cursor);
        py_Cursor = Py_None;
        Py_INCREF(py_Cursor);
    }
    if (PyErr_Occurred())
      goto itemporalobjecttable_update_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_Cursor);
    goto itemporalobjecttable_update_method_cleanup;

    itemporalobjecttable_update_method_cleanup:
    self->m_HR = hr;
    if (ipQueryFilter)
      ipQueryFilter->Release();
    // No cleanup for Recycling
    Py_XDECREF(py_Cursor);
    if (ipCursor)
      ipCursor->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalObjectTable.Update");
    return return_tuple;
}

static PyObject*
ITemporalObjectTableMethod_Insert(PyITemporalObjectTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_useBuffering = VARIANT_FALSE;
    PyObject* pyvar_useBuffering = NULL;
    ICursor* ipCursor = NULL;
    PyObject* py_Cursor = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_useBuffering))
      goto itemporalobjecttable_insert_method_cleanup;

    // Set up initial variable values as needed
    b_useBuffering = ((PyObject_IsTrue(pyvar_useBuffering) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto itemporalobjecttable_insert_method_cleanup;
    
    // No setup for Cursor

    // Call method on actual COM interface
    hr = self->m_pITemporalObjectTable->Insert(b_useBuffering, &ipCursor);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalObjectTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalObjectTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalObjectTable.Insert() returned %ld", (long)hr);
        goto itemporalobjecttable_insert_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for useBuffering
    Py_XDECREF(py_Cursor);
    if (ipCursor)
    {
        IUnknown* pUnk = NULL;
        ipCursor->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_Cursor = IUnknownToPythonIIDObject(pUnk, &IID_ICursor);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_Cursor)
    {
        if (py_Cursor)
           Py_DECREF(py_Cursor);
        py_Cursor = Py_None;
        Py_INCREF(py_Cursor);
    }
    if (PyErr_Occurred())
      goto itemporalobjecttable_insert_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_Cursor);
    goto itemporalobjecttable_insert_method_cleanup;

    itemporalobjecttable_insert_method_cleanup:
    self->m_HR = hr;
    // No cleanup for useBuffering
    Py_XDECREF(py_Cursor);
    if (ipCursor)
      ipCursor->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalObjectTable.Insert");
    return return_tuple;
}

static PyObject*
ITemporalObjectTableMethod_Select(PyITemporalObjectTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IQueryFilter* ipQueryFilter = NULL;
    PyObject* py_QueryFilter;
    esriSelectionType eselType;
    esriSelectionOption eselOption;
    IWorkspace* ipselectionContainer = NULL;
    PyObject* py_selectionContainer;
    ISelectionSet* ipppSelectionSet = NULL;
    PyObject* py_ppSelectionSet = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OiiO", &py_QueryFilter, (int *)&eselType, (int *)&eselOption, &py_selectionContainer))
      goto itemporalobjecttable_select_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_QueryFilter, &IID_IQueryFilter, (void**)&ipQueryFilter))
        PyErr_SetString(PyExc_TypeError, "Argument QueryFilter (position 0) is not IQueryFilter");
    
    if (PyErr_Occurred())
      goto itemporalobjecttable_select_method_cleanup;
    
    // No setup for selType
    // No setup for selOption
    if (!IFaceFromPyObject(py_selectionContainer, &IID_IWorkspace, (void**)&ipselectionContainer))
        PyErr_SetString(PyExc_TypeError, "Argument selectionContainer (position 3) is not IWorkspace");
    
    if (PyErr_Occurred())
      goto itemporalobjecttable_select_method_cleanup;
    
    // No setup for ppSelectionSet

    // Call method on actual COM interface
    hr = self->m_pITemporalObjectTable->Select(ipQueryFilter, eselType, eselOption, ipselectionContainer, &ipppSelectionSet);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalObjectTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalObjectTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalObjectTable.Select() returned %ld", (long)hr);
        goto itemporalobjecttable_select_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for QueryFilter
    // No teardown for selType
    // No teardown for selOption
    // No teardown for selectionContainer
    Py_XDECREF(py_ppSelectionSet);
    if (ipppSelectionSet)
    {
        IUnknown* pUnk = NULL;
        ipppSelectionSet->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppSelectionSet = IUnknownToPythonIIDObject(pUnk, &IID_ISelectionSet);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppSelectionSet)
    {
        if (py_ppSelectionSet)
           Py_DECREF(py_ppSelectionSet);
        py_ppSelectionSet = Py_None;
        Py_INCREF(py_ppSelectionSet);
    }
    if (PyErr_Occurred())
      goto itemporalobjecttable_select_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppSelectionSet);
    goto itemporalobjecttable_select_method_cleanup;

    itemporalobjecttable_select_method_cleanup:
    self->m_HR = hr;
    if (ipQueryFilter)
      ipQueryFilter->Release();
    // No cleanup for selType
    // No cleanup for selOption
    if (ipselectionContainer)
      ipselectionContainer->Release();
    Py_XDECREF(py_ppSelectionSet);
    if (ipppSelectionSet)
      ipppSelectionSet->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalObjectTable.Select");
    return return_tuple;
}

static PyObject*
ITemporalObjectTableMethod_get_HasGeometry(PyITemporalObjectTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pVal = VARIANT_FALSE;
    PyObject* pyvar_pVal = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pITemporalObjectTable->get_HasGeometry(&b_pVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalObjectTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalObjectTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalObjectTable.get_HasGeometry() returned %ld", (long)hr);
        goto itemporalobjecttable_get_hasgeometry_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pVal = ((b_pVal == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto itemporalobjecttable_get_hasgeometry_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pVal);
    goto itemporalobjecttable_get_hasgeometry_method_cleanup;

    itemporalobjecttable_get_hasgeometry_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalObjectTable.get_HasGeometry");
    return return_tuple;
}

static PyObject*
ITemporalObjectTableMethod_get_GeometryColumnName(PyITemporalObjectTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspbstrColumnName;
    PyObject* pyvar_pbstrColumnName = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pbstrColumnName

    // Call method on actual COM interface
    hr = self->m_pITemporalObjectTable->get_GeometryColumnName(&bspbstrColumnName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalObjectTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalObjectTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalObjectTable.get_GeometryColumnName() returned %ld", (long)hr);
        goto itemporalobjecttable_get_geometrycolumnname_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pbstrColumnName = PyUnicode_FromWideChar(bspbstrColumnName,::SysStringLen(bspbstrColumnName));
    ::SysFreeString(bspbstrColumnName);
    
    if (PyErr_Occurred())
      goto itemporalobjecttable_get_geometrycolumnname_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pbstrColumnName);
    goto itemporalobjecttable_get_geometrycolumnname_method_cleanup;

    itemporalobjecttable_get_geometrycolumnname_method_cleanup:
    self->m_HR = hr;
    if (pyvar_pbstrColumnName != Py_None)
        Py_XDECREF(pyvar_pbstrColumnName);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalObjectTable.get_GeometryColumnName");
    return return_tuple;
}

static PyObject*
ITemporalObjectTableMethod_put_GeometryColumnName(PyITemporalObjectTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspbstrColumnName = 0;
    PyObject* pyvar_pbstrColumnName;
    PyObject* unicodepbstrColumnName = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pbstrColumnName))
      goto itemporalobjecttable_put_geometrycolumnname_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_pbstrColumnName))
        unicodepbstrColumnName = PyUnicode_FromObject(pyvar_pbstrColumnName);
    else if (PyUnicode_Check(pyvar_pbstrColumnName))
    {
        unicodepbstrColumnName = pyvar_pbstrColumnName;
        Py_INCREF(unicodepbstrColumnName);
    }
    else if (pyvar_pbstrColumnName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter pbstrColumnName at index 0");
    if (unicodepbstrColumnName)
        bspbstrColumnName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodepbstrColumnName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodepbstrColumnName));
    
    if (PyErr_Occurred())
      goto itemporalobjecttable_put_geometrycolumnname_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITemporalObjectTable->put_GeometryColumnName(bspbstrColumnName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalObjectTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalObjectTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalObjectTable.put_GeometryColumnName() returned %ld", (long)hr);
        goto itemporalobjecttable_put_geometrycolumnname_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pbstrColumnName

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto itemporalobjecttable_put_geometrycolumnname_method_cleanup;

    itemporalobjecttable_put_geometrycolumnname_method_cleanup:
    self->m_HR = hr;
    if (bspbstrColumnName)
        ::SysFreeString(bspbstrColumnName);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalObjectTable.put_GeometryColumnName");
    return return_tuple;
}


PyMethodDef PyITemporalObjectTableMethods[] = {
    {"supports", (PyCFunction)PyITemporalObjectTable_SupportsInterface, METH_O, ""},
    {"get_TrackingColumnName", (PyCFunction)ITemporalObjectTableMethod_get_TrackingColumnName, METH_VARARGS, ""},
    {"FindField", (PyCFunction)ITemporalObjectTableMethod_FindField, METH_VARARGS, ""},
    {"get_Fields", (PyCFunction)ITemporalObjectTableMethod_get_Fields, METH_VARARGS, ""},
    {"AddField", (PyCFunction)ITemporalObjectTableMethod_AddField, METH_VARARGS, ""},
    {"DeleteField", (PyCFunction)ITemporalObjectTableMethod_DeleteField, METH_VARARGS, ""},
    {"CreateRow", (PyCFunction)ITemporalObjectTableMethod_CreateRow, METH_VARARGS, ""},
    {"GetRow", (PyCFunction)ITemporalObjectTableMethod_GetRow, METH_VARARGS, ""},
    {"CreateRowBuffer", (PyCFunction)ITemporalObjectTableMethod_CreateRowBuffer, METH_VARARGS, ""},
    {"RowCount", (PyCFunction)ITemporalObjectTableMethod_RowCount, METH_VARARGS, ""},
    {"Search", (PyCFunction)ITemporalObjectTableMethod_Search, METH_VARARGS, ""},
    {"Update", (PyCFunction)ITemporalObjectTableMethod_Update, METH_VARARGS, ""},
    {"Insert", (PyCFunction)ITemporalObjectTableMethod_Insert, METH_VARARGS, ""},
    {"Select", (PyCFunction)ITemporalObjectTableMethod_Select, METH_VARARGS, ""},
    {"get_HasGeometry", (PyCFunction)ITemporalObjectTableMethod_get_HasGeometry, METH_VARARGS, ""},
    {"get_GeometryColumnName", (PyCFunction)ITemporalObjectTableMethod_get_GeometryColumnName, METH_VARARGS, ""},
    {"put_GeometryColumnName", (PyCFunction)ITemporalObjectTableMethod_put_GeometryColumnName, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyITemporalObjectTableGetSet[] = {
  {"_pUnk", (getter)PyITemporalObjectTable_GetpUnk, NULL, "Get opaque pointer to an Unknown from ITemporalObjectTable", NULL},
  {"_pointer", (getter)PyITemporalObjectTable_GetPointer, NULL, "Get memory address for ITemporalObjectTable", NULL},
  {"_IID", (getter)PyITemporalObjectTable_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyITemporalObjectTable_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyITemporalObjectTable_GetIgnoreFailures, (setter)PyITemporalObjectTable_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyITemporalObjectTableObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.ITemporalObjectTableObject",                          
                                              /* tp_name */
  sizeof(PyITemporalObjectTableObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyITemporalObjectTableObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyITemporalObjectTableMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyITemporalObjectTableGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyITemporalObjectTableObject_new,                      
                                              /* tp_new */
};

// Interface ITemporalObservationsTable2

typedef struct PyITemporalObservationsTable2Object {
    PyObject_HEAD
    ITemporalObservationsTable2* m_pITemporalObservationsTable2;
    HRESULT m_HR;
    int m_ignore_failures;
} PyITemporalObservationsTable2Object;

static PyObject*
PyITemporalObservationsTable2Object_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyITemporalObservationsTable2Object* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ITemporalObservationsTable2* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ITemporalObservationsTable2, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ITemporalObservationsTable2 with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyITemporalObservationsTable2Object *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ITemporalObservationsTable2");
            return NULL;
        }
        self->m_pITemporalObservationsTable2 = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ITemporalObservationsTable2");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ITemporalObservationsTable2");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ITemporalObservationsTable2* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ITemporalObservationsTable2, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ITemporalObservationsTable2");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyITemporalObservationsTable2Object *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ITemporalObservationsTable2");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pITemporalObservationsTable2 = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyITemporalObservationsTable2Object_dealloc(PyITemporalObservationsTable2Object* self)
{
    if (self->m_pITemporalObservationsTable2)
        self->m_pITemporalObservationsTable2->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyITemporalObservationsTable2_GetpUnk(PyITemporalObservationsTable2Object* self)
{
    if (!self->m_pITemporalObservationsTable2)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pITemporalObservationsTable2->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ITemporalObservationsTable2 to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyITemporalObservationsTable2_GetPointer(PyITemporalObservationsTable2Object* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pITemporalObservationsTable2);
}

static PyObject*
PyITemporalObservationsTable2_GetIID(PyITemporalObservationsTable2Object* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "aec7a38a-f684-40fc-b2f2-96000ebf22d8");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyITemporalObservationsTable2_GetHR(PyITemporalObservationsTable2Object* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyITemporalObservationsTable2_GetIgnoreFailures(PyITemporalObservationsTable2Object* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyITemporalObservationsTable2_SetIgnoreFailures(PyITemporalObservationsTable2Object* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyITemporalObservationsTable2_SupportsInterface(PyITemporalObservationsTable2Object* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pITemporalObservationsTable2->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ITemporalObservationsTable2Method_put_TrackingColumnIndex(PyITemporalObservationsTable2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long l_arg1 = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &l_arg1))
      goto itemporalobservationstable2_put_trackingcolumnindex_method_cleanup;

    // Set up initial variable values as needed
    // No setup for _arg1

    // Call method on actual COM interface
    hr = self->m_pITemporalObservationsTable2->put_TrackingColumnIndex(l_arg1);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalObservationsTable2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalObservationsTable2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalObservationsTable2.put_TrackingColumnIndex() returned %ld", (long)hr);
        goto itemporalobservationstable2_put_trackingcolumnindex_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for _arg1

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto itemporalobservationstable2_put_trackingcolumnindex_method_cleanup;

    itemporalobservationstable2_put_trackingcolumnindex_method_cleanup:
    self->m_HR = hr;
    // No cleanup for _arg1
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalObservationsTable2.put_TrackingColumnIndex");
    return return_tuple;
}

static PyObject*
ITemporalObservationsTable2Method_get_AutoPurge(PyITemporalObservationsTable2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pVal = VARIANT_FALSE;
    PyObject* pyvar_pVal = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pITemporalObservationsTable2->get_AutoPurge(&b_pVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalObservationsTable2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalObservationsTable2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalObservationsTable2.get_AutoPurge() returned %ld", (long)hr);
        goto itemporalobservationstable2_get_autopurge_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pVal = ((b_pVal == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto itemporalobservationstable2_get_autopurge_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pVal);
    goto itemporalobservationstable2_get_autopurge_method_cleanup;

    itemporalobservationstable2_get_autopurge_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalObservationsTable2.get_AutoPurge");
    return return_tuple;
}

static PyObject*
ITemporalObservationsTable2Method_put_AutoPurge(PyITemporalObservationsTable2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pVal = VARIANT_FALSE;
    PyObject* pyvar_pVal = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pVal))
      goto itemporalobservationstable2_put_autopurge_method_cleanup;

    // Set up initial variable values as needed
    b_pVal = ((PyObject_IsTrue(pyvar_pVal) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto itemporalobservationstable2_put_autopurge_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITemporalObservationsTable2->put_AutoPurge(b_pVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalObservationsTable2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalObservationsTable2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalObservationsTable2.put_AutoPurge() returned %ld", (long)hr);
        goto itemporalobservationstable2_put_autopurge_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto itemporalobservationstable2_put_autopurge_method_cleanup;

    itemporalobservationstable2_put_autopurge_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalObservationsTable2.put_AutoPurge");
    return return_tuple;
}

static PyObject*
ITemporalObservationsTable2Method_get_Threshold(PyITemporalObservationsTable2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT vpvarVal;
    ::VariantInit(&vpvarVal);
    PyObject* pyvar_pvarVal = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pvarVal

    // Call method on actual COM interface
    hr = self->m_pITemporalObservationsTable2->get_Threshold(&vpvarVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalObservationsTable2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalObservationsTable2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalObservationsTable2.get_Threshold() returned %ld", (long)hr);
        goto itemporalobservationstable2_get_threshold_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pvarVal = Variant_AsPyObject(&vpvarVal);
    if (PyErr_Occurred())
      goto itemporalobservationstable2_get_threshold_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pvarVal);
    goto itemporalobservationstable2_get_threshold_method_cleanup;

    itemporalobservationstable2_get_threshold_method_cleanup:
    self->m_HR = hr;
    ::VariantClear(&vpvarVal);
    Py_XDECREF(pyvar_pvarVal);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalObservationsTable2.get_Threshold");
    return return_tuple;
}

static PyObject*
ITemporalObservationsTable2Method_put_Threshold(PyITemporalObservationsTable2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT vpvarVal;
    ::VariantInit(&vpvarVal);
    PyObject* pyvar_pvarVal = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pvarVal))
      goto itemporalobservationstable2_put_threshold_method_cleanup;

    // Set up initial variable values as needed
    PyObject_AsVariant(pyvar_pvarVal, &vpvarVal);
    
    if (PyErr_Occurred())
      goto itemporalobservationstable2_put_threshold_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITemporalObservationsTable2->put_Threshold(vpvarVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalObservationsTable2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalObservationsTable2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalObservationsTable2.put_Threshold() returned %ld", (long)hr);
        goto itemporalobservationstable2_put_threshold_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pvarVal

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto itemporalobservationstable2_put_threshold_method_cleanup;

    itemporalobservationstable2_put_threshold_method_cleanup:
    self->m_HR = hr;
    ::VariantClear(&vpvarVal);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalObservationsTable2.put_Threshold");
    return return_tuple;
}

static PyObject*
ITemporalObservationsTable2Method_get_PurgePercentage(PyITemporalObservationsTable2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dpVal = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pITemporalObservationsTable2->get_PurgePercentage(&dpVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalObservationsTable2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalObservationsTable2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalObservationsTable2.get_PurgePercentage() returned %ld", (long)hr);
        goto itemporalobservationstable2_get_purgepercentage_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dpVal);
    goto itemporalobservationstable2_get_purgepercentage_method_cleanup;

    itemporalobservationstable2_get_purgepercentage_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalObservationsTable2.get_PurgePercentage");
    return return_tuple;
}

static PyObject*
ITemporalObservationsTable2Method_put_PurgePercentage(PyITemporalObservationsTable2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dpVal = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "d", &dpVal))
      goto itemporalobservationstable2_put_purgepercentage_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pITemporalObservationsTable2->put_PurgePercentage(dpVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalObservationsTable2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalObservationsTable2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalObservationsTable2.put_PurgePercentage() returned %ld", (long)hr);
        goto itemporalobservationstable2_put_purgepercentage_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto itemporalobservationstable2_put_purgepercentage_method_cleanup;

    itemporalobservationstable2_put_purgepercentage_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalObservationsTable2.put_PurgePercentage");
    return return_tuple;
}

static PyObject*
ITemporalObservationsTable2Method_get_Persistant(PyITemporalObservationsTable2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pVal = VARIANT_FALSE;
    PyObject* pyvar_pVal = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pITemporalObservationsTable2->get_Persistant(&b_pVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalObservationsTable2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalObservationsTable2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalObservationsTable2.get_Persistant() returned %ld", (long)hr);
        goto itemporalobservationstable2_get_persistant_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pVal = ((b_pVal == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto itemporalobservationstable2_get_persistant_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pVal);
    goto itemporalobservationstable2_get_persistant_method_cleanup;

    itemporalobservationstable2_get_persistant_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalObservationsTable2.get_Persistant");
    return return_tuple;
}

static PyObject*
ITemporalObservationsTable2Method_put_Persistant(PyITemporalObservationsTable2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pVal = VARIANT_FALSE;
    PyObject* pyvar_pVal = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pVal))
      goto itemporalobservationstable2_put_persistant_method_cleanup;

    // Set up initial variable values as needed
    b_pVal = ((PyObject_IsTrue(pyvar_pVal) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto itemporalobservationstable2_put_persistant_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITemporalObservationsTable2->put_Persistant(b_pVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalObservationsTable2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalObservationsTable2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalObservationsTable2.put_Persistant() returned %ld", (long)hr);
        goto itemporalobservationstable2_put_persistant_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto itemporalobservationstable2_put_persistant_method_cleanup;

    itemporalobservationstable2_put_persistant_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalObservationsTable2.put_Persistant");
    return return_tuple;
}

static PyObject*
ITemporalObservationsTable2Method_get_TemporalColumnName(PyITemporalObservationsTable2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspVal;
    PyObject* pyvar_pVal = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pITemporalObservationsTable2->get_TemporalColumnName(&bspVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalObservationsTable2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalObservationsTable2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalObservationsTable2.get_TemporalColumnName() returned %ld", (long)hr);
        goto itemporalobservationstable2_get_temporalcolumnname_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pVal = PyUnicode_FromWideChar(bspVal,::SysStringLen(bspVal));
    ::SysFreeString(bspVal);
    
    if (PyErr_Occurred())
      goto itemporalobservationstable2_get_temporalcolumnname_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pVal);
    goto itemporalobservationstable2_get_temporalcolumnname_method_cleanup;

    itemporalobservationstable2_get_temporalcolumnname_method_cleanup:
    self->m_HR = hr;
    if (pyvar_pVal != Py_None)
        Py_XDECREF(pyvar_pVal);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalObservationsTable2.get_TemporalColumnName");
    return return_tuple;
}

static PyObject*
ITemporalObservationsTable2Method_put_TemporalColumnName(PyITemporalObservationsTable2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspVal = 0;
    PyObject* pyvar_pVal;
    PyObject* unicodepVal = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pVal))
      goto itemporalobservationstable2_put_temporalcolumnname_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_pVal))
        unicodepVal = PyUnicode_FromObject(pyvar_pVal);
    else if (PyUnicode_Check(pyvar_pVal))
    {
        unicodepVal = pyvar_pVal;
        Py_INCREF(unicodepVal);
    }
    else if (pyvar_pVal != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter pVal at index 0");
    if (unicodepVal)
        bspVal = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodepVal), 
                                            (UINT)PyUnicode_GET_SIZE(unicodepVal));
    
    if (PyErr_Occurred())
      goto itemporalobservationstable2_put_temporalcolumnname_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITemporalObservationsTable2->put_TemporalColumnName(bspVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalObservationsTable2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalObservationsTable2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalObservationsTable2.put_TemporalColumnName() returned %ld", (long)hr);
        goto itemporalobservationstable2_put_temporalcolumnname_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto itemporalobservationstable2_put_temporalcolumnname_method_cleanup;

    itemporalobservationstable2_put_temporalcolumnname_method_cleanup:
    self->m_HR = hr;
    if (bspVal)
        ::SysFreeString(bspVal);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalObservationsTable2.put_TemporalColumnName");
    return return_tuple;
}

static PyObject*
ITemporalObservationsTable2Method_get_PurgeRule(PyITemporalObservationsTable2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    enumPurgeRule epVal;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pITemporalObservationsTable2->get_PurgeRule(&epVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalObservationsTable2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalObservationsTable2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalObservationsTable2.get_PurgeRule() returned %ld", (long)hr);
        goto itemporalobservationstable2_get_purgerule_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)epVal);
    goto itemporalobservationstable2_get_purgerule_method_cleanup;

    itemporalobservationstable2_get_purgerule_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalObservationsTable2.get_PurgeRule");
    return return_tuple;
}

static PyObject*
ITemporalObservationsTable2Method_put_PurgeRule(PyITemporalObservationsTable2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    enumPurgeRule epVal;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&epVal))
      goto itemporalobservationstable2_put_purgerule_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pITemporalObservationsTable2->put_PurgeRule(epVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalObservationsTable2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalObservationsTable2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalObservationsTable2.put_PurgeRule() returned %ld", (long)hr);
        goto itemporalobservationstable2_put_purgerule_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto itemporalobservationstable2_put_purgerule_method_cleanup;

    itemporalobservationstable2_put_purgerule_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalObservationsTable2.put_PurgeRule");
    return return_tuple;
}

static PyObject*
ITemporalObservationsTable2Method_PruneTable(PyITemporalObservationsTable2Object* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pITemporalObservationsTable2->PruneTable();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalObservationsTable2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalObservationsTable2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalObservationsTable2.PruneTable() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}

static PyObject*
ITemporalObservationsTable2Method_QueryTemporalExtent(PyITemporalObservationsTable2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT vpvarStartTime;
    ::VariantInit(&vpvarStartTime);
    PyObject* pyvar_pvarStartTime = NULL;
    VARIANT vpvarEndTime;
    ::VariantInit(&vpvarEndTime);
    PyObject* pyvar_pvarEndTime = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pvarStartTime
    // No setup for pvarEndTime

    // Call method on actual COM interface
    hr = self->m_pITemporalObservationsTable2->QueryTemporalExtent(&vpvarStartTime, &vpvarEndTime);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalObservationsTable2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalObservationsTable2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalObservationsTable2.QueryTemporalExtent() returned %ld", (long)hr);
        goto itemporalobservationstable2_querytemporalextent_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pvarStartTime = Variant_AsPyObject(&vpvarStartTime);
    if (PyErr_Occurred())
      goto itemporalobservationstable2_querytemporalextent_method_cleanup;
    
    pyvar_pvarEndTime = Variant_AsPyObject(&vpvarEndTime);
    if (PyErr_Occurred())
      goto itemporalobservationstable2_querytemporalextent_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("OO",
                                            pyvar_pvarStartTime, pyvar_pvarEndTime);
    goto itemporalobservationstable2_querytemporalextent_method_cleanup;

    itemporalobservationstable2_querytemporalextent_method_cleanup:
    self->m_HR = hr;
    ::VariantClear(&vpvarStartTime);
    Py_XDECREF(pyvar_pvarStartTime);
    ::VariantClear(&vpvarEndTime);
    Py_XDECREF(pyvar_pvarEndTime);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalObservationsTable2.QueryTemporalExtent");
    return return_tuple;
}

static PyObject*
ITemporalObservationsTable2Method_FindField(PyITemporalObservationsTable2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName = 0;
    PyObject* pyvar_Name;
    PyObject* unicodeName = NULL;
    long lFieldIndex = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_Name))
      goto itemporalobservationstable2_findfield_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_Name))
        unicodeName = PyUnicode_FromObject(pyvar_Name);
    else if (PyUnicode_Check(pyvar_Name))
    {
        unicodeName = pyvar_Name;
        Py_INCREF(unicodeName);
    }
    else if (pyvar_Name != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Name at index 0");
    if (unicodeName)
        bsName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeName));
    
    if (PyErr_Occurred())
      goto itemporalobservationstable2_findfield_method_cleanup;
    
    // No setup for FieldIndex

    // Call method on actual COM interface
    hr = self->m_pITemporalObservationsTable2->FindField(bsName, &lFieldIndex);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalObservationsTable2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalObservationsTable2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalObservationsTable2.FindField() returned %ld", (long)hr);
        goto itemporalobservationstable2_findfield_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Name
    // No teardown for FieldIndex

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lFieldIndex);
    goto itemporalobservationstable2_findfield_method_cleanup;

    itemporalobservationstable2_findfield_method_cleanup:
    self->m_HR = hr;
    if (bsName)
        ::SysFreeString(bsName);
    
    // No cleanup for FieldIndex
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalObservationsTable2.FindField");
    return return_tuple;
}

static PyObject*
ITemporalObservationsTable2Method_get_Fields(PyITemporalObservationsTable2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IFields* ipFields = NULL;
    PyObject* py_Fields = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Fields

    // Call method on actual COM interface
    hr = self->m_pITemporalObservationsTable2->get_Fields(&ipFields);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalObservationsTable2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalObservationsTable2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalObservationsTable2.get_Fields() returned %ld", (long)hr);
        goto itemporalobservationstable2_get_fields_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_Fields);
    if (ipFields)
    {
        IUnknown* pUnk = NULL;
        ipFields->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_Fields = IUnknownToPythonIIDObject(pUnk, &IID_IFields);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_Fields)
    {
        if (py_Fields)
           Py_DECREF(py_Fields);
        py_Fields = Py_None;
        Py_INCREF(py_Fields);
    }
    if (PyErr_Occurred())
      goto itemporalobservationstable2_get_fields_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_Fields);
    goto itemporalobservationstable2_get_fields_method_cleanup;

    itemporalobservationstable2_get_fields_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_Fields);
    if (ipFields)
      ipFields->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalObservationsTable2.get_Fields");
    return return_tuple;
}

static PyObject*
ITemporalObservationsTable2Method_AddField(PyITemporalObservationsTable2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IField* ipField = NULL;
    PyObject* py_Field;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_Field))
      goto itemporalobservationstable2_addfield_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_Field, &IID_IField, (void**)&ipField))
        PyErr_SetString(PyExc_TypeError, "Argument Field (position 0) is not IField");
    
    if (PyErr_Occurred())
      goto itemporalobservationstable2_addfield_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITemporalObservationsTable2->AddField(ipField);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalObservationsTable2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalObservationsTable2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalObservationsTable2.AddField() returned %ld", (long)hr);
        goto itemporalobservationstable2_addfield_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Field

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto itemporalobservationstable2_addfield_method_cleanup;

    itemporalobservationstable2_addfield_method_cleanup:
    self->m_HR = hr;
    if (ipField)
      ipField->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalObservationsTable2.AddField");
    return return_tuple;
}

static PyObject*
ITemporalObservationsTable2Method_DeleteField(PyITemporalObservationsTable2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IField* ipField = NULL;
    PyObject* py_Field;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_Field))
      goto itemporalobservationstable2_deletefield_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_Field, &IID_IField, (void**)&ipField))
        PyErr_SetString(PyExc_TypeError, "Argument Field (position 0) is not IField");
    
    if (PyErr_Occurred())
      goto itemporalobservationstable2_deletefield_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITemporalObservationsTable2->DeleteField(ipField);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalObservationsTable2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalObservationsTable2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalObservationsTable2.DeleteField() returned %ld", (long)hr);
        goto itemporalobservationstable2_deletefield_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Field

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto itemporalobservationstable2_deletefield_method_cleanup;

    itemporalobservationstable2_deletefield_method_cleanup:
    self->m_HR = hr;
    if (ipField)
      ipField->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalObservationsTable2.DeleteField");
    return return_tuple;
}

static PyObject*
ITemporalObservationsTable2Method_CreateRow(PyITemporalObservationsTable2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IRow* ipRow = NULL;
    PyObject* py_Row = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Row

    // Call method on actual COM interface
    hr = self->m_pITemporalObservationsTable2->CreateRow(&ipRow);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalObservationsTable2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalObservationsTable2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalObservationsTable2.CreateRow() returned %ld", (long)hr);
        goto itemporalobservationstable2_createrow_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_Row);
    if (ipRow)
    {
        IUnknown* pUnk = NULL;
        ipRow->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_Row = IUnknownToPythonIIDObject(pUnk, &IID_IRow);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_Row)
    {
        if (py_Row)
           Py_DECREF(py_Row);
        py_Row = Py_None;
        Py_INCREF(py_Row);
    }
    if (PyErr_Occurred())
      goto itemporalobservationstable2_createrow_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_Row);
    goto itemporalobservationstable2_createrow_method_cleanup;

    itemporalobservationstable2_createrow_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_Row);
    if (ipRow)
      ipRow->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalObservationsTable2.CreateRow");
    return return_tuple;
}

static PyObject*
ITemporalObservationsTable2Method_GetRow(PyITemporalObservationsTable2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lOID = 0;
    IRow* ipRow = NULL;
    PyObject* py_Row = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lOID))
      goto itemporalobservationstable2_getrow_method_cleanup;

    // Set up initial variable values as needed
    // No setup for OID
    // No setup for Row

    // Call method on actual COM interface
    hr = self->m_pITemporalObservationsTable2->GetRow(lOID, &ipRow);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalObservationsTable2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalObservationsTable2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalObservationsTable2.GetRow() returned %ld", (long)hr);
        goto itemporalobservationstable2_getrow_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for OID
    Py_XDECREF(py_Row);
    if (ipRow)
    {
        IUnknown* pUnk = NULL;
        ipRow->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_Row = IUnknownToPythonIIDObject(pUnk, &IID_IRow);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_Row)
    {
        if (py_Row)
           Py_DECREF(py_Row);
        py_Row = Py_None;
        Py_INCREF(py_Row);
    }
    if (PyErr_Occurred())
      goto itemporalobservationstable2_getrow_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_Row);
    goto itemporalobservationstable2_getrow_method_cleanup;

    itemporalobservationstable2_getrow_method_cleanup:
    self->m_HR = hr;
    // No cleanup for OID
    Py_XDECREF(py_Row);
    if (ipRow)
      ipRow->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalObservationsTable2.GetRow");
    return return_tuple;
}

static PyObject*
ITemporalObservationsTable2Method_CreateRowBuffer(PyITemporalObservationsTable2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IRowBuffer* ipBuffer = NULL;
    PyObject* py_Buffer = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Buffer

    // Call method on actual COM interface
    hr = self->m_pITemporalObservationsTable2->CreateRowBuffer(&ipBuffer);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalObservationsTable2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalObservationsTable2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalObservationsTable2.CreateRowBuffer() returned %ld", (long)hr);
        goto itemporalobservationstable2_createrowbuffer_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_Buffer);
    if (ipBuffer)
    {
        IUnknown* pUnk = NULL;
        ipBuffer->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_Buffer = IUnknownToPythonIIDObject(pUnk, &IID_IRowBuffer);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_Buffer)
    {
        if (py_Buffer)
           Py_DECREF(py_Buffer);
        py_Buffer = Py_None;
        Py_INCREF(py_Buffer);
    }
    if (PyErr_Occurred())
      goto itemporalobservationstable2_createrowbuffer_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_Buffer);
    goto itemporalobservationstable2_createrowbuffer_method_cleanup;

    itemporalobservationstable2_createrowbuffer_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_Buffer);
    if (ipBuffer)
      ipBuffer->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalObservationsTable2.CreateRowBuffer");
    return return_tuple;
}

static PyObject*
ITemporalObservationsTable2Method_RowCount(PyITemporalObservationsTable2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IQueryFilter* ipQueryFilter = NULL;
    PyObject* py_QueryFilter;
    long lNumRows = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_QueryFilter))
      goto itemporalobservationstable2_rowcount_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_QueryFilter, &IID_IQueryFilter, (void**)&ipQueryFilter))
        PyErr_SetString(PyExc_TypeError, "Argument QueryFilter (position 0) is not IQueryFilter");
    
    if (PyErr_Occurred())
      goto itemporalobservationstable2_rowcount_method_cleanup;
    
    // No setup for NumRows

    // Call method on actual COM interface
    hr = self->m_pITemporalObservationsTable2->RowCount(ipQueryFilter, &lNumRows);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalObservationsTable2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalObservationsTable2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalObservationsTable2.RowCount() returned %ld", (long)hr);
        goto itemporalobservationstable2_rowcount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for QueryFilter
    // No teardown for NumRows

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lNumRows);
    goto itemporalobservationstable2_rowcount_method_cleanup;

    itemporalobservationstable2_rowcount_method_cleanup:
    self->m_HR = hr;
    if (ipQueryFilter)
      ipQueryFilter->Release();
    // No cleanup for NumRows
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalObservationsTable2.RowCount");
    return return_tuple;
}

static PyObject*
ITemporalObservationsTable2Method_Search(PyITemporalObservationsTable2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IQueryFilter* ipQueryFilter = NULL;
    PyObject* py_QueryFilter;
    VARIANT_BOOL b_Recycling = VARIANT_FALSE;
    PyObject* pyvar_Recycling = NULL;
    ICursor* ipCursor = NULL;
    PyObject* py_Cursor = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OO", &py_QueryFilter, &pyvar_Recycling))
      goto itemporalobservationstable2_search_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_QueryFilter, &IID_IQueryFilter, (void**)&ipQueryFilter))
        PyErr_SetString(PyExc_TypeError, "Argument QueryFilter (position 0) is not IQueryFilter");
    
    if (PyErr_Occurred())
      goto itemporalobservationstable2_search_method_cleanup;
    
    b_Recycling = ((PyObject_IsTrue(pyvar_Recycling) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto itemporalobservationstable2_search_method_cleanup;
    
    // No setup for Cursor

    // Call method on actual COM interface
    hr = self->m_pITemporalObservationsTable2->Search(ipQueryFilter, b_Recycling, &ipCursor);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalObservationsTable2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalObservationsTable2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalObservationsTable2.Search() returned %ld", (long)hr);
        goto itemporalobservationstable2_search_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for QueryFilter
    // No teardown for Recycling
    Py_XDECREF(py_Cursor);
    if (ipCursor)
    {
        IUnknown* pUnk = NULL;
        ipCursor->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_Cursor = IUnknownToPythonIIDObject(pUnk, &IID_ICursor);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_Cursor)
    {
        if (py_Cursor)
           Py_DECREF(py_Cursor);
        py_Cursor = Py_None;
        Py_INCREF(py_Cursor);
    }
    if (PyErr_Occurred())
      goto itemporalobservationstable2_search_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_Cursor);
    goto itemporalobservationstable2_search_method_cleanup;

    itemporalobservationstable2_search_method_cleanup:
    self->m_HR = hr;
    if (ipQueryFilter)
      ipQueryFilter->Release();
    // No cleanup for Recycling
    Py_XDECREF(py_Cursor);
    if (ipCursor)
      ipCursor->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalObservationsTable2.Search");
    return return_tuple;
}

static PyObject*
ITemporalObservationsTable2Method_Update(PyITemporalObservationsTable2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IQueryFilter* ipQueryFilter = NULL;
    PyObject* py_QueryFilter;
    VARIANT_BOOL b_Recycling = VARIANT_FALSE;
    PyObject* pyvar_Recycling = NULL;
    ICursor* ipCursor = NULL;
    PyObject* py_Cursor = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OO", &py_QueryFilter, &pyvar_Recycling))
      goto itemporalobservationstable2_update_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_QueryFilter, &IID_IQueryFilter, (void**)&ipQueryFilter))
        PyErr_SetString(PyExc_TypeError, "Argument QueryFilter (position 0) is not IQueryFilter");
    
    if (PyErr_Occurred())
      goto itemporalobservationstable2_update_method_cleanup;
    
    b_Recycling = ((PyObject_IsTrue(pyvar_Recycling) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto itemporalobservationstable2_update_method_cleanup;
    
    // No setup for Cursor

    // Call method on actual COM interface
    hr = self->m_pITemporalObservationsTable2->Update(ipQueryFilter, b_Recycling, &ipCursor);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalObservationsTable2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalObservationsTable2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalObservationsTable2.Update() returned %ld", (long)hr);
        goto itemporalobservationstable2_update_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for QueryFilter
    // No teardown for Recycling
    Py_XDECREF(py_Cursor);
    if (ipCursor)
    {
        IUnknown* pUnk = NULL;
        ipCursor->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_Cursor = IUnknownToPythonIIDObject(pUnk, &IID_ICursor);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_Cursor)
    {
        if (py_Cursor)
           Py_DECREF(py_Cursor);
        py_Cursor = Py_None;
        Py_INCREF(py_Cursor);
    }
    if (PyErr_Occurred())
      goto itemporalobservationstable2_update_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_Cursor);
    goto itemporalobservationstable2_update_method_cleanup;

    itemporalobservationstable2_update_method_cleanup:
    self->m_HR = hr;
    if (ipQueryFilter)
      ipQueryFilter->Release();
    // No cleanup for Recycling
    Py_XDECREF(py_Cursor);
    if (ipCursor)
      ipCursor->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalObservationsTable2.Update");
    return return_tuple;
}

static PyObject*
ITemporalObservationsTable2Method_Insert(PyITemporalObservationsTable2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_useBuffering = VARIANT_FALSE;
    PyObject* pyvar_useBuffering = NULL;
    ICursor* ipCursor = NULL;
    PyObject* py_Cursor = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_useBuffering))
      goto itemporalobservationstable2_insert_method_cleanup;

    // Set up initial variable values as needed
    b_useBuffering = ((PyObject_IsTrue(pyvar_useBuffering) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto itemporalobservationstable2_insert_method_cleanup;
    
    // No setup for Cursor

    // Call method on actual COM interface
    hr = self->m_pITemporalObservationsTable2->Insert(b_useBuffering, &ipCursor);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalObservationsTable2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalObservationsTable2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalObservationsTable2.Insert() returned %ld", (long)hr);
        goto itemporalobservationstable2_insert_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for useBuffering
    Py_XDECREF(py_Cursor);
    if (ipCursor)
    {
        IUnknown* pUnk = NULL;
        ipCursor->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_Cursor = IUnknownToPythonIIDObject(pUnk, &IID_ICursor);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_Cursor)
    {
        if (py_Cursor)
           Py_DECREF(py_Cursor);
        py_Cursor = Py_None;
        Py_INCREF(py_Cursor);
    }
    if (PyErr_Occurred())
      goto itemporalobservationstable2_insert_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_Cursor);
    goto itemporalobservationstable2_insert_method_cleanup;

    itemporalobservationstable2_insert_method_cleanup:
    self->m_HR = hr;
    // No cleanup for useBuffering
    Py_XDECREF(py_Cursor);
    if (ipCursor)
      ipCursor->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalObservationsTable2.Insert");
    return return_tuple;
}

static PyObject*
ITemporalObservationsTable2Method_Select(PyITemporalObservationsTable2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IQueryFilter* ipQueryFilter = NULL;
    PyObject* py_QueryFilter;
    esriSelectionType eselType;
    esriSelectionOption eselOption;
    IWorkspace* ipselectionContainer = NULL;
    PyObject* py_selectionContainer;
    ISelectionSet* ipppSelectionSet = NULL;
    PyObject* py_ppSelectionSet = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OiiO", &py_QueryFilter, (int *)&eselType, (int *)&eselOption, &py_selectionContainer))
      goto itemporalobservationstable2_select_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_QueryFilter, &IID_IQueryFilter, (void**)&ipQueryFilter))
        PyErr_SetString(PyExc_TypeError, "Argument QueryFilter (position 0) is not IQueryFilter");
    
    if (PyErr_Occurred())
      goto itemporalobservationstable2_select_method_cleanup;
    
    // No setup for selType
    // No setup for selOption
    if (!IFaceFromPyObject(py_selectionContainer, &IID_IWorkspace, (void**)&ipselectionContainer))
        PyErr_SetString(PyExc_TypeError, "Argument selectionContainer (position 3) is not IWorkspace");
    
    if (PyErr_Occurred())
      goto itemporalobservationstable2_select_method_cleanup;
    
    // No setup for ppSelectionSet

    // Call method on actual COM interface
    hr = self->m_pITemporalObservationsTable2->Select(ipQueryFilter, eselType, eselOption, ipselectionContainer, &ipppSelectionSet);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalObservationsTable2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalObservationsTable2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalObservationsTable2.Select() returned %ld", (long)hr);
        goto itemporalobservationstable2_select_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for QueryFilter
    // No teardown for selType
    // No teardown for selOption
    // No teardown for selectionContainer
    Py_XDECREF(py_ppSelectionSet);
    if (ipppSelectionSet)
    {
        IUnknown* pUnk = NULL;
        ipppSelectionSet->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppSelectionSet = IUnknownToPythonIIDObject(pUnk, &IID_ISelectionSet);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppSelectionSet)
    {
        if (py_ppSelectionSet)
           Py_DECREF(py_ppSelectionSet);
        py_ppSelectionSet = Py_None;
        Py_INCREF(py_ppSelectionSet);
    }
    if (PyErr_Occurred())
      goto itemporalobservationstable2_select_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppSelectionSet);
    goto itemporalobservationstable2_select_method_cleanup;

    itemporalobservationstable2_select_method_cleanup:
    self->m_HR = hr;
    if (ipQueryFilter)
      ipQueryFilter->Release();
    // No cleanup for selType
    // No cleanup for selOption
    if (ipselectionContainer)
      ipselectionContainer->Release();
    Py_XDECREF(py_ppSelectionSet);
    if (ipppSelectionSet)
      ipppSelectionSet->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalObservationsTable2.Select");
    return return_tuple;
}

static PyObject*
ITemporalObservationsTable2Method_get_HasGeometry(PyITemporalObservationsTable2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pVal = VARIANT_FALSE;
    PyObject* pyvar_pVal = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pITemporalObservationsTable2->get_HasGeometry(&b_pVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalObservationsTable2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalObservationsTable2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalObservationsTable2.get_HasGeometry() returned %ld", (long)hr);
        goto itemporalobservationstable2_get_hasgeometry_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pVal = ((b_pVal == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto itemporalobservationstable2_get_hasgeometry_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pVal);
    goto itemporalobservationstable2_get_hasgeometry_method_cleanup;

    itemporalobservationstable2_get_hasgeometry_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalObservationsTable2.get_HasGeometry");
    return return_tuple;
}

static PyObject*
ITemporalObservationsTable2Method_get_GeometryColumnName(PyITemporalObservationsTable2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspbstrColumnName;
    PyObject* pyvar_pbstrColumnName = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pbstrColumnName

    // Call method on actual COM interface
    hr = self->m_pITemporalObservationsTable2->get_GeometryColumnName(&bspbstrColumnName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalObservationsTable2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalObservationsTable2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalObservationsTable2.get_GeometryColumnName() returned %ld", (long)hr);
        goto itemporalobservationstable2_get_geometrycolumnname_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pbstrColumnName = PyUnicode_FromWideChar(bspbstrColumnName,::SysStringLen(bspbstrColumnName));
    ::SysFreeString(bspbstrColumnName);
    
    if (PyErr_Occurred())
      goto itemporalobservationstable2_get_geometrycolumnname_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pbstrColumnName);
    goto itemporalobservationstable2_get_geometrycolumnname_method_cleanup;

    itemporalobservationstable2_get_geometrycolumnname_method_cleanup:
    self->m_HR = hr;
    if (pyvar_pbstrColumnName != Py_None)
        Py_XDECREF(pyvar_pbstrColumnName);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalObservationsTable2.get_GeometryColumnName");
    return return_tuple;
}

static PyObject*
ITemporalObservationsTable2Method_put_GeometryColumnName(PyITemporalObservationsTable2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspbstrColumnName = 0;
    PyObject* pyvar_pbstrColumnName;
    PyObject* unicodepbstrColumnName = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pbstrColumnName))
      goto itemporalobservationstable2_put_geometrycolumnname_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_pbstrColumnName))
        unicodepbstrColumnName = PyUnicode_FromObject(pyvar_pbstrColumnName);
    else if (PyUnicode_Check(pyvar_pbstrColumnName))
    {
        unicodepbstrColumnName = pyvar_pbstrColumnName;
        Py_INCREF(unicodepbstrColumnName);
    }
    else if (pyvar_pbstrColumnName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter pbstrColumnName at index 0");
    if (unicodepbstrColumnName)
        bspbstrColumnName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodepbstrColumnName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodepbstrColumnName));
    
    if (PyErr_Occurred())
      goto itemporalobservationstable2_put_geometrycolumnname_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITemporalObservationsTable2->put_GeometryColumnName(bspbstrColumnName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalObservationsTable2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalObservationsTable2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalObservationsTable2.put_GeometryColumnName() returned %ld", (long)hr);
        goto itemporalobservationstable2_put_geometrycolumnname_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pbstrColumnName

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto itemporalobservationstable2_put_geometrycolumnname_method_cleanup;

    itemporalobservationstable2_put_geometrycolumnname_method_cleanup:
    self->m_HR = hr;
    if (bspbstrColumnName)
        ::SysFreeString(bspbstrColumnName);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalObservationsTable2.put_GeometryColumnName");
    return return_tuple;
}


PyMethodDef PyITemporalObservationsTable2Methods[] = {
    {"supports", (PyCFunction)PyITemporalObservationsTable2_SupportsInterface, METH_O, ""},
    {"put_TrackingColumnIndex", (PyCFunction)ITemporalObservationsTable2Method_put_TrackingColumnIndex, METH_VARARGS, ""},
    {"get_AutoPurge", (PyCFunction)ITemporalObservationsTable2Method_get_AutoPurge, METH_VARARGS, ""},
    {"put_AutoPurge", (PyCFunction)ITemporalObservationsTable2Method_put_AutoPurge, METH_VARARGS, ""},
    {"get_Threshold", (PyCFunction)ITemporalObservationsTable2Method_get_Threshold, METH_VARARGS, ""},
    {"put_Threshold", (PyCFunction)ITemporalObservationsTable2Method_put_Threshold, METH_VARARGS, ""},
    {"get_PurgePercentage", (PyCFunction)ITemporalObservationsTable2Method_get_PurgePercentage, METH_VARARGS, ""},
    {"put_PurgePercentage", (PyCFunction)ITemporalObservationsTable2Method_put_PurgePercentage, METH_VARARGS, ""},
    {"get_Persistant", (PyCFunction)ITemporalObservationsTable2Method_get_Persistant, METH_VARARGS, ""},
    {"put_Persistant", (PyCFunction)ITemporalObservationsTable2Method_put_Persistant, METH_VARARGS, ""},
    {"get_TemporalColumnName", (PyCFunction)ITemporalObservationsTable2Method_get_TemporalColumnName, METH_VARARGS, ""},
    {"put_TemporalColumnName", (PyCFunction)ITemporalObservationsTable2Method_put_TemporalColumnName, METH_VARARGS, ""},
    {"get_PurgeRule", (PyCFunction)ITemporalObservationsTable2Method_get_PurgeRule, METH_VARARGS, ""},
    {"put_PurgeRule", (PyCFunction)ITemporalObservationsTable2Method_put_PurgeRule, METH_VARARGS, ""},
    {"PruneTable", (PyCFunction)ITemporalObservationsTable2Method_PruneTable, METH_NOARGS, ""},
    {"QueryTemporalExtent", (PyCFunction)ITemporalObservationsTable2Method_QueryTemporalExtent, METH_VARARGS, ""},
    {"FindField", (PyCFunction)ITemporalObservationsTable2Method_FindField, METH_VARARGS, ""},
    {"get_Fields", (PyCFunction)ITemporalObservationsTable2Method_get_Fields, METH_VARARGS, ""},
    {"AddField", (PyCFunction)ITemporalObservationsTable2Method_AddField, METH_VARARGS, ""},
    {"DeleteField", (PyCFunction)ITemporalObservationsTable2Method_DeleteField, METH_VARARGS, ""},
    {"CreateRow", (PyCFunction)ITemporalObservationsTable2Method_CreateRow, METH_VARARGS, ""},
    {"GetRow", (PyCFunction)ITemporalObservationsTable2Method_GetRow, METH_VARARGS, ""},
    {"CreateRowBuffer", (PyCFunction)ITemporalObservationsTable2Method_CreateRowBuffer, METH_VARARGS, ""},
    {"RowCount", (PyCFunction)ITemporalObservationsTable2Method_RowCount, METH_VARARGS, ""},
    {"Search", (PyCFunction)ITemporalObservationsTable2Method_Search, METH_VARARGS, ""},
    {"Update", (PyCFunction)ITemporalObservationsTable2Method_Update, METH_VARARGS, ""},
    {"Insert", (PyCFunction)ITemporalObservationsTable2Method_Insert, METH_VARARGS, ""},
    {"Select", (PyCFunction)ITemporalObservationsTable2Method_Select, METH_VARARGS, ""},
    {"get_HasGeometry", (PyCFunction)ITemporalObservationsTable2Method_get_HasGeometry, METH_VARARGS, ""},
    {"get_GeometryColumnName", (PyCFunction)ITemporalObservationsTable2Method_get_GeometryColumnName, METH_VARARGS, ""},
    {"put_GeometryColumnName", (PyCFunction)ITemporalObservationsTable2Method_put_GeometryColumnName, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyITemporalObservationsTable2GetSet[] = {
  {"_pUnk", (getter)PyITemporalObservationsTable2_GetpUnk, NULL, "Get opaque pointer to an Unknown from ITemporalObservationsTable2", NULL},
  {"_pointer", (getter)PyITemporalObservationsTable2_GetPointer, NULL, "Get memory address for ITemporalObservationsTable2", NULL},
  {"_IID", (getter)PyITemporalObservationsTable2_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyITemporalObservationsTable2_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyITemporalObservationsTable2_GetIgnoreFailures, (setter)PyITemporalObservationsTable2_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyITemporalObservationsTable2Object_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.ITemporalObservationsTable2Object",                          
                                              /* tp_name */
  sizeof(PyITemporalObservationsTable2Object),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyITemporalObservationsTable2Object_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyITemporalObservationsTable2Methods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyITemporalObservationsTable2GetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyITemporalObservationsTable2Object_new,                      
                                              /* tp_new */
};

// Interface IExcludedEventIDs

typedef struct PyIExcludedEventIDsObject {
    PyObject_HEAD
    IExcludedEventIDs* m_pIExcludedEventIDs;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIExcludedEventIDsObject;

static PyObject*
PyIExcludedEventIDsObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIExcludedEventIDsObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IExcludedEventIDs* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IExcludedEventIDs, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IExcludedEventIDs with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIExcludedEventIDsObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IExcludedEventIDs");
            return NULL;
        }
        self->m_pIExcludedEventIDs = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IExcludedEventIDs");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IExcludedEventIDs");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IExcludedEventIDs* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IExcludedEventIDs, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IExcludedEventIDs");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIExcludedEventIDsObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IExcludedEventIDs");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIExcludedEventIDs = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIExcludedEventIDsObject_dealloc(PyIExcludedEventIDsObject* self)
{
    if (self->m_pIExcludedEventIDs)
        self->m_pIExcludedEventIDs->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIExcludedEventIDs_GetpUnk(PyIExcludedEventIDsObject* self)
{
    if (!self->m_pIExcludedEventIDs)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIExcludedEventIDs->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IExcludedEventIDs to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIExcludedEventIDs_GetPointer(PyIExcludedEventIDsObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIExcludedEventIDs);
}

static PyObject*
PyIExcludedEventIDs_GetIID(PyIExcludedEventIDsObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "2eb7644e-63dd-4a25-9ef9-b794ec6bf691");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIExcludedEventIDs_GetHR(PyIExcludedEventIDsObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIExcludedEventIDs_GetIgnoreFailures(PyIExcludedEventIDsObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIExcludedEventIDs_SetIgnoreFailures(PyIExcludedEventIDsObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIExcludedEventIDs_SupportsInterface(PyIExcludedEventIDsObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIExcludedEventIDs->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IExcludedEventIDsMethod_get_ExcludedTrackingEventIDs(PyIExcludedEventIDsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IStringArray* ippVal = NULL;
    PyObject* py_pVal = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pIExcludedEventIDs->get_ExcludedTrackingEventIDs(&ippVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExcludedEventIDs->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExcludedEventIDs) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExcludedEventIDs.get_ExcludedTrackingEventIDs() returned %ld", (long)hr);
        goto iexcludedeventids_get_excludedtrackingeventids_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_pVal);
    if (ippVal)
    {
        IUnknown* pUnk = NULL;
        ippVal->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_pVal = IUnknownToPythonIIDObject(pUnk, &IID_IStringArray);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_pVal)
    {
        if (py_pVal)
           Py_DECREF(py_pVal);
        py_pVal = Py_None;
        Py_INCREF(py_pVal);
    }
    if (PyErr_Occurred())
      goto iexcludedeventids_get_excludedtrackingeventids_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_pVal);
    goto iexcludedeventids_get_excludedtrackingeventids_method_cleanup;

    iexcludedeventids_get_excludedtrackingeventids_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_pVal);
    if (ippVal)
      ippVal->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExcludedEventIDs.get_ExcludedTrackingEventIDs");
    return return_tuple;
}

static PyObject*
IExcludedEventIDsMethod_put_ExcludedTrackingEventIDs(PyIExcludedEventIDsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IStringArray* ippVal = NULL;
    PyObject* py_pVal;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_pVal))
      goto iexcludedeventids_put_excludedtrackingeventids_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pVal, &IID_IStringArray, (void**)&ippVal))
        PyErr_SetString(PyExc_TypeError, "Argument pVal (position 0) is not IStringArray");
    
    if (PyErr_Occurred())
      goto iexcludedeventids_put_excludedtrackingeventids_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIExcludedEventIDs->put_ExcludedTrackingEventIDs(ippVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIExcludedEventIDs->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IExcludedEventIDs) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IExcludedEventIDs.put_ExcludedTrackingEventIDs() returned %ld", (long)hr);
        goto iexcludedeventids_put_excludedtrackingeventids_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iexcludedeventids_put_excludedtrackingeventids_method_cleanup;

    iexcludedeventids_put_excludedtrackingeventids_method_cleanup:
    self->m_HR = hr;
    if (ippVal)
      ippVal->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IExcludedEventIDs.put_ExcludedTrackingEventIDs");
    return return_tuple;
}


PyMethodDef PyIExcludedEventIDsMethods[] = {
    {"supports", (PyCFunction)PyIExcludedEventIDs_SupportsInterface, METH_O, ""},
    {"get_ExcludedTrackingEventIDs", (PyCFunction)IExcludedEventIDsMethod_get_ExcludedTrackingEventIDs, METH_VARARGS, ""},
    {"put_ExcludedTrackingEventIDs", (PyCFunction)IExcludedEventIDsMethod_put_ExcludedTrackingEventIDs, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIExcludedEventIDsGetSet[] = {
  {"_pUnk", (getter)PyIExcludedEventIDs_GetpUnk, NULL, "Get opaque pointer to an Unknown from IExcludedEventIDs", NULL},
  {"_pointer", (getter)PyIExcludedEventIDs_GetPointer, NULL, "Get memory address for IExcludedEventIDs", NULL},
  {"_IID", (getter)PyIExcludedEventIDs_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIExcludedEventIDs_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIExcludedEventIDs_GetIgnoreFailures, (setter)PyIExcludedEventIDs_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIExcludedEventIDsObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.IExcludedEventIDsObject",                          
                                              /* tp_name */
  sizeof(PyIExcludedEventIDsObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIExcludedEventIDsObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIExcludedEventIDsMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIExcludedEventIDsGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIExcludedEventIDsObject_new,                      
                                              /* tp_new */
};

// Interface ITemporalQueryFilter

typedef struct PyITemporalQueryFilterObject {
    PyObject_HEAD
    ITemporalQueryFilter* m_pITemporalQueryFilter;
    HRESULT m_HR;
    int m_ignore_failures;
} PyITemporalQueryFilterObject;

static PyObject*
PyITemporalQueryFilterObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyITemporalQueryFilterObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ITemporalQueryFilter* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ITemporalQueryFilter, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ITemporalQueryFilter with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyITemporalQueryFilterObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ITemporalQueryFilter");
            return NULL;
        }
        self->m_pITemporalQueryFilter = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ITemporalQueryFilter");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ITemporalQueryFilter");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ITemporalQueryFilter* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ITemporalQueryFilter, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ITemporalQueryFilter");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyITemporalQueryFilterObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ITemporalQueryFilter");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pITemporalQueryFilter = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyITemporalQueryFilterObject_dealloc(PyITemporalQueryFilterObject* self)
{
    if (self->m_pITemporalQueryFilter)
        self->m_pITemporalQueryFilter->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyITemporalQueryFilter_GetpUnk(PyITemporalQueryFilterObject* self)
{
    if (!self->m_pITemporalQueryFilter)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pITemporalQueryFilter->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ITemporalQueryFilter to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyITemporalQueryFilter_GetPointer(PyITemporalQueryFilterObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pITemporalQueryFilter);
}

static PyObject*
PyITemporalQueryFilter_GetIID(PyITemporalQueryFilterObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "d0cee203-56da-11d5-ae49-00104ba2abcc");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyITemporalQueryFilter_GetHR(PyITemporalQueryFilterObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyITemporalQueryFilter_GetIgnoreFailures(PyITemporalQueryFilterObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyITemporalQueryFilter_SetIgnoreFailures(PyITemporalQueryFilterObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyITemporalQueryFilter_SupportsInterface(PyITemporalQueryFilterObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pITemporalQueryFilter->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ITemporalQueryFilterMethod_get_TemporalOrder(PyITemporalQueryFilterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    enumTemporalOrder epVal;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pITemporalQueryFilter->get_TemporalOrder(&epVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalQueryFilter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalQueryFilter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalQueryFilter.get_TemporalOrder() returned %ld", (long)hr);
        goto itemporalqueryfilter_get_temporalorder_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)epVal);
    goto itemporalqueryfilter_get_temporalorder_method_cleanup;

    itemporalqueryfilter_get_temporalorder_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalQueryFilter.get_TemporalOrder");
    return return_tuple;
}

static PyObject*
ITemporalQueryFilterMethod_put_TemporalOrder(PyITemporalQueryFilterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    enumTemporalOrder epVal;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&epVal))
      goto itemporalqueryfilter_put_temporalorder_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pITemporalQueryFilter->put_TemporalOrder(epVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalQueryFilter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalQueryFilter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalQueryFilter.put_TemporalOrder() returned %ld", (long)hr);
        goto itemporalqueryfilter_put_temporalorder_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto itemporalqueryfilter_put_temporalorder_method_cleanup;

    itemporalqueryfilter_put_temporalorder_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalQueryFilter.put_TemporalOrder");
    return return_tuple;
}

static PyObject*
ITemporalQueryFilterMethod_get_TemporalRelationship(PyITemporalQueryFilterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    enumTemporalRelation epVal;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pITemporalQueryFilter->get_TemporalRelationship(&epVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalQueryFilter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalQueryFilter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalQueryFilter.get_TemporalRelationship() returned %ld", (long)hr);
        goto itemporalqueryfilter_get_temporalrelationship_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)epVal);
    goto itemporalqueryfilter_get_temporalrelationship_method_cleanup;

    itemporalqueryfilter_get_temporalrelationship_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalQueryFilter.get_TemporalRelationship");
    return return_tuple;
}

static PyObject*
ITemporalQueryFilterMethod_put_TemporalRelationship(PyITemporalQueryFilterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    enumTemporalRelation epVal;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&epVal))
      goto itemporalqueryfilter_put_temporalrelationship_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pITemporalQueryFilter->put_TemporalRelationship(epVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalQueryFilter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalQueryFilter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalQueryFilter.put_TemporalRelationship() returned %ld", (long)hr);
        goto itemporalqueryfilter_put_temporalrelationship_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto itemporalqueryfilter_put_temporalrelationship_method_cleanup;

    itemporalqueryfilter_put_temporalrelationship_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalQueryFilter.put_TemporalRelationship");
    return return_tuple;
}

static PyObject*
ITemporalQueryFilterMethod_get_StartingDate(PyITemporalQueryFilterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT vpVal;
    ::VariantInit(&vpVal);
    PyObject* pyvar_pVal = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pITemporalQueryFilter->get_StartingDate(&vpVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalQueryFilter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalQueryFilter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalQueryFilter.get_StartingDate() returned %ld", (long)hr);
        goto itemporalqueryfilter_get_startingdate_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pVal = Variant_AsPyObject(&vpVal);
    if (PyErr_Occurred())
      goto itemporalqueryfilter_get_startingdate_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pVal);
    goto itemporalqueryfilter_get_startingdate_method_cleanup;

    itemporalqueryfilter_get_startingdate_method_cleanup:
    self->m_HR = hr;
    ::VariantClear(&vpVal);
    Py_XDECREF(pyvar_pVal);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalQueryFilter.get_StartingDate");
    return return_tuple;
}

static PyObject*
ITemporalQueryFilterMethod_put_StartingDate(PyITemporalQueryFilterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT vpVal;
    ::VariantInit(&vpVal);
    PyObject* pyvar_pVal = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pVal))
      goto itemporalqueryfilter_put_startingdate_method_cleanup;

    // Set up initial variable values as needed
    PyObject_AsVariant(pyvar_pVal, &vpVal);
    
    if (PyErr_Occurred())
      goto itemporalqueryfilter_put_startingdate_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITemporalQueryFilter->put_StartingDate(vpVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalQueryFilter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalQueryFilter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalQueryFilter.put_StartingDate() returned %ld", (long)hr);
        goto itemporalqueryfilter_put_startingdate_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto itemporalqueryfilter_put_startingdate_method_cleanup;

    itemporalqueryfilter_put_startingdate_method_cleanup:
    self->m_HR = hr;
    ::VariantClear(&vpVal);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalQueryFilter.put_StartingDate");
    return return_tuple;
}

static PyObject*
ITemporalQueryFilterMethod_get_EndingDate(PyITemporalQueryFilterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT vpVal;
    ::VariantInit(&vpVal);
    PyObject* pyvar_pVal = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pITemporalQueryFilter->get_EndingDate(&vpVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalQueryFilter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalQueryFilter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalQueryFilter.get_EndingDate() returned %ld", (long)hr);
        goto itemporalqueryfilter_get_endingdate_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pVal = Variant_AsPyObject(&vpVal);
    if (PyErr_Occurred())
      goto itemporalqueryfilter_get_endingdate_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pVal);
    goto itemporalqueryfilter_get_endingdate_method_cleanup;

    itemporalqueryfilter_get_endingdate_method_cleanup:
    self->m_HR = hr;
    ::VariantClear(&vpVal);
    Py_XDECREF(pyvar_pVal);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalQueryFilter.get_EndingDate");
    return return_tuple;
}

static PyObject*
ITemporalQueryFilterMethod_put_EndingDate(PyITemporalQueryFilterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT vpVal;
    ::VariantInit(&vpVal);
    PyObject* pyvar_pVal = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pVal))
      goto itemporalqueryfilter_put_endingdate_method_cleanup;

    // Set up initial variable values as needed
    PyObject_AsVariant(pyvar_pVal, &vpVal);
    
    if (PyErr_Occurred())
      goto itemporalqueryfilter_put_endingdate_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITemporalQueryFilter->put_EndingDate(vpVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalQueryFilter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalQueryFilter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalQueryFilter.put_EndingDate() returned %ld", (long)hr);
        goto itemporalqueryfilter_put_endingdate_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto itemporalqueryfilter_put_endingdate_method_cleanup;

    itemporalqueryfilter_put_endingdate_method_cleanup:
    self->m_HR = hr;
    ::VariantClear(&vpVal);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalQueryFilter.put_EndingDate");
    return return_tuple;
}

static PyObject*
ITemporalQueryFilterMethod_get_TemporalConversion(PyITemporalQueryFilterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    enumTemporalConversion epVal;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pITemporalQueryFilter->get_TemporalConversion(&epVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalQueryFilter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalQueryFilter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalQueryFilter.get_TemporalConversion() returned %ld", (long)hr);
        goto itemporalqueryfilter_get_temporalconversion_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)epVal);
    goto itemporalqueryfilter_get_temporalconversion_method_cleanup;

    itemporalqueryfilter_get_temporalconversion_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalQueryFilter.get_TemporalConversion");
    return return_tuple;
}

static PyObject*
ITemporalQueryFilterMethod_put_TemporalConversion(PyITemporalQueryFilterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    enumTemporalConversion epVal;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&epVal))
      goto itemporalqueryfilter_put_temporalconversion_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pITemporalQueryFilter->put_TemporalConversion(epVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalQueryFilter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalQueryFilter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalQueryFilter.put_TemporalConversion() returned %ld", (long)hr);
        goto itemporalqueryfilter_put_temporalconversion_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto itemporalqueryfilter_put_temporalconversion_method_cleanup;

    itemporalqueryfilter_put_temporalconversion_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalQueryFilter.put_TemporalConversion");
    return return_tuple;
}

static PyObject*
ITemporalQueryFilterMethod_get_RelativeTimeOperator(PyITemporalQueryFilterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ITemporalOperator* ippVal = NULL;
    PyObject* py_pVal = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pITemporalQueryFilter->get_RelativeTimeOperator(&ippVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalQueryFilter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalQueryFilter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalQueryFilter.get_RelativeTimeOperator() returned %ld", (long)hr);
        goto itemporalqueryfilter_get_relativetimeoperator_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_pVal);
    if (ippVal)
    {
        IUnknown* pUnk = NULL;
        ippVal->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_pVal = IUnknownToPythonIIDObject(pUnk, &IID_ITemporalOperator);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_pVal)
    {
        if (py_pVal)
           Py_DECREF(py_pVal);
        py_pVal = Py_None;
        Py_INCREF(py_pVal);
    }
    if (PyErr_Occurred())
      goto itemporalqueryfilter_get_relativetimeoperator_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_pVal);
    goto itemporalqueryfilter_get_relativetimeoperator_method_cleanup;

    itemporalqueryfilter_get_relativetimeoperator_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_pVal);
    if (ippVal)
      ippVal->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalQueryFilter.get_RelativeTimeOperator");
    return return_tuple;
}

static PyObject*
ITemporalQueryFilterMethod_put_RelativeTimeOperator(PyITemporalQueryFilterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ITemporalOperator* ippVal = NULL;
    PyObject* py_pVal;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_pVal))
      goto itemporalqueryfilter_put_relativetimeoperator_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pVal, &IID_ITemporalOperator, (void**)&ippVal))
        PyErr_SetString(PyExc_TypeError, "Argument pVal (position 0) is not ITemporalOperator");
    
    if (PyErr_Occurred())
      goto itemporalqueryfilter_put_relativetimeoperator_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITemporalQueryFilter->put_RelativeTimeOperator(ippVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalQueryFilter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalQueryFilter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalQueryFilter.put_RelativeTimeOperator() returned %ld", (long)hr);
        goto itemporalqueryfilter_put_relativetimeoperator_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto itemporalqueryfilter_put_relativetimeoperator_method_cleanup;

    itemporalqueryfilter_put_relativetimeoperator_method_cleanup:
    self->m_HR = hr;
    if (ippVal)
      ippVal->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalQueryFilter.put_RelativeTimeOperator");
    return return_tuple;
}


PyMethodDef PyITemporalQueryFilterMethods[] = {
    {"supports", (PyCFunction)PyITemporalQueryFilter_SupportsInterface, METH_O, ""},
    {"get_TemporalOrder", (PyCFunction)ITemporalQueryFilterMethod_get_TemporalOrder, METH_VARARGS, ""},
    {"put_TemporalOrder", (PyCFunction)ITemporalQueryFilterMethod_put_TemporalOrder, METH_VARARGS, ""},
    {"get_TemporalRelationship", (PyCFunction)ITemporalQueryFilterMethod_get_TemporalRelationship, METH_VARARGS, ""},
    {"put_TemporalRelationship", (PyCFunction)ITemporalQueryFilterMethod_put_TemporalRelationship, METH_VARARGS, ""},
    {"get_StartingDate", (PyCFunction)ITemporalQueryFilterMethod_get_StartingDate, METH_VARARGS, ""},
    {"put_StartingDate", (PyCFunction)ITemporalQueryFilterMethod_put_StartingDate, METH_VARARGS, ""},
    {"get_EndingDate", (PyCFunction)ITemporalQueryFilterMethod_get_EndingDate, METH_VARARGS, ""},
    {"put_EndingDate", (PyCFunction)ITemporalQueryFilterMethod_put_EndingDate, METH_VARARGS, ""},
    {"get_TemporalConversion", (PyCFunction)ITemporalQueryFilterMethod_get_TemporalConversion, METH_VARARGS, ""},
    {"put_TemporalConversion", (PyCFunction)ITemporalQueryFilterMethod_put_TemporalConversion, METH_VARARGS, ""},
    {"get_RelativeTimeOperator", (PyCFunction)ITemporalQueryFilterMethod_get_RelativeTimeOperator, METH_VARARGS, ""},
    {"put_RelativeTimeOperator", (PyCFunction)ITemporalQueryFilterMethod_put_RelativeTimeOperator, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyITemporalQueryFilterGetSet[] = {
  {"_pUnk", (getter)PyITemporalQueryFilter_GetpUnk, NULL, "Get opaque pointer to an Unknown from ITemporalQueryFilter", NULL},
  {"_pointer", (getter)PyITemporalQueryFilter_GetPointer, NULL, "Get memory address for ITemporalQueryFilter", NULL},
  {"_IID", (getter)PyITemporalQueryFilter_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyITemporalQueryFilter_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyITemporalQueryFilter_GetIgnoreFailures, (setter)PyITemporalQueryFilter_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyITemporalQueryFilterObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.ITemporalQueryFilterObject",                          
                                              /* tp_name */
  sizeof(PyITemporalQueryFilterObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyITemporalQueryFilterObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyITemporalQueryFilterMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyITemporalQueryFilterGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyITemporalQueryFilterObject_new,                      
                                              /* tp_new */
};

// Interface ITemporalQueryFilter2

typedef struct PyITemporalQueryFilter2Object {
    PyObject_HEAD
    ITemporalQueryFilter2* m_pITemporalQueryFilter2;
    HRESULT m_HR;
    int m_ignore_failures;
} PyITemporalQueryFilter2Object;

static PyObject*
PyITemporalQueryFilter2Object_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyITemporalQueryFilter2Object* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ITemporalQueryFilter2* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ITemporalQueryFilter2, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ITemporalQueryFilter2 with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyITemporalQueryFilter2Object *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ITemporalQueryFilter2");
            return NULL;
        }
        self->m_pITemporalQueryFilter2 = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ITemporalQueryFilter2");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ITemporalQueryFilter2");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ITemporalQueryFilter2* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ITemporalQueryFilter2, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ITemporalQueryFilter2");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyITemporalQueryFilter2Object *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ITemporalQueryFilter2");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pITemporalQueryFilter2 = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyITemporalQueryFilter2Object_dealloc(PyITemporalQueryFilter2Object* self)
{
    if (self->m_pITemporalQueryFilter2)
        self->m_pITemporalQueryFilter2->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyITemporalQueryFilter2_GetpUnk(PyITemporalQueryFilter2Object* self)
{
    if (!self->m_pITemporalQueryFilter2)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pITemporalQueryFilter2->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ITemporalQueryFilter2 to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyITemporalQueryFilter2_GetPointer(PyITemporalQueryFilter2Object* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pITemporalQueryFilter2);
}

static PyObject*
PyITemporalQueryFilter2_GetIID(PyITemporalQueryFilter2Object* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "6d3465e9-f6f4-43d6-bba9-87eee56c146e");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyITemporalQueryFilter2_GetHR(PyITemporalQueryFilter2Object* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyITemporalQueryFilter2_GetIgnoreFailures(PyITemporalQueryFilter2Object* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyITemporalQueryFilter2_SetIgnoreFailures(PyITemporalQueryFilter2Object* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyITemporalQueryFilter2_SupportsInterface(PyITemporalQueryFilter2Object* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pITemporalQueryFilter2->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ITemporalQueryFilter2Method_get_TimeReference(PyITemporalQueryFilter2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ITimeReference* ipTimeReference = NULL;
    PyObject* py_TimeReference = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for TimeReference

    // Call method on actual COM interface
    hr = self->m_pITemporalQueryFilter2->get_TimeReference(&ipTimeReference);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalQueryFilter2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalQueryFilter2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalQueryFilter2.get_TimeReference() returned %ld", (long)hr);
        goto itemporalqueryfilter2_get_timereference_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_TimeReference);
    if (ipTimeReference)
    {
        IUnknown* pUnk = NULL;
        ipTimeReference->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_TimeReference = IUnknownToPythonIIDObject(pUnk, &IID_ITimeReference);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_TimeReference)
    {
        if (py_TimeReference)
           Py_DECREF(py_TimeReference);
        py_TimeReference = Py_None;
        Py_INCREF(py_TimeReference);
    }
    if (PyErr_Occurred())
      goto itemporalqueryfilter2_get_timereference_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_TimeReference);
    goto itemporalqueryfilter2_get_timereference_method_cleanup;

    itemporalqueryfilter2_get_timereference_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_TimeReference);
    if (ipTimeReference)
      ipTimeReference->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalQueryFilter2.get_TimeReference");
    return return_tuple;
}

static PyObject*
ITemporalQueryFilter2Method_putref_TimeReference(PyITemporalQueryFilter2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ITimeReference* ipTimeReference = NULL;
    PyObject* py_TimeReference;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_TimeReference))
      goto itemporalqueryfilter2_putref_timereference_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_TimeReference, &IID_ITimeReference, (void**)&ipTimeReference))
        PyErr_SetString(PyExc_TypeError, "Argument TimeReference (position 0) is not ITimeReference");
    
    if (PyErr_Occurred())
      goto itemporalqueryfilter2_putref_timereference_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITemporalQueryFilter2->putref_TimeReference(ipTimeReference);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalQueryFilter2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalQueryFilter2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalQueryFilter2.putref_TimeReference() returned %ld", (long)hr);
        goto itemporalqueryfilter2_putref_timereference_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for TimeReference

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto itemporalqueryfilter2_putref_timereference_method_cleanup;

    itemporalqueryfilter2_putref_timereference_method_cleanup:
    self->m_HR = hr;
    if (ipTimeReference)
      ipTimeReference->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalQueryFilter2.putref_TimeReference");
    return return_tuple;
}

static PyObject*
ITemporalQueryFilter2Method_get_TemporalOrder(PyITemporalQueryFilter2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    enumTemporalOrder epVal;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pITemporalQueryFilter2->get_TemporalOrder(&epVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalQueryFilter2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalQueryFilter2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalQueryFilter2.get_TemporalOrder() returned %ld", (long)hr);
        goto itemporalqueryfilter2_get_temporalorder_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)epVal);
    goto itemporalqueryfilter2_get_temporalorder_method_cleanup;

    itemporalqueryfilter2_get_temporalorder_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalQueryFilter2.get_TemporalOrder");
    return return_tuple;
}

static PyObject*
ITemporalQueryFilter2Method_put_TemporalOrder(PyITemporalQueryFilter2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    enumTemporalOrder epVal;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&epVal))
      goto itemporalqueryfilter2_put_temporalorder_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pITemporalQueryFilter2->put_TemporalOrder(epVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalQueryFilter2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalQueryFilter2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalQueryFilter2.put_TemporalOrder() returned %ld", (long)hr);
        goto itemporalqueryfilter2_put_temporalorder_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto itemporalqueryfilter2_put_temporalorder_method_cleanup;

    itemporalqueryfilter2_put_temporalorder_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalQueryFilter2.put_TemporalOrder");
    return return_tuple;
}

static PyObject*
ITemporalQueryFilter2Method_get_TemporalRelationship(PyITemporalQueryFilter2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    enumTemporalRelation epVal;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pITemporalQueryFilter2->get_TemporalRelationship(&epVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalQueryFilter2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalQueryFilter2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalQueryFilter2.get_TemporalRelationship() returned %ld", (long)hr);
        goto itemporalqueryfilter2_get_temporalrelationship_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)epVal);
    goto itemporalqueryfilter2_get_temporalrelationship_method_cleanup;

    itemporalqueryfilter2_get_temporalrelationship_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalQueryFilter2.get_TemporalRelationship");
    return return_tuple;
}

static PyObject*
ITemporalQueryFilter2Method_put_TemporalRelationship(PyITemporalQueryFilter2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    enumTemporalRelation epVal;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&epVal))
      goto itemporalqueryfilter2_put_temporalrelationship_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pITemporalQueryFilter2->put_TemporalRelationship(epVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalQueryFilter2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalQueryFilter2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalQueryFilter2.put_TemporalRelationship() returned %ld", (long)hr);
        goto itemporalqueryfilter2_put_temporalrelationship_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto itemporalqueryfilter2_put_temporalrelationship_method_cleanup;

    itemporalqueryfilter2_put_temporalrelationship_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalQueryFilter2.put_TemporalRelationship");
    return return_tuple;
}

static PyObject*
ITemporalQueryFilter2Method_get_StartingDate(PyITemporalQueryFilter2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT vpVal;
    ::VariantInit(&vpVal);
    PyObject* pyvar_pVal = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pITemporalQueryFilter2->get_StartingDate(&vpVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalQueryFilter2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalQueryFilter2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalQueryFilter2.get_StartingDate() returned %ld", (long)hr);
        goto itemporalqueryfilter2_get_startingdate_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pVal = Variant_AsPyObject(&vpVal);
    if (PyErr_Occurred())
      goto itemporalqueryfilter2_get_startingdate_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pVal);
    goto itemporalqueryfilter2_get_startingdate_method_cleanup;

    itemporalqueryfilter2_get_startingdate_method_cleanup:
    self->m_HR = hr;
    ::VariantClear(&vpVal);
    Py_XDECREF(pyvar_pVal);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalQueryFilter2.get_StartingDate");
    return return_tuple;
}

static PyObject*
ITemporalQueryFilter2Method_put_StartingDate(PyITemporalQueryFilter2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT vpVal;
    ::VariantInit(&vpVal);
    PyObject* pyvar_pVal = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pVal))
      goto itemporalqueryfilter2_put_startingdate_method_cleanup;

    // Set up initial variable values as needed
    PyObject_AsVariant(pyvar_pVal, &vpVal);
    
    if (PyErr_Occurred())
      goto itemporalqueryfilter2_put_startingdate_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITemporalQueryFilter2->put_StartingDate(vpVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalQueryFilter2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalQueryFilter2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalQueryFilter2.put_StartingDate() returned %ld", (long)hr);
        goto itemporalqueryfilter2_put_startingdate_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto itemporalqueryfilter2_put_startingdate_method_cleanup;

    itemporalqueryfilter2_put_startingdate_method_cleanup:
    self->m_HR = hr;
    ::VariantClear(&vpVal);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalQueryFilter2.put_StartingDate");
    return return_tuple;
}

static PyObject*
ITemporalQueryFilter2Method_get_EndingDate(PyITemporalQueryFilter2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT vpVal;
    ::VariantInit(&vpVal);
    PyObject* pyvar_pVal = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pITemporalQueryFilter2->get_EndingDate(&vpVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalQueryFilter2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalQueryFilter2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalQueryFilter2.get_EndingDate() returned %ld", (long)hr);
        goto itemporalqueryfilter2_get_endingdate_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pVal = Variant_AsPyObject(&vpVal);
    if (PyErr_Occurred())
      goto itemporalqueryfilter2_get_endingdate_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pVal);
    goto itemporalqueryfilter2_get_endingdate_method_cleanup;

    itemporalqueryfilter2_get_endingdate_method_cleanup:
    self->m_HR = hr;
    ::VariantClear(&vpVal);
    Py_XDECREF(pyvar_pVal);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalQueryFilter2.get_EndingDate");
    return return_tuple;
}

static PyObject*
ITemporalQueryFilter2Method_put_EndingDate(PyITemporalQueryFilter2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT vpVal;
    ::VariantInit(&vpVal);
    PyObject* pyvar_pVal = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pVal))
      goto itemporalqueryfilter2_put_endingdate_method_cleanup;

    // Set up initial variable values as needed
    PyObject_AsVariant(pyvar_pVal, &vpVal);
    
    if (PyErr_Occurred())
      goto itemporalqueryfilter2_put_endingdate_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITemporalQueryFilter2->put_EndingDate(vpVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalQueryFilter2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalQueryFilter2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalQueryFilter2.put_EndingDate() returned %ld", (long)hr);
        goto itemporalqueryfilter2_put_endingdate_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto itemporalqueryfilter2_put_endingdate_method_cleanup;

    itemporalqueryfilter2_put_endingdate_method_cleanup:
    self->m_HR = hr;
    ::VariantClear(&vpVal);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalQueryFilter2.put_EndingDate");
    return return_tuple;
}

static PyObject*
ITemporalQueryFilter2Method_get_TemporalConversion(PyITemporalQueryFilter2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    enumTemporalConversion epVal;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pITemporalQueryFilter2->get_TemporalConversion(&epVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalQueryFilter2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalQueryFilter2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalQueryFilter2.get_TemporalConversion() returned %ld", (long)hr);
        goto itemporalqueryfilter2_get_temporalconversion_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)epVal);
    goto itemporalqueryfilter2_get_temporalconversion_method_cleanup;

    itemporalqueryfilter2_get_temporalconversion_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalQueryFilter2.get_TemporalConversion");
    return return_tuple;
}

static PyObject*
ITemporalQueryFilter2Method_put_TemporalConversion(PyITemporalQueryFilter2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    enumTemporalConversion epVal;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&epVal))
      goto itemporalqueryfilter2_put_temporalconversion_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pITemporalQueryFilter2->put_TemporalConversion(epVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalQueryFilter2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalQueryFilter2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalQueryFilter2.put_TemporalConversion() returned %ld", (long)hr);
        goto itemporalqueryfilter2_put_temporalconversion_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto itemporalqueryfilter2_put_temporalconversion_method_cleanup;

    itemporalqueryfilter2_put_temporalconversion_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalQueryFilter2.put_TemporalConversion");
    return return_tuple;
}

static PyObject*
ITemporalQueryFilter2Method_get_RelativeTimeOperator(PyITemporalQueryFilter2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ITemporalOperator* ippVal = NULL;
    PyObject* py_pVal = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pITemporalQueryFilter2->get_RelativeTimeOperator(&ippVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalQueryFilter2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalQueryFilter2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalQueryFilter2.get_RelativeTimeOperator() returned %ld", (long)hr);
        goto itemporalqueryfilter2_get_relativetimeoperator_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_pVal);
    if (ippVal)
    {
        IUnknown* pUnk = NULL;
        ippVal->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_pVal = IUnknownToPythonIIDObject(pUnk, &IID_ITemporalOperator);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_pVal)
    {
        if (py_pVal)
           Py_DECREF(py_pVal);
        py_pVal = Py_None;
        Py_INCREF(py_pVal);
    }
    if (PyErr_Occurred())
      goto itemporalqueryfilter2_get_relativetimeoperator_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_pVal);
    goto itemporalqueryfilter2_get_relativetimeoperator_method_cleanup;

    itemporalqueryfilter2_get_relativetimeoperator_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_pVal);
    if (ippVal)
      ippVal->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalQueryFilter2.get_RelativeTimeOperator");
    return return_tuple;
}

static PyObject*
ITemporalQueryFilter2Method_put_RelativeTimeOperator(PyITemporalQueryFilter2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ITemporalOperator* ippVal = NULL;
    PyObject* py_pVal;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_pVal))
      goto itemporalqueryfilter2_put_relativetimeoperator_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pVal, &IID_ITemporalOperator, (void**)&ippVal))
        PyErr_SetString(PyExc_TypeError, "Argument pVal (position 0) is not ITemporalOperator");
    
    if (PyErr_Occurred())
      goto itemporalqueryfilter2_put_relativetimeoperator_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITemporalQueryFilter2->put_RelativeTimeOperator(ippVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalQueryFilter2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalQueryFilter2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalQueryFilter2.put_RelativeTimeOperator() returned %ld", (long)hr);
        goto itemporalqueryfilter2_put_relativetimeoperator_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto itemporalqueryfilter2_put_relativetimeoperator_method_cleanup;

    itemporalqueryfilter2_put_relativetimeoperator_method_cleanup:
    self->m_HR = hr;
    if (ippVal)
      ippVal->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalQueryFilter2.put_RelativeTimeOperator");
    return return_tuple;
}


PyMethodDef PyITemporalQueryFilter2Methods[] = {
    {"supports", (PyCFunction)PyITemporalQueryFilter2_SupportsInterface, METH_O, ""},
    {"get_TimeReference", (PyCFunction)ITemporalQueryFilter2Method_get_TimeReference, METH_VARARGS, ""},
    {"putref_TimeReference", (PyCFunction)ITemporalQueryFilter2Method_putref_TimeReference, METH_VARARGS, ""},
    {"get_TemporalOrder", (PyCFunction)ITemporalQueryFilter2Method_get_TemporalOrder, METH_VARARGS, ""},
    {"put_TemporalOrder", (PyCFunction)ITemporalQueryFilter2Method_put_TemporalOrder, METH_VARARGS, ""},
    {"get_TemporalRelationship", (PyCFunction)ITemporalQueryFilter2Method_get_TemporalRelationship, METH_VARARGS, ""},
    {"put_TemporalRelationship", (PyCFunction)ITemporalQueryFilter2Method_put_TemporalRelationship, METH_VARARGS, ""},
    {"get_StartingDate", (PyCFunction)ITemporalQueryFilter2Method_get_StartingDate, METH_VARARGS, ""},
    {"put_StartingDate", (PyCFunction)ITemporalQueryFilter2Method_put_StartingDate, METH_VARARGS, ""},
    {"get_EndingDate", (PyCFunction)ITemporalQueryFilter2Method_get_EndingDate, METH_VARARGS, ""},
    {"put_EndingDate", (PyCFunction)ITemporalQueryFilter2Method_put_EndingDate, METH_VARARGS, ""},
    {"get_TemporalConversion", (PyCFunction)ITemporalQueryFilter2Method_get_TemporalConversion, METH_VARARGS, ""},
    {"put_TemporalConversion", (PyCFunction)ITemporalQueryFilter2Method_put_TemporalConversion, METH_VARARGS, ""},
    {"get_RelativeTimeOperator", (PyCFunction)ITemporalQueryFilter2Method_get_RelativeTimeOperator, METH_VARARGS, ""},
    {"put_RelativeTimeOperator", (PyCFunction)ITemporalQueryFilter2Method_put_RelativeTimeOperator, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyITemporalQueryFilter2GetSet[] = {
  {"_pUnk", (getter)PyITemporalQueryFilter2_GetpUnk, NULL, "Get opaque pointer to an Unknown from ITemporalQueryFilter2", NULL},
  {"_pointer", (getter)PyITemporalQueryFilter2_GetPointer, NULL, "Get memory address for ITemporalQueryFilter2", NULL},
  {"_IID", (getter)PyITemporalQueryFilter2_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyITemporalQueryFilter2_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyITemporalQueryFilter2_GetIgnoreFailures, (setter)PyITemporalQueryFilter2_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyITemporalQueryFilter2Object_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.ITemporalQueryFilter2Object",                          
                                              /* tp_name */
  sizeof(PyITemporalQueryFilter2Object),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyITemporalQueryFilter2Object_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyITemporalQueryFilter2Methods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyITemporalQueryFilter2GetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyITemporalQueryFilter2Object_new,                      
                                              /* tp_new */
};

// Interface IListener

typedef struct PyIListenerObject {
    PyObject_HEAD
    IListener* m_pIListener;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIListenerObject;

static PyObject*
PyIListenerObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIListenerObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IListener* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IListener, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IListener with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIListenerObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IListener");
            return NULL;
        }
        self->m_pIListener = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IListener");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IListener");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IListener* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IListener, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IListener");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIListenerObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IListener");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIListener = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIListenerObject_dealloc(PyIListenerObject* self)
{
    if (self->m_pIListener)
        self->m_pIListener->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIListener_GetpUnk(PyIListenerObject* self)
{
    if (!self->m_pIListener)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIListener->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IListener to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIListener_GetPointer(PyIListenerObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIListener);
}

static PyObject*
PyIListener_GetIID(PyIListenerObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "d890e524-dab5-11d5-b811-00010265adc5");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIListener_GetHR(PyIListenerObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIListener_GetIgnoreFailures(PyIListenerObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIListener_SetIgnoreFailures(PyIListenerObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIListener_SupportsInterface(PyIListenerObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIListener->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IListenerMethod_AddData(PyIListenerObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IFeatureClass* ippiFeatureClass = NULL;
    PyObject* py_piFeatureClass;
    double ddXMin = 0;
    double ddYMin = 0;
    double ddXMax = 0;
    double ddYMax = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "Odddd", &py_piFeatureClass, &ddXMin, &ddYMin, &ddXMax, &ddYMax))
      goto ilistener_adddata_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_piFeatureClass, &IID_IFeatureClass, (void**)&ippiFeatureClass))
        PyErr_SetString(PyExc_TypeError, "Argument piFeatureClass (position 0) is not IFeatureClass");
    
    if (PyErr_Occurred())
      goto ilistener_adddata_method_cleanup;
    
    // No setup for dXMin
    // No setup for dYMin
    // No setup for dXMax
    // No setup for dYMax

    // Call method on actual COM interface
    hr = self->m_pIListener->AddData(ippiFeatureClass, ddXMin, ddYMin, ddXMax, ddYMax);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIListener->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IListener) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IListener.AddData() returned %ld", (long)hr);
        goto ilistener_adddata_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for piFeatureClass
    // No teardown for dXMin
    // No teardown for dYMin
    // No teardown for dXMax
    // No teardown for dYMax

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ilistener_adddata_method_cleanup;

    ilistener_adddata_method_cleanup:
    self->m_HR = hr;
    if (ippiFeatureClass)
      ippiFeatureClass->Release();
    // No cleanup for dXMin
    // No cleanup for dYMin
    // No cleanup for dXMax
    // No cleanup for dYMax
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IListener.AddData");
    return return_tuple;
}

static PyObject*
IListenerMethod_RemoveData(PyIListenerObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IFeatureClass* ippiFeatureClass = NULL;
    PyObject* py_piFeatureClass;
    double ddXMin = 0;
    double ddYMin = 0;
    double ddXMax = 0;
    double ddYMax = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "Odddd", &py_piFeatureClass, &ddXMin, &ddYMin, &ddXMax, &ddYMax))
      goto ilistener_removedata_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_piFeatureClass, &IID_IFeatureClass, (void**)&ippiFeatureClass))
        PyErr_SetString(PyExc_TypeError, "Argument piFeatureClass (position 0) is not IFeatureClass");
    
    if (PyErr_Occurred())
      goto ilistener_removedata_method_cleanup;
    
    // No setup for dXMin
    // No setup for dYMin
    // No setup for dXMax
    // No setup for dYMax

    // Call method on actual COM interface
    hr = self->m_pIListener->RemoveData(ippiFeatureClass, ddXMin, ddYMin, ddXMax, ddYMax);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIListener->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IListener) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IListener.RemoveData() returned %ld", (long)hr);
        goto ilistener_removedata_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for piFeatureClass
    // No teardown for dXMin
    // No teardown for dYMin
    // No teardown for dXMax
    // No teardown for dYMax

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ilistener_removedata_method_cleanup;

    ilistener_removedata_method_cleanup:
    self->m_HR = hr;
    if (ippiFeatureClass)
      ippiFeatureClass->Release();
    // No cleanup for dXMin
    // No cleanup for dYMin
    // No cleanup for dXMax
    // No cleanup for dYMax
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IListener.RemoveData");
    return return_tuple;
}


PyMethodDef PyIListenerMethods[] = {
    {"supports", (PyCFunction)PyIListener_SupportsInterface, METH_O, ""},
    {"AddData", (PyCFunction)IListenerMethod_AddData, METH_VARARGS, ""},
    {"RemoveData", (PyCFunction)IListenerMethod_RemoveData, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIListenerGetSet[] = {
  {"_pUnk", (getter)PyIListener_GetpUnk, NULL, "Get opaque pointer to an Unknown from IListener", NULL},
  {"_pointer", (getter)PyIListener_GetPointer, NULL, "Get memory address for IListener", NULL},
  {"_IID", (getter)PyIListener_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIListener_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIListener_GetIgnoreFailures, (setter)PyIListener_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIListenerObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.IListenerObject",                          
                                              /* tp_name */
  sizeof(PyIListenerObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIListenerObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIListenerMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIListenerGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIListenerObject_new,                      
                                              /* tp_new */
};

// Interface ITemporalFeature

typedef struct PyITemporalFeatureObject {
    PyObject_HEAD
    ITemporalFeature* m_pITemporalFeature;
    HRESULT m_HR;
    int m_ignore_failures;
} PyITemporalFeatureObject;

static PyObject*
PyITemporalFeatureObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyITemporalFeatureObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ITemporalFeature* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ITemporalFeature, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ITemporalFeature with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyITemporalFeatureObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ITemporalFeature");
            return NULL;
        }
        self->m_pITemporalFeature = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ITemporalFeature");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ITemporalFeature");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ITemporalFeature* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ITemporalFeature, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ITemporalFeature");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyITemporalFeatureObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ITemporalFeature");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pITemporalFeature = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyITemporalFeatureObject_dealloc(PyITemporalFeatureObject* self)
{
    if (self->m_pITemporalFeature)
        self->m_pITemporalFeature->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyITemporalFeature_GetpUnk(PyITemporalFeatureObject* self)
{
    if (!self->m_pITemporalFeature)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pITemporalFeature->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ITemporalFeature to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyITemporalFeature_GetPointer(PyITemporalFeatureObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pITemporalFeature);
}

static PyObject*
PyITemporalFeature_GetIID(PyITemporalFeatureObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "a677ab62-2fb8-11d5-b7e2-00010265adc5");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyITemporalFeature_GetHR(PyITemporalFeatureObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyITemporalFeature_GetIgnoreFailures(PyITemporalFeatureObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyITemporalFeature_SetIgnoreFailures(PyITemporalFeatureObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyITemporalFeature_SupportsInterface(PyITemporalFeatureObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pITemporalFeature->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ITemporalFeatureMethod_get_TemporalFeatureType(PyITemporalFeatureObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    enumTemporalFeatureType epVal;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pITemporalFeature->get_TemporalFeatureType(&epVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalFeature->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalFeature) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalFeature.get_TemporalFeatureType() returned %ld", (long)hr);
        goto itemporalfeature_get_temporalfeaturetype_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)epVal);
    goto itemporalfeature_get_temporalfeaturetype_method_cleanup;

    itemporalfeature_get_temporalfeaturetype_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalFeature.get_TemporalFeatureType");
    return return_tuple;
}

static PyObject*
ITemporalFeatureMethod_get_ShapeCopy(PyITemporalFeatureObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IGeometry* ipShape = NULL;
    PyObject* py_Shape = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Shape

    // Call method on actual COM interface
    hr = self->m_pITemporalFeature->get_ShapeCopy(&ipShape);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalFeature->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalFeature) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalFeature.get_ShapeCopy() returned %ld", (long)hr);
        goto itemporalfeature_get_shapecopy_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_Shape);
    if (ipShape)
    {
        IUnknown* pUnk = NULL;
        ipShape->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_Shape = IUnknownToPythonIIDObject(pUnk, &IID_IGeometry);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_Shape)
    {
        if (py_Shape)
           Py_DECREF(py_Shape);
        py_Shape = Py_None;
        Py_INCREF(py_Shape);
    }
    if (PyErr_Occurred())
      goto itemporalfeature_get_shapecopy_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_Shape);
    goto itemporalfeature_get_shapecopy_method_cleanup;

    itemporalfeature_get_shapecopy_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_Shape);
    if (ipShape)
      ipShape->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalFeature.get_ShapeCopy");
    return return_tuple;
}

static PyObject*
ITemporalFeatureMethod_get_Shape(PyITemporalFeatureObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IGeometry* ipShape = NULL;
    PyObject* py_Shape = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Shape

    // Call method on actual COM interface
    hr = self->m_pITemporalFeature->get_Shape(&ipShape);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalFeature->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalFeature) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalFeature.get_Shape() returned %ld", (long)hr);
        goto itemporalfeature_get_shape_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_Shape);
    if (ipShape)
    {
        IUnknown* pUnk = NULL;
        ipShape->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_Shape = IUnknownToPythonIIDObject(pUnk, &IID_IGeometry);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_Shape)
    {
        if (py_Shape)
           Py_DECREF(py_Shape);
        py_Shape = Py_None;
        Py_INCREF(py_Shape);
    }
    if (PyErr_Occurred())
      goto itemporalfeature_get_shape_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_Shape);
    goto itemporalfeature_get_shape_method_cleanup;

    itemporalfeature_get_shape_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_Shape);
    if (ipShape)
      ipShape->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalFeature.get_Shape");
    return return_tuple;
}

static PyObject*
ITemporalFeatureMethod_putref_Shape(PyITemporalFeatureObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IGeometry* ipShape = NULL;
    PyObject* py_Shape;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_Shape))
      goto itemporalfeature_putref_shape_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_Shape, &IID_IGeometry, (void**)&ipShape))
        PyErr_SetString(PyExc_TypeError, "Argument Shape (position 0) is not IGeometry");
    
    if (PyErr_Occurred())
      goto itemporalfeature_putref_shape_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITemporalFeature->putref_Shape(ipShape);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalFeature->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalFeature) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalFeature.putref_Shape() returned %ld", (long)hr);
        goto itemporalfeature_putref_shape_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Shape

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto itemporalfeature_putref_shape_method_cleanup;

    itemporalfeature_putref_shape_method_cleanup:
    self->m_HR = hr;
    if (ipShape)
      ipShape->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalFeature.putref_Shape");
    return return_tuple;
}

static PyObject*
ITemporalFeatureMethod_get_Extent(PyITemporalFeatureObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IEnvelope* ipExtent = NULL;
    PyObject* py_Extent = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Extent

    // Call method on actual COM interface
    hr = self->m_pITemporalFeature->get_Extent(&ipExtent);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalFeature->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalFeature) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalFeature.get_Extent() returned %ld", (long)hr);
        goto itemporalfeature_get_extent_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_Extent);
    if (ipExtent)
    {
        IUnknown* pUnk = NULL;
        ipExtent->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_Extent = IUnknownToPythonIIDObject(pUnk, &IID_IEnvelope);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_Extent)
    {
        if (py_Extent)
           Py_DECREF(py_Extent);
        py_Extent = Py_None;
        Py_INCREF(py_Extent);
    }
    if (PyErr_Occurred())
      goto itemporalfeature_get_extent_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_Extent);
    goto itemporalfeature_get_extent_method_cleanup;

    itemporalfeature_get_extent_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_Extent);
    if (ipExtent)
      ipExtent->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalFeature.get_Extent");
    return return_tuple;
}

static PyObject*
ITemporalFeatureMethod_get_FeatureType(PyITemporalFeatureObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriFeatureType eType;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Type

    // Call method on actual COM interface
    hr = self->m_pITemporalFeature->get_FeatureType(&eType);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalFeature->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalFeature) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalFeature.get_FeatureType() returned %ld", (long)hr);
        goto itemporalfeature_get_featuretype_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Type

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)eType);
    goto itemporalfeature_get_featuretype_method_cleanup;

    itemporalfeature_get_featuretype_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Type
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalFeature.get_FeatureType");
    return return_tuple;
}

static PyObject*
ITemporalFeatureMethod_get_Class(PyITemporalFeatureObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IObjectClass* ipTable = NULL;
    PyObject* py_Table = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Table

    // Call method on actual COM interface
    hr = self->m_pITemporalFeature->get_Class(&ipTable);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalFeature->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalFeature) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalFeature.get_Class() returned %ld", (long)hr);
        goto itemporalfeature_get_class_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_Table);
    if (ipTable)
    {
        IUnknown* pUnk = NULL;
        ipTable->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_Table = IUnknownToPythonIIDObject(pUnk, &IID_IObjectClass);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_Table)
    {
        if (py_Table)
           Py_DECREF(py_Table);
        py_Table = Py_None;
        Py_INCREF(py_Table);
    }
    if (PyErr_Occurred())
      goto itemporalfeature_get_class_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_Table);
    goto itemporalfeature_get_class_method_cleanup;

    itemporalfeature_get_class_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_Table);
    if (ipTable)
      ipTable->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalFeature.get_Class");
    return return_tuple;
}

static PyObject*
ITemporalFeatureMethod_get_HasOID(PyITemporalFeatureObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_HasOID = VARIANT_FALSE;
    PyObject* pyvar_HasOID = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for HasOID

    // Call method on actual COM interface
    hr = self->m_pITemporalFeature->get_HasOID(&b_HasOID);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalFeature->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalFeature) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalFeature.get_HasOID() returned %ld", (long)hr);
        goto itemporalfeature_get_hasoid_method_cleanup;
    }

    // Set up return values as needed
    pyvar_HasOID = ((b_HasOID == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto itemporalfeature_get_hasoid_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_HasOID);
    goto itemporalfeature_get_hasoid_method_cleanup;

    itemporalfeature_get_hasoid_method_cleanup:
    self->m_HR = hr;
    // No cleanup for HasOID
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalFeature.get_HasOID");
    return return_tuple;
}

static PyObject*
ITemporalFeatureMethod_get_OID(PyITemporalFeatureObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lOID = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for OID

    // Call method on actual COM interface
    hr = self->m_pITemporalFeature->get_OID(&lOID);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalFeature->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalFeature) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalFeature.get_OID() returned %ld", (long)hr);
        goto itemporalfeature_get_oid_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for OID

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lOID);
    goto itemporalfeature_get_oid_method_cleanup;

    itemporalfeature_get_oid_method_cleanup:
    self->m_HR = hr;
    // No cleanup for OID
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalFeature.get_OID");
    return return_tuple;
}

static PyObject*
ITemporalFeatureMethod_get_Table(PyITemporalFeatureObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ITable* ipTable = NULL;
    PyObject* py_Table = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Table

    // Call method on actual COM interface
    hr = self->m_pITemporalFeature->get_Table(&ipTable);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalFeature->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalFeature) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalFeature.get_Table() returned %ld", (long)hr);
        goto itemporalfeature_get_table_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_Table);
    if (ipTable)
    {
        IUnknown* pUnk = NULL;
        ipTable->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_Table = IUnknownToPythonIIDObject(pUnk, &IID_ITable);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_Table)
    {
        if (py_Table)
           Py_DECREF(py_Table);
        py_Table = Py_None;
        Py_INCREF(py_Table);
    }
    if (PyErr_Occurred())
      goto itemporalfeature_get_table_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_Table);
    goto itemporalfeature_get_table_method_cleanup;

    itemporalfeature_get_table_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_Table);
    if (ipTable)
      ipTable->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalFeature.get_Table");
    return return_tuple;
}

static PyObject*
ITemporalFeatureMethod_Store(PyITemporalFeatureObject* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pITemporalFeature->Store();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalFeature->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalFeature) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalFeature.Store() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}

static PyObject*
ITemporalFeatureMethod_Delete(PyITemporalFeatureObject* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pITemporalFeature->Delete();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalFeature->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalFeature) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalFeature.Delete() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}

static PyObject*
ITemporalFeatureMethod_get_Value(PyITemporalFeatureObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lIndex = 0;
    VARIANT vValue;
    ::VariantInit(&vValue);
    PyObject* pyvar_Value = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lIndex))
      goto itemporalfeature_get_value_method_cleanup;

    // Set up initial variable values as needed
    // No setup for Index
    // No setup for Value

    // Call method on actual COM interface
    hr = self->m_pITemporalFeature->get_Value(lIndex, &vValue);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalFeature->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalFeature) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalFeature.get_Value() returned %ld", (long)hr);
        goto itemporalfeature_get_value_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Index
    pyvar_Value = Variant_AsPyObject(&vValue);
    if (PyErr_Occurred())
      goto itemporalfeature_get_value_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Value);
    goto itemporalfeature_get_value_method_cleanup;

    itemporalfeature_get_value_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Index
    ::VariantClear(&vValue);
    Py_XDECREF(pyvar_Value);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalFeature.get_Value");
    return return_tuple;
}

static PyObject*
ITemporalFeatureMethod_put_Value(PyITemporalFeatureObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lIndex = 0;
    VARIANT vValue;
    ::VariantInit(&vValue);
    PyObject* pyvar_Value = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "lO", &lIndex, &pyvar_Value))
      goto itemporalfeature_put_value_method_cleanup;

    // Set up initial variable values as needed
    // No setup for Index
    PyObject_AsVariant(pyvar_Value, &vValue);
    
    if (PyErr_Occurred())
      goto itemporalfeature_put_value_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITemporalFeature->put_Value(lIndex, vValue);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalFeature->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalFeature) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalFeature.put_Value() returned %ld", (long)hr);
        goto itemporalfeature_put_value_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Index
    // No teardown for Value

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto itemporalfeature_put_value_method_cleanup;

    itemporalfeature_put_value_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Index
    ::VariantClear(&vValue);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalFeature.put_Value");
    return return_tuple;
}

static PyObject*
ITemporalFeatureMethod_get_Fields(PyITemporalFeatureObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IFields* ipFields = NULL;
    PyObject* py_Fields = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Fields

    // Call method on actual COM interface
    hr = self->m_pITemporalFeature->get_Fields(&ipFields);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalFeature->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalFeature) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalFeature.get_Fields() returned %ld", (long)hr);
        goto itemporalfeature_get_fields_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_Fields);
    if (ipFields)
    {
        IUnknown* pUnk = NULL;
        ipFields->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_Fields = IUnknownToPythonIIDObject(pUnk, &IID_IFields);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_Fields)
    {
        if (py_Fields)
           Py_DECREF(py_Fields);
        py_Fields = Py_None;
        Py_INCREF(py_Fields);
    }
    if (PyErr_Occurred())
      goto itemporalfeature_get_fields_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_Fields);
    goto itemporalfeature_get_fields_method_cleanup;

    itemporalfeature_get_fields_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_Fields);
    if (ipFields)
      ipFields->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalFeature.get_Fields");
    return return_tuple;
}


PyMethodDef PyITemporalFeatureMethods[] = {
    {"supports", (PyCFunction)PyITemporalFeature_SupportsInterface, METH_O, ""},
    {"get_TemporalFeatureType", (PyCFunction)ITemporalFeatureMethod_get_TemporalFeatureType, METH_VARARGS, ""},
    {"get_ShapeCopy", (PyCFunction)ITemporalFeatureMethod_get_ShapeCopy, METH_VARARGS, ""},
    {"get_Shape", (PyCFunction)ITemporalFeatureMethod_get_Shape, METH_VARARGS, ""},
    {"putref_Shape", (PyCFunction)ITemporalFeatureMethod_putref_Shape, METH_VARARGS, ""},
    {"get_Extent", (PyCFunction)ITemporalFeatureMethod_get_Extent, METH_VARARGS, ""},
    {"get_FeatureType", (PyCFunction)ITemporalFeatureMethod_get_FeatureType, METH_VARARGS, ""},
    {"get_Class", (PyCFunction)ITemporalFeatureMethod_get_Class, METH_VARARGS, ""},
    {"get_HasOID", (PyCFunction)ITemporalFeatureMethod_get_HasOID, METH_VARARGS, ""},
    {"get_OID", (PyCFunction)ITemporalFeatureMethod_get_OID, METH_VARARGS, ""},
    {"get_Table", (PyCFunction)ITemporalFeatureMethod_get_Table, METH_VARARGS, ""},
    {"Store", (PyCFunction)ITemporalFeatureMethod_Store, METH_NOARGS, ""},
    {"Delete", (PyCFunction)ITemporalFeatureMethod_Delete, METH_NOARGS, ""},
    {"get_Value", (PyCFunction)ITemporalFeatureMethod_get_Value, METH_VARARGS, ""},
    {"put_Value", (PyCFunction)ITemporalFeatureMethod_put_Value, METH_VARARGS, ""},
    {"get_Fields", (PyCFunction)ITemporalFeatureMethod_get_Fields, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyITemporalFeatureGetSet[] = {
  {"_pUnk", (getter)PyITemporalFeature_GetpUnk, NULL, "Get opaque pointer to an Unknown from ITemporalFeature", NULL},
  {"_pointer", (getter)PyITemporalFeature_GetPointer, NULL, "Get memory address for ITemporalFeature", NULL},
  {"_IID", (getter)PyITemporalFeature_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyITemporalFeature_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyITemporalFeature_GetIgnoreFailures, (setter)PyITemporalFeature_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyITemporalFeatureObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.ITemporalFeatureObject",                          
                                              /* tp_name */
  sizeof(PyITemporalFeatureObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyITemporalFeatureObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyITemporalFeatureMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyITemporalFeatureGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyITemporalFeatureObject_new,                      
                                              /* tp_new */
};

// Interface IAMSDatasetName

typedef struct PyIAMSDatasetNameObject {
    PyObject_HEAD
    IAMSDatasetName* m_pIAMSDatasetName;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIAMSDatasetNameObject;

static PyObject*
PyIAMSDatasetNameObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIAMSDatasetNameObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IAMSDatasetName* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IAMSDatasetName, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IAMSDatasetName with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIAMSDatasetNameObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IAMSDatasetName");
            return NULL;
        }
        self->m_pIAMSDatasetName = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IAMSDatasetName");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IAMSDatasetName");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IAMSDatasetName* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IAMSDatasetName, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IAMSDatasetName");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIAMSDatasetNameObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IAMSDatasetName");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIAMSDatasetName = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIAMSDatasetNameObject_dealloc(PyIAMSDatasetNameObject* self)
{
    if (self->m_pIAMSDatasetName)
        self->m_pIAMSDatasetName->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIAMSDatasetName_GetpUnk(PyIAMSDatasetNameObject* self)
{
    if (!self->m_pIAMSDatasetName)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIAMSDatasetName->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IAMSDatasetName to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIAMSDatasetName_GetPointer(PyIAMSDatasetNameObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIAMSDatasetName);
}

static PyObject*
PyIAMSDatasetName_GetIID(PyIAMSDatasetNameObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "a677ab64-2fb8-11d5-b7e2-00010265adc5");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIAMSDatasetName_GetHR(PyIAMSDatasetNameObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIAMSDatasetName_GetIgnoreFailures(PyIAMSDatasetNameObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIAMSDatasetName_SetIgnoreFailures(PyIAMSDatasetNameObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIAMSDatasetName_SupportsInterface(PyIAMSDatasetNameObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIAMSDatasetName->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IAMSDatasetNameMethod_get_Visible(PyIAMSDatasetNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pVal = VARIANT_FALSE;
    PyObject* pyvar_pVal = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pIAMSDatasetName->get_Visible(&b_pVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAMSDatasetName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAMSDatasetName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAMSDatasetName.get_Visible() returned %ld", (long)hr);
        goto iamsdatasetname_get_visible_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pVal = ((b_pVal == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto iamsdatasetname_get_visible_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pVal);
    goto iamsdatasetname_get_visible_method_cleanup;

    iamsdatasetname_get_visible_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAMSDatasetName.get_Visible");
    return return_tuple;
}

static PyObject*
IAMSDatasetNameMethod_put_Visible(PyIAMSDatasetNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pVal = VARIANT_FALSE;
    PyObject* pyvar_pVal = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pVal))
      goto iamsdatasetname_put_visible_method_cleanup;

    // Set up initial variable values as needed
    b_pVal = ((PyObject_IsTrue(pyvar_pVal) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iamsdatasetname_put_visible_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIAMSDatasetName->put_Visible(b_pVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAMSDatasetName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAMSDatasetName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAMSDatasetName.put_Visible() returned %ld", (long)hr);
        goto iamsdatasetname_put_visible_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iamsdatasetname_put_visible_method_cleanup;

    iamsdatasetname_put_visible_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAMSDatasetName.put_Visible");
    return return_tuple;
}

static PyObject*
IAMSDatasetNameMethod_get_TemporalColumnName(PyIAMSDatasetNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspVal;
    PyObject* pyvar_pVal = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pIAMSDatasetName->get_TemporalColumnName(&bspVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAMSDatasetName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAMSDatasetName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAMSDatasetName.get_TemporalColumnName() returned %ld", (long)hr);
        goto iamsdatasetname_get_temporalcolumnname_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pVal = PyUnicode_FromWideChar(bspVal,::SysStringLen(bspVal));
    ::SysFreeString(bspVal);
    
    if (PyErr_Occurred())
      goto iamsdatasetname_get_temporalcolumnname_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pVal);
    goto iamsdatasetname_get_temporalcolumnname_method_cleanup;

    iamsdatasetname_get_temporalcolumnname_method_cleanup:
    self->m_HR = hr;
    if (pyvar_pVal != Py_None)
        Py_XDECREF(pyvar_pVal);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAMSDatasetName.get_TemporalColumnName");
    return return_tuple;
}

static PyObject*
IAMSDatasetNameMethod_get_TrackingService(PyIAMSDatasetNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ITrackingServiceDef* ippVal = NULL;
    PyObject* py_pVal = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pVal

    // Call method on actual COM interface
    hr = self->m_pIAMSDatasetName->get_TrackingService(&ippVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAMSDatasetName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAMSDatasetName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAMSDatasetName.get_TrackingService() returned %ld", (long)hr);
        goto iamsdatasetname_get_trackingservice_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_pVal);
    if (ippVal)
    {
        IUnknown* pUnk = NULL;
        ippVal->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_pVal = IUnknownToPythonIIDObject(pUnk, &IID_ITrackingServiceDef);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_pVal)
    {
        if (py_pVal)
           Py_DECREF(py_pVal);
        py_pVal = Py_None;
        Py_INCREF(py_pVal);
    }
    if (PyErr_Occurred())
      goto iamsdatasetname_get_trackingservice_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_pVal);
    goto iamsdatasetname_get_trackingservice_method_cleanup;

    iamsdatasetname_get_trackingservice_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_pVal);
    if (ippVal)
      ippVal->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAMSDatasetName.get_TrackingService");
    return return_tuple;
}

static PyObject*
IAMSDatasetNameMethod_putref_TrackingService(PyIAMSDatasetNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ITrackingServiceDef* ippVal = NULL;
    PyObject* py_pVal;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_pVal))
      goto iamsdatasetname_putref_trackingservice_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pVal, &IID_ITrackingServiceDef, (void**)&ippVal))
        PyErr_SetString(PyExc_TypeError, "Argument pVal (position 0) is not ITrackingServiceDef");
    
    if (PyErr_Occurred())
      goto iamsdatasetname_putref_trackingservice_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIAMSDatasetName->putref_TrackingService(ippVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAMSDatasetName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAMSDatasetName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAMSDatasetName.putref_TrackingService() returned %ld", (long)hr);
        goto iamsdatasetname_putref_trackingservice_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pVal

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iamsdatasetname_putref_trackingservice_method_cleanup;

    iamsdatasetname_putref_trackingservice_method_cleanup:
    self->m_HR = hr;
    if (ippVal)
      ippVal->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAMSDatasetName.putref_TrackingService");
    return return_tuple;
}

static PyObject*
IAMSDatasetNameMethod_get_ShapeType(PyIAMSDatasetNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriGeometryType eType;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Type

    // Call method on actual COM interface
    hr = self->m_pIAMSDatasetName->get_ShapeType(&eType);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAMSDatasetName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAMSDatasetName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAMSDatasetName.get_ShapeType() returned %ld", (long)hr);
        goto iamsdatasetname_get_shapetype_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Type

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)eType);
    goto iamsdatasetname_get_shapetype_method_cleanup;

    iamsdatasetname_get_shapetype_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Type
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAMSDatasetName.get_ShapeType");
    return return_tuple;
}

static PyObject*
IAMSDatasetNameMethod_put_ShapeType(PyIAMSDatasetNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriGeometryType eType;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&eType))
      goto iamsdatasetname_put_shapetype_method_cleanup;

    // Set up initial variable values as needed
    // No setup for Type

    // Call method on actual COM interface
    hr = self->m_pIAMSDatasetName->put_ShapeType(eType);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAMSDatasetName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAMSDatasetName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAMSDatasetName.put_ShapeType() returned %ld", (long)hr);
        goto iamsdatasetname_put_shapetype_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Type

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iamsdatasetname_put_shapetype_method_cleanup;

    iamsdatasetname_put_shapetype_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Type
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAMSDatasetName.put_ShapeType");
    return return_tuple;
}

static PyObject*
IAMSDatasetNameMethod_get_FeatureDatasetName(PyIAMSDatasetNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IDatasetName* ipFeatureDatasetName = NULL;
    PyObject* py_FeatureDatasetName = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for FeatureDatasetName

    // Call method on actual COM interface
    hr = self->m_pIAMSDatasetName->get_FeatureDatasetName(&ipFeatureDatasetName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAMSDatasetName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAMSDatasetName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAMSDatasetName.get_FeatureDatasetName() returned %ld", (long)hr);
        goto iamsdatasetname_get_featuredatasetname_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_FeatureDatasetName);
    if (ipFeatureDatasetName)
    {
        IUnknown* pUnk = NULL;
        ipFeatureDatasetName->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_FeatureDatasetName = IUnknownToPythonIIDObject(pUnk, &IID_IDatasetName);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_FeatureDatasetName)
    {
        if (py_FeatureDatasetName)
           Py_DECREF(py_FeatureDatasetName);
        py_FeatureDatasetName = Py_None;
        Py_INCREF(py_FeatureDatasetName);
    }
    if (PyErr_Occurred())
      goto iamsdatasetname_get_featuredatasetname_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_FeatureDatasetName);
    goto iamsdatasetname_get_featuredatasetname_method_cleanup;

    iamsdatasetname_get_featuredatasetname_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_FeatureDatasetName);
    if (ipFeatureDatasetName)
      ipFeatureDatasetName->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAMSDatasetName.get_FeatureDatasetName");
    return return_tuple;
}

static PyObject*
IAMSDatasetNameMethod_putref_FeatureDatasetName(PyIAMSDatasetNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IDatasetName* ipFeatureDatasetName = NULL;
    PyObject* py_FeatureDatasetName;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_FeatureDatasetName))
      goto iamsdatasetname_putref_featuredatasetname_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_FeatureDatasetName, &IID_IDatasetName, (void**)&ipFeatureDatasetName))
        PyErr_SetString(PyExc_TypeError, "Argument FeatureDatasetName (position 0) is not IDatasetName");
    
    if (PyErr_Occurred())
      goto iamsdatasetname_putref_featuredatasetname_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIAMSDatasetName->putref_FeatureDatasetName(ipFeatureDatasetName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAMSDatasetName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAMSDatasetName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAMSDatasetName.putref_FeatureDatasetName() returned %ld", (long)hr);
        goto iamsdatasetname_putref_featuredatasetname_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for FeatureDatasetName

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iamsdatasetname_putref_featuredatasetname_method_cleanup;

    iamsdatasetname_putref_featuredatasetname_method_cleanup:
    self->m_HR = hr;
    if (ipFeatureDatasetName)
      ipFeatureDatasetName->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAMSDatasetName.putref_FeatureDatasetName");
    return return_tuple;
}

static PyObject*
IAMSDatasetNameMethod_get_FeatureType(PyIAMSDatasetNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriFeatureType eType;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Type

    // Call method on actual COM interface
    hr = self->m_pIAMSDatasetName->get_FeatureType(&eType);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAMSDatasetName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAMSDatasetName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAMSDatasetName.get_FeatureType() returned %ld", (long)hr);
        goto iamsdatasetname_get_featuretype_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Type

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)eType);
    goto iamsdatasetname_get_featuretype_method_cleanup;

    iamsdatasetname_get_featuretype_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Type
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAMSDatasetName.get_FeatureType");
    return return_tuple;
}

static PyObject*
IAMSDatasetNameMethod_put_FeatureType(PyIAMSDatasetNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriFeatureType eType;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&eType))
      goto iamsdatasetname_put_featuretype_method_cleanup;

    // Set up initial variable values as needed
    // No setup for Type

    // Call method on actual COM interface
    hr = self->m_pIAMSDatasetName->put_FeatureType(eType);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAMSDatasetName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAMSDatasetName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAMSDatasetName.put_FeatureType() returned %ld", (long)hr);
        goto iamsdatasetname_put_featuretype_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Type

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iamsdatasetname_put_featuretype_method_cleanup;

    iamsdatasetname_put_featuretype_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Type
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAMSDatasetName.put_FeatureType");
    return return_tuple;
}

static PyObject*
IAMSDatasetNameMethod_get_ShapeFieldName(PyIAMSDatasetNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName;
    PyObject* pyvar_Name = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Name

    // Call method on actual COM interface
    hr = self->m_pIAMSDatasetName->get_ShapeFieldName(&bsName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAMSDatasetName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAMSDatasetName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAMSDatasetName.get_ShapeFieldName() returned %ld", (long)hr);
        goto iamsdatasetname_get_shapefieldname_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Name = PyUnicode_FromWideChar(bsName,::SysStringLen(bsName));
    ::SysFreeString(bsName);
    
    if (PyErr_Occurred())
      goto iamsdatasetname_get_shapefieldname_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Name);
    goto iamsdatasetname_get_shapefieldname_method_cleanup;

    iamsdatasetname_get_shapefieldname_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Name != Py_None)
        Py_XDECREF(pyvar_Name);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAMSDatasetName.get_ShapeFieldName");
    return return_tuple;
}

static PyObject*
IAMSDatasetNameMethod_put_ShapeFieldName(PyIAMSDatasetNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName = 0;
    PyObject* pyvar_Name;
    PyObject* unicodeName = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_Name))
      goto iamsdatasetname_put_shapefieldname_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_Name))
        unicodeName = PyUnicode_FromObject(pyvar_Name);
    else if (PyUnicode_Check(pyvar_Name))
    {
        unicodeName = pyvar_Name;
        Py_INCREF(unicodeName);
    }
    else if (pyvar_Name != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Name at index 0");
    if (unicodeName)
        bsName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeName));
    
    if (PyErr_Occurred())
      goto iamsdatasetname_put_shapefieldname_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIAMSDatasetName->put_ShapeFieldName(bsName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAMSDatasetName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAMSDatasetName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAMSDatasetName.put_ShapeFieldName() returned %ld", (long)hr);
        goto iamsdatasetname_put_shapefieldname_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Name

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iamsdatasetname_put_shapefieldname_method_cleanup;

    iamsdatasetname_put_shapefieldname_method_cleanup:
    self->m_HR = hr;
    if (bsName)
        ::SysFreeString(bsName);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAMSDatasetName.put_ShapeFieldName");
    return return_tuple;
}

static PyObject*
IAMSDatasetNameMethod_get_Name(PyIAMSDatasetNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName;
    PyObject* pyvar_Name = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Name

    // Call method on actual COM interface
    hr = self->m_pIAMSDatasetName->get_Name(&bsName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAMSDatasetName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAMSDatasetName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAMSDatasetName.get_Name() returned %ld", (long)hr);
        goto iamsdatasetname_get_name_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Name = PyUnicode_FromWideChar(bsName,::SysStringLen(bsName));
    ::SysFreeString(bsName);
    
    if (PyErr_Occurred())
      goto iamsdatasetname_get_name_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Name);
    goto iamsdatasetname_get_name_method_cleanup;

    iamsdatasetname_get_name_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Name != Py_None)
        Py_XDECREF(pyvar_Name);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAMSDatasetName.get_Name");
    return return_tuple;
}

static PyObject*
IAMSDatasetNameMethod_put_Name(PyIAMSDatasetNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName = 0;
    PyObject* pyvar_Name;
    PyObject* unicodeName = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_Name))
      goto iamsdatasetname_put_name_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_Name))
        unicodeName = PyUnicode_FromObject(pyvar_Name);
    else if (PyUnicode_Check(pyvar_Name))
    {
        unicodeName = pyvar_Name;
        Py_INCREF(unicodeName);
    }
    else if (pyvar_Name != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Name at index 0");
    if (unicodeName)
        bsName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeName));
    
    if (PyErr_Occurred())
      goto iamsdatasetname_put_name_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIAMSDatasetName->put_Name(bsName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAMSDatasetName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAMSDatasetName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAMSDatasetName.put_Name() returned %ld", (long)hr);
        goto iamsdatasetname_put_name_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Name

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iamsdatasetname_put_name_method_cleanup;

    iamsdatasetname_put_name_method_cleanup:
    self->m_HR = hr;
    if (bsName)
        ::SysFreeString(bsName);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAMSDatasetName.put_Name");
    return return_tuple;
}

static PyObject*
IAMSDatasetNameMethod_get_Type(PyIAMSDatasetNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriDatasetType eType;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Type

    // Call method on actual COM interface
    hr = self->m_pIAMSDatasetName->get_Type(&eType);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAMSDatasetName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAMSDatasetName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAMSDatasetName.get_Type() returned %ld", (long)hr);
        goto iamsdatasetname_get_type_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Type

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)eType);
    goto iamsdatasetname_get_type_method_cleanup;

    iamsdatasetname_get_type_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Type
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAMSDatasetName.get_Type");
    return return_tuple;
}

static PyObject*
IAMSDatasetNameMethod_get_Category(PyIAMSDatasetNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsCategory;
    PyObject* pyvar_Category = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Category

    // Call method on actual COM interface
    hr = self->m_pIAMSDatasetName->get_Category(&bsCategory);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAMSDatasetName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAMSDatasetName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAMSDatasetName.get_Category() returned %ld", (long)hr);
        goto iamsdatasetname_get_category_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Category = PyUnicode_FromWideChar(bsCategory,::SysStringLen(bsCategory));
    ::SysFreeString(bsCategory);
    
    if (PyErr_Occurred())
      goto iamsdatasetname_get_category_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Category);
    goto iamsdatasetname_get_category_method_cleanup;

    iamsdatasetname_get_category_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Category != Py_None)
        Py_XDECREF(pyvar_Category);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAMSDatasetName.get_Category");
    return return_tuple;
}

static PyObject*
IAMSDatasetNameMethod_put_Category(PyIAMSDatasetNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsCategory = 0;
    PyObject* pyvar_Category;
    PyObject* unicodeCategory = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_Category))
      goto iamsdatasetname_put_category_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_Category))
        unicodeCategory = PyUnicode_FromObject(pyvar_Category);
    else if (PyUnicode_Check(pyvar_Category))
    {
        unicodeCategory = pyvar_Category;
        Py_INCREF(unicodeCategory);
    }
    else if (pyvar_Category != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Category at index 0");
    if (unicodeCategory)
        bsCategory = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeCategory), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeCategory));
    
    if (PyErr_Occurred())
      goto iamsdatasetname_put_category_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIAMSDatasetName->put_Category(bsCategory);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAMSDatasetName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAMSDatasetName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAMSDatasetName.put_Category() returned %ld", (long)hr);
        goto iamsdatasetname_put_category_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Category

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iamsdatasetname_put_category_method_cleanup;

    iamsdatasetname_put_category_method_cleanup:
    self->m_HR = hr;
    if (bsCategory)
        ::SysFreeString(bsCategory);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAMSDatasetName.put_Category");
    return return_tuple;
}

static PyObject*
IAMSDatasetNameMethod_get_WorkspaceName(PyIAMSDatasetNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IWorkspaceName* ipWorkspaceName = NULL;
    PyObject* py_WorkspaceName = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for WorkspaceName

    // Call method on actual COM interface
    hr = self->m_pIAMSDatasetName->get_WorkspaceName(&ipWorkspaceName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAMSDatasetName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAMSDatasetName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAMSDatasetName.get_WorkspaceName() returned %ld", (long)hr);
        goto iamsdatasetname_get_workspacename_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_WorkspaceName);
    if (ipWorkspaceName)
    {
        IUnknown* pUnk = NULL;
        ipWorkspaceName->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_WorkspaceName = IUnknownToPythonIIDObject(pUnk, &IID_IWorkspaceName);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_WorkspaceName)
    {
        if (py_WorkspaceName)
           Py_DECREF(py_WorkspaceName);
        py_WorkspaceName = Py_None;
        Py_INCREF(py_WorkspaceName);
    }
    if (PyErr_Occurred())
      goto iamsdatasetname_get_workspacename_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_WorkspaceName);
    goto iamsdatasetname_get_workspacename_method_cleanup;

    iamsdatasetname_get_workspacename_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_WorkspaceName);
    if (ipWorkspaceName)
      ipWorkspaceName->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAMSDatasetName.get_WorkspaceName");
    return return_tuple;
}

static PyObject*
IAMSDatasetNameMethod_putref_WorkspaceName(PyIAMSDatasetNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IWorkspaceName* ipWorkspaceName = NULL;
    PyObject* py_WorkspaceName;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_WorkspaceName))
      goto iamsdatasetname_putref_workspacename_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_WorkspaceName, &IID_IWorkspaceName, (void**)&ipWorkspaceName))
        PyErr_SetString(PyExc_TypeError, "Argument WorkspaceName (position 0) is not IWorkspaceName");
    
    if (PyErr_Occurred())
      goto iamsdatasetname_putref_workspacename_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIAMSDatasetName->putref_WorkspaceName(ipWorkspaceName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAMSDatasetName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAMSDatasetName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAMSDatasetName.putref_WorkspaceName() returned %ld", (long)hr);
        goto iamsdatasetname_putref_workspacename_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for WorkspaceName

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iamsdatasetname_putref_workspacename_method_cleanup;

    iamsdatasetname_putref_workspacename_method_cleanup:
    self->m_HR = hr;
    if (ipWorkspaceName)
      ipWorkspaceName->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAMSDatasetName.putref_WorkspaceName");
    return return_tuple;
}

static PyObject*
IAMSDatasetNameMethod_get_SubsetNames(PyIAMSDatasetNameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IEnumDatasetName* ipSubsetNames = NULL;
    PyObject* py_SubsetNames = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for SubsetNames

    // Call method on actual COM interface
    hr = self->m_pIAMSDatasetName->get_SubsetNames(&ipSubsetNames);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAMSDatasetName->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAMSDatasetName) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAMSDatasetName.get_SubsetNames() returned %ld", (long)hr);
        goto iamsdatasetname_get_subsetnames_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_SubsetNames);
    if (ipSubsetNames)
    {
        IUnknown* pUnk = NULL;
        ipSubsetNames->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_SubsetNames = IUnknownToPythonIIDObject(pUnk, &IID_IEnumDatasetName);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_SubsetNames)
    {
        if (py_SubsetNames)
           Py_DECREF(py_SubsetNames);
        py_SubsetNames = Py_None;
        Py_INCREF(py_SubsetNames);
    }
    if (PyErr_Occurred())
      goto iamsdatasetname_get_subsetnames_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_SubsetNames);
    goto iamsdatasetname_get_subsetnames_method_cleanup;

    iamsdatasetname_get_subsetnames_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_SubsetNames);
    if (ipSubsetNames)
      ipSubsetNames->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAMSDatasetName.get_SubsetNames");
    return return_tuple;
}


PyMethodDef PyIAMSDatasetNameMethods[] = {
    {"supports", (PyCFunction)PyIAMSDatasetName_SupportsInterface, METH_O, ""},
    {"get_Visible", (PyCFunction)IAMSDatasetNameMethod_get_Visible, METH_VARARGS, ""},
    {"put_Visible", (PyCFunction)IAMSDatasetNameMethod_put_Visible, METH_VARARGS, ""},
    {"get_TemporalColumnName", (PyCFunction)IAMSDatasetNameMethod_get_TemporalColumnName, METH_VARARGS, ""},
    {"get_TrackingService", (PyCFunction)IAMSDatasetNameMethod_get_TrackingService, METH_VARARGS, ""},
    {"putref_TrackingService", (PyCFunction)IAMSDatasetNameMethod_putref_TrackingService, METH_VARARGS, ""},
    {"get_ShapeType", (PyCFunction)IAMSDatasetNameMethod_get_ShapeType, METH_VARARGS, ""},
    {"put_ShapeType", (PyCFunction)IAMSDatasetNameMethod_put_ShapeType, METH_VARARGS, ""},
    {"get_FeatureDatasetName", (PyCFunction)IAMSDatasetNameMethod_get_FeatureDatasetName, METH_VARARGS, ""},
    {"putref_FeatureDatasetName", (PyCFunction)IAMSDatasetNameMethod_putref_FeatureDatasetName, METH_VARARGS, ""},
    {"get_FeatureType", (PyCFunction)IAMSDatasetNameMethod_get_FeatureType, METH_VARARGS, ""},
    {"put_FeatureType", (PyCFunction)IAMSDatasetNameMethod_put_FeatureType, METH_VARARGS, ""},
    {"get_ShapeFieldName", (PyCFunction)IAMSDatasetNameMethod_get_ShapeFieldName, METH_VARARGS, ""},
    {"put_ShapeFieldName", (PyCFunction)IAMSDatasetNameMethod_put_ShapeFieldName, METH_VARARGS, ""},
    {"get_Name", (PyCFunction)IAMSDatasetNameMethod_get_Name, METH_VARARGS, ""},
    {"put_Name", (PyCFunction)IAMSDatasetNameMethod_put_Name, METH_VARARGS, ""},
    {"get_Type", (PyCFunction)IAMSDatasetNameMethod_get_Type, METH_VARARGS, ""},
    {"get_Category", (PyCFunction)IAMSDatasetNameMethod_get_Category, METH_VARARGS, ""},
    {"put_Category", (PyCFunction)IAMSDatasetNameMethod_put_Category, METH_VARARGS, ""},
    {"get_WorkspaceName", (PyCFunction)IAMSDatasetNameMethod_get_WorkspaceName, METH_VARARGS, ""},
    {"putref_WorkspaceName", (PyCFunction)IAMSDatasetNameMethod_putref_WorkspaceName, METH_VARARGS, ""},
    {"get_SubsetNames", (PyCFunction)IAMSDatasetNameMethod_get_SubsetNames, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIAMSDatasetNameGetSet[] = {
  {"_pUnk", (getter)PyIAMSDatasetName_GetpUnk, NULL, "Get opaque pointer to an Unknown from IAMSDatasetName", NULL},
  {"_pointer", (getter)PyIAMSDatasetName_GetPointer, NULL, "Get memory address for IAMSDatasetName", NULL},
  {"_IID", (getter)PyIAMSDatasetName_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIAMSDatasetName_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIAMSDatasetName_GetIgnoreFailures, (setter)PyIAMSDatasetName_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIAMSDatasetNameObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.IAMSDatasetNameObject",                          
                                              /* tp_name */
  sizeof(PyIAMSDatasetNameObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIAMSDatasetNameObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIAMSDatasetNameMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIAMSDatasetNameGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIAMSDatasetNameObject_new,                      
                                              /* tp_new */
};

// Interface ITemporalFeatureClassStatistics

typedef struct PyITemporalFeatureClassStatisticsObject {
    PyObject_HEAD
    ITemporalFeatureClassStatistics* m_pITemporalFeatureClassStatistics;
    HRESULT m_HR;
    int m_ignore_failures;
} PyITemporalFeatureClassStatisticsObject;

static PyObject*
PyITemporalFeatureClassStatisticsObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyITemporalFeatureClassStatisticsObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ITemporalFeatureClassStatistics* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ITemporalFeatureClassStatistics, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ITemporalFeatureClassStatistics with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyITemporalFeatureClassStatisticsObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ITemporalFeatureClassStatistics");
            return NULL;
        }
        self->m_pITemporalFeatureClassStatistics = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ITemporalFeatureClassStatistics");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ITemporalFeatureClassStatistics");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ITemporalFeatureClassStatistics* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ITemporalFeatureClassStatistics, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ITemporalFeatureClassStatistics");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyITemporalFeatureClassStatisticsObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ITemporalFeatureClassStatistics");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pITemporalFeatureClassStatistics = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyITemporalFeatureClassStatisticsObject_dealloc(PyITemporalFeatureClassStatisticsObject* self)
{
    if (self->m_pITemporalFeatureClassStatistics)
        self->m_pITemporalFeatureClassStatistics->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyITemporalFeatureClassStatistics_GetpUnk(PyITemporalFeatureClassStatisticsObject* self)
{
    if (!self->m_pITemporalFeatureClassStatistics)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pITemporalFeatureClassStatistics->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ITemporalFeatureClassStatistics to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyITemporalFeatureClassStatistics_GetPointer(PyITemporalFeatureClassStatisticsObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pITemporalFeatureClassStatistics);
}

static PyObject*
PyITemporalFeatureClassStatistics_GetIID(PyITemporalFeatureClassStatisticsObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "5f007f4d-9fae-463c-a3d6-0aad83eb59a5");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyITemporalFeatureClassStatistics_GetHR(PyITemporalFeatureClassStatisticsObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyITemporalFeatureClassStatistics_GetIgnoreFailures(PyITemporalFeatureClassStatisticsObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyITemporalFeatureClassStatistics_SetIgnoreFailures(PyITemporalFeatureClassStatisticsObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyITemporalFeatureClassStatistics_SupportsInterface(PyITemporalFeatureClassStatisticsObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pITemporalFeatureClassStatistics->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ITemporalFeatureClassStatisticsMethod_get_TrackCount(PyITemporalFeatureClassStatisticsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lplTrackCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for plTrackCount

    // Call method on actual COM interface
    hr = self->m_pITemporalFeatureClassStatistics->get_TrackCount(&lplTrackCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalFeatureClassStatistics->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalFeatureClassStatistics) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalFeatureClassStatistics.get_TrackCount() returned %ld", (long)hr);
        goto itemporalfeatureclassstatistics_get_trackcount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for plTrackCount

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lplTrackCount);
    goto itemporalfeatureclassstatistics_get_trackcount_method_cleanup;

    itemporalfeatureclassstatistics_get_trackcount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for plTrackCount
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalFeatureClassStatistics.get_TrackCount");
    return return_tuple;
}

static PyObject*
ITemporalFeatureClassStatisticsMethod_get_MessageRate(PyITemporalFeatureClassStatisticsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dpdMessageRate = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pdMessageRate

    // Call method on actual COM interface
    hr = self->m_pITemporalFeatureClassStatistics->get_MessageRate(&dpdMessageRate);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalFeatureClassStatistics->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalFeatureClassStatistics) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalFeatureClassStatistics.get_MessageRate() returned %ld", (long)hr);
        goto itemporalfeatureclassstatistics_get_messagerate_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pdMessageRate

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dpdMessageRate);
    goto itemporalfeatureclassstatistics_get_messagerate_method_cleanup;

    itemporalfeatureclassstatistics_get_messagerate_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pdMessageRate
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalFeatureClassStatistics.get_MessageRate");
    return return_tuple;
}

static PyObject*
ITemporalFeatureClassStatisticsMethod_get_SampleSize(PyITemporalFeatureClassStatisticsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lplSampleSize = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for plSampleSize

    // Call method on actual COM interface
    hr = self->m_pITemporalFeatureClassStatistics->get_SampleSize(&lplSampleSize);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalFeatureClassStatistics->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalFeatureClassStatistics) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalFeatureClassStatistics.get_SampleSize() returned %ld", (long)hr);
        goto itemporalfeatureclassstatistics_get_samplesize_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for plSampleSize

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lplSampleSize);
    goto itemporalfeatureclassstatistics_get_samplesize_method_cleanup;

    itemporalfeatureclassstatistics_get_samplesize_method_cleanup:
    self->m_HR = hr;
    // No cleanup for plSampleSize
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalFeatureClassStatistics.get_SampleSize");
    return return_tuple;
}

static PyObject*
ITemporalFeatureClassStatisticsMethod_put_SampleSize(PyITemporalFeatureClassStatisticsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lplSampleSize = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lplSampleSize))
      goto itemporalfeatureclassstatistics_put_samplesize_method_cleanup;

    // Set up initial variable values as needed
    // No setup for plSampleSize

    // Call method on actual COM interface
    hr = self->m_pITemporalFeatureClassStatistics->put_SampleSize(lplSampleSize);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalFeatureClassStatistics->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalFeatureClassStatistics) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalFeatureClassStatistics.put_SampleSize() returned %ld", (long)hr);
        goto itemporalfeatureclassstatistics_put_samplesize_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for plSampleSize

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto itemporalfeatureclassstatistics_put_samplesize_method_cleanup;

    itemporalfeatureclassstatistics_put_samplesize_method_cleanup:
    self->m_HR = hr;
    // No cleanup for plSampleSize
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalFeatureClassStatistics.put_SampleSize");
    return return_tuple;
}

static PyObject*
ITemporalFeatureClassStatisticsMethod_get_TotalFeatureCount(PyITemporalFeatureClassStatisticsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT vpvarTotalFeatureCount;
    ::VariantInit(&vpvarTotalFeatureCount);
    PyObject* pyvar_pvarTotalFeatureCount = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pvarTotalFeatureCount

    // Call method on actual COM interface
    hr = self->m_pITemporalFeatureClassStatistics->get_TotalFeatureCount(&vpvarTotalFeatureCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalFeatureClassStatistics->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalFeatureClassStatistics) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalFeatureClassStatistics.get_TotalFeatureCount() returned %ld", (long)hr);
        goto itemporalfeatureclassstatistics_get_totalfeaturecount_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pvarTotalFeatureCount = Variant_AsPyObject(&vpvarTotalFeatureCount);
    if (PyErr_Occurred())
      goto itemporalfeatureclassstatistics_get_totalfeaturecount_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pvarTotalFeatureCount);
    goto itemporalfeatureclassstatistics_get_totalfeaturecount_method_cleanup;

    itemporalfeatureclassstatistics_get_totalfeaturecount_method_cleanup:
    self->m_HR = hr;
    ::VariantClear(&vpvarTotalFeatureCount);
    Py_XDECREF(pyvar_pvarTotalFeatureCount);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalFeatureClassStatistics.get_TotalFeatureCount");
    return return_tuple;
}

static PyObject*
ITemporalFeatureClassStatisticsMethod_ResetFeatureCount(PyITemporalFeatureClassStatisticsObject* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pITemporalFeatureClassStatistics->ResetFeatureCount();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalFeatureClassStatistics->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalFeatureClassStatistics) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalFeatureClassStatistics.ResetFeatureCount() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}

static PyObject*
ITemporalFeatureClassStatisticsMethod_ResetMessageRate(PyITemporalFeatureClassStatisticsObject* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pITemporalFeatureClassStatistics->ResetMessageRate();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalFeatureClassStatistics->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalFeatureClassStatistics) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalFeatureClassStatistics.ResetMessageRate() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}


PyMethodDef PyITemporalFeatureClassStatisticsMethods[] = {
    {"supports", (PyCFunction)PyITemporalFeatureClassStatistics_SupportsInterface, METH_O, ""},
    {"get_TrackCount", (PyCFunction)ITemporalFeatureClassStatisticsMethod_get_TrackCount, METH_VARARGS, ""},
    {"get_MessageRate", (PyCFunction)ITemporalFeatureClassStatisticsMethod_get_MessageRate, METH_VARARGS, ""},
    {"get_SampleSize", (PyCFunction)ITemporalFeatureClassStatisticsMethod_get_SampleSize, METH_VARARGS, ""},
    {"put_SampleSize", (PyCFunction)ITemporalFeatureClassStatisticsMethod_put_SampleSize, METH_VARARGS, ""},
    {"get_TotalFeatureCount", (PyCFunction)ITemporalFeatureClassStatisticsMethod_get_TotalFeatureCount, METH_VARARGS, ""},
    {"ResetFeatureCount", (PyCFunction)ITemporalFeatureClassStatisticsMethod_ResetFeatureCount, METH_NOARGS, ""},
    {"ResetMessageRate", (PyCFunction)ITemporalFeatureClassStatisticsMethod_ResetMessageRate, METH_NOARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyITemporalFeatureClassStatisticsGetSet[] = {
  {"_pUnk", (getter)PyITemporalFeatureClassStatistics_GetpUnk, NULL, "Get opaque pointer to an Unknown from ITemporalFeatureClassStatistics", NULL},
  {"_pointer", (getter)PyITemporalFeatureClassStatistics_GetPointer, NULL, "Get memory address for ITemporalFeatureClassStatistics", NULL},
  {"_IID", (getter)PyITemporalFeatureClassStatistics_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyITemporalFeatureClassStatistics_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyITemporalFeatureClassStatistics_GetIgnoreFailures, (setter)PyITemporalFeatureClassStatistics_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyITemporalFeatureClassStatisticsObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.ITemporalFeatureClassStatisticsObject",                          
                                              /* tp_name */
  sizeof(PyITemporalFeatureClassStatisticsObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyITemporalFeatureClassStatisticsObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyITemporalFeatureClassStatisticsMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyITemporalFeatureClassStatisticsGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyITemporalFeatureClassStatisticsObject_new,                      
                                              /* tp_new */
};

// Interface ITemporalWorkspaceStatistics

typedef struct PyITemporalWorkspaceStatisticsObject {
    PyObject_HEAD
    ITemporalWorkspaceStatistics* m_pITemporalWorkspaceStatistics;
    HRESULT m_HR;
    int m_ignore_failures;
} PyITemporalWorkspaceStatisticsObject;

static PyObject*
PyITemporalWorkspaceStatisticsObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyITemporalWorkspaceStatisticsObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ITemporalWorkspaceStatistics* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ITemporalWorkspaceStatistics, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ITemporalWorkspaceStatistics with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyITemporalWorkspaceStatisticsObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ITemporalWorkspaceStatistics");
            return NULL;
        }
        self->m_pITemporalWorkspaceStatistics = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ITemporalWorkspaceStatistics");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ITemporalWorkspaceStatistics");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ITemporalWorkspaceStatistics* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ITemporalWorkspaceStatistics, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ITemporalWorkspaceStatistics");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyITemporalWorkspaceStatisticsObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ITemporalWorkspaceStatistics");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pITemporalWorkspaceStatistics = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyITemporalWorkspaceStatisticsObject_dealloc(PyITemporalWorkspaceStatisticsObject* self)
{
    if (self->m_pITemporalWorkspaceStatistics)
        self->m_pITemporalWorkspaceStatistics->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyITemporalWorkspaceStatistics_GetpUnk(PyITemporalWorkspaceStatisticsObject* self)
{
    if (!self->m_pITemporalWorkspaceStatistics)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pITemporalWorkspaceStatistics->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ITemporalWorkspaceStatistics to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyITemporalWorkspaceStatistics_GetPointer(PyITemporalWorkspaceStatisticsObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pITemporalWorkspaceStatistics);
}

static PyObject*
PyITemporalWorkspaceStatistics_GetIID(PyITemporalWorkspaceStatisticsObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "052ac5b2-cdc1-479d-b69e-479e34a2c071");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyITemporalWorkspaceStatistics_GetHR(PyITemporalWorkspaceStatisticsObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyITemporalWorkspaceStatistics_GetIgnoreFailures(PyITemporalWorkspaceStatisticsObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyITemporalWorkspaceStatistics_SetIgnoreFailures(PyITemporalWorkspaceStatisticsObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyITemporalWorkspaceStatistics_SupportsInterface(PyITemporalWorkspaceStatisticsObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pITemporalWorkspaceStatistics->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ITemporalWorkspaceStatisticsMethod_get_AllTrackCounts(PyITemporalWorkspaceStatisticsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IPropertySet* ipppiAllTrackCounts = NULL;
    PyObject* py_ppiAllTrackCounts = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppiAllTrackCounts

    // Call method on actual COM interface
    hr = self->m_pITemporalWorkspaceStatistics->get_AllTrackCounts(&ipppiAllTrackCounts);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalWorkspaceStatistics->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalWorkspaceStatistics) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalWorkspaceStatistics.get_AllTrackCounts() returned %ld", (long)hr);
        goto itemporalworkspacestatistics_get_alltrackcounts_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppiAllTrackCounts);
    if (ipppiAllTrackCounts)
    {
        IUnknown* pUnk = NULL;
        ipppiAllTrackCounts->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppiAllTrackCounts = IUnknownToPythonIIDObject(pUnk, &IID_IPropertySet);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppiAllTrackCounts)
    {
        if (py_ppiAllTrackCounts)
           Py_DECREF(py_ppiAllTrackCounts);
        py_ppiAllTrackCounts = Py_None;
        Py_INCREF(py_ppiAllTrackCounts);
    }
    if (PyErr_Occurred())
      goto itemporalworkspacestatistics_get_alltrackcounts_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppiAllTrackCounts);
    goto itemporalworkspacestatistics_get_alltrackcounts_method_cleanup;

    itemporalworkspacestatistics_get_alltrackcounts_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppiAllTrackCounts);
    if (ipppiAllTrackCounts)
      ipppiAllTrackCounts->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalWorkspaceStatistics.get_AllTrackCounts");
    return return_tuple;
}

static PyObject*
ITemporalWorkspaceStatisticsMethod_get_AllMessageRates(PyITemporalWorkspaceStatisticsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IPropertySet* ipppiAllMessageRates = NULL;
    PyObject* py_ppiAllMessageRates = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppiAllMessageRates

    // Call method on actual COM interface
    hr = self->m_pITemporalWorkspaceStatistics->get_AllMessageRates(&ipppiAllMessageRates);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalWorkspaceStatistics->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalWorkspaceStatistics) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalWorkspaceStatistics.get_AllMessageRates() returned %ld", (long)hr);
        goto itemporalworkspacestatistics_get_allmessagerates_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppiAllMessageRates);
    if (ipppiAllMessageRates)
    {
        IUnknown* pUnk = NULL;
        ipppiAllMessageRates->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppiAllMessageRates = IUnknownToPythonIIDObject(pUnk, &IID_IPropertySet);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppiAllMessageRates)
    {
        if (py_ppiAllMessageRates)
           Py_DECREF(py_ppiAllMessageRates);
        py_ppiAllMessageRates = Py_None;
        Py_INCREF(py_ppiAllMessageRates);
    }
    if (PyErr_Occurred())
      goto itemporalworkspacestatistics_get_allmessagerates_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppiAllMessageRates);
    goto itemporalworkspacestatistics_get_allmessagerates_method_cleanup;

    itemporalworkspacestatistics_get_allmessagerates_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppiAllMessageRates);
    if (ipppiAllMessageRates)
      ipppiAllMessageRates->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalWorkspaceStatistics.get_AllMessageRates");
    return return_tuple;
}

static PyObject*
ITemporalWorkspaceStatisticsMethod_get_AllSampleSizes(PyITemporalWorkspaceStatisticsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IPropertySet* ipppiAllSampleSizes = NULL;
    PyObject* py_ppiAllSampleSizes = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppiAllSampleSizes

    // Call method on actual COM interface
    hr = self->m_pITemporalWorkspaceStatistics->get_AllSampleSizes(&ipppiAllSampleSizes);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalWorkspaceStatistics->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalWorkspaceStatistics) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalWorkspaceStatistics.get_AllSampleSizes() returned %ld", (long)hr);
        goto itemporalworkspacestatistics_get_allsamplesizes_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppiAllSampleSizes);
    if (ipppiAllSampleSizes)
    {
        IUnknown* pUnk = NULL;
        ipppiAllSampleSizes->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppiAllSampleSizes = IUnknownToPythonIIDObject(pUnk, &IID_IPropertySet);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppiAllSampleSizes)
    {
        if (py_ppiAllSampleSizes)
           Py_DECREF(py_ppiAllSampleSizes);
        py_ppiAllSampleSizes = Py_None;
        Py_INCREF(py_ppiAllSampleSizes);
    }
    if (PyErr_Occurred())
      goto itemporalworkspacestatistics_get_allsamplesizes_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppiAllSampleSizes);
    goto itemporalworkspacestatistics_get_allsamplesizes_method_cleanup;

    itemporalworkspacestatistics_get_allsamplesizes_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppiAllSampleSizes);
    if (ipppiAllSampleSizes)
      ipppiAllSampleSizes->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalWorkspaceStatistics.get_AllSampleSizes");
    return return_tuple;
}

static PyObject*
ITemporalWorkspaceStatisticsMethod_get_AllTotalFeatureCounts(PyITemporalWorkspaceStatisticsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IPropertySet* ipppiAllTotalFeatureCounts = NULL;
    PyObject* py_ppiAllTotalFeatureCounts = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppiAllTotalFeatureCounts

    // Call method on actual COM interface
    hr = self->m_pITemporalWorkspaceStatistics->get_AllTotalFeatureCounts(&ipppiAllTotalFeatureCounts);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalWorkspaceStatistics->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalWorkspaceStatistics) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalWorkspaceStatistics.get_AllTotalFeatureCounts() returned %ld", (long)hr);
        goto itemporalworkspacestatistics_get_alltotalfeaturecounts_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppiAllTotalFeatureCounts);
    if (ipppiAllTotalFeatureCounts)
    {
        IUnknown* pUnk = NULL;
        ipppiAllTotalFeatureCounts->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppiAllTotalFeatureCounts = IUnknownToPythonIIDObject(pUnk, &IID_IPropertySet);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppiAllTotalFeatureCounts)
    {
        if (py_ppiAllTotalFeatureCounts)
           Py_DECREF(py_ppiAllTotalFeatureCounts);
        py_ppiAllTotalFeatureCounts = Py_None;
        Py_INCREF(py_ppiAllTotalFeatureCounts);
    }
    if (PyErr_Occurred())
      goto itemporalworkspacestatistics_get_alltotalfeaturecounts_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppiAllTotalFeatureCounts);
    goto itemporalworkspacestatistics_get_alltotalfeaturecounts_method_cleanup;

    itemporalworkspacestatistics_get_alltotalfeaturecounts_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppiAllTotalFeatureCounts);
    if (ipppiAllTotalFeatureCounts)
      ipppiAllTotalFeatureCounts->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalWorkspaceStatistics.get_AllTotalFeatureCounts");
    return return_tuple;
}

static PyObject*
ITemporalWorkspaceStatisticsMethod_get_ConnectionStatus(PyITemporalWorkspaceStatisticsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IPropertySet* ipppiConnectionStatus = NULL;
    PyObject* py_ppiConnectionStatus = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppiConnectionStatus

    // Call method on actual COM interface
    hr = self->m_pITemporalWorkspaceStatistics->get_ConnectionStatus(&ipppiConnectionStatus);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalWorkspaceStatistics->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalWorkspaceStatistics) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalWorkspaceStatistics.get_ConnectionStatus() returned %ld", (long)hr);
        goto itemporalworkspacestatistics_get_connectionstatus_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppiConnectionStatus);
    if (ipppiConnectionStatus)
    {
        IUnknown* pUnk = NULL;
        ipppiConnectionStatus->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppiConnectionStatus = IUnknownToPythonIIDObject(pUnk, &IID_IPropertySet);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppiConnectionStatus)
    {
        if (py_ppiConnectionStatus)
           Py_DECREF(py_ppiConnectionStatus);
        py_ppiConnectionStatus = Py_None;
        Py_INCREF(py_ppiConnectionStatus);
    }
    if (PyErr_Occurred())
      goto itemporalworkspacestatistics_get_connectionstatus_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppiConnectionStatus);
    goto itemporalworkspacestatistics_get_connectionstatus_method_cleanup;

    itemporalworkspacestatistics_get_connectionstatus_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppiConnectionStatus);
    if (ipppiConnectionStatus)
      ipppiConnectionStatus->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalWorkspaceStatistics.get_ConnectionStatus");
    return return_tuple;
}

static PyObject*
ITemporalWorkspaceStatisticsMethod_get_ReceivedMessageCounts(PyITemporalWorkspaceStatisticsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IPropertySet* ipppiReceivedMsgCounts = NULL;
    PyObject* py_ppiReceivedMsgCounts = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppiReceivedMsgCounts

    // Call method on actual COM interface
    hr = self->m_pITemporalWorkspaceStatistics->get_ReceivedMessageCounts(&ipppiReceivedMsgCounts);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalWorkspaceStatistics->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalWorkspaceStatistics) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalWorkspaceStatistics.get_ReceivedMessageCounts() returned %ld", (long)hr);
        goto itemporalworkspacestatistics_get_receivedmessagecounts_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppiReceivedMsgCounts);
    if (ipppiReceivedMsgCounts)
    {
        IUnknown* pUnk = NULL;
        ipppiReceivedMsgCounts->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppiReceivedMsgCounts = IUnknownToPythonIIDObject(pUnk, &IID_IPropertySet);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppiReceivedMsgCounts)
    {
        if (py_ppiReceivedMsgCounts)
           Py_DECREF(py_ppiReceivedMsgCounts);
        py_ppiReceivedMsgCounts = Py_None;
        Py_INCREF(py_ppiReceivedMsgCounts);
    }
    if (PyErr_Occurred())
      goto itemporalworkspacestatistics_get_receivedmessagecounts_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppiReceivedMsgCounts);
    goto itemporalworkspacestatistics_get_receivedmessagecounts_method_cleanup;

    itemporalworkspacestatistics_get_receivedmessagecounts_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppiReceivedMsgCounts);
    if (ipppiReceivedMsgCounts)
      ipppiReceivedMsgCounts->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalWorkspaceStatistics.get_ReceivedMessageCounts");
    return return_tuple;
}

static PyObject*
ITemporalWorkspaceStatisticsMethod_get_PulledMessageCounts(PyITemporalWorkspaceStatisticsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IPropertySet* ipppiPulledMsgCounts = NULL;
    PyObject* py_ppiPulledMsgCounts = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppiPulledMsgCounts

    // Call method on actual COM interface
    hr = self->m_pITemporalWorkspaceStatistics->get_PulledMessageCounts(&ipppiPulledMsgCounts);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalWorkspaceStatistics->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalWorkspaceStatistics) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalWorkspaceStatistics.get_PulledMessageCounts() returned %ld", (long)hr);
        goto itemporalworkspacestatistics_get_pulledmessagecounts_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppiPulledMsgCounts);
    if (ipppiPulledMsgCounts)
    {
        IUnknown* pUnk = NULL;
        ipppiPulledMsgCounts->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppiPulledMsgCounts = IUnknownToPythonIIDObject(pUnk, &IID_IPropertySet);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppiPulledMsgCounts)
    {
        if (py_ppiPulledMsgCounts)
           Py_DECREF(py_ppiPulledMsgCounts);
        py_ppiPulledMsgCounts = Py_None;
        Py_INCREF(py_ppiPulledMsgCounts);
    }
    if (PyErr_Occurred())
      goto itemporalworkspacestatistics_get_pulledmessagecounts_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppiPulledMsgCounts);
    goto itemporalworkspacestatistics_get_pulledmessagecounts_method_cleanup;

    itemporalworkspacestatistics_get_pulledmessagecounts_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppiPulledMsgCounts);
    if (ipppiPulledMsgCounts)
      ipppiPulledMsgCounts->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalWorkspaceStatistics.get_PulledMessageCounts");
    return return_tuple;
}

static PyObject*
ITemporalWorkspaceStatisticsMethod_get_DiscardedMessageCounts(PyITemporalWorkspaceStatisticsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IPropertySet* ipppiDiscardedMsgCounts = NULL;
    PyObject* py_ppiDiscardedMsgCounts = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppiDiscardedMsgCounts

    // Call method on actual COM interface
    hr = self->m_pITemporalWorkspaceStatistics->get_DiscardedMessageCounts(&ipppiDiscardedMsgCounts);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalWorkspaceStatistics->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalWorkspaceStatistics) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalWorkspaceStatistics.get_DiscardedMessageCounts() returned %ld", (long)hr);
        goto itemporalworkspacestatistics_get_discardedmessagecounts_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppiDiscardedMsgCounts);
    if (ipppiDiscardedMsgCounts)
    {
        IUnknown* pUnk = NULL;
        ipppiDiscardedMsgCounts->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppiDiscardedMsgCounts = IUnknownToPythonIIDObject(pUnk, &IID_IPropertySet);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppiDiscardedMsgCounts)
    {
        if (py_ppiDiscardedMsgCounts)
           Py_DECREF(py_ppiDiscardedMsgCounts);
        py_ppiDiscardedMsgCounts = Py_None;
        Py_INCREF(py_ppiDiscardedMsgCounts);
    }
    if (PyErr_Occurred())
      goto itemporalworkspacestatistics_get_discardedmessagecounts_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppiDiscardedMsgCounts);
    goto itemporalworkspacestatistics_get_discardedmessagecounts_method_cleanup;

    itemporalworkspacestatistics_get_discardedmessagecounts_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppiDiscardedMsgCounts);
    if (ipppiDiscardedMsgCounts)
      ipppiDiscardedMsgCounts->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalWorkspaceStatistics.get_DiscardedMessageCounts");
    return return_tuple;
}

static PyObject*
ITemporalWorkspaceStatisticsMethod_get_CurrentDiscardedMessageCounts(PyITemporalWorkspaceStatisticsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IPropertySet* ipppiCurDiscardedMsgCounts = NULL;
    PyObject* py_ppiCurDiscardedMsgCounts = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppiCurDiscardedMsgCounts

    // Call method on actual COM interface
    hr = self->m_pITemporalWorkspaceStatistics->get_CurrentDiscardedMessageCounts(&ipppiCurDiscardedMsgCounts);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalWorkspaceStatistics->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalWorkspaceStatistics) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalWorkspaceStatistics.get_CurrentDiscardedMessageCounts() returned %ld", (long)hr);
        goto itemporalworkspacestatistics_get_currentdiscardedmessagecounts_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppiCurDiscardedMsgCounts);
    if (ipppiCurDiscardedMsgCounts)
    {
        IUnknown* pUnk = NULL;
        ipppiCurDiscardedMsgCounts->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppiCurDiscardedMsgCounts = IUnknownToPythonIIDObject(pUnk, &IID_IPropertySet);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppiCurDiscardedMsgCounts)
    {
        if (py_ppiCurDiscardedMsgCounts)
           Py_DECREF(py_ppiCurDiscardedMsgCounts);
        py_ppiCurDiscardedMsgCounts = Py_None;
        Py_INCREF(py_ppiCurDiscardedMsgCounts);
    }
    if (PyErr_Occurred())
      goto itemporalworkspacestatistics_get_currentdiscardedmessagecounts_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppiCurDiscardedMsgCounts);
    goto itemporalworkspacestatistics_get_currentdiscardedmessagecounts_method_cleanup;

    itemporalworkspacestatistics_get_currentdiscardedmessagecounts_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppiCurDiscardedMsgCounts);
    if (ipppiCurDiscardedMsgCounts)
      ipppiCurDiscardedMsgCounts->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalWorkspaceStatistics.get_CurrentDiscardedMessageCounts");
    return return_tuple;
}

static PyObject*
ITemporalWorkspaceStatisticsMethod_get_QueuedMessageCounts(PyITemporalWorkspaceStatisticsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IPropertySet* ipppiQueuedMsgCounts = NULL;
    PyObject* py_ppiQueuedMsgCounts = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppiQueuedMsgCounts

    // Call method on actual COM interface
    hr = self->m_pITemporalWorkspaceStatistics->get_QueuedMessageCounts(&ipppiQueuedMsgCounts);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalWorkspaceStatistics->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalWorkspaceStatistics) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalWorkspaceStatistics.get_QueuedMessageCounts() returned %ld", (long)hr);
        goto itemporalworkspacestatistics_get_queuedmessagecounts_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppiQueuedMsgCounts);
    if (ipppiQueuedMsgCounts)
    {
        IUnknown* pUnk = NULL;
        ipppiQueuedMsgCounts->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppiQueuedMsgCounts = IUnknownToPythonIIDObject(pUnk, &IID_IPropertySet);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppiQueuedMsgCounts)
    {
        if (py_ppiQueuedMsgCounts)
           Py_DECREF(py_ppiQueuedMsgCounts);
        py_ppiQueuedMsgCounts = Py_None;
        Py_INCREF(py_ppiQueuedMsgCounts);
    }
    if (PyErr_Occurred())
      goto itemporalworkspacestatistics_get_queuedmessagecounts_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppiQueuedMsgCounts);
    goto itemporalworkspacestatistics_get_queuedmessagecounts_method_cleanup;

    itemporalworkspacestatistics_get_queuedmessagecounts_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppiQueuedMsgCounts);
    if (ipppiQueuedMsgCounts)
      ipppiQueuedMsgCounts->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalWorkspaceStatistics.get_QueuedMessageCounts");
    return return_tuple;
}

static PyObject*
ITemporalWorkspaceStatisticsMethod_ResetAllFeatureCounts(PyITemporalWorkspaceStatisticsObject* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pITemporalWorkspaceStatistics->ResetAllFeatureCounts();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalWorkspaceStatistics->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalWorkspaceStatistics) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalWorkspaceStatistics.ResetAllFeatureCounts() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}

static PyObject*
ITemporalWorkspaceStatisticsMethod_ResetAllMessageRates(PyITemporalWorkspaceStatisticsObject* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pITemporalWorkspaceStatistics->ResetAllMessageRates();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalWorkspaceStatistics->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalWorkspaceStatistics) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalWorkspaceStatistics.ResetAllMessageRates() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}

static PyObject*
ITemporalWorkspaceStatisticsMethod_SetAllSampleSizes(PyITemporalWorkspaceStatisticsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long llSampleSize = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &llSampleSize))
      goto itemporalworkspacestatistics_setallsamplesizes_method_cleanup;

    // Set up initial variable values as needed
    // No setup for lSampleSize

    // Call method on actual COM interface
    hr = self->m_pITemporalWorkspaceStatistics->SetAllSampleSizes(llSampleSize);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalWorkspaceStatistics->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalWorkspaceStatistics) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalWorkspaceStatistics.SetAllSampleSizes() returned %ld", (long)hr);
        goto itemporalworkspacestatistics_setallsamplesizes_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for lSampleSize

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto itemporalworkspacestatistics_setallsamplesizes_method_cleanup;

    itemporalworkspacestatistics_setallsamplesizes_method_cleanup:
    self->m_HR = hr;
    // No cleanup for lSampleSize
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalWorkspaceStatistics.SetAllSampleSizes");
    return return_tuple;
}


PyMethodDef PyITemporalWorkspaceStatisticsMethods[] = {
    {"supports", (PyCFunction)PyITemporalWorkspaceStatistics_SupportsInterface, METH_O, ""},
    {"get_AllTrackCounts", (PyCFunction)ITemporalWorkspaceStatisticsMethod_get_AllTrackCounts, METH_VARARGS, ""},
    {"get_AllMessageRates", (PyCFunction)ITemporalWorkspaceStatisticsMethod_get_AllMessageRates, METH_VARARGS, ""},
    {"get_AllSampleSizes", (PyCFunction)ITemporalWorkspaceStatisticsMethod_get_AllSampleSizes, METH_VARARGS, ""},
    {"get_AllTotalFeatureCounts", (PyCFunction)ITemporalWorkspaceStatisticsMethod_get_AllTotalFeatureCounts, METH_VARARGS, ""},
    {"get_ConnectionStatus", (PyCFunction)ITemporalWorkspaceStatisticsMethod_get_ConnectionStatus, METH_VARARGS, ""},
    {"get_ReceivedMessageCounts", (PyCFunction)ITemporalWorkspaceStatisticsMethod_get_ReceivedMessageCounts, METH_VARARGS, ""},
    {"get_PulledMessageCounts", (PyCFunction)ITemporalWorkspaceStatisticsMethod_get_PulledMessageCounts, METH_VARARGS, ""},
    {"get_DiscardedMessageCounts", (PyCFunction)ITemporalWorkspaceStatisticsMethod_get_DiscardedMessageCounts, METH_VARARGS, ""},
    {"get_CurrentDiscardedMessageCounts", (PyCFunction)ITemporalWorkspaceStatisticsMethod_get_CurrentDiscardedMessageCounts, METH_VARARGS, ""},
    {"get_QueuedMessageCounts", (PyCFunction)ITemporalWorkspaceStatisticsMethod_get_QueuedMessageCounts, METH_VARARGS, ""},
    {"ResetAllFeatureCounts", (PyCFunction)ITemporalWorkspaceStatisticsMethod_ResetAllFeatureCounts, METH_NOARGS, ""},
    {"ResetAllMessageRates", (PyCFunction)ITemporalWorkspaceStatisticsMethod_ResetAllMessageRates, METH_NOARGS, ""},
    {"SetAllSampleSizes", (PyCFunction)ITemporalWorkspaceStatisticsMethod_SetAllSampleSizes, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyITemporalWorkspaceStatisticsGetSet[] = {
  {"_pUnk", (getter)PyITemporalWorkspaceStatistics_GetpUnk, NULL, "Get opaque pointer to an Unknown from ITemporalWorkspaceStatistics", NULL},
  {"_pointer", (getter)PyITemporalWorkspaceStatistics_GetPointer, NULL, "Get memory address for ITemporalWorkspaceStatistics", NULL},
  {"_IID", (getter)PyITemporalWorkspaceStatistics_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyITemporalWorkspaceStatistics_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyITemporalWorkspaceStatistics_GetIgnoreFailures, (setter)PyITemporalWorkspaceStatistics_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyITemporalWorkspaceStatisticsObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.ITemporalWorkspaceStatisticsObject",                          
                                              /* tp_name */
  sizeof(PyITemporalWorkspaceStatisticsObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyITemporalWorkspaceStatisticsObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyITemporalWorkspaceStatisticsMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyITemporalWorkspaceStatisticsGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyITemporalWorkspaceStatisticsObject_new,                      
                                              /* tp_new */
};

// Interface ITemporalWorkspaceStatistics2

typedef struct PyITemporalWorkspaceStatistics2Object {
    PyObject_HEAD
    ITemporalWorkspaceStatistics2* m_pITemporalWorkspaceStatistics2;
    HRESULT m_HR;
    int m_ignore_failures;
} PyITemporalWorkspaceStatistics2Object;

static PyObject*
PyITemporalWorkspaceStatistics2Object_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyITemporalWorkspaceStatistics2Object* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ITemporalWorkspaceStatistics2* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ITemporalWorkspaceStatistics2, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ITemporalWorkspaceStatistics2 with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyITemporalWorkspaceStatistics2Object *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ITemporalWorkspaceStatistics2");
            return NULL;
        }
        self->m_pITemporalWorkspaceStatistics2 = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ITemporalWorkspaceStatistics2");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ITemporalWorkspaceStatistics2");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ITemporalWorkspaceStatistics2* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ITemporalWorkspaceStatistics2, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ITemporalWorkspaceStatistics2");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyITemporalWorkspaceStatistics2Object *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ITemporalWorkspaceStatistics2");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pITemporalWorkspaceStatistics2 = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyITemporalWorkspaceStatistics2Object_dealloc(PyITemporalWorkspaceStatistics2Object* self)
{
    if (self->m_pITemporalWorkspaceStatistics2)
        self->m_pITemporalWorkspaceStatistics2->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyITemporalWorkspaceStatistics2_GetpUnk(PyITemporalWorkspaceStatistics2Object* self)
{
    if (!self->m_pITemporalWorkspaceStatistics2)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pITemporalWorkspaceStatistics2->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ITemporalWorkspaceStatistics2 to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyITemporalWorkspaceStatistics2_GetPointer(PyITemporalWorkspaceStatistics2Object* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pITemporalWorkspaceStatistics2);
}

static PyObject*
PyITemporalWorkspaceStatistics2_GetIID(PyITemporalWorkspaceStatistics2Object* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "f5677ccf-e3d7-4b9a-8803-670895aa262f");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyITemporalWorkspaceStatistics2_GetHR(PyITemporalWorkspaceStatistics2Object* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyITemporalWorkspaceStatistics2_GetIgnoreFailures(PyITemporalWorkspaceStatistics2Object* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyITemporalWorkspaceStatistics2_SetIgnoreFailures(PyITemporalWorkspaceStatistics2Object* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyITemporalWorkspaceStatistics2_SupportsInterface(PyITemporalWorkspaceStatistics2Object* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pITemporalWorkspaceStatistics2->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ITemporalWorkspaceStatistics2Method_get_ConnectionTime(PyITemporalWorkspaceStatistics2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ITime* ipConnectionTime = NULL;
    PyObject* py_ConnectionTime = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ConnectionTime

    // Call method on actual COM interface
    hr = self->m_pITemporalWorkspaceStatistics2->get_ConnectionTime(&ipConnectionTime);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalWorkspaceStatistics2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalWorkspaceStatistics2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalWorkspaceStatistics2.get_ConnectionTime() returned %ld", (long)hr);
        goto itemporalworkspacestatistics2_get_connectiontime_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ConnectionTime);
    if (ipConnectionTime)
    {
        IUnknown* pUnk = NULL;
        ipConnectionTime->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ConnectionTime = IUnknownToPythonIIDObject(pUnk, &IID_ITime);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ConnectionTime)
    {
        if (py_ConnectionTime)
           Py_DECREF(py_ConnectionTime);
        py_ConnectionTime = Py_None;
        Py_INCREF(py_ConnectionTime);
    }
    if (PyErr_Occurred())
      goto itemporalworkspacestatistics2_get_connectiontime_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ConnectionTime);
    goto itemporalworkspacestatistics2_get_connectiontime_method_cleanup;

    itemporalworkspacestatistics2_get_connectiontime_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ConnectionTime);
    if (ipConnectionTime)
      ipConnectionTime->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalWorkspaceStatistics2.get_ConnectionTime");
    return return_tuple;
}

static PyObject*
ITemporalWorkspaceStatistics2Method_get_Subscribed(PyITemporalWorkspaceStatistics2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsserviceName = 0;
    PyObject* pyvar_serviceName;
    PyObject* unicodeserviceName = NULL;
    VARIANT_BOOL b_Subscribed = VARIANT_FALSE;
    PyObject* pyvar_Subscribed = Py_False;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_serviceName))
      goto itemporalworkspacestatistics2_get_subscribed_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_serviceName))
        unicodeserviceName = PyUnicode_FromObject(pyvar_serviceName);
    else if (PyUnicode_Check(pyvar_serviceName))
    {
        unicodeserviceName = pyvar_serviceName;
        Py_INCREF(unicodeserviceName);
    }
    else if (pyvar_serviceName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter serviceName at index 0");
    if (unicodeserviceName)
        bsserviceName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeserviceName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeserviceName));
    
    if (PyErr_Occurred())
      goto itemporalworkspacestatistics2_get_subscribed_method_cleanup;
    
    // No setup for Subscribed

    // Call method on actual COM interface
    hr = self->m_pITemporalWorkspaceStatistics2->get_Subscribed(bsserviceName, &b_Subscribed);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalWorkspaceStatistics2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalWorkspaceStatistics2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalWorkspaceStatistics2.get_Subscribed() returned %ld", (long)hr);
        goto itemporalworkspacestatistics2_get_subscribed_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for serviceName
    pyvar_Subscribed = ((b_Subscribed == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto itemporalworkspacestatistics2_get_subscribed_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Subscribed);
    goto itemporalworkspacestatistics2_get_subscribed_method_cleanup;

    itemporalworkspacestatistics2_get_subscribed_method_cleanup:
    self->m_HR = hr;
    if (bsserviceName)
        ::SysFreeString(bsserviceName);
    
    // No cleanup for Subscribed
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalWorkspaceStatistics2.get_Subscribed");
    return return_tuple;
}

static PyObject*
ITemporalWorkspaceStatistics2Method_get_SubscriptionTime(PyITemporalWorkspaceStatistics2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsserviceName = 0;
    PyObject* pyvar_serviceName;
    PyObject* unicodeserviceName = NULL;
    ITime* ipSubscriptionTime = NULL;
    PyObject* py_SubscriptionTime = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_serviceName))
      goto itemporalworkspacestatistics2_get_subscriptiontime_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_serviceName))
        unicodeserviceName = PyUnicode_FromObject(pyvar_serviceName);
    else if (PyUnicode_Check(pyvar_serviceName))
    {
        unicodeserviceName = pyvar_serviceName;
        Py_INCREF(unicodeserviceName);
    }
    else if (pyvar_serviceName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter serviceName at index 0");
    if (unicodeserviceName)
        bsserviceName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeserviceName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeserviceName));
    
    if (PyErr_Occurred())
      goto itemporalworkspacestatistics2_get_subscriptiontime_method_cleanup;
    
    // No setup for SubscriptionTime

    // Call method on actual COM interface
    hr = self->m_pITemporalWorkspaceStatistics2->get_SubscriptionTime(bsserviceName, &ipSubscriptionTime);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalWorkspaceStatistics2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalWorkspaceStatistics2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalWorkspaceStatistics2.get_SubscriptionTime() returned %ld", (long)hr);
        goto itemporalworkspacestatistics2_get_subscriptiontime_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for serviceName
    Py_XDECREF(py_SubscriptionTime);
    if (ipSubscriptionTime)
    {
        IUnknown* pUnk = NULL;
        ipSubscriptionTime->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_SubscriptionTime = IUnknownToPythonIIDObject(pUnk, &IID_ITime);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_SubscriptionTime)
    {
        if (py_SubscriptionTime)
           Py_DECREF(py_SubscriptionTime);
        py_SubscriptionTime = Py_None;
        Py_INCREF(py_SubscriptionTime);
    }
    if (PyErr_Occurred())
      goto itemporalworkspacestatistics2_get_subscriptiontime_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_SubscriptionTime);
    goto itemporalworkspacestatistics2_get_subscriptiontime_method_cleanup;

    itemporalworkspacestatistics2_get_subscriptiontime_method_cleanup:
    self->m_HR = hr;
    if (bsserviceName)
        ::SysFreeString(bsserviceName);
    
    Py_XDECREF(py_SubscriptionTime);
    if (ipSubscriptionTime)
      ipSubscriptionTime->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalWorkspaceStatistics2.get_SubscriptionTime");
    return return_tuple;
}

static PyObject*
ITemporalWorkspaceStatistics2Method_get_AllTrackCounts(PyITemporalWorkspaceStatistics2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IPropertySet* ipppiAllTrackCounts = NULL;
    PyObject* py_ppiAllTrackCounts = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppiAllTrackCounts

    // Call method on actual COM interface
    hr = self->m_pITemporalWorkspaceStatistics2->get_AllTrackCounts(&ipppiAllTrackCounts);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalWorkspaceStatistics2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalWorkspaceStatistics2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalWorkspaceStatistics2.get_AllTrackCounts() returned %ld", (long)hr);
        goto itemporalworkspacestatistics2_get_alltrackcounts_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppiAllTrackCounts);
    if (ipppiAllTrackCounts)
    {
        IUnknown* pUnk = NULL;
        ipppiAllTrackCounts->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppiAllTrackCounts = IUnknownToPythonIIDObject(pUnk, &IID_IPropertySet);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppiAllTrackCounts)
    {
        if (py_ppiAllTrackCounts)
           Py_DECREF(py_ppiAllTrackCounts);
        py_ppiAllTrackCounts = Py_None;
        Py_INCREF(py_ppiAllTrackCounts);
    }
    if (PyErr_Occurred())
      goto itemporalworkspacestatistics2_get_alltrackcounts_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppiAllTrackCounts);
    goto itemporalworkspacestatistics2_get_alltrackcounts_method_cleanup;

    itemporalworkspacestatistics2_get_alltrackcounts_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppiAllTrackCounts);
    if (ipppiAllTrackCounts)
      ipppiAllTrackCounts->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalWorkspaceStatistics2.get_AllTrackCounts");
    return return_tuple;
}

static PyObject*
ITemporalWorkspaceStatistics2Method_get_AllMessageRates(PyITemporalWorkspaceStatistics2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IPropertySet* ipppiAllMessageRates = NULL;
    PyObject* py_ppiAllMessageRates = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppiAllMessageRates

    // Call method on actual COM interface
    hr = self->m_pITemporalWorkspaceStatistics2->get_AllMessageRates(&ipppiAllMessageRates);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalWorkspaceStatistics2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalWorkspaceStatistics2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalWorkspaceStatistics2.get_AllMessageRates() returned %ld", (long)hr);
        goto itemporalworkspacestatistics2_get_allmessagerates_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppiAllMessageRates);
    if (ipppiAllMessageRates)
    {
        IUnknown* pUnk = NULL;
        ipppiAllMessageRates->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppiAllMessageRates = IUnknownToPythonIIDObject(pUnk, &IID_IPropertySet);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppiAllMessageRates)
    {
        if (py_ppiAllMessageRates)
           Py_DECREF(py_ppiAllMessageRates);
        py_ppiAllMessageRates = Py_None;
        Py_INCREF(py_ppiAllMessageRates);
    }
    if (PyErr_Occurred())
      goto itemporalworkspacestatistics2_get_allmessagerates_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppiAllMessageRates);
    goto itemporalworkspacestatistics2_get_allmessagerates_method_cleanup;

    itemporalworkspacestatistics2_get_allmessagerates_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppiAllMessageRates);
    if (ipppiAllMessageRates)
      ipppiAllMessageRates->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalWorkspaceStatistics2.get_AllMessageRates");
    return return_tuple;
}

static PyObject*
ITemporalWorkspaceStatistics2Method_get_AllSampleSizes(PyITemporalWorkspaceStatistics2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IPropertySet* ipppiAllSampleSizes = NULL;
    PyObject* py_ppiAllSampleSizes = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppiAllSampleSizes

    // Call method on actual COM interface
    hr = self->m_pITemporalWorkspaceStatistics2->get_AllSampleSizes(&ipppiAllSampleSizes);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalWorkspaceStatistics2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalWorkspaceStatistics2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalWorkspaceStatistics2.get_AllSampleSizes() returned %ld", (long)hr);
        goto itemporalworkspacestatistics2_get_allsamplesizes_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppiAllSampleSizes);
    if (ipppiAllSampleSizes)
    {
        IUnknown* pUnk = NULL;
        ipppiAllSampleSizes->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppiAllSampleSizes = IUnknownToPythonIIDObject(pUnk, &IID_IPropertySet);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppiAllSampleSizes)
    {
        if (py_ppiAllSampleSizes)
           Py_DECREF(py_ppiAllSampleSizes);
        py_ppiAllSampleSizes = Py_None;
        Py_INCREF(py_ppiAllSampleSizes);
    }
    if (PyErr_Occurred())
      goto itemporalworkspacestatistics2_get_allsamplesizes_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppiAllSampleSizes);
    goto itemporalworkspacestatistics2_get_allsamplesizes_method_cleanup;

    itemporalworkspacestatistics2_get_allsamplesizes_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppiAllSampleSizes);
    if (ipppiAllSampleSizes)
      ipppiAllSampleSizes->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalWorkspaceStatistics2.get_AllSampleSizes");
    return return_tuple;
}

static PyObject*
ITemporalWorkspaceStatistics2Method_get_AllTotalFeatureCounts(PyITemporalWorkspaceStatistics2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IPropertySet* ipppiAllTotalFeatureCounts = NULL;
    PyObject* py_ppiAllTotalFeatureCounts = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppiAllTotalFeatureCounts

    // Call method on actual COM interface
    hr = self->m_pITemporalWorkspaceStatistics2->get_AllTotalFeatureCounts(&ipppiAllTotalFeatureCounts);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalWorkspaceStatistics2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalWorkspaceStatistics2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalWorkspaceStatistics2.get_AllTotalFeatureCounts() returned %ld", (long)hr);
        goto itemporalworkspacestatistics2_get_alltotalfeaturecounts_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppiAllTotalFeatureCounts);
    if (ipppiAllTotalFeatureCounts)
    {
        IUnknown* pUnk = NULL;
        ipppiAllTotalFeatureCounts->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppiAllTotalFeatureCounts = IUnknownToPythonIIDObject(pUnk, &IID_IPropertySet);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppiAllTotalFeatureCounts)
    {
        if (py_ppiAllTotalFeatureCounts)
           Py_DECREF(py_ppiAllTotalFeatureCounts);
        py_ppiAllTotalFeatureCounts = Py_None;
        Py_INCREF(py_ppiAllTotalFeatureCounts);
    }
    if (PyErr_Occurred())
      goto itemporalworkspacestatistics2_get_alltotalfeaturecounts_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppiAllTotalFeatureCounts);
    goto itemporalworkspacestatistics2_get_alltotalfeaturecounts_method_cleanup;

    itemporalworkspacestatistics2_get_alltotalfeaturecounts_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppiAllTotalFeatureCounts);
    if (ipppiAllTotalFeatureCounts)
      ipppiAllTotalFeatureCounts->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalWorkspaceStatistics2.get_AllTotalFeatureCounts");
    return return_tuple;
}

static PyObject*
ITemporalWorkspaceStatistics2Method_get_ConnectionStatus(PyITemporalWorkspaceStatistics2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IPropertySet* ipppiConnectionStatus = NULL;
    PyObject* py_ppiConnectionStatus = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppiConnectionStatus

    // Call method on actual COM interface
    hr = self->m_pITemporalWorkspaceStatistics2->get_ConnectionStatus(&ipppiConnectionStatus);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalWorkspaceStatistics2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalWorkspaceStatistics2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalWorkspaceStatistics2.get_ConnectionStatus() returned %ld", (long)hr);
        goto itemporalworkspacestatistics2_get_connectionstatus_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppiConnectionStatus);
    if (ipppiConnectionStatus)
    {
        IUnknown* pUnk = NULL;
        ipppiConnectionStatus->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppiConnectionStatus = IUnknownToPythonIIDObject(pUnk, &IID_IPropertySet);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppiConnectionStatus)
    {
        if (py_ppiConnectionStatus)
           Py_DECREF(py_ppiConnectionStatus);
        py_ppiConnectionStatus = Py_None;
        Py_INCREF(py_ppiConnectionStatus);
    }
    if (PyErr_Occurred())
      goto itemporalworkspacestatistics2_get_connectionstatus_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppiConnectionStatus);
    goto itemporalworkspacestatistics2_get_connectionstatus_method_cleanup;

    itemporalworkspacestatistics2_get_connectionstatus_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppiConnectionStatus);
    if (ipppiConnectionStatus)
      ipppiConnectionStatus->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalWorkspaceStatistics2.get_ConnectionStatus");
    return return_tuple;
}

static PyObject*
ITemporalWorkspaceStatistics2Method_get_ReceivedMessageCounts(PyITemporalWorkspaceStatistics2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IPropertySet* ipppiReceivedMsgCounts = NULL;
    PyObject* py_ppiReceivedMsgCounts = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppiReceivedMsgCounts

    // Call method on actual COM interface
    hr = self->m_pITemporalWorkspaceStatistics2->get_ReceivedMessageCounts(&ipppiReceivedMsgCounts);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalWorkspaceStatistics2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalWorkspaceStatistics2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalWorkspaceStatistics2.get_ReceivedMessageCounts() returned %ld", (long)hr);
        goto itemporalworkspacestatistics2_get_receivedmessagecounts_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppiReceivedMsgCounts);
    if (ipppiReceivedMsgCounts)
    {
        IUnknown* pUnk = NULL;
        ipppiReceivedMsgCounts->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppiReceivedMsgCounts = IUnknownToPythonIIDObject(pUnk, &IID_IPropertySet);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppiReceivedMsgCounts)
    {
        if (py_ppiReceivedMsgCounts)
           Py_DECREF(py_ppiReceivedMsgCounts);
        py_ppiReceivedMsgCounts = Py_None;
        Py_INCREF(py_ppiReceivedMsgCounts);
    }
    if (PyErr_Occurred())
      goto itemporalworkspacestatistics2_get_receivedmessagecounts_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppiReceivedMsgCounts);
    goto itemporalworkspacestatistics2_get_receivedmessagecounts_method_cleanup;

    itemporalworkspacestatistics2_get_receivedmessagecounts_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppiReceivedMsgCounts);
    if (ipppiReceivedMsgCounts)
      ipppiReceivedMsgCounts->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalWorkspaceStatistics2.get_ReceivedMessageCounts");
    return return_tuple;
}

static PyObject*
ITemporalWorkspaceStatistics2Method_get_PulledMessageCounts(PyITemporalWorkspaceStatistics2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IPropertySet* ipppiPulledMsgCounts = NULL;
    PyObject* py_ppiPulledMsgCounts = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppiPulledMsgCounts

    // Call method on actual COM interface
    hr = self->m_pITemporalWorkspaceStatistics2->get_PulledMessageCounts(&ipppiPulledMsgCounts);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalWorkspaceStatistics2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalWorkspaceStatistics2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalWorkspaceStatistics2.get_PulledMessageCounts() returned %ld", (long)hr);
        goto itemporalworkspacestatistics2_get_pulledmessagecounts_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppiPulledMsgCounts);
    if (ipppiPulledMsgCounts)
    {
        IUnknown* pUnk = NULL;
        ipppiPulledMsgCounts->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppiPulledMsgCounts = IUnknownToPythonIIDObject(pUnk, &IID_IPropertySet);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppiPulledMsgCounts)
    {
        if (py_ppiPulledMsgCounts)
           Py_DECREF(py_ppiPulledMsgCounts);
        py_ppiPulledMsgCounts = Py_None;
        Py_INCREF(py_ppiPulledMsgCounts);
    }
    if (PyErr_Occurred())
      goto itemporalworkspacestatistics2_get_pulledmessagecounts_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppiPulledMsgCounts);
    goto itemporalworkspacestatistics2_get_pulledmessagecounts_method_cleanup;

    itemporalworkspacestatistics2_get_pulledmessagecounts_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppiPulledMsgCounts);
    if (ipppiPulledMsgCounts)
      ipppiPulledMsgCounts->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalWorkspaceStatistics2.get_PulledMessageCounts");
    return return_tuple;
}

static PyObject*
ITemporalWorkspaceStatistics2Method_get_DiscardedMessageCounts(PyITemporalWorkspaceStatistics2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IPropertySet* ipppiDiscardedMsgCounts = NULL;
    PyObject* py_ppiDiscardedMsgCounts = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppiDiscardedMsgCounts

    // Call method on actual COM interface
    hr = self->m_pITemporalWorkspaceStatistics2->get_DiscardedMessageCounts(&ipppiDiscardedMsgCounts);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalWorkspaceStatistics2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalWorkspaceStatistics2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalWorkspaceStatistics2.get_DiscardedMessageCounts() returned %ld", (long)hr);
        goto itemporalworkspacestatistics2_get_discardedmessagecounts_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppiDiscardedMsgCounts);
    if (ipppiDiscardedMsgCounts)
    {
        IUnknown* pUnk = NULL;
        ipppiDiscardedMsgCounts->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppiDiscardedMsgCounts = IUnknownToPythonIIDObject(pUnk, &IID_IPropertySet);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppiDiscardedMsgCounts)
    {
        if (py_ppiDiscardedMsgCounts)
           Py_DECREF(py_ppiDiscardedMsgCounts);
        py_ppiDiscardedMsgCounts = Py_None;
        Py_INCREF(py_ppiDiscardedMsgCounts);
    }
    if (PyErr_Occurred())
      goto itemporalworkspacestatistics2_get_discardedmessagecounts_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppiDiscardedMsgCounts);
    goto itemporalworkspacestatistics2_get_discardedmessagecounts_method_cleanup;

    itemporalworkspacestatistics2_get_discardedmessagecounts_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppiDiscardedMsgCounts);
    if (ipppiDiscardedMsgCounts)
      ipppiDiscardedMsgCounts->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalWorkspaceStatistics2.get_DiscardedMessageCounts");
    return return_tuple;
}

static PyObject*
ITemporalWorkspaceStatistics2Method_get_CurrentDiscardedMessageCounts(PyITemporalWorkspaceStatistics2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IPropertySet* ipppiCurDiscardedMsgCounts = NULL;
    PyObject* py_ppiCurDiscardedMsgCounts = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppiCurDiscardedMsgCounts

    // Call method on actual COM interface
    hr = self->m_pITemporalWorkspaceStatistics2->get_CurrentDiscardedMessageCounts(&ipppiCurDiscardedMsgCounts);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalWorkspaceStatistics2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalWorkspaceStatistics2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalWorkspaceStatistics2.get_CurrentDiscardedMessageCounts() returned %ld", (long)hr);
        goto itemporalworkspacestatistics2_get_currentdiscardedmessagecounts_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppiCurDiscardedMsgCounts);
    if (ipppiCurDiscardedMsgCounts)
    {
        IUnknown* pUnk = NULL;
        ipppiCurDiscardedMsgCounts->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppiCurDiscardedMsgCounts = IUnknownToPythonIIDObject(pUnk, &IID_IPropertySet);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppiCurDiscardedMsgCounts)
    {
        if (py_ppiCurDiscardedMsgCounts)
           Py_DECREF(py_ppiCurDiscardedMsgCounts);
        py_ppiCurDiscardedMsgCounts = Py_None;
        Py_INCREF(py_ppiCurDiscardedMsgCounts);
    }
    if (PyErr_Occurred())
      goto itemporalworkspacestatistics2_get_currentdiscardedmessagecounts_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppiCurDiscardedMsgCounts);
    goto itemporalworkspacestatistics2_get_currentdiscardedmessagecounts_method_cleanup;

    itemporalworkspacestatistics2_get_currentdiscardedmessagecounts_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppiCurDiscardedMsgCounts);
    if (ipppiCurDiscardedMsgCounts)
      ipppiCurDiscardedMsgCounts->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalWorkspaceStatistics2.get_CurrentDiscardedMessageCounts");
    return return_tuple;
}

static PyObject*
ITemporalWorkspaceStatistics2Method_get_QueuedMessageCounts(PyITemporalWorkspaceStatistics2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IPropertySet* ipppiQueuedMsgCounts = NULL;
    PyObject* py_ppiQueuedMsgCounts = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppiQueuedMsgCounts

    // Call method on actual COM interface
    hr = self->m_pITemporalWorkspaceStatistics2->get_QueuedMessageCounts(&ipppiQueuedMsgCounts);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalWorkspaceStatistics2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalWorkspaceStatistics2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalWorkspaceStatistics2.get_QueuedMessageCounts() returned %ld", (long)hr);
        goto itemporalworkspacestatistics2_get_queuedmessagecounts_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppiQueuedMsgCounts);
    if (ipppiQueuedMsgCounts)
    {
        IUnknown* pUnk = NULL;
        ipppiQueuedMsgCounts->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppiQueuedMsgCounts = IUnknownToPythonIIDObject(pUnk, &IID_IPropertySet);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppiQueuedMsgCounts)
    {
        if (py_ppiQueuedMsgCounts)
           Py_DECREF(py_ppiQueuedMsgCounts);
        py_ppiQueuedMsgCounts = Py_None;
        Py_INCREF(py_ppiQueuedMsgCounts);
    }
    if (PyErr_Occurred())
      goto itemporalworkspacestatistics2_get_queuedmessagecounts_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppiQueuedMsgCounts);
    goto itemporalworkspacestatistics2_get_queuedmessagecounts_method_cleanup;

    itemporalworkspacestatistics2_get_queuedmessagecounts_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppiQueuedMsgCounts);
    if (ipppiQueuedMsgCounts)
      ipppiQueuedMsgCounts->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalWorkspaceStatistics2.get_QueuedMessageCounts");
    return return_tuple;
}

static PyObject*
ITemporalWorkspaceStatistics2Method_ResetAllFeatureCounts(PyITemporalWorkspaceStatistics2Object* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pITemporalWorkspaceStatistics2->ResetAllFeatureCounts();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalWorkspaceStatistics2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalWorkspaceStatistics2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalWorkspaceStatistics2.ResetAllFeatureCounts() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}

static PyObject*
ITemporalWorkspaceStatistics2Method_ResetAllMessageRates(PyITemporalWorkspaceStatistics2Object* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pITemporalWorkspaceStatistics2->ResetAllMessageRates();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalWorkspaceStatistics2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalWorkspaceStatistics2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalWorkspaceStatistics2.ResetAllMessageRates() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}

static PyObject*
ITemporalWorkspaceStatistics2Method_SetAllSampleSizes(PyITemporalWorkspaceStatistics2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long llSampleSize = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &llSampleSize))
      goto itemporalworkspacestatistics2_setallsamplesizes_method_cleanup;

    // Set up initial variable values as needed
    // No setup for lSampleSize

    // Call method on actual COM interface
    hr = self->m_pITemporalWorkspaceStatistics2->SetAllSampleSizes(llSampleSize);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalWorkspaceStatistics2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalWorkspaceStatistics2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalWorkspaceStatistics2.SetAllSampleSizes() returned %ld", (long)hr);
        goto itemporalworkspacestatistics2_setallsamplesizes_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for lSampleSize

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto itemporalworkspacestatistics2_setallsamplesizes_method_cleanup;

    itemporalworkspacestatistics2_setallsamplesizes_method_cleanup:
    self->m_HR = hr;
    // No cleanup for lSampleSize
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalWorkspaceStatistics2.SetAllSampleSizes");
    return return_tuple;
}


PyMethodDef PyITemporalWorkspaceStatistics2Methods[] = {
    {"supports", (PyCFunction)PyITemporalWorkspaceStatistics2_SupportsInterface, METH_O, ""},
    {"get_ConnectionTime", (PyCFunction)ITemporalWorkspaceStatistics2Method_get_ConnectionTime, METH_VARARGS, ""},
    {"get_Subscribed", (PyCFunction)ITemporalWorkspaceStatistics2Method_get_Subscribed, METH_VARARGS, ""},
    {"get_SubscriptionTime", (PyCFunction)ITemporalWorkspaceStatistics2Method_get_SubscriptionTime, METH_VARARGS, ""},
    {"get_AllTrackCounts", (PyCFunction)ITemporalWorkspaceStatistics2Method_get_AllTrackCounts, METH_VARARGS, ""},
    {"get_AllMessageRates", (PyCFunction)ITemporalWorkspaceStatistics2Method_get_AllMessageRates, METH_VARARGS, ""},
    {"get_AllSampleSizes", (PyCFunction)ITemporalWorkspaceStatistics2Method_get_AllSampleSizes, METH_VARARGS, ""},
    {"get_AllTotalFeatureCounts", (PyCFunction)ITemporalWorkspaceStatistics2Method_get_AllTotalFeatureCounts, METH_VARARGS, ""},
    {"get_ConnectionStatus", (PyCFunction)ITemporalWorkspaceStatistics2Method_get_ConnectionStatus, METH_VARARGS, ""},
    {"get_ReceivedMessageCounts", (PyCFunction)ITemporalWorkspaceStatistics2Method_get_ReceivedMessageCounts, METH_VARARGS, ""},
    {"get_PulledMessageCounts", (PyCFunction)ITemporalWorkspaceStatistics2Method_get_PulledMessageCounts, METH_VARARGS, ""},
    {"get_DiscardedMessageCounts", (PyCFunction)ITemporalWorkspaceStatistics2Method_get_DiscardedMessageCounts, METH_VARARGS, ""},
    {"get_CurrentDiscardedMessageCounts", (PyCFunction)ITemporalWorkspaceStatistics2Method_get_CurrentDiscardedMessageCounts, METH_VARARGS, ""},
    {"get_QueuedMessageCounts", (PyCFunction)ITemporalWorkspaceStatistics2Method_get_QueuedMessageCounts, METH_VARARGS, ""},
    {"ResetAllFeatureCounts", (PyCFunction)ITemporalWorkspaceStatistics2Method_ResetAllFeatureCounts, METH_NOARGS, ""},
    {"ResetAllMessageRates", (PyCFunction)ITemporalWorkspaceStatistics2Method_ResetAllMessageRates, METH_NOARGS, ""},
    {"SetAllSampleSizes", (PyCFunction)ITemporalWorkspaceStatistics2Method_SetAllSampleSizes, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyITemporalWorkspaceStatistics2GetSet[] = {
  {"_pUnk", (getter)PyITemporalWorkspaceStatistics2_GetpUnk, NULL, "Get opaque pointer to an Unknown from ITemporalWorkspaceStatistics2", NULL},
  {"_pointer", (getter)PyITemporalWorkspaceStatistics2_GetPointer, NULL, "Get memory address for ITemporalWorkspaceStatistics2", NULL},
  {"_IID", (getter)PyITemporalWorkspaceStatistics2_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyITemporalWorkspaceStatistics2_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyITemporalWorkspaceStatistics2_GetIgnoreFailures, (setter)PyITemporalWorkspaceStatistics2_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyITemporalWorkspaceStatistics2Object_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.ITemporalWorkspaceStatistics2Object",                          
                                              /* tp_name */
  sizeof(PyITemporalWorkspaceStatistics2Object),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyITemporalWorkspaceStatistics2Object_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyITemporalWorkspaceStatistics2Methods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyITemporalWorkspaceStatistics2GetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyITemporalWorkspaceStatistics2Object_new,                      
                                              /* tp_new */
};

// Interface ILockedFeatureSearch

typedef struct PyILockedFeatureSearchObject {
    PyObject_HEAD
    ILockedFeatureSearch* m_pILockedFeatureSearch;
    HRESULT m_HR;
    int m_ignore_failures;
} PyILockedFeatureSearchObject;

static PyObject*
PyILockedFeatureSearchObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyILockedFeatureSearchObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ILockedFeatureSearch* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ILockedFeatureSearch, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ILockedFeatureSearch with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyILockedFeatureSearchObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ILockedFeatureSearch");
            return NULL;
        }
        self->m_pILockedFeatureSearch = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ILockedFeatureSearch");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ILockedFeatureSearch");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ILockedFeatureSearch* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ILockedFeatureSearch, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ILockedFeatureSearch");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyILockedFeatureSearchObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ILockedFeatureSearch");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pILockedFeatureSearch = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyILockedFeatureSearchObject_dealloc(PyILockedFeatureSearchObject* self)
{
    if (self->m_pILockedFeatureSearch)
        self->m_pILockedFeatureSearch->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyILockedFeatureSearch_GetpUnk(PyILockedFeatureSearchObject* self)
{
    if (!self->m_pILockedFeatureSearch)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pILockedFeatureSearch->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ILockedFeatureSearch to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyILockedFeatureSearch_GetPointer(PyILockedFeatureSearchObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pILockedFeatureSearch);
}

static PyObject*
PyILockedFeatureSearch_GetIID(PyILockedFeatureSearchObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "6fb36881-6399-4bd6-be3d-b07033a79114");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyILockedFeatureSearch_GetHR(PyILockedFeatureSearchObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyILockedFeatureSearch_GetIgnoreFailures(PyILockedFeatureSearchObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyILockedFeatureSearch_SetIgnoreFailures(PyILockedFeatureSearchObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyILockedFeatureSearch_SupportsInterface(PyILockedFeatureSearchObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pILockedFeatureSearch->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ILockedFeatureSearchMethod_get_AllLockedFIDs(PyILockedFeatureSearchObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IFIDSet* ipppiAllLockedFIDs = NULL;
    PyObject* py_ppiAllLockedFIDs = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppiAllLockedFIDs

    // Call method on actual COM interface
    hr = self->m_pILockedFeatureSearch->get_AllLockedFIDs(&ipppiAllLockedFIDs);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILockedFeatureSearch->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILockedFeatureSearch) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILockedFeatureSearch.get_AllLockedFIDs() returned %ld", (long)hr);
        goto ilockedfeaturesearch_get_alllockedfids_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppiAllLockedFIDs);
    if (ipppiAllLockedFIDs)
    {
        IUnknown* pUnk = NULL;
        ipppiAllLockedFIDs->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppiAllLockedFIDs = IUnknownToPythonIIDObject(pUnk, &IID_IFIDSet);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppiAllLockedFIDs)
    {
        if (py_ppiAllLockedFIDs)
           Py_DECREF(py_ppiAllLockedFIDs);
        py_ppiAllLockedFIDs = Py_None;
        Py_INCREF(py_ppiAllLockedFIDs);
    }
    if (PyErr_Occurred())
      goto ilockedfeaturesearch_get_alllockedfids_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppiAllLockedFIDs);
    goto ilockedfeaturesearch_get_alllockedfids_method_cleanup;

    ilockedfeaturesearch_get_alllockedfids_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppiAllLockedFIDs);
    if (ipppiAllLockedFIDs)
      ipppiAllLockedFIDs->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILockedFeatureSearch.get_AllLockedFIDs");
    return return_tuple;
}

static PyObject*
ILockedFeatureSearchMethod_SearchAndLock(PyILockedFeatureSearchObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IQueryFilter* ippiQueryFilter = NULL;
    PyObject* py_piQueryFilter;
    VARIANT_BOOL b_Recycling = VARIANT_FALSE;
    PyObject* pyvar_Recycling = NULL;
    ICursor* ipppiCursor = NULL;
    PyObject* py_ppiCursor = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OO", &py_piQueryFilter, &pyvar_Recycling))
      goto ilockedfeaturesearch_searchandlock_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_piQueryFilter, &IID_IQueryFilter, (void**)&ippiQueryFilter))
        PyErr_SetString(PyExc_TypeError, "Argument piQueryFilter (position 0) is not IQueryFilter");
    
    if (PyErr_Occurred())
      goto ilockedfeaturesearch_searchandlock_method_cleanup;
    
    b_Recycling = ((PyObject_IsTrue(pyvar_Recycling) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto ilockedfeaturesearch_searchandlock_method_cleanup;
    
    // No setup for ppiCursor

    // Call method on actual COM interface
    hr = self->m_pILockedFeatureSearch->SearchAndLock(ippiQueryFilter, b_Recycling, &ipppiCursor);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILockedFeatureSearch->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILockedFeatureSearch) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILockedFeatureSearch.SearchAndLock() returned %ld", (long)hr);
        goto ilockedfeaturesearch_searchandlock_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for piQueryFilter
    // No teardown for Recycling
    Py_XDECREF(py_ppiCursor);
    if (ipppiCursor)
    {
        IUnknown* pUnk = NULL;
        ipppiCursor->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppiCursor = IUnknownToPythonIIDObject(pUnk, &IID_ICursor);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppiCursor)
    {
        if (py_ppiCursor)
           Py_DECREF(py_ppiCursor);
        py_ppiCursor = Py_None;
        Py_INCREF(py_ppiCursor);
    }
    if (PyErr_Occurred())
      goto ilockedfeaturesearch_searchandlock_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppiCursor);
    goto ilockedfeaturesearch_searchandlock_method_cleanup;

    ilockedfeaturesearch_searchandlock_method_cleanup:
    self->m_HR = hr;
    if (ippiQueryFilter)
      ippiQueryFilter->Release();
    // No cleanup for Recycling
    Py_XDECREF(py_ppiCursor);
    if (ipppiCursor)
      ipppiCursor->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILockedFeatureSearch.SearchAndLock");
    return return_tuple;
}

static PyObject*
ILockedFeatureSearchMethod_SelectAndLock(PyILockedFeatureSearchObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IQueryFilter* ippiQueryFilter = NULL;
    PyObject* py_piQueryFilter;
    esriSelectionType eselType;
    esriSelectionOption eselOption;
    IWorkspace* ippiSelectionContainer = NULL;
    PyObject* py_piSelectionContainer;
    ISelectionSet* ipppiSelectionSet = NULL;
    PyObject* py_ppiSelectionSet = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OiiO", &py_piQueryFilter, (int *)&eselType, (int *)&eselOption, &py_piSelectionContainer))
      goto ilockedfeaturesearch_selectandlock_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_piQueryFilter, &IID_IQueryFilter, (void**)&ippiQueryFilter))
        PyErr_SetString(PyExc_TypeError, "Argument piQueryFilter (position 0) is not IQueryFilter");
    
    if (PyErr_Occurred())
      goto ilockedfeaturesearch_selectandlock_method_cleanup;
    
    // No setup for selType
    // No setup for selOption
    if (!IFaceFromPyObject(py_piSelectionContainer, &IID_IWorkspace, (void**)&ippiSelectionContainer))
        PyErr_SetString(PyExc_TypeError, "Argument piSelectionContainer (position 3) is not IWorkspace");
    
    if (PyErr_Occurred())
      goto ilockedfeaturesearch_selectandlock_method_cleanup;
    
    // No setup for ppiSelectionSet

    // Call method on actual COM interface
    hr = self->m_pILockedFeatureSearch->SelectAndLock(ippiQueryFilter, eselType, eselOption, ippiSelectionContainer, &ipppiSelectionSet);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILockedFeatureSearch->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILockedFeatureSearch) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILockedFeatureSearch.SelectAndLock() returned %ld", (long)hr);
        goto ilockedfeaturesearch_selectandlock_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for piQueryFilter
    // No teardown for selType
    // No teardown for selOption
    // No teardown for piSelectionContainer
    Py_XDECREF(py_ppiSelectionSet);
    if (ipppiSelectionSet)
    {
        IUnknown* pUnk = NULL;
        ipppiSelectionSet->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppiSelectionSet = IUnknownToPythonIIDObject(pUnk, &IID_ISelectionSet);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppiSelectionSet)
    {
        if (py_ppiSelectionSet)
           Py_DECREF(py_ppiSelectionSet);
        py_ppiSelectionSet = Py_None;
        Py_INCREF(py_ppiSelectionSet);
    }
    if (PyErr_Occurred())
      goto ilockedfeaturesearch_selectandlock_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppiSelectionSet);
    goto ilockedfeaturesearch_selectandlock_method_cleanup;

    ilockedfeaturesearch_selectandlock_method_cleanup:
    self->m_HR = hr;
    if (ippiQueryFilter)
      ippiQueryFilter->Release();
    // No cleanup for selType
    // No cleanup for selOption
    if (ippiSelectionContainer)
      ippiSelectionContainer->Release();
    Py_XDECREF(py_ppiSelectionSet);
    if (ipppiSelectionSet)
      ipppiSelectionSet->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ILockedFeatureSearch.SelectAndLock");
    return return_tuple;
}

static PyObject*
ILockedFeatureSearchMethod_UnlockAllFeatures(PyILockedFeatureSearchObject* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pILockedFeatureSearch->UnlockAllFeatures();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pILockedFeatureSearch->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ILockedFeatureSearch) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ILockedFeatureSearch.UnlockAllFeatures() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}


PyMethodDef PyILockedFeatureSearchMethods[] = {
    {"supports", (PyCFunction)PyILockedFeatureSearch_SupportsInterface, METH_O, ""},
    {"get_AllLockedFIDs", (PyCFunction)ILockedFeatureSearchMethod_get_AllLockedFIDs, METH_VARARGS, ""},
    {"SearchAndLock", (PyCFunction)ILockedFeatureSearchMethod_SearchAndLock, METH_VARARGS, ""},
    {"SelectAndLock", (PyCFunction)ILockedFeatureSearchMethod_SelectAndLock, METH_VARARGS, ""},
    {"UnlockAllFeatures", (PyCFunction)ILockedFeatureSearchMethod_UnlockAllFeatures, METH_NOARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyILockedFeatureSearchGetSet[] = {
  {"_pUnk", (getter)PyILockedFeatureSearch_GetpUnk, NULL, "Get opaque pointer to an Unknown from ILockedFeatureSearch", NULL},
  {"_pointer", (getter)PyILockedFeatureSearch_GetPointer, NULL, "Get memory address for ILockedFeatureSearch", NULL},
  {"_IID", (getter)PyILockedFeatureSearch_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyILockedFeatureSearch_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyILockedFeatureSearch_GetIgnoreFailures, (setter)PyILockedFeatureSearch_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyILockedFeatureSearchObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.ILockedFeatureSearchObject",                          
                                              /* tp_name */
  sizeof(PyILockedFeatureSearchObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyILockedFeatureSearchObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyILockedFeatureSearchMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyILockedFeatureSearchGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyILockedFeatureSearchObject_new,                      
                                              /* tp_new */
};

// Interface ITxWorkspaceEditor

typedef struct PyITxWorkspaceEditorObject {
    PyObject_HEAD
    ITxWorkspaceEditor* m_pITxWorkspaceEditor;
    HRESULT m_HR;
    int m_ignore_failures;
} PyITxWorkspaceEditorObject;

static PyObject*
PyITxWorkspaceEditorObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyITxWorkspaceEditorObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ITxWorkspaceEditor* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ITxWorkspaceEditor, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ITxWorkspaceEditor with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyITxWorkspaceEditorObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ITxWorkspaceEditor");
            return NULL;
        }
        self->m_pITxWorkspaceEditor = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ITxWorkspaceEditor");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ITxWorkspaceEditor");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ITxWorkspaceEditor* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ITxWorkspaceEditor, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ITxWorkspaceEditor");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyITxWorkspaceEditorObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ITxWorkspaceEditor");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pITxWorkspaceEditor = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyITxWorkspaceEditorObject_dealloc(PyITxWorkspaceEditorObject* self)
{
    if (self->m_pITxWorkspaceEditor)
        self->m_pITxWorkspaceEditor->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyITxWorkspaceEditor_GetpUnk(PyITxWorkspaceEditorObject* self)
{
    if (!self->m_pITxWorkspaceEditor)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pITxWorkspaceEditor->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ITxWorkspaceEditor to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyITxWorkspaceEditor_GetPointer(PyITxWorkspaceEditorObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pITxWorkspaceEditor);
}

static PyObject*
PyITxWorkspaceEditor_GetIID(PyITxWorkspaceEditorObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "a1ff9810-87a9-11d7-b87a-00010265adc5");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyITxWorkspaceEditor_GetHR(PyITxWorkspaceEditorObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyITxWorkspaceEditor_GetIgnoreFailures(PyITxWorkspaceEditorObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyITxWorkspaceEditor_SetIgnoreFailures(PyITxWorkspaceEditorObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyITxWorkspaceEditor_SupportsInterface(PyITxWorkspaceEditorObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pITxWorkspaceEditor->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ITxWorkspaceEditorMethod_put_ConnectionProperties(PyITxWorkspaceEditorObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IPropertySet* ipppiConnectionProperties = NULL;
    PyObject* py_ppiConnectionProperties;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_ppiConnectionProperties))
      goto itxworkspaceeditor_put_connectionproperties_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_ppiConnectionProperties, &IID_IPropertySet, (void**)&ipppiConnectionProperties))
        PyErr_SetString(PyExc_TypeError, "Argument ppiConnectionProperties (position 0) is not IPropertySet");
    
    if (PyErr_Occurred())
      goto itxworkspaceeditor_put_connectionproperties_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITxWorkspaceEditor->put_ConnectionProperties(ipppiConnectionProperties);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITxWorkspaceEditor->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITxWorkspaceEditor) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITxWorkspaceEditor.put_ConnectionProperties() returned %ld", (long)hr);
        goto itxworkspaceeditor_put_connectionproperties_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ppiConnectionProperties

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto itxworkspaceeditor_put_connectionproperties_method_cleanup;

    itxworkspaceeditor_put_connectionproperties_method_cleanup:
    self->m_HR = hr;
    if (ipppiConnectionProperties)
      ipppiConnectionProperties->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITxWorkspaceEditor.put_ConnectionProperties");
    return return_tuple;
}

static PyObject*
ITxWorkspaceEditorMethod_get_ConnectionProperties(PyITxWorkspaceEditorObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IPropertySet* ipppiConnectionProperties = NULL;
    PyObject* py_ppiConnectionProperties = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppiConnectionProperties

    // Call method on actual COM interface
    hr = self->m_pITxWorkspaceEditor->get_ConnectionProperties(&ipppiConnectionProperties);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITxWorkspaceEditor->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITxWorkspaceEditor) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITxWorkspaceEditor.get_ConnectionProperties() returned %ld", (long)hr);
        goto itxworkspaceeditor_get_connectionproperties_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppiConnectionProperties);
    if (ipppiConnectionProperties)
    {
        IUnknown* pUnk = NULL;
        ipppiConnectionProperties->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppiConnectionProperties = IUnknownToPythonIIDObject(pUnk, &IID_IPropertySet);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppiConnectionProperties)
    {
        if (py_ppiConnectionProperties)
           Py_DECREF(py_ppiConnectionProperties);
        py_ppiConnectionProperties = Py_None;
        Py_INCREF(py_ppiConnectionProperties);
    }
    if (PyErr_Occurred())
      goto itxworkspaceeditor_get_connectionproperties_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppiConnectionProperties);
    goto itxworkspaceeditor_get_connectionproperties_method_cleanup;

    itxworkspaceeditor_get_connectionproperties_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppiConnectionProperties);
    if (ipppiConnectionProperties)
      ipppiConnectionProperties->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITxWorkspaceEditor.get_ConnectionProperties");
    return return_tuple;
}

static PyObject*
ITxWorkspaceEditorMethod_Invoke(PyITxWorkspaceEditorObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    OLE_HANDLE HhParentWnd = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "I", &HhParentWnd))
      goto itxworkspaceeditor_invoke_method_cleanup;

    // Set up initial variable values as needed
    // No setup for hParentWnd

    // Call method on actual COM interface
    hr = self->m_pITxWorkspaceEditor->Invoke(HhParentWnd);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITxWorkspaceEditor->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITxWorkspaceEditor) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITxWorkspaceEditor.Invoke() returned %ld", (long)hr);
        goto itxworkspaceeditor_invoke_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for hParentWnd

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto itxworkspaceeditor_invoke_method_cleanup;

    itxworkspaceeditor_invoke_method_cleanup:
    self->m_HR = hr;
    // No cleanup for hParentWnd
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITxWorkspaceEditor.Invoke");
    return return_tuple;
}


PyMethodDef PyITxWorkspaceEditorMethods[] = {
    {"supports", (PyCFunction)PyITxWorkspaceEditor_SupportsInterface, METH_O, ""},
    {"put_ConnectionProperties", (PyCFunction)ITxWorkspaceEditorMethod_put_ConnectionProperties, METH_VARARGS, ""},
    {"get_ConnectionProperties", (PyCFunction)ITxWorkspaceEditorMethod_get_ConnectionProperties, METH_VARARGS, ""},
    {"Invoke", (PyCFunction)ITxWorkspaceEditorMethod_Invoke, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyITxWorkspaceEditorGetSet[] = {
  {"_pUnk", (getter)PyITxWorkspaceEditor_GetpUnk, NULL, "Get opaque pointer to an Unknown from ITxWorkspaceEditor", NULL},
  {"_pointer", (getter)PyITxWorkspaceEditor_GetPointer, NULL, "Get memory address for ITxWorkspaceEditor", NULL},
  {"_IID", (getter)PyITxWorkspaceEditor_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyITxWorkspaceEditor_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyITxWorkspaceEditor_GetIgnoreFailures, (setter)PyITxWorkspaceEditor_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyITxWorkspaceEditorObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.ITxWorkspaceEditorObject",                          
                                              /* tp_name */
  sizeof(PyITxWorkspaceEditorObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyITxWorkspaceEditorObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyITxWorkspaceEditorMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyITxWorkspaceEditorGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyITxWorkspaceEditorObject_new,                      
                                              /* tp_new */
};

// Interface ITemporalRecordSet

typedef struct PyITemporalRecordSetObject {
    PyObject_HEAD
    ITemporalRecordSet* m_pITemporalRecordSet;
    HRESULT m_HR;
    int m_ignore_failures;
} PyITemporalRecordSetObject;

static PyObject*
PyITemporalRecordSetObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyITemporalRecordSetObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ITemporalRecordSet* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ITemporalRecordSet, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ITemporalRecordSet with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyITemporalRecordSetObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ITemporalRecordSet");
            return NULL;
        }
        self->m_pITemporalRecordSet = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ITemporalRecordSet");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ITemporalRecordSet");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ITemporalRecordSet* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ITemporalRecordSet, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ITemporalRecordSet");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyITemporalRecordSetObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ITemporalRecordSet");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pITemporalRecordSet = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyITemporalRecordSetObject_dealloc(PyITemporalRecordSetObject* self)
{
    if (self->m_pITemporalRecordSet)
        self->m_pITemporalRecordSet->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyITemporalRecordSet_GetpUnk(PyITemporalRecordSetObject* self)
{
    if (!self->m_pITemporalRecordSet)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pITemporalRecordSet->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ITemporalRecordSet to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyITemporalRecordSet_GetPointer(PyITemporalRecordSetObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pITemporalRecordSet);
}

static PyObject*
PyITemporalRecordSet_GetIID(PyITemporalRecordSetObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "78c74302-17cf-11d5-b7cf-00010265adc5");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyITemporalRecordSet_GetHR(PyITemporalRecordSetObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyITemporalRecordSet_GetIgnoreFailures(PyITemporalRecordSetObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyITemporalRecordSet_SetIgnoreFailures(PyITemporalRecordSetObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyITemporalRecordSet_SupportsInterface(PyITemporalRecordSetObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pITemporalRecordSet->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ITemporalRecordSetMethod_get_TemporalColumnName(PyITemporalRecordSetObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName;
    PyObject* pyvar_Name = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Name

    // Call method on actual COM interface
    hr = self->m_pITemporalRecordSet->get_TemporalColumnName(&bsName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalRecordSet->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalRecordSet) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalRecordSet.get_TemporalColumnName() returned %ld", (long)hr);
        goto itemporalrecordset_get_temporalcolumnname_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Name = PyUnicode_FromWideChar(bsName,::SysStringLen(bsName));
    ::SysFreeString(bsName);
    
    if (PyErr_Occurred())
      goto itemporalrecordset_get_temporalcolumnname_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Name);
    goto itemporalrecordset_get_temporalcolumnname_method_cleanup;

    itemporalrecordset_get_temporalcolumnname_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Name != Py_None)
        Py_XDECREF(pyvar_Name);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalRecordSet.get_TemporalColumnName");
    return return_tuple;
}

static PyObject*
ITemporalRecordSetMethod_put_TemporalColumnName(PyITemporalRecordSetObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName = 0;
    PyObject* pyvar_Name;
    PyObject* unicodeName = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_Name))
      goto itemporalrecordset_put_temporalcolumnname_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_Name))
        unicodeName = PyUnicode_FromObject(pyvar_Name);
    else if (PyUnicode_Check(pyvar_Name))
    {
        unicodeName = pyvar_Name;
        Py_INCREF(unicodeName);
    }
    else if (pyvar_Name != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Name at index 0");
    if (unicodeName)
        bsName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeName));
    
    if (PyErr_Occurred())
      goto itemporalrecordset_put_temporalcolumnname_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITemporalRecordSet->put_TemporalColumnName(bsName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalRecordSet->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalRecordSet) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalRecordSet.put_TemporalColumnName() returned %ld", (long)hr);
        goto itemporalrecordset_put_temporalcolumnname_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Name

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto itemporalrecordset_put_temporalcolumnname_method_cleanup;

    itemporalrecordset_put_temporalcolumnname_method_cleanup:
    self->m_HR = hr;
    if (bsName)
        ::SysFreeString(bsName);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalRecordSet.put_TemporalColumnName");
    return return_tuple;
}

static PyObject*
ITemporalRecordSetMethod_get_FeatureClass(PyITemporalRecordSetObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IFeatureClass* ipFeatureClass = NULL;
    PyObject* py_FeatureClass = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for FeatureClass

    // Call method on actual COM interface
    hr = self->m_pITemporalRecordSet->get_FeatureClass(&ipFeatureClass);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalRecordSet->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalRecordSet) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalRecordSet.get_FeatureClass() returned %ld", (long)hr);
        goto itemporalrecordset_get_featureclass_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_FeatureClass);
    if (ipFeatureClass)
    {
        IUnknown* pUnk = NULL;
        ipFeatureClass->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_FeatureClass = IUnknownToPythonIIDObject(pUnk, &IID_IFeatureClass);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_FeatureClass)
    {
        if (py_FeatureClass)
           Py_DECREF(py_FeatureClass);
        py_FeatureClass = Py_None;
        Py_INCREF(py_FeatureClass);
    }
    if (PyErr_Occurred())
      goto itemporalrecordset_get_featureclass_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_FeatureClass);
    goto itemporalrecordset_get_featureclass_method_cleanup;

    itemporalrecordset_get_featureclass_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_FeatureClass);
    if (ipFeatureClass)
      ipFeatureClass->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalRecordSet.get_FeatureClass");
    return return_tuple;
}

static PyObject*
ITemporalRecordSetMethod_putref_FeatureClass(PyITemporalRecordSetObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IFeatureClass* ipFeatureClass = NULL;
    PyObject* py_FeatureClass;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_FeatureClass))
      goto itemporalrecordset_putref_featureclass_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_FeatureClass, &IID_IFeatureClass, (void**)&ipFeatureClass))
        PyErr_SetString(PyExc_TypeError, "Argument FeatureClass (position 0) is not IFeatureClass");
    
    if (PyErr_Occurred())
      goto itemporalrecordset_putref_featureclass_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITemporalRecordSet->putref_FeatureClass(ipFeatureClass);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalRecordSet->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalRecordSet) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalRecordSet.putref_FeatureClass() returned %ld", (long)hr);
        goto itemporalrecordset_putref_featureclass_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for FeatureClass

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto itemporalrecordset_putref_featureclass_method_cleanup;

    itemporalrecordset_putref_featureclass_method_cleanup:
    self->m_HR = hr;
    if (ipFeatureClass)
      ipFeatureClass->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalRecordSet.putref_FeatureClass");
    return return_tuple;
}

static PyObject*
ITemporalRecordSetMethod_IndexFeatureClass(PyITemporalRecordSetObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT vcacheStartingTime;
    ::VariantInit(&vcacheStartingTime);
    PyObject* pyvar_cacheStartingTime = NULL;
    VARIANT vcacheEndingTime;
    ::VariantInit(&vcacheEndingTime);
    PyObject* pyvar_cacheEndingTime = NULL;
    ISelectionSet* ipselSet = NULL;
    PyObject* py_selSet;
    IQueryFilter* ipQueryFilter = NULL;
    PyObject* py_QueryFilter;
    long llocaleLanguageID = 0;
    BSTR bsdateFormat = 0;
    PyObject* pyvar_dateFormat;
    PyObject* unicodedateFormat = NULL;
    BSTR bstimeFormat = 0;
    PyObject* pyvar_timeFormat;
    PyObject* unicodetimeFormat = NULL;
    BSTR bsamDesignator = 0;
    PyObject* pyvar_amDesignator;
    PyObject* unicodeamDesignator = NULL;
    BSTR bspmDesignator = 0;
    PyObject* pyvar_pmDesignator;
    PyObject* unicodepmDesignator = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOOOlOOOO", &pyvar_cacheStartingTime, &pyvar_cacheEndingTime, &py_selSet, &py_QueryFilter, &llocaleLanguageID, &pyvar_dateFormat, &pyvar_timeFormat, &pyvar_amDesignator, &pyvar_pmDesignator))
      goto itemporalrecordset_indexfeatureclass_method_cleanup;

    // Set up initial variable values as needed
    PyObject_AsVariant(pyvar_cacheStartingTime, &vcacheStartingTime);
    
    if (PyErr_Occurred())
      goto itemporalrecordset_indexfeatureclass_method_cleanup;
    
    PyObject_AsVariant(pyvar_cacheEndingTime, &vcacheEndingTime);
    
    if (PyErr_Occurred())
      goto itemporalrecordset_indexfeatureclass_method_cleanup;
    
    if (!IFaceFromPyObject(py_selSet, &IID_ISelectionSet, (void**)&ipselSet))
        PyErr_SetString(PyExc_TypeError, "Argument selSet (position 2) is not ISelectionSet");
    
    if (PyErr_Occurred())
      goto itemporalrecordset_indexfeatureclass_method_cleanup;
    
    if (!IFaceFromPyObject(py_QueryFilter, &IID_IQueryFilter, (void**)&ipQueryFilter))
        PyErr_SetString(PyExc_TypeError, "Argument QueryFilter (position 3) is not IQueryFilter");
    
    if (PyErr_Occurred())
      goto itemporalrecordset_indexfeatureclass_method_cleanup;
    
    // No setup for localeLanguageID
    if (PyString_Check(pyvar_dateFormat))
        unicodedateFormat = PyUnicode_FromObject(pyvar_dateFormat);
    else if (PyUnicode_Check(pyvar_dateFormat))
    {
        unicodedateFormat = pyvar_dateFormat;
        Py_INCREF(unicodedateFormat);
    }
    else if (pyvar_dateFormat != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter dateFormat at index 5");
    if (unicodedateFormat)
        bsdateFormat = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodedateFormat), 
                                            (UINT)PyUnicode_GET_SIZE(unicodedateFormat));
    
    if (PyErr_Occurred())
      goto itemporalrecordset_indexfeatureclass_method_cleanup;
    
    if (PyString_Check(pyvar_timeFormat))
        unicodetimeFormat = PyUnicode_FromObject(pyvar_timeFormat);
    else if (PyUnicode_Check(pyvar_timeFormat))
    {
        unicodetimeFormat = pyvar_timeFormat;
        Py_INCREF(unicodetimeFormat);
    }
    else if (pyvar_timeFormat != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter timeFormat at index 6");
    if (unicodetimeFormat)
        bstimeFormat = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodetimeFormat), 
                                            (UINT)PyUnicode_GET_SIZE(unicodetimeFormat));
    
    if (PyErr_Occurred())
      goto itemporalrecordset_indexfeatureclass_method_cleanup;
    
    if (PyString_Check(pyvar_amDesignator))
        unicodeamDesignator = PyUnicode_FromObject(pyvar_amDesignator);
    else if (PyUnicode_Check(pyvar_amDesignator))
    {
        unicodeamDesignator = pyvar_amDesignator;
        Py_INCREF(unicodeamDesignator);
    }
    else if (pyvar_amDesignator != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter amDesignator at index 7");
    if (unicodeamDesignator)
        bsamDesignator = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeamDesignator), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeamDesignator));
    
    if (PyErr_Occurred())
      goto itemporalrecordset_indexfeatureclass_method_cleanup;
    
    if (PyString_Check(pyvar_pmDesignator))
        unicodepmDesignator = PyUnicode_FromObject(pyvar_pmDesignator);
    else if (PyUnicode_Check(pyvar_pmDesignator))
    {
        unicodepmDesignator = pyvar_pmDesignator;
        Py_INCREF(unicodepmDesignator);
    }
    else if (pyvar_pmDesignator != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter pmDesignator at index 8");
    if (unicodepmDesignator)
        bspmDesignator = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodepmDesignator), 
                                            (UINT)PyUnicode_GET_SIZE(unicodepmDesignator));
    
    if (PyErr_Occurred())
      goto itemporalrecordset_indexfeatureclass_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITemporalRecordSet->IndexFeatureClass(vcacheStartingTime, vcacheEndingTime, ipselSet, ipQueryFilter, llocaleLanguageID, bsdateFormat, bstimeFormat, bsamDesignator, bspmDesignator);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalRecordSet->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalRecordSet) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalRecordSet.IndexFeatureClass() returned %ld", (long)hr);
        goto itemporalrecordset_indexfeatureclass_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for cacheStartingTime
    // No teardown for cacheEndingTime
    // No teardown for selSet
    // No teardown for QueryFilter
    // No teardown for localeLanguageID
    // No teardown for dateFormat
    // No teardown for timeFormat
    // No teardown for amDesignator
    // No teardown for pmDesignator

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto itemporalrecordset_indexfeatureclass_method_cleanup;

    itemporalrecordset_indexfeatureclass_method_cleanup:
    self->m_HR = hr;
    ::VariantClear(&vcacheStartingTime);
    ::VariantClear(&vcacheEndingTime);
    if (ipselSet)
      ipselSet->Release();
    if (ipQueryFilter)
      ipQueryFilter->Release();
    // No cleanup for localeLanguageID
    if (bsdateFormat)
        ::SysFreeString(bsdateFormat);
    
    if (bstimeFormat)
        ::SysFreeString(bstimeFormat);
    
    if (bsamDesignator)
        ::SysFreeString(bsamDesignator);
    
    if (bspmDesignator)
        ::SysFreeString(bspmDesignator);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalRecordSet.IndexFeatureClass");
    return return_tuple;
}

static PyObject*
ITemporalRecordSetMethod_get_Count(PyITemporalRecordSetObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Count

    // Call method on actual COM interface
    hr = self->m_pITemporalRecordSet->get_Count(&lCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalRecordSet->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalRecordSet) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalRecordSet.get_Count() returned %ld", (long)hr);
        goto itemporalrecordset_get_count_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Count

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lCount);
    goto itemporalrecordset_get_count_method_cleanup;

    itemporalrecordset_get_count_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Count
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalRecordSet.get_Count");
    return return_tuple;
}

static PyObject*
ITemporalRecordSetMethod_Search(PyITemporalRecordSetObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IQueryFilter* ipQueryFilter = NULL;
    PyObject* py_QueryFilter;
    VARIANT_BOOL b_Recycling = VARIANT_FALSE;
    PyObject* pyvar_Recycling = NULL;
    VARIANT_BOOL b_forDrawing = VARIANT_FALSE;
    PyObject* pyvar_forDrawing = NULL;
    IFeatureCursor* ipfeatureCursor = NULL;
    PyObject* py_featureCursor = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOO", &py_QueryFilter, &pyvar_Recycling, &pyvar_forDrawing))
      goto itemporalrecordset_search_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_QueryFilter, &IID_IQueryFilter, (void**)&ipQueryFilter))
        PyErr_SetString(PyExc_TypeError, "Argument QueryFilter (position 0) is not IQueryFilter");
    
    if (PyErr_Occurred())
      goto itemporalrecordset_search_method_cleanup;
    
    b_Recycling = ((PyObject_IsTrue(pyvar_Recycling) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto itemporalrecordset_search_method_cleanup;
    
    b_forDrawing = ((PyObject_IsTrue(pyvar_forDrawing) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto itemporalrecordset_search_method_cleanup;
    
    // No setup for featureCursor

    // Call method on actual COM interface
    hr = self->m_pITemporalRecordSet->Search(ipQueryFilter, b_Recycling, b_forDrawing, &ipfeatureCursor);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalRecordSet->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalRecordSet) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalRecordSet.Search() returned %ld", (long)hr);
        goto itemporalrecordset_search_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for QueryFilter
    // No teardown for Recycling
    // No teardown for forDrawing
    Py_XDECREF(py_featureCursor);
    if (ipfeatureCursor)
    {
        IUnknown* pUnk = NULL;
        ipfeatureCursor->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_featureCursor = IUnknownToPythonIIDObject(pUnk, &IID_IFeatureCursor);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_featureCursor)
    {
        if (py_featureCursor)
           Py_DECREF(py_featureCursor);
        py_featureCursor = Py_None;
        Py_INCREF(py_featureCursor);
    }
    if (PyErr_Occurred())
      goto itemporalrecordset_search_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_featureCursor);
    goto itemporalrecordset_search_method_cleanup;

    itemporalrecordset_search_method_cleanup:
    self->m_HR = hr;
    if (ipQueryFilter)
      ipQueryFilter->Release();
    // No cleanup for Recycling
    // No cleanup for forDrawing
    Py_XDECREF(py_featureCursor);
    if (ipfeatureCursor)
      ipfeatureCursor->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalRecordSet.Search");
    return return_tuple;
}

static PyObject*
ITemporalRecordSetMethod_get_CacheFeatures(PyITemporalRecordSetObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_cacheTheFeatures = VARIANT_FALSE;
    PyObject* pyvar_cacheTheFeatures = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for cacheTheFeatures

    // Call method on actual COM interface
    hr = self->m_pITemporalRecordSet->get_CacheFeatures(&b_cacheTheFeatures);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalRecordSet->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalRecordSet) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalRecordSet.get_CacheFeatures() returned %ld", (long)hr);
        goto itemporalrecordset_get_cachefeatures_method_cleanup;
    }

    // Set up return values as needed
    pyvar_cacheTheFeatures = ((b_cacheTheFeatures == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto itemporalrecordset_get_cachefeatures_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_cacheTheFeatures);
    goto itemporalrecordset_get_cachefeatures_method_cleanup;

    itemporalrecordset_get_cachefeatures_method_cleanup:
    self->m_HR = hr;
    // No cleanup for cacheTheFeatures
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalRecordSet.get_CacheFeatures");
    return return_tuple;
}

static PyObject*
ITemporalRecordSetMethod_put_CacheFeatures(PyITemporalRecordSetObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_cacheTheFeatures = VARIANT_FALSE;
    PyObject* pyvar_cacheTheFeatures = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_cacheTheFeatures))
      goto itemporalrecordset_put_cachefeatures_method_cleanup;

    // Set up initial variable values as needed
    b_cacheTheFeatures = ((PyObject_IsTrue(pyvar_cacheTheFeatures) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto itemporalrecordset_put_cachefeatures_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITemporalRecordSet->put_CacheFeatures(b_cacheTheFeatures);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalRecordSet->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalRecordSet) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalRecordSet.put_CacheFeatures() returned %ld", (long)hr);
        goto itemporalrecordset_put_cachefeatures_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for cacheTheFeatures

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto itemporalrecordset_put_cachefeatures_method_cleanup;

    itemporalrecordset_put_cachefeatures_method_cleanup:
    self->m_HR = hr;
    // No cleanup for cacheTheFeatures
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalRecordSet.put_CacheFeatures");
    return return_tuple;
}

static PyObject*
ITemporalRecordSetMethod_get_TimeSeriesColumnName(PyITemporalRecordSetObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName;
    PyObject* pyvar_Name = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Name

    // Call method on actual COM interface
    hr = self->m_pITemporalRecordSet->get_TimeSeriesColumnName(&bsName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalRecordSet->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalRecordSet) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalRecordSet.get_TimeSeriesColumnName() returned %ld", (long)hr);
        goto itemporalrecordset_get_timeseriescolumnname_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Name = PyUnicode_FromWideChar(bsName,::SysStringLen(bsName));
    ::SysFreeString(bsName);
    
    if (PyErr_Occurred())
      goto itemporalrecordset_get_timeseriescolumnname_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Name);
    goto itemporalrecordset_get_timeseriescolumnname_method_cleanup;

    itemporalrecordset_get_timeseriescolumnname_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Name != Py_None)
        Py_XDECREF(pyvar_Name);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalRecordSet.get_TimeSeriesColumnName");
    return return_tuple;
}

static PyObject*
ITemporalRecordSetMethod_put_TimeSeriesColumnName(PyITemporalRecordSetObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName = 0;
    PyObject* pyvar_Name;
    PyObject* unicodeName = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_Name))
      goto itemporalrecordset_put_timeseriescolumnname_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_Name))
        unicodeName = PyUnicode_FromObject(pyvar_Name);
    else if (PyUnicode_Check(pyvar_Name))
    {
        unicodeName = pyvar_Name;
        Py_INCREF(unicodeName);
    }
    else if (pyvar_Name != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Name at index 0");
    if (unicodeName)
        bsName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeName));
    
    if (PyErr_Occurred())
      goto itemporalrecordset_put_timeseriescolumnname_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITemporalRecordSet->put_TimeSeriesColumnName(bsName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalRecordSet->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalRecordSet) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalRecordSet.put_TimeSeriesColumnName() returned %ld", (long)hr);
        goto itemporalrecordset_put_timeseriescolumnname_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Name

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto itemporalrecordset_put_timeseriescolumnname_method_cleanup;

    itemporalrecordset_put_timeseriescolumnname_method_cleanup:
    self->m_HR = hr;
    if (bsName)
        ::SysFreeString(bsName);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalRecordSet.put_TimeSeriesColumnName");
    return return_tuple;
}

static PyObject*
ITemporalRecordSetMethod_get_FeatureCacheWindow(PyITemporalRecordSetObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    int ipercent = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for percent

    // Call method on actual COM interface
    hr = self->m_pITemporalRecordSet->get_FeatureCacheWindow(&ipercent);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalRecordSet->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalRecordSet) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalRecordSet.get_FeatureCacheWindow() returned %ld", (long)hr);
        goto itemporalrecordset_get_featurecachewindow_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for percent

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            ipercent);
    goto itemporalrecordset_get_featurecachewindow_method_cleanup;

    itemporalrecordset_get_featurecachewindow_method_cleanup:
    self->m_HR = hr;
    // No cleanup for percent
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalRecordSet.get_FeatureCacheWindow");
    return return_tuple;
}

static PyObject*
ITemporalRecordSetMethod_put_FeatureCacheWindow(PyITemporalRecordSetObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    int ipercent = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", &ipercent))
      goto itemporalrecordset_put_featurecachewindow_method_cleanup;

    // Set up initial variable values as needed
    // No setup for percent

    // Call method on actual COM interface
    hr = self->m_pITemporalRecordSet->put_FeatureCacheWindow(ipercent);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalRecordSet->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalRecordSet) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalRecordSet.put_FeatureCacheWindow() returned %ld", (long)hr);
        goto itemporalrecordset_put_featurecachewindow_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for percent

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto itemporalrecordset_put_featurecachewindow_method_cleanup;

    itemporalrecordset_put_featurecachewindow_method_cleanup:
    self->m_HR = hr;
    // No cleanup for percent
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalRecordSet.put_FeatureCacheWindow");
    return return_tuple;
}

static PyObject*
ITemporalRecordSetMethod_get_OldestFeature(PyITemporalRecordSetObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT vfeature;
    ::VariantInit(&vfeature);
    PyObject* pyvar_feature = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for feature

    // Call method on actual COM interface
    hr = self->m_pITemporalRecordSet->get_OldestFeature(&vfeature);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalRecordSet->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalRecordSet) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalRecordSet.get_OldestFeature() returned %ld", (long)hr);
        goto itemporalrecordset_get_oldestfeature_method_cleanup;
    }

    // Set up return values as needed
    pyvar_feature = Variant_AsPyObject(&vfeature);
    if (PyErr_Occurred())
      goto itemporalrecordset_get_oldestfeature_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_feature);
    goto itemporalrecordset_get_oldestfeature_method_cleanup;

    itemporalrecordset_get_oldestfeature_method_cleanup:
    self->m_HR = hr;
    ::VariantClear(&vfeature);
    Py_XDECREF(pyvar_feature);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalRecordSet.get_OldestFeature");
    return return_tuple;
}

static PyObject*
ITemporalRecordSetMethod_get_MostCurrentFeature(PyITemporalRecordSetObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT vfeature;
    ::VariantInit(&vfeature);
    PyObject* pyvar_feature = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for feature

    // Call method on actual COM interface
    hr = self->m_pITemporalRecordSet->get_MostCurrentFeature(&vfeature);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalRecordSet->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalRecordSet) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalRecordSet.get_MostCurrentFeature() returned %ld", (long)hr);
        goto itemporalrecordset_get_mostcurrentfeature_method_cleanup;
    }

    // Set up return values as needed
    pyvar_feature = Variant_AsPyObject(&vfeature);
    if (PyErr_Occurred())
      goto itemporalrecordset_get_mostcurrentfeature_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_feature);
    goto itemporalrecordset_get_mostcurrentfeature_method_cleanup;

    itemporalrecordset_get_mostcurrentfeature_method_cleanup:
    self->m_HR = hr;
    ::VariantClear(&vfeature);
    Py_XDECREF(pyvar_feature);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalRecordSet.get_MostCurrentFeature");
    return return_tuple;
}

static PyObject*
ITemporalRecordSetMethod_SelectByDate(PyITemporalRecordSetObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT vStartDate;
    ::VariantInit(&vStartDate);
    PyObject* pyvar_StartDate = NULL;
    VARIANT vendDate;
    ::VariantInit(&vendDate);
    PyObject* pyvar_endDate = NULL;
    ISelectionSet* ipselectionSet = NULL;
    PyObject* py_selectionSet = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OO", &pyvar_StartDate, &pyvar_endDate))
      goto itemporalrecordset_selectbydate_method_cleanup;

    // Set up initial variable values as needed
    PyObject_AsVariant(pyvar_StartDate, &vStartDate);
    
    if (PyErr_Occurred())
      goto itemporalrecordset_selectbydate_method_cleanup;
    
    PyObject_AsVariant(pyvar_endDate, &vendDate);
    
    if (PyErr_Occurred())
      goto itemporalrecordset_selectbydate_method_cleanup;
    
    // No setup for selectionSet

    // Call method on actual COM interface
    hr = self->m_pITemporalRecordSet->SelectByDate(vStartDate, vendDate, &ipselectionSet);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalRecordSet->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalRecordSet) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalRecordSet.SelectByDate() returned %ld", (long)hr);
        goto itemporalrecordset_selectbydate_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for StartDate
    // No teardown for endDate
    Py_XDECREF(py_selectionSet);
    if (ipselectionSet)
    {
        IUnknown* pUnk = NULL;
        ipselectionSet->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_selectionSet = IUnknownToPythonIIDObject(pUnk, &IID_ISelectionSet);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_selectionSet)
    {
        if (py_selectionSet)
           Py_DECREF(py_selectionSet);
        py_selectionSet = Py_None;
        Py_INCREF(py_selectionSet);
    }
    if (PyErr_Occurred())
      goto itemporalrecordset_selectbydate_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_selectionSet);
    goto itemporalrecordset_selectbydate_method_cleanup;

    itemporalrecordset_selectbydate_method_cleanup:
    self->m_HR = hr;
    ::VariantClear(&vStartDate);
    ::VariantClear(&vendDate);
    Py_XDECREF(py_selectionSet);
    if (ipselectionSet)
      ipselectionSet->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalRecordSet.SelectByDate");
    return return_tuple;
}


PyMethodDef PyITemporalRecordSetMethods[] = {
    {"supports", (PyCFunction)PyITemporalRecordSet_SupportsInterface, METH_O, ""},
    {"get_TemporalColumnName", (PyCFunction)ITemporalRecordSetMethod_get_TemporalColumnName, METH_VARARGS, ""},
    {"put_TemporalColumnName", (PyCFunction)ITemporalRecordSetMethod_put_TemporalColumnName, METH_VARARGS, ""},
    {"get_FeatureClass", (PyCFunction)ITemporalRecordSetMethod_get_FeatureClass, METH_VARARGS, ""},
    {"putref_FeatureClass", (PyCFunction)ITemporalRecordSetMethod_putref_FeatureClass, METH_VARARGS, ""},
    {"IndexFeatureClass", (PyCFunction)ITemporalRecordSetMethod_IndexFeatureClass, METH_VARARGS, ""},
    {"get_Count", (PyCFunction)ITemporalRecordSetMethod_get_Count, METH_VARARGS, ""},
    {"Search", (PyCFunction)ITemporalRecordSetMethod_Search, METH_VARARGS, ""},
    {"get_CacheFeatures", (PyCFunction)ITemporalRecordSetMethod_get_CacheFeatures, METH_VARARGS, ""},
    {"put_CacheFeatures", (PyCFunction)ITemporalRecordSetMethod_put_CacheFeatures, METH_VARARGS, ""},
    {"get_TimeSeriesColumnName", (PyCFunction)ITemporalRecordSetMethod_get_TimeSeriesColumnName, METH_VARARGS, ""},
    {"put_TimeSeriesColumnName", (PyCFunction)ITemporalRecordSetMethod_put_TimeSeriesColumnName, METH_VARARGS, ""},
    {"get_FeatureCacheWindow", (PyCFunction)ITemporalRecordSetMethod_get_FeatureCacheWindow, METH_VARARGS, ""},
    {"put_FeatureCacheWindow", (PyCFunction)ITemporalRecordSetMethod_put_FeatureCacheWindow, METH_VARARGS, ""},
    {"get_OldestFeature", (PyCFunction)ITemporalRecordSetMethod_get_OldestFeature, METH_VARARGS, ""},
    {"get_MostCurrentFeature", (PyCFunction)ITemporalRecordSetMethod_get_MostCurrentFeature, METH_VARARGS, ""},
    {"SelectByDate", (PyCFunction)ITemporalRecordSetMethod_SelectByDate, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyITemporalRecordSetGetSet[] = {
  {"_pUnk", (getter)PyITemporalRecordSet_GetpUnk, NULL, "Get opaque pointer to an Unknown from ITemporalRecordSet", NULL},
  {"_pointer", (getter)PyITemporalRecordSet_GetPointer, NULL, "Get memory address for ITemporalRecordSet", NULL},
  {"_IID", (getter)PyITemporalRecordSet_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyITemporalRecordSet_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyITemporalRecordSet_GetIgnoreFailures, (setter)PyITemporalRecordSet_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyITemporalRecordSetObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.ITemporalRecordSetObject",                          
                                              /* tp_name */
  sizeof(PyITemporalRecordSetObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyITemporalRecordSetObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyITemporalRecordSetMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyITemporalRecordSetGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyITemporalRecordSetObject_new,                      
                                              /* tp_new */
};

// Interface ITxFeatureClass

typedef struct PyITxFeatureClassObject {
    PyObject_HEAD
    ITxFeatureClass* m_pITxFeatureClass;
    HRESULT m_HR;
    int m_ignore_failures;
} PyITxFeatureClassObject;

static PyObject*
PyITxFeatureClassObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyITxFeatureClassObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ITxFeatureClass* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ITxFeatureClass, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ITxFeatureClass with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyITxFeatureClassObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ITxFeatureClass");
            return NULL;
        }
        self->m_pITxFeatureClass = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ITxFeatureClass");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ITxFeatureClass");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ITxFeatureClass* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ITxFeatureClass, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ITxFeatureClass");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyITxFeatureClassObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ITxFeatureClass");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pITxFeatureClass = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyITxFeatureClassObject_dealloc(PyITxFeatureClassObject* self)
{
    if (self->m_pITxFeatureClass)
        self->m_pITxFeatureClass->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyITxFeatureClass_GetpUnk(PyITxFeatureClassObject* self)
{
    if (!self->m_pITxFeatureClass)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pITxFeatureClass->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ITxFeatureClass to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyITxFeatureClass_GetPointer(PyITxFeatureClassObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pITxFeatureClass);
}

static PyObject*
PyITxFeatureClass_GetIID(PyITxFeatureClassObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "b7a65dde-9218-4e42-8c62-299ac695a66a");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyITxFeatureClass_GetHR(PyITxFeatureClassObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyITxFeatureClass_GetIgnoreFailures(PyITxFeatureClassObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyITxFeatureClass_SetIgnoreFailures(PyITxFeatureClassObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyITxFeatureClass_SupportsInterface(PyITxFeatureClassObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pITxFeatureClass->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ITxFeatureClassMethod_get_FeatureClass(PyITxFeatureClassObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IFeatureClass* ipFeatureClass = NULL;
    PyObject* py_FeatureClass = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for FeatureClass

    // Call method on actual COM interface
    hr = self->m_pITxFeatureClass->get_FeatureClass(&ipFeatureClass);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITxFeatureClass->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITxFeatureClass) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITxFeatureClass.get_FeatureClass() returned %ld", (long)hr);
        goto itxfeatureclass_get_featureclass_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_FeatureClass);
    if (ipFeatureClass)
    {
        IUnknown* pUnk = NULL;
        ipFeatureClass->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_FeatureClass = IUnknownToPythonIIDObject(pUnk, &IID_IFeatureClass);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_FeatureClass)
    {
        if (py_FeatureClass)
           Py_DECREF(py_FeatureClass);
        py_FeatureClass = Py_None;
        Py_INCREF(py_FeatureClass);
    }
    if (PyErr_Occurred())
      goto itxfeatureclass_get_featureclass_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_FeatureClass);
    goto itxfeatureclass_get_featureclass_method_cleanup;

    itxfeatureclass_get_featureclass_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_FeatureClass);
    if (ipFeatureClass)
      ipFeatureClass->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITxFeatureClass.get_FeatureClass");
    return return_tuple;
}

static PyObject*
ITxFeatureClassMethod_putref_FeatureClass(PyITxFeatureClassObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IFeatureClass* ipFeatureClass = NULL;
    PyObject* py_FeatureClass;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_FeatureClass))
      goto itxfeatureclass_putref_featureclass_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_FeatureClass, &IID_IFeatureClass, (void**)&ipFeatureClass))
        PyErr_SetString(PyExc_TypeError, "Argument FeatureClass (position 0) is not IFeatureClass");
    
    if (PyErr_Occurred())
      goto itxfeatureclass_putref_featureclass_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITxFeatureClass->putref_FeatureClass(ipFeatureClass);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITxFeatureClass->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITxFeatureClass) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITxFeatureClass.putref_FeatureClass() returned %ld", (long)hr);
        goto itxfeatureclass_putref_featureclass_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for FeatureClass

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto itxfeatureclass_putref_featureclass_method_cleanup;

    itxfeatureclass_putref_featureclass_method_cleanup:
    self->m_HR = hr;
    if (ipFeatureClass)
      ipFeatureClass->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITxFeatureClass.putref_FeatureClass");
    return return_tuple;
}

static PyObject*
ITxFeatureClassMethod_get_CachingMode(PyITxFeatureClassObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriTxFeatureClassCachingMode eCachingMode;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for CachingMode

    // Call method on actual COM interface
    hr = self->m_pITxFeatureClass->get_CachingMode(&eCachingMode);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITxFeatureClass->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITxFeatureClass) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITxFeatureClass.get_CachingMode() returned %ld", (long)hr);
        goto itxfeatureclass_get_cachingmode_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for CachingMode

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)eCachingMode);
    goto itxfeatureclass_get_cachingmode_method_cleanup;

    itxfeatureclass_get_cachingmode_method_cleanup:
    self->m_HR = hr;
    // No cleanup for CachingMode
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITxFeatureClass.get_CachingMode");
    return return_tuple;
}

static PyObject*
ITxFeatureClassMethod_put_CachingMode(PyITxFeatureClassObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriTxFeatureClassCachingMode eCachingMode;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&eCachingMode))
      goto itxfeatureclass_put_cachingmode_method_cleanup;

    // Set up initial variable values as needed
    // No setup for CachingMode

    // Call method on actual COM interface
    hr = self->m_pITxFeatureClass->put_CachingMode(eCachingMode);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITxFeatureClass->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITxFeatureClass) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITxFeatureClass.put_CachingMode() returned %ld", (long)hr);
        goto itxfeatureclass_put_cachingmode_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for CachingMode

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto itxfeatureclass_put_cachingmode_method_cleanup;

    itxfeatureclass_put_cachingmode_method_cleanup:
    self->m_HR = hr;
    // No cleanup for CachingMode
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITxFeatureClass.put_CachingMode");
    return return_tuple;
}

static PyObject*
ITxFeatureClassMethod_get_TrackIDFieldName(PyITxFeatureClassObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName;
    PyObject* pyvar_Name = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Name

    // Call method on actual COM interface
    hr = self->m_pITxFeatureClass->get_TrackIDFieldName(&bsName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITxFeatureClass->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITxFeatureClass) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITxFeatureClass.get_TrackIDFieldName() returned %ld", (long)hr);
        goto itxfeatureclass_get_trackidfieldname_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Name = PyUnicode_FromWideChar(bsName,::SysStringLen(bsName));
    ::SysFreeString(bsName);
    
    if (PyErr_Occurred())
      goto itxfeatureclass_get_trackidfieldname_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Name);
    goto itxfeatureclass_get_trackidfieldname_method_cleanup;

    itxfeatureclass_get_trackidfieldname_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Name != Py_None)
        Py_XDECREF(pyvar_Name);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITxFeatureClass.get_TrackIDFieldName");
    return return_tuple;
}

static PyObject*
ITxFeatureClassMethod_put_TrackIDFieldName(PyITxFeatureClassObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName = 0;
    PyObject* pyvar_Name;
    PyObject* unicodeName = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_Name))
      goto itxfeatureclass_put_trackidfieldname_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_Name))
        unicodeName = PyUnicode_FromObject(pyvar_Name);
    else if (PyUnicode_Check(pyvar_Name))
    {
        unicodeName = pyvar_Name;
        Py_INCREF(unicodeName);
    }
    else if (pyvar_Name != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Name at index 0");
    if (unicodeName)
        bsName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeName));
    
    if (PyErr_Occurred())
      goto itxfeatureclass_put_trackidfieldname_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITxFeatureClass->put_TrackIDFieldName(bsName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITxFeatureClass->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITxFeatureClass) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITxFeatureClass.put_TrackIDFieldName() returned %ld", (long)hr);
        goto itxfeatureclass_put_trackidfieldname_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Name

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto itxfeatureclass_put_trackidfieldname_method_cleanup;

    itxfeatureclass_put_trackidfieldname_method_cleanup:
    self->m_HR = hr;
    if (bsName)
        ::SysFreeString(bsName);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITxFeatureClass.put_TrackIDFieldName");
    return return_tuple;
}

static PyObject*
ITxFeatureClassMethod_get_StartTimeFieldName(PyITxFeatureClassObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName;
    PyObject* pyvar_Name = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Name

    // Call method on actual COM interface
    hr = self->m_pITxFeatureClass->get_StartTimeFieldName(&bsName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITxFeatureClass->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITxFeatureClass) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITxFeatureClass.get_StartTimeFieldName() returned %ld", (long)hr);
        goto itxfeatureclass_get_starttimefieldname_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Name = PyUnicode_FromWideChar(bsName,::SysStringLen(bsName));
    ::SysFreeString(bsName);
    
    if (PyErr_Occurred())
      goto itxfeatureclass_get_starttimefieldname_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Name);
    goto itxfeatureclass_get_starttimefieldname_method_cleanup;

    itxfeatureclass_get_starttimefieldname_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Name != Py_None)
        Py_XDECREF(pyvar_Name);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITxFeatureClass.get_StartTimeFieldName");
    return return_tuple;
}

static PyObject*
ITxFeatureClassMethod_put_StartTimeFieldName(PyITxFeatureClassObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName = 0;
    PyObject* pyvar_Name;
    PyObject* unicodeName = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_Name))
      goto itxfeatureclass_put_starttimefieldname_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_Name))
        unicodeName = PyUnicode_FromObject(pyvar_Name);
    else if (PyUnicode_Check(pyvar_Name))
    {
        unicodeName = pyvar_Name;
        Py_INCREF(unicodeName);
    }
    else if (pyvar_Name != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Name at index 0");
    if (unicodeName)
        bsName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeName));
    
    if (PyErr_Occurred())
      goto itxfeatureclass_put_starttimefieldname_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITxFeatureClass->put_StartTimeFieldName(bsName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITxFeatureClass->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITxFeatureClass) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITxFeatureClass.put_StartTimeFieldName() returned %ld", (long)hr);
        goto itxfeatureclass_put_starttimefieldname_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Name

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto itxfeatureclass_put_starttimefieldname_method_cleanup;

    itxfeatureclass_put_starttimefieldname_method_cleanup:
    self->m_HR = hr;
    if (bsName)
        ::SysFreeString(bsName);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITxFeatureClass.put_StartTimeFieldName");
    return return_tuple;
}

static PyObject*
ITxFeatureClassMethod_get_EndTimeFieldName(PyITxFeatureClassObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName;
    PyObject* pyvar_Name = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Name

    // Call method on actual COM interface
    hr = self->m_pITxFeatureClass->get_EndTimeFieldName(&bsName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITxFeatureClass->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITxFeatureClass) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITxFeatureClass.get_EndTimeFieldName() returned %ld", (long)hr);
        goto itxfeatureclass_get_endtimefieldname_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Name = PyUnicode_FromWideChar(bsName,::SysStringLen(bsName));
    ::SysFreeString(bsName);
    
    if (PyErr_Occurred())
      goto itxfeatureclass_get_endtimefieldname_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Name);
    goto itxfeatureclass_get_endtimefieldname_method_cleanup;

    itxfeatureclass_get_endtimefieldname_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Name != Py_None)
        Py_XDECREF(pyvar_Name);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITxFeatureClass.get_EndTimeFieldName");
    return return_tuple;
}

static PyObject*
ITxFeatureClassMethod_put_EndTimeFieldName(PyITxFeatureClassObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName = 0;
    PyObject* pyvar_Name;
    PyObject* unicodeName = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_Name))
      goto itxfeatureclass_put_endtimefieldname_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_Name))
        unicodeName = PyUnicode_FromObject(pyvar_Name);
    else if (PyUnicode_Check(pyvar_Name))
    {
        unicodeName = pyvar_Name;
        Py_INCREF(unicodeName);
    }
    else if (pyvar_Name != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Name at index 0");
    if (unicodeName)
        bsName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeName));
    
    if (PyErr_Occurred())
      goto itxfeatureclass_put_endtimefieldname_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITxFeatureClass->put_EndTimeFieldName(bsName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITxFeatureClass->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITxFeatureClass) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITxFeatureClass.put_EndTimeFieldName() returned %ld", (long)hr);
        goto itxfeatureclass_put_endtimefieldname_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Name

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto itxfeatureclass_put_endtimefieldname_method_cleanup;

    itxfeatureclass_put_endtimefieldname_method_cleanup:
    self->m_HR = hr;
    if (bsName)
        ::SysFreeString(bsName);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITxFeatureClass.put_EndTimeFieldName");
    return return_tuple;
}

static PyObject*
ITxFeatureClassMethod_get_TimeFieldFormat(PyITxFeatureClassObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsTimeFieldFormat;
    PyObject* pyvar_TimeFieldFormat = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for TimeFieldFormat

    // Call method on actual COM interface
    hr = self->m_pITxFeatureClass->get_TimeFieldFormat(&bsTimeFieldFormat);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITxFeatureClass->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITxFeatureClass) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITxFeatureClass.get_TimeFieldFormat() returned %ld", (long)hr);
        goto itxfeatureclass_get_timefieldformat_method_cleanup;
    }

    // Set up return values as needed
    pyvar_TimeFieldFormat = PyUnicode_FromWideChar(bsTimeFieldFormat,::SysStringLen(bsTimeFieldFormat));
    ::SysFreeString(bsTimeFieldFormat);
    
    if (PyErr_Occurred())
      goto itxfeatureclass_get_timefieldformat_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_TimeFieldFormat);
    goto itxfeatureclass_get_timefieldformat_method_cleanup;

    itxfeatureclass_get_timefieldformat_method_cleanup:
    self->m_HR = hr;
    if (pyvar_TimeFieldFormat != Py_None)
        Py_XDECREF(pyvar_TimeFieldFormat);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITxFeatureClass.get_TimeFieldFormat");
    return return_tuple;
}

static PyObject*
ITxFeatureClassMethod_put_TimeFieldFormat(PyITxFeatureClassObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsTimeFieldFormat = 0;
    PyObject* pyvar_TimeFieldFormat;
    PyObject* unicodeTimeFieldFormat = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_TimeFieldFormat))
      goto itxfeatureclass_put_timefieldformat_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_TimeFieldFormat))
        unicodeTimeFieldFormat = PyUnicode_FromObject(pyvar_TimeFieldFormat);
    else if (PyUnicode_Check(pyvar_TimeFieldFormat))
    {
        unicodeTimeFieldFormat = pyvar_TimeFieldFormat;
        Py_INCREF(unicodeTimeFieldFormat);
    }
    else if (pyvar_TimeFieldFormat != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter TimeFieldFormat at index 0");
    if (unicodeTimeFieldFormat)
        bsTimeFieldFormat = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeTimeFieldFormat), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeTimeFieldFormat));
    
    if (PyErr_Occurred())
      goto itxfeatureclass_put_timefieldformat_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITxFeatureClass->put_TimeFieldFormat(bsTimeFieldFormat);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITxFeatureClass->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITxFeatureClass) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITxFeatureClass.put_TimeFieldFormat() returned %ld", (long)hr);
        goto itxfeatureclass_put_timefieldformat_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for TimeFieldFormat

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto itxfeatureclass_put_timefieldformat_method_cleanup;

    itxfeatureclass_put_timefieldformat_method_cleanup:
    self->m_HR = hr;
    if (bsTimeFieldFormat)
        ::SysFreeString(bsTimeFieldFormat);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITxFeatureClass.put_TimeFieldFormat");
    return return_tuple;
}

static PyObject*
ITxFeatureClassMethod_get_TimeFieldAmFormat(PyITxFeatureClassObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsamFormat;
    PyObject* pyvar_amFormat = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for amFormat

    // Call method on actual COM interface
    hr = self->m_pITxFeatureClass->get_TimeFieldAmFormat(&bsamFormat);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITxFeatureClass->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITxFeatureClass) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITxFeatureClass.get_TimeFieldAmFormat() returned %ld", (long)hr);
        goto itxfeatureclass_get_timefieldamformat_method_cleanup;
    }

    // Set up return values as needed
    pyvar_amFormat = PyUnicode_FromWideChar(bsamFormat,::SysStringLen(bsamFormat));
    ::SysFreeString(bsamFormat);
    
    if (PyErr_Occurred())
      goto itxfeatureclass_get_timefieldamformat_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_amFormat);
    goto itxfeatureclass_get_timefieldamformat_method_cleanup;

    itxfeatureclass_get_timefieldamformat_method_cleanup:
    self->m_HR = hr;
    if (pyvar_amFormat != Py_None)
        Py_XDECREF(pyvar_amFormat);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITxFeatureClass.get_TimeFieldAmFormat");
    return return_tuple;
}

static PyObject*
ITxFeatureClassMethod_put_TimeFieldAmFormat(PyITxFeatureClassObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsamFormat = 0;
    PyObject* pyvar_amFormat;
    PyObject* unicodeamFormat = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_amFormat))
      goto itxfeatureclass_put_timefieldamformat_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_amFormat))
        unicodeamFormat = PyUnicode_FromObject(pyvar_amFormat);
    else if (PyUnicode_Check(pyvar_amFormat))
    {
        unicodeamFormat = pyvar_amFormat;
        Py_INCREF(unicodeamFormat);
    }
    else if (pyvar_amFormat != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter amFormat at index 0");
    if (unicodeamFormat)
        bsamFormat = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeamFormat), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeamFormat));
    
    if (PyErr_Occurred())
      goto itxfeatureclass_put_timefieldamformat_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITxFeatureClass->put_TimeFieldAmFormat(bsamFormat);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITxFeatureClass->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITxFeatureClass) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITxFeatureClass.put_TimeFieldAmFormat() returned %ld", (long)hr);
        goto itxfeatureclass_put_timefieldamformat_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for amFormat

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto itxfeatureclass_put_timefieldamformat_method_cleanup;

    itxfeatureclass_put_timefieldamformat_method_cleanup:
    self->m_HR = hr;
    if (bsamFormat)
        ::SysFreeString(bsamFormat);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITxFeatureClass.put_TimeFieldAmFormat");
    return return_tuple;
}

static PyObject*
ITxFeatureClassMethod_get_TimeFieldPmFormat(PyITxFeatureClassObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspmFormat;
    PyObject* pyvar_pmFormat = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pmFormat

    // Call method on actual COM interface
    hr = self->m_pITxFeatureClass->get_TimeFieldPmFormat(&bspmFormat);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITxFeatureClass->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITxFeatureClass) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITxFeatureClass.get_TimeFieldPmFormat() returned %ld", (long)hr);
        goto itxfeatureclass_get_timefieldpmformat_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pmFormat = PyUnicode_FromWideChar(bspmFormat,::SysStringLen(bspmFormat));
    ::SysFreeString(bspmFormat);
    
    if (PyErr_Occurred())
      goto itxfeatureclass_get_timefieldpmformat_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pmFormat);
    goto itxfeatureclass_get_timefieldpmformat_method_cleanup;

    itxfeatureclass_get_timefieldpmformat_method_cleanup:
    self->m_HR = hr;
    if (pyvar_pmFormat != Py_None)
        Py_XDECREF(pyvar_pmFormat);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITxFeatureClass.get_TimeFieldPmFormat");
    return return_tuple;
}

static PyObject*
ITxFeatureClassMethod_put_TimeFieldPmFormat(PyITxFeatureClassObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspmFormat = 0;
    PyObject* pyvar_pmFormat;
    PyObject* unicodepmFormat = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pmFormat))
      goto itxfeatureclass_put_timefieldpmformat_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_pmFormat))
        unicodepmFormat = PyUnicode_FromObject(pyvar_pmFormat);
    else if (PyUnicode_Check(pyvar_pmFormat))
    {
        unicodepmFormat = pyvar_pmFormat;
        Py_INCREF(unicodepmFormat);
    }
    else if (pyvar_pmFormat != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter pmFormat at index 0");
    if (unicodepmFormat)
        bspmFormat = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodepmFormat), 
                                            (UINT)PyUnicode_GET_SIZE(unicodepmFormat));
    
    if (PyErr_Occurred())
      goto itxfeatureclass_put_timefieldpmformat_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITxFeatureClass->put_TimeFieldPmFormat(bspmFormat);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITxFeatureClass->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITxFeatureClass) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITxFeatureClass.put_TimeFieldPmFormat() returned %ld", (long)hr);
        goto itxfeatureclass_put_timefieldpmformat_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pmFormat

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto itxfeatureclass_put_timefieldpmformat_method_cleanup;

    itxfeatureclass_put_timefieldpmformat_method_cleanup:
    self->m_HR = hr;
    if (bspmFormat)
        ::SysFreeString(bspmFormat);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITxFeatureClass.put_TimeFieldPmFormat");
    return return_tuple;
}

static PyObject*
ITxFeatureClassMethod_get_TimeFieldLocaleID(PyITxFeatureClassObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long llocaleID = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for localeID

    // Call method on actual COM interface
    hr = self->m_pITxFeatureClass->get_TimeFieldLocaleID(&llocaleID);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITxFeatureClass->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITxFeatureClass) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITxFeatureClass.get_TimeFieldLocaleID() returned %ld", (long)hr);
        goto itxfeatureclass_get_timefieldlocaleid_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for localeID

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            llocaleID);
    goto itxfeatureclass_get_timefieldlocaleid_method_cleanup;

    itxfeatureclass_get_timefieldlocaleid_method_cleanup:
    self->m_HR = hr;
    // No cleanup for localeID
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITxFeatureClass.get_TimeFieldLocaleID");
    return return_tuple;
}

static PyObject*
ITxFeatureClassMethod_put_TimeFieldLocaleID(PyITxFeatureClassObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long llocaleID = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &llocaleID))
      goto itxfeatureclass_put_timefieldlocaleid_method_cleanup;

    // Set up initial variable values as needed
    // No setup for localeID

    // Call method on actual COM interface
    hr = self->m_pITxFeatureClass->put_TimeFieldLocaleID(llocaleID);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITxFeatureClass->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITxFeatureClass) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITxFeatureClass.put_TimeFieldLocaleID() returned %ld", (long)hr);
        goto itxfeatureclass_put_timefieldlocaleid_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for localeID

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto itxfeatureclass_put_timefieldlocaleid_method_cleanup;

    itxfeatureclass_put_timefieldlocaleid_method_cleanup:
    self->m_HR = hr;
    // No cleanup for localeID
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITxFeatureClass.put_TimeFieldLocaleID");
    return return_tuple;
}

static PyObject*
ITxFeatureClassMethod_IndexFeatureClass2(PyITxFeatureClassObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT vstartingTime;
    ::VariantInit(&vstartingTime);
    PyObject* pyvar_startingTime = NULL;
    VARIANT vendingTime;
    ::VariantInit(&vendingTime);
    PyObject* pyvar_endingTime = NULL;
    ISelectionSet* ipselSet = NULL;
    PyObject* py_selSet;
    IQueryFilter* ipQueryFilter = NULL;
    PyObject* py_QueryFilter;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOOO", &pyvar_startingTime, &pyvar_endingTime, &py_selSet, &py_QueryFilter))
      goto itxfeatureclass_indexfeatureclass2_method_cleanup;

    // Set up initial variable values as needed
    PyObject_AsVariant(pyvar_startingTime, &vstartingTime);
    
    if (PyErr_Occurred())
      goto itxfeatureclass_indexfeatureclass2_method_cleanup;
    
    PyObject_AsVariant(pyvar_endingTime, &vendingTime);
    
    if (PyErr_Occurred())
      goto itxfeatureclass_indexfeatureclass2_method_cleanup;
    
    if (!IFaceFromPyObject(py_selSet, &IID_ISelectionSet, (void**)&ipselSet))
        PyErr_SetString(PyExc_TypeError, "Argument selSet (position 2) is not ISelectionSet");
    
    if (PyErr_Occurred())
      goto itxfeatureclass_indexfeatureclass2_method_cleanup;
    
    if (!IFaceFromPyObject(py_QueryFilter, &IID_IQueryFilter, (void**)&ipQueryFilter))
        PyErr_SetString(PyExc_TypeError, "Argument QueryFilter (position 3) is not IQueryFilter");
    
    if (PyErr_Occurred())
      goto itxfeatureclass_indexfeatureclass2_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITxFeatureClass->IndexFeatureClass2(vstartingTime, vendingTime, ipselSet, ipQueryFilter);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITxFeatureClass->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITxFeatureClass) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITxFeatureClass.IndexFeatureClass2() returned %ld", (long)hr);
        goto itxfeatureclass_indexfeatureclass2_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for startingTime
    // No teardown for endingTime
    // No teardown for selSet
    // No teardown for QueryFilter

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto itxfeatureclass_indexfeatureclass2_method_cleanup;

    itxfeatureclass_indexfeatureclass2_method_cleanup:
    self->m_HR = hr;
    ::VariantClear(&vstartingTime);
    ::VariantClear(&vendingTime);
    if (ipselSet)
      ipselSet->Release();
    if (ipQueryFilter)
      ipQueryFilter->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITxFeatureClass.IndexFeatureClass2");
    return return_tuple;
}

static PyObject*
ITxFeatureClassMethod_RebuildIndex(PyITxFeatureClassObject* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pITxFeatureClass->RebuildIndex();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITxFeatureClass->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITxFeatureClass) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITxFeatureClass.RebuildIndex() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}


PyMethodDef PyITxFeatureClassMethods[] = {
    {"supports", (PyCFunction)PyITxFeatureClass_SupportsInterface, METH_O, ""},
    {"get_FeatureClass", (PyCFunction)ITxFeatureClassMethod_get_FeatureClass, METH_VARARGS, ""},
    {"putref_FeatureClass", (PyCFunction)ITxFeatureClassMethod_putref_FeatureClass, METH_VARARGS, ""},
    {"get_CachingMode", (PyCFunction)ITxFeatureClassMethod_get_CachingMode, METH_VARARGS, ""},
    {"put_CachingMode", (PyCFunction)ITxFeatureClassMethod_put_CachingMode, METH_VARARGS, ""},
    {"get_TrackIDFieldName", (PyCFunction)ITxFeatureClassMethod_get_TrackIDFieldName, METH_VARARGS, ""},
    {"put_TrackIDFieldName", (PyCFunction)ITxFeatureClassMethod_put_TrackIDFieldName, METH_VARARGS, ""},
    {"get_StartTimeFieldName", (PyCFunction)ITxFeatureClassMethod_get_StartTimeFieldName, METH_VARARGS, ""},
    {"put_StartTimeFieldName", (PyCFunction)ITxFeatureClassMethod_put_StartTimeFieldName, METH_VARARGS, ""},
    {"get_EndTimeFieldName", (PyCFunction)ITxFeatureClassMethod_get_EndTimeFieldName, METH_VARARGS, ""},
    {"put_EndTimeFieldName", (PyCFunction)ITxFeatureClassMethod_put_EndTimeFieldName, METH_VARARGS, ""},
    {"get_TimeFieldFormat", (PyCFunction)ITxFeatureClassMethod_get_TimeFieldFormat, METH_VARARGS, ""},
    {"put_TimeFieldFormat", (PyCFunction)ITxFeatureClassMethod_put_TimeFieldFormat, METH_VARARGS, ""},
    {"get_TimeFieldAmFormat", (PyCFunction)ITxFeatureClassMethod_get_TimeFieldAmFormat, METH_VARARGS, ""},
    {"put_TimeFieldAmFormat", (PyCFunction)ITxFeatureClassMethod_put_TimeFieldAmFormat, METH_VARARGS, ""},
    {"get_TimeFieldPmFormat", (PyCFunction)ITxFeatureClassMethod_get_TimeFieldPmFormat, METH_VARARGS, ""},
    {"put_TimeFieldPmFormat", (PyCFunction)ITxFeatureClassMethod_put_TimeFieldPmFormat, METH_VARARGS, ""},
    {"get_TimeFieldLocaleID", (PyCFunction)ITxFeatureClassMethod_get_TimeFieldLocaleID, METH_VARARGS, ""},
    {"put_TimeFieldLocaleID", (PyCFunction)ITxFeatureClassMethod_put_TimeFieldLocaleID, METH_VARARGS, ""},
    {"IndexFeatureClass2", (PyCFunction)ITxFeatureClassMethod_IndexFeatureClass2, METH_VARARGS, ""},
    {"RebuildIndex", (PyCFunction)ITxFeatureClassMethod_RebuildIndex, METH_NOARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyITxFeatureClassGetSet[] = {
  {"_pUnk", (getter)PyITxFeatureClass_GetpUnk, NULL, "Get opaque pointer to an Unknown from ITxFeatureClass", NULL},
  {"_pointer", (getter)PyITxFeatureClass_GetPointer, NULL, "Get memory address for ITxFeatureClass", NULL},
  {"_IID", (getter)PyITxFeatureClass_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyITxFeatureClass_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyITxFeatureClass_GetIgnoreFailures, (setter)PyITxFeatureClass_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyITxFeatureClassObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.ITxFeatureClassObject",                          
                                              /* tp_name */
  sizeof(PyITxFeatureClassObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyITxFeatureClassObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyITxFeatureClassMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyITxFeatureClassGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyITxFeatureClassObject_new,                      
                                              /* tp_new */
};

// Interface ITxEnumTrackId

typedef struct PyITxEnumTrackIdObject {
    PyObject_HEAD
    ITxEnumTrackId* m_pITxEnumTrackId;
    HRESULT m_HR;
    int m_ignore_failures;
} PyITxEnumTrackIdObject;

static PyObject*
PyITxEnumTrackIdObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyITxEnumTrackIdObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ITxEnumTrackId* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ITxEnumTrackId, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ITxEnumTrackId with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyITxEnumTrackIdObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ITxEnumTrackId");
            return NULL;
        }
        self->m_pITxEnumTrackId = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ITxEnumTrackId");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ITxEnumTrackId");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ITxEnumTrackId* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ITxEnumTrackId, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ITxEnumTrackId");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyITxEnumTrackIdObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ITxEnumTrackId");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pITxEnumTrackId = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyITxEnumTrackIdObject_dealloc(PyITxEnumTrackIdObject* self)
{
    if (self->m_pITxEnumTrackId)
        self->m_pITxEnumTrackId->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyITxEnumTrackId_GetpUnk(PyITxEnumTrackIdObject* self)
{
    if (!self->m_pITxEnumTrackId)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pITxEnumTrackId->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ITxEnumTrackId to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyITxEnumTrackId_GetPointer(PyITxEnumTrackIdObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pITxEnumTrackId);
}

static PyObject*
PyITxEnumTrackId_GetIID(PyITxEnumTrackIdObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "057b4c30-5c61-4b6c-a24d-b02f98be418f");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyITxEnumTrackId_GetHR(PyITxEnumTrackIdObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyITxEnumTrackId_GetIgnoreFailures(PyITxEnumTrackIdObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyITxEnumTrackId_SetIgnoreFailures(PyITxEnumTrackIdObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyITxEnumTrackId_SupportsInterface(PyITxEnumTrackIdObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pITxEnumTrackId->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ITxEnumTrackIdMethod_get_FirstTrackId(PyITxEnumTrackIdObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bstrackId;
    PyObject* pyvar_trackId = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for trackId

    // Call method on actual COM interface
    hr = self->m_pITxEnumTrackId->get_FirstTrackId(&bstrackId);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITxEnumTrackId->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITxEnumTrackId) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITxEnumTrackId.get_FirstTrackId() returned %ld", (long)hr);
        goto itxenumtrackid_get_firsttrackid_method_cleanup;
    }

    // Set up return values as needed
    pyvar_trackId = PyUnicode_FromWideChar(bstrackId,::SysStringLen(bstrackId));
    ::SysFreeString(bstrackId);
    
    if (PyErr_Occurred())
      goto itxenumtrackid_get_firsttrackid_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_trackId);
    goto itxenumtrackid_get_firsttrackid_method_cleanup;

    itxenumtrackid_get_firsttrackid_method_cleanup:
    self->m_HR = hr;
    if (pyvar_trackId != Py_None)
        Py_XDECREF(pyvar_trackId);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITxEnumTrackId.get_FirstTrackId");
    return return_tuple;
}

static PyObject*
ITxEnumTrackIdMethod_get_NextTrackId(PyITxEnumTrackIdObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bstrackId;
    PyObject* pyvar_trackId = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for trackId

    // Call method on actual COM interface
    hr = self->m_pITxEnumTrackId->get_NextTrackId(&bstrackId);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITxEnumTrackId->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITxEnumTrackId) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITxEnumTrackId.get_NextTrackId() returned %ld", (long)hr);
        goto itxenumtrackid_get_nexttrackid_method_cleanup;
    }

    // Set up return values as needed
    pyvar_trackId = PyUnicode_FromWideChar(bstrackId,::SysStringLen(bstrackId));
    ::SysFreeString(bstrackId);
    
    if (PyErr_Occurred())
      goto itxenumtrackid_get_nexttrackid_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_trackId);
    goto itxenumtrackid_get_nexttrackid_method_cleanup;

    itxenumtrackid_get_nexttrackid_method_cleanup:
    self->m_HR = hr;
    if (pyvar_trackId != Py_None)
        Py_XDECREF(pyvar_trackId);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITxEnumTrackId.get_NextTrackId");
    return return_tuple;
}

static PyObject*
ITxEnumTrackIdMethod_get_TrackIds(PyITxEnumTrackIdObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    SAFEARRAY* paTrackIds = NULL;
    PyObject* py_TrackIds = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for TrackIds

    // Call method on actual COM interface
    hr = self->m_pITxEnumTrackId->get_TrackIds(&paTrackIds);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITxEnumTrackId->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITxEnumTrackId) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITxEnumTrackId.get_TrackIds() returned %ld", (long)hr);
        goto itxenumtrackid_get_trackids_method_cleanup;
    }

    // Set up return values as needed
    py_TrackIds = SAFEARRAYToPyObject(paTrackIds, VT_NULL);
    if (PyErr_Occurred())
      goto itxenumtrackid_get_trackids_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_TrackIds);
    goto itxenumtrackid_get_trackids_method_cleanup;

    itxenumtrackid_get_trackids_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_TrackIds);
    if(paTrackIds)
      SafeArrayDestroy(paTrackIds);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITxEnumTrackId.get_TrackIds");
    return return_tuple;
}

static PyObject*
ITxEnumTrackIdMethod_get_TrackFeatures(PyITxEnumTrackIdObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bstrackId = 0;
    PyObject* pyvar_trackId;
    PyObject* unicodetrackId = NULL;
    ISelectionSet* ipfeatures = NULL;
    PyObject* py_features = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_trackId))
      goto itxenumtrackid_get_trackfeatures_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_trackId))
        unicodetrackId = PyUnicode_FromObject(pyvar_trackId);
    else if (PyUnicode_Check(pyvar_trackId))
    {
        unicodetrackId = pyvar_trackId;
        Py_INCREF(unicodetrackId);
    }
    else if (pyvar_trackId != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter trackId at index 0");
    if (unicodetrackId)
        bstrackId = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodetrackId), 
                                            (UINT)PyUnicode_GET_SIZE(unicodetrackId));
    
    if (PyErr_Occurred())
      goto itxenumtrackid_get_trackfeatures_method_cleanup;
    
    // No setup for features

    // Call method on actual COM interface
    hr = self->m_pITxEnumTrackId->get_TrackFeatures(bstrackId, &ipfeatures);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITxEnumTrackId->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITxEnumTrackId) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITxEnumTrackId.get_TrackFeatures() returned %ld", (long)hr);
        goto itxenumtrackid_get_trackfeatures_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for trackId
    Py_XDECREF(py_features);
    if (ipfeatures)
    {
        IUnknown* pUnk = NULL;
        ipfeatures->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_features = IUnknownToPythonIIDObject(pUnk, &IID_ISelectionSet);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_features)
    {
        if (py_features)
           Py_DECREF(py_features);
        py_features = Py_None;
        Py_INCREF(py_features);
    }
    if (PyErr_Occurred())
      goto itxenumtrackid_get_trackfeatures_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_features);
    goto itxenumtrackid_get_trackfeatures_method_cleanup;

    itxenumtrackid_get_trackfeatures_method_cleanup:
    self->m_HR = hr;
    if (bstrackId)
        ::SysFreeString(bstrackId);
    
    Py_XDECREF(py_features);
    if (ipfeatures)
      ipfeatures->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITxEnumTrackId.get_TrackFeatures");
    return return_tuple;
}

static PyObject*
ITxEnumTrackIdMethod_get_LastUpdateTime(PyITxEnumTrackIdObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bstrackId = 0;
    PyObject* pyvar_trackId;
    PyObject* unicodetrackId = NULL;
    ITime* ipLastUpdateTime = NULL;
    PyObject* py_LastUpdateTime = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_trackId))
      goto itxenumtrackid_get_lastupdatetime_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_trackId))
        unicodetrackId = PyUnicode_FromObject(pyvar_trackId);
    else if (PyUnicode_Check(pyvar_trackId))
    {
        unicodetrackId = pyvar_trackId;
        Py_INCREF(unicodetrackId);
    }
    else if (pyvar_trackId != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter trackId at index 0");
    if (unicodetrackId)
        bstrackId = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodetrackId), 
                                            (UINT)PyUnicode_GET_SIZE(unicodetrackId));
    
    if (PyErr_Occurred())
      goto itxenumtrackid_get_lastupdatetime_method_cleanup;
    
    // No setup for LastUpdateTime

    // Call method on actual COM interface
    hr = self->m_pITxEnumTrackId->get_LastUpdateTime(bstrackId, &ipLastUpdateTime);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITxEnumTrackId->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITxEnumTrackId) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITxEnumTrackId.get_LastUpdateTime() returned %ld", (long)hr);
        goto itxenumtrackid_get_lastupdatetime_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for trackId
    Py_XDECREF(py_LastUpdateTime);
    if (ipLastUpdateTime)
    {
        IUnknown* pUnk = NULL;
        ipLastUpdateTime->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_LastUpdateTime = IUnknownToPythonIIDObject(pUnk, &IID_ITime);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_LastUpdateTime)
    {
        if (py_LastUpdateTime)
           Py_DECREF(py_LastUpdateTime);
        py_LastUpdateTime = Py_None;
        Py_INCREF(py_LastUpdateTime);
    }
    if (PyErr_Occurred())
      goto itxenumtrackid_get_lastupdatetime_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_LastUpdateTime);
    goto itxenumtrackid_get_lastupdatetime_method_cleanup;

    itxenumtrackid_get_lastupdatetime_method_cleanup:
    self->m_HR = hr;
    if (bstrackId)
        ::SysFreeString(bstrackId);
    
    Py_XDECREF(py_LastUpdateTime);
    if (ipLastUpdateTime)
      ipLastUpdateTime->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITxEnumTrackId.get_LastUpdateTime");
    return return_tuple;
}

static PyObject*
ITxEnumTrackIdMethod_QueryTrackTimeExtent(PyITxEnumTrackIdObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bstrackId = 0;
    PyObject* pyvar_trackId;
    PyObject* unicodetrackId = NULL;
    ITime* ipstartTime = NULL;
    PyObject* py_startTime = NULL;
    ITime* ipendTime = NULL;
    PyObject* py_endTime = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_trackId))
      goto itxenumtrackid_querytracktimeextent_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_trackId))
        unicodetrackId = PyUnicode_FromObject(pyvar_trackId);
    else if (PyUnicode_Check(pyvar_trackId))
    {
        unicodetrackId = pyvar_trackId;
        Py_INCREF(unicodetrackId);
    }
    else if (pyvar_trackId != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter trackId at index 0");
    if (unicodetrackId)
        bstrackId = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodetrackId), 
                                            (UINT)PyUnicode_GET_SIZE(unicodetrackId));
    
    if (PyErr_Occurred())
      goto itxenumtrackid_querytracktimeextent_method_cleanup;
    
    // No setup for startTime
    // No setup for endTime

    // Call method on actual COM interface
    hr = self->m_pITxEnumTrackId->QueryTrackTimeExtent(bstrackId, &ipstartTime, &ipendTime);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITxEnumTrackId->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITxEnumTrackId) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITxEnumTrackId.QueryTrackTimeExtent() returned %ld", (long)hr);
        goto itxenumtrackid_querytracktimeextent_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for trackId
    Py_XDECREF(py_startTime);
    if (ipstartTime)
    {
        IUnknown* pUnk = NULL;
        ipstartTime->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_startTime = IUnknownToPythonIIDObject(pUnk, &IID_ITime);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_startTime)
    {
        if (py_startTime)
           Py_DECREF(py_startTime);
        py_startTime = Py_None;
        Py_INCREF(py_startTime);
    }
    if (PyErr_Occurred())
      goto itxenumtrackid_querytracktimeextent_method_cleanup;
    
    Py_XDECREF(py_endTime);
    if (ipendTime)
    {
        IUnknown* pUnk = NULL;
        ipendTime->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_endTime = IUnknownToPythonIIDObject(pUnk, &IID_ITime);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_endTime)
    {
        if (py_endTime)
           Py_DECREF(py_endTime);
        py_endTime = Py_None;
        Py_INCREF(py_endTime);
    }
    if (PyErr_Occurred())
      goto itxenumtrackid_querytracktimeextent_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("OO",
                                            py_startTime, py_endTime);
    goto itxenumtrackid_querytracktimeextent_method_cleanup;

    itxenumtrackid_querytracktimeextent_method_cleanup:
    self->m_HR = hr;
    if (bstrackId)
        ::SysFreeString(bstrackId);
    
    Py_XDECREF(py_startTime);
    if (ipstartTime)
      ipstartTime->Release();
    Py_XDECREF(py_endTime);
    if (ipendTime)
      ipendTime->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITxEnumTrackId.QueryTrackTimeExtent");
    return return_tuple;
}


PyMethodDef PyITxEnumTrackIdMethods[] = {
    {"supports", (PyCFunction)PyITxEnumTrackId_SupportsInterface, METH_O, ""},
    {"get_FirstTrackId", (PyCFunction)ITxEnumTrackIdMethod_get_FirstTrackId, METH_VARARGS, ""},
    {"get_NextTrackId", (PyCFunction)ITxEnumTrackIdMethod_get_NextTrackId, METH_VARARGS, ""},
    {"get_TrackIds", (PyCFunction)ITxEnumTrackIdMethod_get_TrackIds, METH_VARARGS, ""},
    {"get_TrackFeatures", (PyCFunction)ITxEnumTrackIdMethod_get_TrackFeatures, METH_VARARGS, ""},
    {"get_LastUpdateTime", (PyCFunction)ITxEnumTrackIdMethod_get_LastUpdateTime, METH_VARARGS, ""},
    {"QueryTrackTimeExtent", (PyCFunction)ITxEnumTrackIdMethod_QueryTrackTimeExtent, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyITxEnumTrackIdGetSet[] = {
  {"_pUnk", (getter)PyITxEnumTrackId_GetpUnk, NULL, "Get opaque pointer to an Unknown from ITxEnumTrackId", NULL},
  {"_pointer", (getter)PyITxEnumTrackId_GetPointer, NULL, "Get memory address for ITxEnumTrackId", NULL},
  {"_IID", (getter)PyITxEnumTrackId_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyITxEnumTrackId_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyITxEnumTrackId_GetIgnoreFailures, (setter)PyITxEnumTrackId_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyITxEnumTrackIdObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.ITxEnumTrackIdObject",                          
                                              /* tp_name */
  sizeof(PyITxEnumTrackIdObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyITxEnumTrackIdObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyITxEnumTrackIdMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyITxEnumTrackIdGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyITxEnumTrackIdObject_new,                      
                                              /* tp_new */
};

// Interface ITemporalCursor

typedef struct PyITemporalCursorObject {
    PyObject_HEAD
    ITemporalCursor* m_pITemporalCursor;
    HRESULT m_HR;
    int m_ignore_failures;
} PyITemporalCursorObject;

static PyObject*
PyITemporalCursorObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyITemporalCursorObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ITemporalCursor* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ITemporalCursor, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ITemporalCursor with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyITemporalCursorObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ITemporalCursor");
            return NULL;
        }
        self->m_pITemporalCursor = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ITemporalCursor");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ITemporalCursor");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ITemporalCursor* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ITemporalCursor, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ITemporalCursor");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyITemporalCursorObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ITemporalCursor");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pITemporalCursor = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyITemporalCursorObject_dealloc(PyITemporalCursorObject* self)
{
    if (self->m_pITemporalCursor)
        self->m_pITemporalCursor->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyITemporalCursor_GetpUnk(PyITemporalCursorObject* self)
{
    if (!self->m_pITemporalCursor)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pITemporalCursor->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ITemporalCursor to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyITemporalCursor_GetPointer(PyITemporalCursorObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pITemporalCursor);
}

static PyObject*
PyITemporalCursor_GetIID(PyITemporalCursorObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "cc018a66-24fb-11d4-b34c-00104ba2abcc");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyITemporalCursor_GetHR(PyITemporalCursorObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyITemporalCursor_GetIgnoreFailures(PyITemporalCursorObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyITemporalCursor_SetIgnoreFailures(PyITemporalCursorObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyITemporalCursor_SupportsInterface(PyITemporalCursorObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pITemporalCursor->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ITemporalCursorMethod_NextObject(PyITemporalCursorObject* self, PyObject* args)
{
    /* Param types that are unhandleable: 
       INPUT [u'IFeature', u'*', u'*']
       INPUT [u'__int64', u'*']
       INPUT [u'long', u'*']
    */
    PyErr_SetString(PyExc_NotImplementedError, "Wrapper for ITemporalCursor.NextObject not implemented.");
    return NULL;
}

static PyObject*
ITemporalCursorMethod_Reset(PyITemporalCursorObject* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pITemporalCursor->Reset();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalCursor->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalCursor) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalCursor.Reset() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}

static PyObject*
ITemporalCursorMethod_FindField(PyITemporalCursorObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName = 0;
    PyObject* pyvar_Name;
    PyObject* unicodeName = NULL;
    long lFieldIndex = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_Name))
      goto itemporalcursor_findfield_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_Name))
        unicodeName = PyUnicode_FromObject(pyvar_Name);
    else if (PyUnicode_Check(pyvar_Name))
    {
        unicodeName = pyvar_Name;
        Py_INCREF(unicodeName);
    }
    else if (pyvar_Name != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Name at index 0");
    if (unicodeName)
        bsName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeName));
    
    if (PyErr_Occurred())
      goto itemporalcursor_findfield_method_cleanup;
    
    // No setup for FieldIndex

    // Call method on actual COM interface
    hr = self->m_pITemporalCursor->FindField(bsName, &lFieldIndex);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalCursor->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalCursor) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalCursor.FindField() returned %ld", (long)hr);
        goto itemporalcursor_findfield_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Name
    // No teardown for FieldIndex

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lFieldIndex);
    goto itemporalcursor_findfield_method_cleanup;

    itemporalcursor_findfield_method_cleanup:
    self->m_HR = hr;
    if (bsName)
        ::SysFreeString(bsName);
    
    // No cleanup for FieldIndex
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalCursor.FindField");
    return return_tuple;
}

static PyObject*
ITemporalCursorMethod_get_Fields(PyITemporalCursorObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IFields* ipFields = NULL;
    PyObject* py_Fields = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Fields

    // Call method on actual COM interface
    hr = self->m_pITemporalCursor->get_Fields(&ipFields);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalCursor->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalCursor) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalCursor.get_Fields() returned %ld", (long)hr);
        goto itemporalcursor_get_fields_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_Fields);
    if (ipFields)
    {
        IUnknown* pUnk = NULL;
        ipFields->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_Fields = IUnknownToPythonIIDObject(pUnk, &IID_IFields);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_Fields)
    {
        if (py_Fields)
           Py_DECREF(py_Fields);
        py_Fields = Py_None;
        Py_INCREF(py_Fields);
    }
    if (PyErr_Occurred())
      goto itemporalcursor_get_fields_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_Fields);
    goto itemporalcursor_get_fields_method_cleanup;

    itemporalcursor_get_fields_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_Fields);
    if (ipFields)
      ipFields->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalCursor.get_Fields");
    return return_tuple;
}

static PyObject*
ITemporalCursorMethod_NextFeature(PyITemporalCursorObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IFeature* ipObject = NULL;
    PyObject* py_Object = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Object

    // Call method on actual COM interface
    hr = self->m_pITemporalCursor->NextFeature(&ipObject);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalCursor->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalCursor) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalCursor.NextFeature() returned %ld", (long)hr);
        goto itemporalcursor_nextfeature_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_Object);
    if (ipObject)
    {
        IUnknown* pUnk = NULL;
        ipObject->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_Object = IUnknownToPythonIIDObject(pUnk, &IID_IFeature);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_Object)
    {
        if (py_Object)
           Py_DECREF(py_Object);
        py_Object = Py_None;
        Py_INCREF(py_Object);
    }
    if (PyErr_Occurred())
      goto itemporalcursor_nextfeature_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_Object);
    goto itemporalcursor_nextfeature_method_cleanup;

    itemporalcursor_nextfeature_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_Object);
    if (ipObject)
      ipObject->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalCursor.NextFeature");
    return return_tuple;
}

static PyObject*
ITemporalCursorMethod_UpdateFeature(PyITemporalCursorObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IFeature* ipObject = NULL;
    PyObject* py_Object;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_Object))
      goto itemporalcursor_updatefeature_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_Object, &IID_IFeature, (void**)&ipObject))
        PyErr_SetString(PyExc_TypeError, "Argument Object (position 0) is not IFeature");
    
    if (PyErr_Occurred())
      goto itemporalcursor_updatefeature_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITemporalCursor->UpdateFeature(ipObject);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalCursor->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalCursor) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalCursor.UpdateFeature() returned %ld", (long)hr);
        goto itemporalcursor_updatefeature_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Object

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto itemporalcursor_updatefeature_method_cleanup;

    itemporalcursor_updatefeature_method_cleanup:
    self->m_HR = hr;
    if (ipObject)
      ipObject->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalCursor.UpdateFeature");
    return return_tuple;
}

static PyObject*
ITemporalCursorMethod_DeleteFeature(PyITemporalCursorObject* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pITemporalCursor->DeleteFeature();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalCursor->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalCursor) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalCursor.DeleteFeature() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}

static PyObject*
ITemporalCursorMethod_InsertFeature(PyITemporalCursorObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IFeatureBuffer* ipbuffer = NULL;
    PyObject* py_buffer;
    VARIANT vID;
    ::VariantInit(&vID);
    PyObject* pyvar_ID = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_buffer))
      goto itemporalcursor_insertfeature_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_buffer, &IID_IFeatureBuffer, (void**)&ipbuffer))
        PyErr_SetString(PyExc_TypeError, "Argument buffer (position 0) is not IFeatureBuffer");
    
    if (PyErr_Occurred())
      goto itemporalcursor_insertfeature_method_cleanup;
    
    // No setup for ID

    // Call method on actual COM interface
    hr = self->m_pITemporalCursor->InsertFeature(ipbuffer, &vID);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalCursor->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalCursor) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalCursor.InsertFeature() returned %ld", (long)hr);
        goto itemporalcursor_insertfeature_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for buffer
    pyvar_ID = Variant_AsPyObject(&vID);
    if (PyErr_Occurred())
      goto itemporalcursor_insertfeature_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_ID);
    goto itemporalcursor_insertfeature_method_cleanup;

    itemporalcursor_insertfeature_method_cleanup:
    self->m_HR = hr;
    if (ipbuffer)
      ipbuffer->Release();
    ::VariantClear(&vID);
    Py_XDECREF(pyvar_ID);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemporalCursor.InsertFeature");
    return return_tuple;
}

static PyObject*
ITemporalCursorMethod_Flush(PyITemporalCursorObject* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pITemporalCursor->Flush();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemporalCursor->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemporalCursor) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemporalCursor.Flush() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}


PyMethodDef PyITemporalCursorMethods[] = {
    {"supports", (PyCFunction)PyITemporalCursor_SupportsInterface, METH_O, ""},
    {"NextObject", (PyCFunction)ITemporalCursorMethod_NextObject, METH_VARARGS, ""},
    {"Reset", (PyCFunction)ITemporalCursorMethod_Reset, METH_NOARGS, ""},
    {"FindField", (PyCFunction)ITemporalCursorMethod_FindField, METH_VARARGS, ""},
    {"get_Fields", (PyCFunction)ITemporalCursorMethod_get_Fields, METH_VARARGS, ""},
    {"NextFeature", (PyCFunction)ITemporalCursorMethod_NextFeature, METH_VARARGS, ""},
    {"UpdateFeature", (PyCFunction)ITemporalCursorMethod_UpdateFeature, METH_VARARGS, ""},
    {"DeleteFeature", (PyCFunction)ITemporalCursorMethod_DeleteFeature, METH_NOARGS, ""},
    {"InsertFeature", (PyCFunction)ITemporalCursorMethod_InsertFeature, METH_VARARGS, ""},
    {"Flush", (PyCFunction)ITemporalCursorMethod_Flush, METH_NOARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyITemporalCursorGetSet[] = {
  {"_pUnk", (getter)PyITemporalCursor_GetpUnk, NULL, "Get opaque pointer to an Unknown from ITemporalCursor", NULL},
  {"_pointer", (getter)PyITemporalCursor_GetPointer, NULL, "Get memory address for ITemporalCursor", NULL},
  {"_IID", (getter)PyITemporalCursor_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyITemporalCursor_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyITemporalCursor_GetIgnoreFailures, (setter)PyITemporalCursor_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyITemporalCursorObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.ITemporalCursorObject",                          
                                              /* tp_name */
  sizeof(PyITemporalCursorObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyITemporalCursorObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyITemporalCursorMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyITemporalCursorGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyITemporalCursorObject_new,                      
                                              /* tp_new */
};

// Interface ITerrain

typedef struct PyITerrainObject {
    PyObject_HEAD
    ITerrain* m_pITerrain;
    HRESULT m_HR;
    int m_ignore_failures;
} PyITerrainObject;

static PyObject*
PyITerrainObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyITerrainObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ITerrain* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ITerrain, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ITerrain with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyITerrainObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ITerrain");
            return NULL;
        }
        self->m_pITerrain = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ITerrain");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ITerrain");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ITerrain* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ITerrain, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ITerrain");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyITerrainObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ITerrain");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pITerrain = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyITerrainObject_dealloc(PyITerrainObject* self)
{
    if (self->m_pITerrain)
        self->m_pITerrain->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyITerrain_GetpUnk(PyITerrainObject* self)
{
    if (!self->m_pITerrain)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pITerrain->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ITerrain to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyITerrain_GetPointer(PyITerrainObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pITerrain);
}

static PyObject*
PyITerrain_GetIID(PyITerrainObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "f657c7ed-fe73-493e-8cf7-845e20cb7d9b");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyITerrain_GetHR(PyITerrainObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyITerrain_GetIgnoreFailures(PyITerrainObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyITerrain_SetIgnoreFailures(PyITerrainObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyITerrain_SupportsInterface(PyITerrainObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pITerrain->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ITerrainMethod_get_Name(PyITerrainObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspName;
    PyObject* pyvar_pName = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pName

    // Call method on actual COM interface
    hr = self->m_pITerrain->get_Name(&bspName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrain->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrain) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrain.get_Name() returned %ld", (long)hr);
        goto iterrain_get_name_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pName = PyUnicode_FromWideChar(bspName,::SysStringLen(bspName));
    ::SysFreeString(bspName);
    
    if (PyErr_Occurred())
      goto iterrain_get_name_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pName);
    goto iterrain_get_name_method_cleanup;

    iterrain_get_name_method_cleanup:
    self->m_HR = hr;
    if (pyvar_pName != Py_None)
        Py_XDECREF(pyvar_pName);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrain.get_Name");
    return return_tuple;
}

static PyObject*
ITerrainMethod_get_ID(PyITerrainObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpID = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pID

    // Call method on actual COM interface
    hr = self->m_pITerrain->get_ID(&lpID);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrain->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrain) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrain.get_ID() returned %ld", (long)hr);
        goto iterrain_get_id_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pID

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpID);
    goto iterrain_get_id_method_cleanup;

    iterrain_get_id_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pID
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrain.get_ID");
    return return_tuple;
}

static PyObject*
ITerrainMethod_get_Size(PyITerrainObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dpcPoints = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pcPoints

    // Call method on actual COM interface
    hr = self->m_pITerrain->get_Size(&dpcPoints);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrain->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrain) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrain.get_Size() returned %ld", (long)hr);
        goto iterrain_get_size_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pcPoints

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dpcPoints);
    goto iterrain_get_size_method_cleanup;

    iterrain_get_size_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pcPoints
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrain.get_Size");
    return return_tuple;
}

static PyObject*
ITerrainMethod_get_IsValid(PyITerrainObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pbIsValid = VARIANT_FALSE;
    PyObject* pyvar_pbIsValid = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pbIsValid

    // Call method on actual COM interface
    hr = self->m_pITerrain->get_IsValid(&b_pbIsValid);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrain->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrain) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrain.get_IsValid() returned %ld", (long)hr);
        goto iterrain_get_isvalid_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pbIsValid = ((b_pbIsValid == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto iterrain_get_isvalid_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pbIsValid);
    goto iterrain_get_isvalid_method_cleanup;

    iterrain_get_isvalid_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pbIsValid
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrain.get_IsValid");
    return return_tuple;
}

static PyObject*
ITerrainMethod_get_IsDirty(PyITerrainObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pbIsDirty = VARIANT_FALSE;
    PyObject* pyvar_pbIsDirty = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pbIsDirty

    // Call method on actual COM interface
    hr = self->m_pITerrain->get_IsDirty(&b_pbIsDirty);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrain->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrain) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrain.get_IsDirty() returned %ld", (long)hr);
        goto iterrain_get_isdirty_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pbIsDirty = ((b_pbIsDirty == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto iterrain_get_isdirty_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pbIsDirty);
    goto iterrain_get_isdirty_method_cleanup;

    iterrain_get_isdirty_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pbIsDirty
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrain.get_IsDirty");
    return return_tuple;
}

static PyObject*
ITerrainMethod_get_SpatialReference(PyITerrainObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ISpatialReference* ipppSpatialRef = NULL;
    PyObject* py_ppSpatialRef = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppSpatialRef

    // Call method on actual COM interface
    hr = self->m_pITerrain->get_SpatialReference(&ipppSpatialRef);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrain->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrain) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrain.get_SpatialReference() returned %ld", (long)hr);
        goto iterrain_get_spatialreference_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppSpatialRef);
    if (ipppSpatialRef)
    {
        IUnknown* pUnk = NULL;
        ipppSpatialRef->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppSpatialRef = IUnknownToPythonIIDObject(pUnk, &IID_ISpatialReference);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppSpatialRef)
    {
        if (py_ppSpatialRef)
           Py_DECREF(py_ppSpatialRef);
        py_ppSpatialRef = Py_None;
        Py_INCREF(py_ppSpatialRef);
    }
    if (PyErr_Occurred())
      goto iterrain_get_spatialreference_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppSpatialRef);
    goto iterrain_get_spatialreference_method_cleanup;

    iterrain_get_spatialreference_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppSpatialRef);
    if (ipppSpatialRef)
      ipppSpatialRef->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrain.get_SpatialReference");
    return return_tuple;
}

static PyObject*
ITerrainMethod_get_Extent(PyITerrainObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IEnvelope* ipppExtent = NULL;
    PyObject* py_ppExtent = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppExtent

    // Call method on actual COM interface
    hr = self->m_pITerrain->get_Extent(&ipppExtent);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrain->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrain) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrain.get_Extent() returned %ld", (long)hr);
        goto iterrain_get_extent_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppExtent);
    if (ipppExtent)
    {
        IUnknown* pUnk = NULL;
        ipppExtent->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppExtent = IUnknownToPythonIIDObject(pUnk, &IID_IEnvelope);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppExtent)
    {
        if (py_ppExtent)
           Py_DECREF(py_ppExtent);
        py_ppExtent = Py_None;
        Py_INCREF(py_ppExtent);
    }
    if (PyErr_Occurred())
      goto iterrain_get_extent_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppExtent);
    goto iterrain_get_extent_method_cleanup;

    iterrain_get_extent_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppExtent);
    if (ipppExtent)
      ipppExtent->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrain.get_Extent");
    return return_tuple;
}

static PyObject*
ITerrainMethod_get_FeatureDataset(PyITerrainObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IFeatureDataset* ipppDataset = NULL;
    PyObject* py_ppDataset = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppDataset

    // Call method on actual COM interface
    hr = self->m_pITerrain->get_FeatureDataset(&ipppDataset);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrain->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrain) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrain.get_FeatureDataset() returned %ld", (long)hr);
        goto iterrain_get_featuredataset_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppDataset);
    if (ipppDataset)
    {
        IUnknown* pUnk = NULL;
        ipppDataset->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppDataset = IUnknownToPythonIIDObject(pUnk, &IID_IFeatureDataset);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppDataset)
    {
        if (py_ppDataset)
           Py_DECREF(py_ppDataset);
        py_ppDataset = Py_None;
        Py_INCREF(py_ppDataset);
    }
    if (PyErr_Occurred())
      goto iterrain_get_featuredataset_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppDataset);
    goto iterrain_get_featuredataset_method_cleanup;

    iterrain_get_featuredataset_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppDataset);
    if (ipppDataset)
      ipppDataset->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrain.get_FeatureDataset");
    return return_tuple;
}

static PyObject*
ITerrainMethod_get_DataSourceCount(PyITerrainObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpcDataSources = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pcDataSources

    // Call method on actual COM interface
    hr = self->m_pITerrain->get_DataSourceCount(&lpcDataSources);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrain->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrain) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrain.get_DataSourceCount() returned %ld", (long)hr);
        goto iterrain_get_datasourcecount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pcDataSources

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpcDataSources);
    goto iterrain_get_datasourcecount_method_cleanup;

    iterrain_get_datasourcecount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pcDataSources
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrain.get_DataSourceCount");
    return return_tuple;
}

static PyObject*
ITerrainMethod_get_DataSource(PyITerrainObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;
    ITerrainDataSource* ipppDataSource = NULL;
    PyObject* py_ppDataSource = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lindex))
      goto iterrain_get_datasource_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index
    // No setup for ppDataSource

    // Call method on actual COM interface
    hr = self->m_pITerrain->get_DataSource(lindex, &ipppDataSource);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrain->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrain) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrain.get_DataSource() returned %ld", (long)hr);
        goto iterrain_get_datasource_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index
    Py_XDECREF(py_ppDataSource);
    if (ipppDataSource)
    {
        IUnknown* pUnk = NULL;
        ipppDataSource->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppDataSource = IUnknownToPythonIIDObject(pUnk, &IID_ITerrainDataSource);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppDataSource)
    {
        if (py_ppDataSource)
           Py_DECREF(py_ppDataSource);
        py_ppDataSource = Py_None;
        Py_INCREF(py_ppDataSource);
    }
    if (PyErr_Occurred())
      goto iterrain_get_datasource_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppDataSource);
    goto iterrain_get_datasource_method_cleanup;

    iterrain_get_datasource_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    Py_XDECREF(py_ppDataSource);
    if (ipppDataSource)
      ipppDataSource->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrain.get_DataSource");
    return return_tuple;
}

static PyObject*
ITerrainMethod_get_PyramidLevelCount(PyITerrainObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpcPyramidLevels = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pcPyramidLevels

    // Call method on actual COM interface
    hr = self->m_pITerrain->get_PyramidLevelCount(&lpcPyramidLevels);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrain->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrain) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrain.get_PyramidLevelCount() returned %ld", (long)hr);
        goto iterrain_get_pyramidlevelcount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pcPyramidLevels

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpcPyramidLevels);
    goto iterrain_get_pyramidlevelcount_method_cleanup;

    iterrain_get_pyramidlevelcount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pcPyramidLevels
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrain.get_PyramidLevelCount");
    return return_tuple;
}

static PyObject*
ITerrainMethod_get_PyramidLevel(PyITerrainObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;
    ITerrainPyramidLevel* ipppPyramidLevel = NULL;
    PyObject* py_ppPyramidLevel = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lindex))
      goto iterrain_get_pyramidlevel_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index
    // No setup for ppPyramidLevel

    // Call method on actual COM interface
    hr = self->m_pITerrain->get_PyramidLevel(lindex, &ipppPyramidLevel);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrain->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrain) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrain.get_PyramidLevel() returned %ld", (long)hr);
        goto iterrain_get_pyramidlevel_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index
    Py_XDECREF(py_ppPyramidLevel);
    if (ipppPyramidLevel)
    {
        IUnknown* pUnk = NULL;
        ipppPyramidLevel->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppPyramidLevel = IUnknownToPythonIIDObject(pUnk, &IID_ITerrainPyramidLevel);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppPyramidLevel)
    {
        if (py_ppPyramidLevel)
           Py_DECREF(py_ppPyramidLevel);
        py_ppPyramidLevel = Py_None;
        Py_INCREF(py_ppPyramidLevel);
    }
    if (PyErr_Occurred())
      goto iterrain_get_pyramidlevel_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppPyramidLevel);
    goto iterrain_get_pyramidlevel_method_cleanup;

    iterrain_get_pyramidlevel_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    Py_XDECREF(py_ppPyramidLevel);
    if (ipppPyramidLevel)
      ipppPyramidLevel->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrain.get_PyramidLevel");
    return return_tuple;
}

static PyObject*
ITerrainMethod_get_TileSize(PyITerrainObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dpSize = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pSize

    // Call method on actual COM interface
    hr = self->m_pITerrain->get_TileSize(&dpSize);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrain->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrain) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrain.get_TileSize() returned %ld", (long)hr);
        goto iterrain_get_tilesize_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pSize

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dpSize);
    goto iterrain_get_tilesize_method_cleanup;

    iterrain_get_tilesize_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pSize
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrain.get_TileSize");
    return return_tuple;
}

static PyObject*
ITerrainMethod_get_PyramidType(PyITerrainObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriTerrainPyramidType epType;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pType

    // Call method on actual COM interface
    hr = self->m_pITerrain->get_PyramidType(&epType);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrain->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrain) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrain.get_PyramidType() returned %ld", (long)hr);
        goto iterrain_get_pyramidtype_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pType

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)epType);
    goto iterrain_get_pyramidtype_method_cleanup;

    iterrain_get_pyramidtype_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pType
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrain.get_PyramidType");
    return return_tuple;
}

static PyObject*
ITerrainMethod_get_MaxOverviewTerrainPoints(PyITerrainObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpcPoints = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pcPoints

    // Call method on actual COM interface
    hr = self->m_pITerrain->get_MaxOverviewTerrainPoints(&lpcPoints);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrain->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrain) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrain.get_MaxOverviewTerrainPoints() returned %ld", (long)hr);
        goto iterrain_get_maxoverviewterrainpoints_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pcPoints

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpcPoints);
    goto iterrain_get_maxoverviewterrainpoints_method_cleanup;

    iterrain_get_maxoverviewterrainpoints_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pcPoints
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrain.get_MaxOverviewTerrainPoints");
    return return_tuple;
}

static PyObject*
ITerrainMethod_get_MaxPointsPerShape(PyITerrainObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpcPoints = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pcPoints

    // Call method on actual COM interface
    hr = self->m_pITerrain->get_MaxPointsPerShape(&lpcPoints);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrain->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrain) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrain.get_MaxPointsPerShape() returned %ld", (long)hr);
        goto iterrain_get_maxpointspershape_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pcPoints

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpcPoints);
    goto iterrain_get_maxpointspershape_method_cleanup;

    iterrain_get_maxpointspershape_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pcPoints
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrain.get_MaxPointsPerShape");
    return return_tuple;
}

static PyObject*
ITerrainMethod_QueryTileInfo(PyITerrainObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpRowBegin = 0;
    long lpRowEnd = 0;
    long lpColBegin = 0;
    long lpColEnd = 0;
    double dpXMin = 0;
    double dpYMin = 0;
    double dpTileSize = 0;
    long lpRowCountDomain = 0;
    long lpColCountDomain = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pRowBegin
    // No setup for pRowEnd
    // No setup for pColBegin
    // No setup for pColEnd
    // No setup for pXMin
    // No setup for pYMin
    // No setup for pTileSize
    // No setup for pRowCountDomain
    // No setup for pColCountDomain

    // Call method on actual COM interface
    hr = self->m_pITerrain->QueryTileInfo(&lpRowBegin, &lpRowEnd, &lpColBegin, &lpColEnd, &dpXMin, &dpYMin, &dpTileSize, &lpRowCountDomain, &lpColCountDomain);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrain->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrain) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrain.QueryTileInfo() returned %ld", (long)hr);
        goto iterrain_querytileinfo_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pRowBegin
    // No teardown for pRowEnd
    // No teardown for pColBegin
    // No teardown for pColEnd
    // No teardown for pXMin
    // No teardown for pYMin
    // No teardown for pTileSize
    // No teardown for pRowCountDomain
    // No teardown for pColCountDomain

    // Initialize output tuple
    return_tuple = Py_BuildValue("lllldddll",
                                            lpRowBegin, lpRowEnd, lpColBegin, lpColEnd, dpXMin, dpYMin, dpTileSize, lpRowCountDomain, lpColCountDomain);
    goto iterrain_querytileinfo_method_cleanup;

    iterrain_querytileinfo_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pRowBegin
    // No cleanup for pRowEnd
    // No cleanup for pColBegin
    // No cleanup for pColEnd
    // No cleanup for pXMin
    // No cleanup for pYMin
    // No cleanup for pTileSize
    // No cleanup for pRowCountDomain
    // No cleanup for pColCountDomain
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrain.QueryTileInfo");
    return return_tuple;
}

static PyObject*
ITerrainMethod_GetDirtyTiles(PyITerrainObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IEnumEnvelope* ipppTiles = NULL;
    PyObject* py_ppTiles = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppTiles

    // Call method on actual COM interface
    hr = self->m_pITerrain->GetDirtyTiles(&ipppTiles);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrain->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrain) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrain.GetDirtyTiles() returned %ld", (long)hr);
        goto iterrain_getdirtytiles_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppTiles);
    if (ipppTiles)
    {
        IUnknown* pUnk = NULL;
        ipppTiles->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppTiles = IUnknownToPythonIIDObject(pUnk, &IID_IEnumEnvelope);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppTiles)
    {
        if (py_ppTiles)
           Py_DECREF(py_ppTiles);
        py_ppTiles = Py_None;
        Py_INCREF(py_ppTiles);
    }
    if (PyErr_Occurred())
      goto iterrain_getdirtytiles_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppTiles);
    goto iterrain_getdirtytiles_method_cleanup;

    iterrain_getdirtytiles_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppTiles);
    if (ipppTiles)
      ipppTiles->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrain.GetDirtyTiles");
    return return_tuple;
}

static PyObject*
ITerrainMethod_GetPointCount(PyITerrainObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IEnvelope* ippAOI = NULL;
    PyObject* py_pAOI;
    double dResolution = 0;
    double dpcPoints = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "Od", &py_pAOI, &dResolution))
      goto iterrain_getpointcount_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pAOI, &IID_IEnvelope, (void**)&ippAOI))
        PyErr_SetString(PyExc_TypeError, "Argument pAOI (position 0) is not IEnvelope");
    
    if (PyErr_Occurred())
      goto iterrain_getpointcount_method_cleanup;
    
    // No setup for Resolution
    // No setup for pcPoints

    // Call method on actual COM interface
    hr = self->m_pITerrain->GetPointCount(ippAOI, dResolution, &dpcPoints);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrain->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrain) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrain.GetPointCount() returned %ld", (long)hr);
        goto iterrain_getpointcount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pAOI
    // No teardown for Resolution
    // No teardown for pcPoints

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dpcPoints);
    goto iterrain_getpointcount_method_cleanup;

    iterrain_getpointcount_method_cleanup:
    self->m_HR = hr;
    if (ippAOI)
      ippAOI->Release();
    // No cleanup for Resolution
    // No cleanup for pcPoints
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrain.GetPointCount");
    return return_tuple;
}

static PyObject*
ITerrainMethod_CreateDynamicSurface(PyITerrainObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IDynamicSurface* ipppDynamicSurface = NULL;
    PyObject* py_ppDynamicSurface = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppDynamicSurface

    // Call method on actual COM interface
    hr = self->m_pITerrain->CreateDynamicSurface(&ipppDynamicSurface);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrain->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrain) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrain.CreateDynamicSurface() returned %ld", (long)hr);
        goto iterrain_createdynamicsurface_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppDynamicSurface);
    if (ipppDynamicSurface)
    {
        IUnknown* pUnk = NULL;
        ipppDynamicSurface->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppDynamicSurface = IUnknownToPythonIIDObject(pUnk, &IID_IDynamicSurface);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppDynamicSurface)
    {
        if (py_ppDynamicSurface)
           Py_DECREF(py_ppDynamicSurface);
        py_ppDynamicSurface = Py_None;
        Py_INCREF(py_ppDynamicSurface);
    }
    if (PyErr_Occurred())
      goto iterrain_createdynamicsurface_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppDynamicSurface);
    goto iterrain_createdynamicsurface_method_cleanup;

    iterrain_createdynamicsurface_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppDynamicSurface);
    if (ipppDynamicSurface)
      ipppDynamicSurface->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrain.CreateDynamicSurface");
    return return_tuple;
}

static PyObject*
ITerrainMethod_ExtractFromEmbeddedDataSource(PyITerrainObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;
    IFeatureClass* ippFeatureClass = NULL;
    PyObject* py_pFeatureClass;
    IEnvelope* ippAOI = NULL;
    PyObject* py_pAOI;
    double dResolution = 0;
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;

    // Unpack values
    if (!PyArg_ParseTuple(args, "lOOdO", &lindex, &py_pFeatureClass, &py_pAOI, &dResolution, &py_pTrackCancel))
      goto iterrain_extractfromembeddeddatasource_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index
    if (!IFaceFromPyObject(py_pFeatureClass, &IID_IFeatureClass, (void**)&ippFeatureClass))
        PyErr_SetString(PyExc_TypeError, "Argument pFeatureClass (position 1) is not IFeatureClass");
    
    if (PyErr_Occurred())
      goto iterrain_extractfromembeddeddatasource_method_cleanup;
    
    if (!IFaceFromPyObject(py_pAOI, &IID_IEnvelope, (void**)&ippAOI))
        PyErr_SetString(PyExc_TypeError, "Argument pAOI (position 2) is not IEnvelope");
    
    if (PyErr_Occurred())
      goto iterrain_extractfromembeddeddatasource_method_cleanup;
    
    // No setup for Resolution
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 4) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto iterrain_extractfromembeddeddatasource_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITerrain->ExtractFromEmbeddedDataSource(lindex, ippFeatureClass, ippAOI, dResolution, ippTrackCancel);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrain->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrain) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrain.ExtractFromEmbeddedDataSource() returned %ld", (long)hr);
        goto iterrain_extractfromembeddeddatasource_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index
    // No teardown for pFeatureClass
    // No teardown for pAOI
    // No teardown for Resolution
    // No teardown for pTrackCancel

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterrain_extractfromembeddeddatasource_method_cleanup;

    iterrain_extractfromembeddeddatasource_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    if (ippFeatureClass)
      ippFeatureClass->Release();
    if (ippAOI)
      ippAOI->Release();
    // No cleanup for Resolution
    if (ippTrackCancel)
      ippTrackCancel->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrain.ExtractFromEmbeddedDataSource");
    return return_tuple;
}


PyMethodDef PyITerrainMethods[] = {
    {"supports", (PyCFunction)PyITerrain_SupportsInterface, METH_O, ""},
    {"get_Name", (PyCFunction)ITerrainMethod_get_Name, METH_VARARGS, ""},
    {"get_ID", (PyCFunction)ITerrainMethod_get_ID, METH_VARARGS, ""},
    {"get_Size", (PyCFunction)ITerrainMethod_get_Size, METH_VARARGS, ""},
    {"get_IsValid", (PyCFunction)ITerrainMethod_get_IsValid, METH_VARARGS, ""},
    {"get_IsDirty", (PyCFunction)ITerrainMethod_get_IsDirty, METH_VARARGS, ""},
    {"get_SpatialReference", (PyCFunction)ITerrainMethod_get_SpatialReference, METH_VARARGS, ""},
    {"get_Extent", (PyCFunction)ITerrainMethod_get_Extent, METH_VARARGS, ""},
    {"get_FeatureDataset", (PyCFunction)ITerrainMethod_get_FeatureDataset, METH_VARARGS, ""},
    {"get_DataSourceCount", (PyCFunction)ITerrainMethod_get_DataSourceCount, METH_VARARGS, ""},
    {"get_DataSource", (PyCFunction)ITerrainMethod_get_DataSource, METH_VARARGS, ""},
    {"get_PyramidLevelCount", (PyCFunction)ITerrainMethod_get_PyramidLevelCount, METH_VARARGS, ""},
    {"get_PyramidLevel", (PyCFunction)ITerrainMethod_get_PyramidLevel, METH_VARARGS, ""},
    {"get_TileSize", (PyCFunction)ITerrainMethod_get_TileSize, METH_VARARGS, ""},
    {"get_PyramidType", (PyCFunction)ITerrainMethod_get_PyramidType, METH_VARARGS, ""},
    {"get_MaxOverviewTerrainPoints", (PyCFunction)ITerrainMethod_get_MaxOverviewTerrainPoints, METH_VARARGS, ""},
    {"get_MaxPointsPerShape", (PyCFunction)ITerrainMethod_get_MaxPointsPerShape, METH_VARARGS, ""},
    {"QueryTileInfo", (PyCFunction)ITerrainMethod_QueryTileInfo, METH_VARARGS, ""},
    {"GetDirtyTiles", (PyCFunction)ITerrainMethod_GetDirtyTiles, METH_VARARGS, ""},
    {"GetPointCount", (PyCFunction)ITerrainMethod_GetPointCount, METH_VARARGS, ""},
    {"CreateDynamicSurface", (PyCFunction)ITerrainMethod_CreateDynamicSurface, METH_VARARGS, ""},
    {"ExtractFromEmbeddedDataSource", (PyCFunction)ITerrainMethod_ExtractFromEmbeddedDataSource, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyITerrainGetSet[] = {
  {"_pUnk", (getter)PyITerrain_GetpUnk, NULL, "Get opaque pointer to an Unknown from ITerrain", NULL},
  {"_pointer", (getter)PyITerrain_GetPointer, NULL, "Get memory address for ITerrain", NULL},
  {"_IID", (getter)PyITerrain_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyITerrain_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyITerrain_GetIgnoreFailures, (setter)PyITerrain_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyITerrainObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.ITerrainObject",                          
                                              /* tp_name */
  sizeof(PyITerrainObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyITerrainObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyITerrainMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyITerrainGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyITerrainObject_new,                      
                                              /* tp_new */
};

// Interface IDynamicSurface

typedef struct PyIDynamicSurfaceObject {
    PyObject_HEAD
    IDynamicSurface* m_pIDynamicSurface;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIDynamicSurfaceObject;

static PyObject*
PyIDynamicSurfaceObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIDynamicSurfaceObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IDynamicSurface* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IDynamicSurface, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IDynamicSurface with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIDynamicSurfaceObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IDynamicSurface");
            return NULL;
        }
        self->m_pIDynamicSurface = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IDynamicSurface");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IDynamicSurface");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IDynamicSurface* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IDynamicSurface, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IDynamicSurface");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIDynamicSurfaceObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IDynamicSurface");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIDynamicSurface = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIDynamicSurfaceObject_dealloc(PyIDynamicSurfaceObject* self)
{
    if (self->m_pIDynamicSurface)
        self->m_pIDynamicSurface->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIDynamicSurface_GetpUnk(PyIDynamicSurfaceObject* self)
{
    if (!self->m_pIDynamicSurface)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIDynamicSurface->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IDynamicSurface to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIDynamicSurface_GetPointer(PyIDynamicSurfaceObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIDynamicSurface);
}

static PyObject*
PyIDynamicSurface_GetIID(PyIDynamicSurfaceObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "36e5cbc7-14b3-4ea8-b19d-f084cb0911d9");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIDynamicSurface_GetHR(PyIDynamicSurfaceObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIDynamicSurface_GetIgnoreFailures(PyIDynamicSurfaceObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIDynamicSurface_SetIgnoreFailures(PyIDynamicSurfaceObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIDynamicSurface_SupportsInterface(PyIDynamicSurfaceObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIDynamicSurface->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IDynamicSurfaceMethod_put_RasterBlockSize(PyIDynamicSurfaceObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpSize = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lpSize))
      goto idynamicsurface_put_rasterblocksize_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pSize

    // Call method on actual COM interface
    hr = self->m_pIDynamicSurface->put_RasterBlockSize(lpSize);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDynamicSurface->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDynamicSurface) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDynamicSurface.put_RasterBlockSize() returned %ld", (long)hr);
        goto idynamicsurface_put_rasterblocksize_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pSize

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idynamicsurface_put_rasterblocksize_method_cleanup;

    idynamicsurface_put_rasterblocksize_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pSize
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDynamicSurface.put_RasterBlockSize");
    return return_tuple;
}

static PyObject*
IDynamicSurfaceMethod_get_RasterBlockSize(PyIDynamicSurfaceObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpSize = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pSize

    // Call method on actual COM interface
    hr = self->m_pIDynamicSurface->get_RasterBlockSize(&lpSize);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDynamicSurface->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDynamicSurface) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDynamicSurface.get_RasterBlockSize() returned %ld", (long)hr);
        goto idynamicsurface_get_rasterblocksize_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pSize

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpSize);
    goto idynamicsurface_get_rasterblocksize_method_cleanup;

    idynamicsurface_get_rasterblocksize_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pSize
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDynamicSurface.get_RasterBlockSize");
    return return_tuple;
}

static PyObject*
IDynamicSurfaceMethod_get_Terrain(PyIDynamicSurfaceObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ITerrain* ipppTerrain = NULL;
    PyObject* py_ppTerrain = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppTerrain

    // Call method on actual COM interface
    hr = self->m_pIDynamicSurface->get_Terrain(&ipppTerrain);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDynamicSurface->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDynamicSurface) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDynamicSurface.get_Terrain() returned %ld", (long)hr);
        goto idynamicsurface_get_terrain_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppTerrain);
    if (ipppTerrain)
    {
        IUnknown* pUnk = NULL;
        ipppTerrain->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppTerrain = IUnknownToPythonIIDObject(pUnk, &IID_ITerrain);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppTerrain)
    {
        if (py_ppTerrain)
           Py_DECREF(py_ppTerrain);
        py_ppTerrain = Py_None;
        Py_INCREF(py_ppTerrain);
    }
    if (PyErr_Occurred())
      goto idynamicsurface_get_terrain_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppTerrain);
    goto idynamicsurface_get_terrain_method_cleanup;

    idynamicsurface_get_terrain_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppTerrain);
    if (ipppTerrain)
      ipppTerrain->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDynamicSurface.get_Terrain");
    return return_tuple;
}

static PyObject*
IDynamicSurfaceMethod_GetTin(PyIDynamicSurfaceObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IEnvelope* ippAreaOfInterest = NULL;
    PyObject* py_pAreaOfInterest;
    double dResolution = 0;
    VARIANT_BOOL b_bClipWithAOI = VARIANT_FALSE;
    PyObject* pyvar_bClipWithAOI = NULL;
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;
    ITin* ipppTin = NULL;
    PyObject* py_ppTin = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OdOO", &py_pAreaOfInterest, &dResolution, &pyvar_bClipWithAOI, &py_pTrackCancel))
      goto idynamicsurface_gettin_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pAreaOfInterest, &IID_IEnvelope, (void**)&ippAreaOfInterest))
        PyErr_SetString(PyExc_TypeError, "Argument pAreaOfInterest (position 0) is not IEnvelope");
    
    if (PyErr_Occurred())
      goto idynamicsurface_gettin_method_cleanup;
    
    // No setup for Resolution
    b_bClipWithAOI = ((PyObject_IsTrue(pyvar_bClipWithAOI) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto idynamicsurface_gettin_method_cleanup;
    
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 3) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto idynamicsurface_gettin_method_cleanup;
    
    // No setup for ppTin

    // Call method on actual COM interface
    hr = self->m_pIDynamicSurface->GetTin(ippAreaOfInterest, dResolution, b_bClipWithAOI, ippTrackCancel, &ipppTin);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDynamicSurface->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDynamicSurface) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDynamicSurface.GetTin() returned %ld", (long)hr);
        goto idynamicsurface_gettin_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pAreaOfInterest
    // No teardown for Resolution
    // No teardown for bClipWithAOI
    // No teardown for pTrackCancel
    Py_XDECREF(py_ppTin);
    if (ipppTin)
    {
        IUnknown* pUnk = NULL;
        ipppTin->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppTin = IUnknownToPythonIIDObject(pUnk, &IID_ITin);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppTin)
    {
        if (py_ppTin)
           Py_DECREF(py_ppTin);
        py_ppTin = Py_None;
        Py_INCREF(py_ppTin);
    }
    if (PyErr_Occurred())
      goto idynamicsurface_gettin_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppTin);
    goto idynamicsurface_gettin_method_cleanup;

    idynamicsurface_gettin_method_cleanup:
    self->m_HR = hr;
    if (ippAreaOfInterest)
      ippAreaOfInterest->Release();
    // No cleanup for Resolution
    // No cleanup for bClipWithAOI
    if (ippTrackCancel)
      ippTrackCancel->Release();
    Py_XDECREF(py_ppTin);
    if (ipppTin)
      ipppTin->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDynamicSurface.GetTin");
    return return_tuple;
}

static PyObject*
IDynamicSurfaceMethod_QueryRaster(PyIDynamicSurfaceObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IRasterDataset* ippDataset = NULL;
    PyObject* py_pDataset;
    IEnvelope* ippAreaOfInterest = NULL;
    PyObject* py_pAreaOfInterest;
    double dResolution = 0;
    esriSurfaceInterpolationType eMethod;
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOdiO", &py_pDataset, &py_pAreaOfInterest, &dResolution, (int *)&eMethod, &py_pTrackCancel))
      goto idynamicsurface_queryraster_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pDataset, &IID_IRasterDataset, (void**)&ippDataset))
        PyErr_SetString(PyExc_TypeError, "Argument pDataset (position 0) is not IRasterDataset");
    
    if (PyErr_Occurred())
      goto idynamicsurface_queryraster_method_cleanup;
    
    if (!IFaceFromPyObject(py_pAreaOfInterest, &IID_IEnvelope, (void**)&ippAreaOfInterest))
        PyErr_SetString(PyExc_TypeError, "Argument pAreaOfInterest (position 1) is not IEnvelope");
    
    if (PyErr_Occurred())
      goto idynamicsurface_queryraster_method_cleanup;
    
    // No setup for Resolution
    // No setup for Method
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 4) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto idynamicsurface_queryraster_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIDynamicSurface->QueryRaster(ippDataset, ippAreaOfInterest, dResolution, eMethod, ippTrackCancel);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDynamicSurface->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDynamicSurface) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDynamicSurface.QueryRaster() returned %ld", (long)hr);
        goto idynamicsurface_queryraster_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pDataset
    // No teardown for pAreaOfInterest
    // No teardown for Resolution
    // No teardown for Method
    // No teardown for pTrackCancel

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idynamicsurface_queryraster_method_cleanup;

    idynamicsurface_queryraster_method_cleanup:
    self->m_HR = hr;
    if (ippDataset)
      ippDataset->Release();
    if (ippAreaOfInterest)
      ippAreaOfInterest->Release();
    // No cleanup for Resolution
    // No cleanup for Method
    if (ippTrackCancel)
      ippTrackCancel->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDynamicSurface.QueryRaster");
    return return_tuple;
}

static PyObject*
IDynamicSurfaceMethod_QueryAsFeatureClass(PyIDynamicSurfaceObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IFeatureClass* ippFeatureClass = NULL;
    PyObject* py_pFeatureClass;
    IEnvelope* ippAreaOfInterest = NULL;
    PyObject* py_pAreaOfInterest;
    double dResolution = 0;
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOdO", &py_pFeatureClass, &py_pAreaOfInterest, &dResolution, &py_pTrackCancel))
      goto idynamicsurface_queryasfeatureclass_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pFeatureClass, &IID_IFeatureClass, (void**)&ippFeatureClass))
        PyErr_SetString(PyExc_TypeError, "Argument pFeatureClass (position 0) is not IFeatureClass");
    
    if (PyErr_Occurred())
      goto idynamicsurface_queryasfeatureclass_method_cleanup;
    
    if (!IFaceFromPyObject(py_pAreaOfInterest, &IID_IEnvelope, (void**)&ippAreaOfInterest))
        PyErr_SetString(PyExc_TypeError, "Argument pAreaOfInterest (position 1) is not IEnvelope");
    
    if (PyErr_Occurred())
      goto idynamicsurface_queryasfeatureclass_method_cleanup;
    
    // No setup for Resolution
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 3) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto idynamicsurface_queryasfeatureclass_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIDynamicSurface->QueryAsFeatureClass(ippFeatureClass, ippAreaOfInterest, dResolution, ippTrackCancel);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDynamicSurface->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDynamicSurface) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDynamicSurface.QueryAsFeatureClass() returned %ld", (long)hr);
        goto idynamicsurface_queryasfeatureclass_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pFeatureClass
    // No teardown for pAreaOfInterest
    // No teardown for Resolution
    // No teardown for pTrackCancel

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idynamicsurface_queryasfeatureclass_method_cleanup;

    idynamicsurface_queryasfeatureclass_method_cleanup:
    self->m_HR = hr;
    if (ippFeatureClass)
      ippFeatureClass->Release();
    if (ippAreaOfInterest)
      ippAreaOfInterest->Release();
    // No cleanup for Resolution
    if (ippTrackCancel)
      ippTrackCancel->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDynamicSurface.QueryAsFeatureClass");
    return return_tuple;
}


PyMethodDef PyIDynamicSurfaceMethods[] = {
    {"supports", (PyCFunction)PyIDynamicSurface_SupportsInterface, METH_O, ""},
    {"put_RasterBlockSize", (PyCFunction)IDynamicSurfaceMethod_put_RasterBlockSize, METH_VARARGS, ""},
    {"get_RasterBlockSize", (PyCFunction)IDynamicSurfaceMethod_get_RasterBlockSize, METH_VARARGS, ""},
    {"get_Terrain", (PyCFunction)IDynamicSurfaceMethod_get_Terrain, METH_VARARGS, ""},
    {"GetTin", (PyCFunction)IDynamicSurfaceMethod_GetTin, METH_VARARGS, ""},
    {"QueryRaster", (PyCFunction)IDynamicSurfaceMethod_QueryRaster, METH_VARARGS, ""},
    {"QueryAsFeatureClass", (PyCFunction)IDynamicSurfaceMethod_QueryAsFeatureClass, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIDynamicSurfaceGetSet[] = {
  {"_pUnk", (getter)PyIDynamicSurface_GetpUnk, NULL, "Get opaque pointer to an Unknown from IDynamicSurface", NULL},
  {"_pointer", (getter)PyIDynamicSurface_GetPointer, NULL, "Get memory address for IDynamicSurface", NULL},
  {"_IID", (getter)PyIDynamicSurface_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIDynamicSurface_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIDynamicSurface_GetIgnoreFailures, (setter)PyIDynamicSurface_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIDynamicSurfaceObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.IDynamicSurfaceObject",                          
                                              /* tp_name */
  sizeof(PyIDynamicSurfaceObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIDynamicSurfaceObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIDynamicSurfaceMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIDynamicSurfaceGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIDynamicSurfaceObject_new,                      
                                              /* tp_new */
};

// Interface ITerrain2

typedef struct PyITerrain2Object {
    PyObject_HEAD
    ITerrain2* m_pITerrain2;
    HRESULT m_HR;
    int m_ignore_failures;
} PyITerrain2Object;

static PyObject*
PyITerrain2Object_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyITerrain2Object* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ITerrain2* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ITerrain2, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ITerrain2 with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyITerrain2Object *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ITerrain2");
            return NULL;
        }
        self->m_pITerrain2 = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ITerrain2");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ITerrain2");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ITerrain2* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ITerrain2, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ITerrain2");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyITerrain2Object *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ITerrain2");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pITerrain2 = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyITerrain2Object_dealloc(PyITerrain2Object* self)
{
    if (self->m_pITerrain2)
        self->m_pITerrain2->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyITerrain2_GetpUnk(PyITerrain2Object* self)
{
    if (!self->m_pITerrain2)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pITerrain2->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ITerrain2 to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyITerrain2_GetPointer(PyITerrain2Object* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pITerrain2);
}

static PyObject*
PyITerrain2_GetIID(PyITerrain2Object* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "5d6d7322-d2d5-4c16-a52d-0b1199efa98d");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyITerrain2_GetHR(PyITerrain2Object* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyITerrain2_GetIgnoreFailures(PyITerrain2Object* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyITerrain2_SetIgnoreFailures(PyITerrain2Object* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyITerrain2_SupportsInterface(PyITerrain2Object* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pITerrain2->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ITerrain2Method_GetEmbeddedDataSourceShapeFieldName(PyITerrain2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspName;
    PyObject* pyvar_pName = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pName

    // Call method on actual COM interface
    hr = self->m_pITerrain2->GetEmbeddedDataSourceShapeFieldName(&bspName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrain2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrain2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrain2.GetEmbeddedDataSourceShapeFieldName() returned %ld", (long)hr);
        goto iterrain2_getembeddeddatasourceshapefieldname_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pName = PyUnicode_FromWideChar(bspName,::SysStringLen(bspName));
    ::SysFreeString(bspName);
    
    if (PyErr_Occurred())
      goto iterrain2_getembeddeddatasourceshapefieldname_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pName);
    goto iterrain2_getembeddeddatasourceshapefieldname_method_cleanup;

    iterrain2_getembeddeddatasourceshapefieldname_method_cleanup:
    self->m_HR = hr;
    if (pyvar_pName != Py_None)
        Py_XDECREF(pyvar_pName);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrain2.GetEmbeddedDataSourceShapeFieldName");
    return return_tuple;
}

static PyObject*
ITerrain2Method_SearchFromEmbeddedDataSource(PyITerrain2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;
    IEnvelope* ippAOI = NULL;
    PyObject* py_pAOI;
    double dResolution = 0;
    IStringArray* ippSubFields = NULL;
    PyObject* py_pSubFields;
    IFeatureCursor* ipppCursor = NULL;
    PyObject* py_ppCursor = NULL;
    ILongArray* ipppFieldIndices = NULL;
    PyObject* py_ppFieldIndices = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "lOdO", &lindex, &py_pAOI, &dResolution, &py_pSubFields))
      goto iterrain2_searchfromembeddeddatasource_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index
    if (!IFaceFromPyObject(py_pAOI, &IID_IEnvelope, (void**)&ippAOI))
        PyErr_SetString(PyExc_TypeError, "Argument pAOI (position 1) is not IEnvelope");
    
    if (PyErr_Occurred())
      goto iterrain2_searchfromembeddeddatasource_method_cleanup;
    
    // No setup for Resolution
    if (!IFaceFromPyObject(py_pSubFields, &IID_IStringArray, (void**)&ippSubFields))
        PyErr_SetString(PyExc_TypeError, "Argument pSubFields (position 3) is not IStringArray");
    
    if (PyErr_Occurred())
      goto iterrain2_searchfromembeddeddatasource_method_cleanup;
    
    // No setup for ppCursor
    // No setup for ppFieldIndices

    // Call method on actual COM interface
    hr = self->m_pITerrain2->SearchFromEmbeddedDataSource(lindex, ippAOI, dResolution, ippSubFields, &ipppCursor, &ipppFieldIndices);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrain2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrain2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrain2.SearchFromEmbeddedDataSource() returned %ld", (long)hr);
        goto iterrain2_searchfromembeddeddatasource_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index
    // No teardown for pAOI
    // No teardown for Resolution
    // No teardown for pSubFields
    Py_XDECREF(py_ppCursor);
    if (ipppCursor)
    {
        IUnknown* pUnk = NULL;
        ipppCursor->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppCursor = IUnknownToPythonIIDObject(pUnk, &IID_IFeatureCursor);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppCursor)
    {
        if (py_ppCursor)
           Py_DECREF(py_ppCursor);
        py_ppCursor = Py_None;
        Py_INCREF(py_ppCursor);
    }
    if (PyErr_Occurred())
      goto iterrain2_searchfromembeddeddatasource_method_cleanup;
    
    Py_XDECREF(py_ppFieldIndices);
    if (ipppFieldIndices)
    {
        IUnknown* pUnk = NULL;
        ipppFieldIndices->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppFieldIndices = IUnknownToPythonIIDObject(pUnk, &IID_ILongArray);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppFieldIndices)
    {
        if (py_ppFieldIndices)
           Py_DECREF(py_ppFieldIndices);
        py_ppFieldIndices = Py_None;
        Py_INCREF(py_ppFieldIndices);
    }
    if (PyErr_Occurred())
      goto iterrain2_searchfromembeddeddatasource_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("OO",
                                            py_ppCursor, py_ppFieldIndices);
    goto iterrain2_searchfromembeddeddatasource_method_cleanup;

    iterrain2_searchfromembeddeddatasource_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    if (ippAOI)
      ippAOI->Release();
    // No cleanup for Resolution
    if (ippSubFields)
      ippSubFields->Release();
    Py_XDECREF(py_ppCursor);
    if (ipppCursor)
      ipppCursor->Release();
    Py_XDECREF(py_ppFieldIndices);
    if (ipppFieldIndices)
      ipppFieldIndices->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrain2.SearchFromEmbeddedDataSource");
    return return_tuple;
}

static PyObject*
ITerrain2Method_get_Name(PyITerrain2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspName;
    PyObject* pyvar_pName = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pName

    // Call method on actual COM interface
    hr = self->m_pITerrain2->get_Name(&bspName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrain2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrain2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrain2.get_Name() returned %ld", (long)hr);
        goto iterrain2_get_name_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pName = PyUnicode_FromWideChar(bspName,::SysStringLen(bspName));
    ::SysFreeString(bspName);
    
    if (PyErr_Occurred())
      goto iterrain2_get_name_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pName);
    goto iterrain2_get_name_method_cleanup;

    iterrain2_get_name_method_cleanup:
    self->m_HR = hr;
    if (pyvar_pName != Py_None)
        Py_XDECREF(pyvar_pName);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrain2.get_Name");
    return return_tuple;
}

static PyObject*
ITerrain2Method_get_ID(PyITerrain2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpID = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pID

    // Call method on actual COM interface
    hr = self->m_pITerrain2->get_ID(&lpID);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrain2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrain2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrain2.get_ID() returned %ld", (long)hr);
        goto iterrain2_get_id_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pID

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpID);
    goto iterrain2_get_id_method_cleanup;

    iterrain2_get_id_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pID
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrain2.get_ID");
    return return_tuple;
}

static PyObject*
ITerrain2Method_get_Size(PyITerrain2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dpcPoints = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pcPoints

    // Call method on actual COM interface
    hr = self->m_pITerrain2->get_Size(&dpcPoints);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrain2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrain2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrain2.get_Size() returned %ld", (long)hr);
        goto iterrain2_get_size_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pcPoints

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dpcPoints);
    goto iterrain2_get_size_method_cleanup;

    iterrain2_get_size_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pcPoints
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrain2.get_Size");
    return return_tuple;
}

static PyObject*
ITerrain2Method_get_IsValid(PyITerrain2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pbIsValid = VARIANT_FALSE;
    PyObject* pyvar_pbIsValid = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pbIsValid

    // Call method on actual COM interface
    hr = self->m_pITerrain2->get_IsValid(&b_pbIsValid);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrain2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrain2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrain2.get_IsValid() returned %ld", (long)hr);
        goto iterrain2_get_isvalid_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pbIsValid = ((b_pbIsValid == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto iterrain2_get_isvalid_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pbIsValid);
    goto iterrain2_get_isvalid_method_cleanup;

    iterrain2_get_isvalid_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pbIsValid
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrain2.get_IsValid");
    return return_tuple;
}

static PyObject*
ITerrain2Method_get_IsDirty(PyITerrain2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pbIsDirty = VARIANT_FALSE;
    PyObject* pyvar_pbIsDirty = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pbIsDirty

    // Call method on actual COM interface
    hr = self->m_pITerrain2->get_IsDirty(&b_pbIsDirty);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrain2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrain2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrain2.get_IsDirty() returned %ld", (long)hr);
        goto iterrain2_get_isdirty_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pbIsDirty = ((b_pbIsDirty == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto iterrain2_get_isdirty_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pbIsDirty);
    goto iterrain2_get_isdirty_method_cleanup;

    iterrain2_get_isdirty_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pbIsDirty
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrain2.get_IsDirty");
    return return_tuple;
}

static PyObject*
ITerrain2Method_get_SpatialReference(PyITerrain2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ISpatialReference* ipppSpatialRef = NULL;
    PyObject* py_ppSpatialRef = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppSpatialRef

    // Call method on actual COM interface
    hr = self->m_pITerrain2->get_SpatialReference(&ipppSpatialRef);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrain2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrain2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrain2.get_SpatialReference() returned %ld", (long)hr);
        goto iterrain2_get_spatialreference_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppSpatialRef);
    if (ipppSpatialRef)
    {
        IUnknown* pUnk = NULL;
        ipppSpatialRef->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppSpatialRef = IUnknownToPythonIIDObject(pUnk, &IID_ISpatialReference);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppSpatialRef)
    {
        if (py_ppSpatialRef)
           Py_DECREF(py_ppSpatialRef);
        py_ppSpatialRef = Py_None;
        Py_INCREF(py_ppSpatialRef);
    }
    if (PyErr_Occurred())
      goto iterrain2_get_spatialreference_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppSpatialRef);
    goto iterrain2_get_spatialreference_method_cleanup;

    iterrain2_get_spatialreference_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppSpatialRef);
    if (ipppSpatialRef)
      ipppSpatialRef->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrain2.get_SpatialReference");
    return return_tuple;
}

static PyObject*
ITerrain2Method_get_Extent(PyITerrain2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IEnvelope* ipppExtent = NULL;
    PyObject* py_ppExtent = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppExtent

    // Call method on actual COM interface
    hr = self->m_pITerrain2->get_Extent(&ipppExtent);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrain2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrain2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrain2.get_Extent() returned %ld", (long)hr);
        goto iterrain2_get_extent_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppExtent);
    if (ipppExtent)
    {
        IUnknown* pUnk = NULL;
        ipppExtent->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppExtent = IUnknownToPythonIIDObject(pUnk, &IID_IEnvelope);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppExtent)
    {
        if (py_ppExtent)
           Py_DECREF(py_ppExtent);
        py_ppExtent = Py_None;
        Py_INCREF(py_ppExtent);
    }
    if (PyErr_Occurred())
      goto iterrain2_get_extent_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppExtent);
    goto iterrain2_get_extent_method_cleanup;

    iterrain2_get_extent_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppExtent);
    if (ipppExtent)
      ipppExtent->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrain2.get_Extent");
    return return_tuple;
}

static PyObject*
ITerrain2Method_get_FeatureDataset(PyITerrain2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IFeatureDataset* ipppDataset = NULL;
    PyObject* py_ppDataset = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppDataset

    // Call method on actual COM interface
    hr = self->m_pITerrain2->get_FeatureDataset(&ipppDataset);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrain2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrain2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrain2.get_FeatureDataset() returned %ld", (long)hr);
        goto iterrain2_get_featuredataset_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppDataset);
    if (ipppDataset)
    {
        IUnknown* pUnk = NULL;
        ipppDataset->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppDataset = IUnknownToPythonIIDObject(pUnk, &IID_IFeatureDataset);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppDataset)
    {
        if (py_ppDataset)
           Py_DECREF(py_ppDataset);
        py_ppDataset = Py_None;
        Py_INCREF(py_ppDataset);
    }
    if (PyErr_Occurred())
      goto iterrain2_get_featuredataset_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppDataset);
    goto iterrain2_get_featuredataset_method_cleanup;

    iterrain2_get_featuredataset_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppDataset);
    if (ipppDataset)
      ipppDataset->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrain2.get_FeatureDataset");
    return return_tuple;
}

static PyObject*
ITerrain2Method_get_DataSourceCount(PyITerrain2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpcDataSources = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pcDataSources

    // Call method on actual COM interface
    hr = self->m_pITerrain2->get_DataSourceCount(&lpcDataSources);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrain2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrain2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrain2.get_DataSourceCount() returned %ld", (long)hr);
        goto iterrain2_get_datasourcecount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pcDataSources

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpcDataSources);
    goto iterrain2_get_datasourcecount_method_cleanup;

    iterrain2_get_datasourcecount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pcDataSources
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrain2.get_DataSourceCount");
    return return_tuple;
}

static PyObject*
ITerrain2Method_get_DataSource(PyITerrain2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;
    ITerrainDataSource* ipppDataSource = NULL;
    PyObject* py_ppDataSource = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lindex))
      goto iterrain2_get_datasource_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index
    // No setup for ppDataSource

    // Call method on actual COM interface
    hr = self->m_pITerrain2->get_DataSource(lindex, &ipppDataSource);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrain2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrain2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrain2.get_DataSource() returned %ld", (long)hr);
        goto iterrain2_get_datasource_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index
    Py_XDECREF(py_ppDataSource);
    if (ipppDataSource)
    {
        IUnknown* pUnk = NULL;
        ipppDataSource->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppDataSource = IUnknownToPythonIIDObject(pUnk, &IID_ITerrainDataSource);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppDataSource)
    {
        if (py_ppDataSource)
           Py_DECREF(py_ppDataSource);
        py_ppDataSource = Py_None;
        Py_INCREF(py_ppDataSource);
    }
    if (PyErr_Occurred())
      goto iterrain2_get_datasource_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppDataSource);
    goto iterrain2_get_datasource_method_cleanup;

    iterrain2_get_datasource_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    Py_XDECREF(py_ppDataSource);
    if (ipppDataSource)
      ipppDataSource->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrain2.get_DataSource");
    return return_tuple;
}

static PyObject*
ITerrain2Method_get_PyramidLevelCount(PyITerrain2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpcPyramidLevels = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pcPyramidLevels

    // Call method on actual COM interface
    hr = self->m_pITerrain2->get_PyramidLevelCount(&lpcPyramidLevels);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrain2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrain2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrain2.get_PyramidLevelCount() returned %ld", (long)hr);
        goto iterrain2_get_pyramidlevelcount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pcPyramidLevels

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpcPyramidLevels);
    goto iterrain2_get_pyramidlevelcount_method_cleanup;

    iterrain2_get_pyramidlevelcount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pcPyramidLevels
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrain2.get_PyramidLevelCount");
    return return_tuple;
}

static PyObject*
ITerrain2Method_get_PyramidLevel(PyITerrain2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;
    ITerrainPyramidLevel* ipppPyramidLevel = NULL;
    PyObject* py_ppPyramidLevel = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lindex))
      goto iterrain2_get_pyramidlevel_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index
    // No setup for ppPyramidLevel

    // Call method on actual COM interface
    hr = self->m_pITerrain2->get_PyramidLevel(lindex, &ipppPyramidLevel);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrain2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrain2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrain2.get_PyramidLevel() returned %ld", (long)hr);
        goto iterrain2_get_pyramidlevel_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index
    Py_XDECREF(py_ppPyramidLevel);
    if (ipppPyramidLevel)
    {
        IUnknown* pUnk = NULL;
        ipppPyramidLevel->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppPyramidLevel = IUnknownToPythonIIDObject(pUnk, &IID_ITerrainPyramidLevel);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppPyramidLevel)
    {
        if (py_ppPyramidLevel)
           Py_DECREF(py_ppPyramidLevel);
        py_ppPyramidLevel = Py_None;
        Py_INCREF(py_ppPyramidLevel);
    }
    if (PyErr_Occurred())
      goto iterrain2_get_pyramidlevel_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppPyramidLevel);
    goto iterrain2_get_pyramidlevel_method_cleanup;

    iterrain2_get_pyramidlevel_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    Py_XDECREF(py_ppPyramidLevel);
    if (ipppPyramidLevel)
      ipppPyramidLevel->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrain2.get_PyramidLevel");
    return return_tuple;
}

static PyObject*
ITerrain2Method_get_TileSize(PyITerrain2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dpSize = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pSize

    // Call method on actual COM interface
    hr = self->m_pITerrain2->get_TileSize(&dpSize);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrain2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrain2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrain2.get_TileSize() returned %ld", (long)hr);
        goto iterrain2_get_tilesize_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pSize

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dpSize);
    goto iterrain2_get_tilesize_method_cleanup;

    iterrain2_get_tilesize_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pSize
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrain2.get_TileSize");
    return return_tuple;
}

static PyObject*
ITerrain2Method_get_PyramidType(PyITerrain2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriTerrainPyramidType epType;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pType

    // Call method on actual COM interface
    hr = self->m_pITerrain2->get_PyramidType(&epType);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrain2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrain2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrain2.get_PyramidType() returned %ld", (long)hr);
        goto iterrain2_get_pyramidtype_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pType

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)epType);
    goto iterrain2_get_pyramidtype_method_cleanup;

    iterrain2_get_pyramidtype_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pType
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrain2.get_PyramidType");
    return return_tuple;
}

static PyObject*
ITerrain2Method_get_MaxOverviewTerrainPoints(PyITerrain2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpcPoints = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pcPoints

    // Call method on actual COM interface
    hr = self->m_pITerrain2->get_MaxOverviewTerrainPoints(&lpcPoints);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrain2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrain2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrain2.get_MaxOverviewTerrainPoints() returned %ld", (long)hr);
        goto iterrain2_get_maxoverviewterrainpoints_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pcPoints

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpcPoints);
    goto iterrain2_get_maxoverviewterrainpoints_method_cleanup;

    iterrain2_get_maxoverviewterrainpoints_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pcPoints
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrain2.get_MaxOverviewTerrainPoints");
    return return_tuple;
}

static PyObject*
ITerrain2Method_get_MaxPointsPerShape(PyITerrain2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpcPoints = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pcPoints

    // Call method on actual COM interface
    hr = self->m_pITerrain2->get_MaxPointsPerShape(&lpcPoints);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrain2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrain2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrain2.get_MaxPointsPerShape() returned %ld", (long)hr);
        goto iterrain2_get_maxpointspershape_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pcPoints

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpcPoints);
    goto iterrain2_get_maxpointspershape_method_cleanup;

    iterrain2_get_maxpointspershape_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pcPoints
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrain2.get_MaxPointsPerShape");
    return return_tuple;
}

static PyObject*
ITerrain2Method_QueryTileInfo(PyITerrain2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpRowBegin = 0;
    long lpRowEnd = 0;
    long lpColBegin = 0;
    long lpColEnd = 0;
    double dpXMin = 0;
    double dpYMin = 0;
    double dpTileSize = 0;
    long lpRowCountDomain = 0;
    long lpColCountDomain = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pRowBegin
    // No setup for pRowEnd
    // No setup for pColBegin
    // No setup for pColEnd
    // No setup for pXMin
    // No setup for pYMin
    // No setup for pTileSize
    // No setup for pRowCountDomain
    // No setup for pColCountDomain

    // Call method on actual COM interface
    hr = self->m_pITerrain2->QueryTileInfo(&lpRowBegin, &lpRowEnd, &lpColBegin, &lpColEnd, &dpXMin, &dpYMin, &dpTileSize, &lpRowCountDomain, &lpColCountDomain);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrain2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrain2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrain2.QueryTileInfo() returned %ld", (long)hr);
        goto iterrain2_querytileinfo_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pRowBegin
    // No teardown for pRowEnd
    // No teardown for pColBegin
    // No teardown for pColEnd
    // No teardown for pXMin
    // No teardown for pYMin
    // No teardown for pTileSize
    // No teardown for pRowCountDomain
    // No teardown for pColCountDomain

    // Initialize output tuple
    return_tuple = Py_BuildValue("lllldddll",
                                            lpRowBegin, lpRowEnd, lpColBegin, lpColEnd, dpXMin, dpYMin, dpTileSize, lpRowCountDomain, lpColCountDomain);
    goto iterrain2_querytileinfo_method_cleanup;

    iterrain2_querytileinfo_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pRowBegin
    // No cleanup for pRowEnd
    // No cleanup for pColBegin
    // No cleanup for pColEnd
    // No cleanup for pXMin
    // No cleanup for pYMin
    // No cleanup for pTileSize
    // No cleanup for pRowCountDomain
    // No cleanup for pColCountDomain
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrain2.QueryTileInfo");
    return return_tuple;
}

static PyObject*
ITerrain2Method_GetDirtyTiles(PyITerrain2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IEnumEnvelope* ipppTiles = NULL;
    PyObject* py_ppTiles = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppTiles

    // Call method on actual COM interface
    hr = self->m_pITerrain2->GetDirtyTiles(&ipppTiles);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrain2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrain2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrain2.GetDirtyTiles() returned %ld", (long)hr);
        goto iterrain2_getdirtytiles_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppTiles);
    if (ipppTiles)
    {
        IUnknown* pUnk = NULL;
        ipppTiles->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppTiles = IUnknownToPythonIIDObject(pUnk, &IID_IEnumEnvelope);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppTiles)
    {
        if (py_ppTiles)
           Py_DECREF(py_ppTiles);
        py_ppTiles = Py_None;
        Py_INCREF(py_ppTiles);
    }
    if (PyErr_Occurred())
      goto iterrain2_getdirtytiles_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppTiles);
    goto iterrain2_getdirtytiles_method_cleanup;

    iterrain2_getdirtytiles_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppTiles);
    if (ipppTiles)
      ipppTiles->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrain2.GetDirtyTiles");
    return return_tuple;
}

static PyObject*
ITerrain2Method_GetPointCount(PyITerrain2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IEnvelope* ippAOI = NULL;
    PyObject* py_pAOI;
    double dResolution = 0;
    double dpcPoints = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "Od", &py_pAOI, &dResolution))
      goto iterrain2_getpointcount_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pAOI, &IID_IEnvelope, (void**)&ippAOI))
        PyErr_SetString(PyExc_TypeError, "Argument pAOI (position 0) is not IEnvelope");
    
    if (PyErr_Occurred())
      goto iterrain2_getpointcount_method_cleanup;
    
    // No setup for Resolution
    // No setup for pcPoints

    // Call method on actual COM interface
    hr = self->m_pITerrain2->GetPointCount(ippAOI, dResolution, &dpcPoints);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrain2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrain2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrain2.GetPointCount() returned %ld", (long)hr);
        goto iterrain2_getpointcount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pAOI
    // No teardown for Resolution
    // No teardown for pcPoints

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dpcPoints);
    goto iterrain2_getpointcount_method_cleanup;

    iterrain2_getpointcount_method_cleanup:
    self->m_HR = hr;
    if (ippAOI)
      ippAOI->Release();
    // No cleanup for Resolution
    // No cleanup for pcPoints
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrain2.GetPointCount");
    return return_tuple;
}

static PyObject*
ITerrain2Method_CreateDynamicSurface(PyITerrain2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IDynamicSurface* ipppDynamicSurface = NULL;
    PyObject* py_ppDynamicSurface = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppDynamicSurface

    // Call method on actual COM interface
    hr = self->m_pITerrain2->CreateDynamicSurface(&ipppDynamicSurface);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrain2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrain2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrain2.CreateDynamicSurface() returned %ld", (long)hr);
        goto iterrain2_createdynamicsurface_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppDynamicSurface);
    if (ipppDynamicSurface)
    {
        IUnknown* pUnk = NULL;
        ipppDynamicSurface->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppDynamicSurface = IUnknownToPythonIIDObject(pUnk, &IID_IDynamicSurface);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppDynamicSurface)
    {
        if (py_ppDynamicSurface)
           Py_DECREF(py_ppDynamicSurface);
        py_ppDynamicSurface = Py_None;
        Py_INCREF(py_ppDynamicSurface);
    }
    if (PyErr_Occurred())
      goto iterrain2_createdynamicsurface_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppDynamicSurface);
    goto iterrain2_createdynamicsurface_method_cleanup;

    iterrain2_createdynamicsurface_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppDynamicSurface);
    if (ipppDynamicSurface)
      ipppDynamicSurface->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrain2.CreateDynamicSurface");
    return return_tuple;
}

static PyObject*
ITerrain2Method_ExtractFromEmbeddedDataSource(PyITerrain2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lindex = 0;
    IFeatureClass* ippFeatureClass = NULL;
    PyObject* py_pFeatureClass;
    IEnvelope* ippAOI = NULL;
    PyObject* py_pAOI;
    double dResolution = 0;
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;

    // Unpack values
    if (!PyArg_ParseTuple(args, "lOOdO", &lindex, &py_pFeatureClass, &py_pAOI, &dResolution, &py_pTrackCancel))
      goto iterrain2_extractfromembeddeddatasource_method_cleanup;

    // Set up initial variable values as needed
    // No setup for index
    if (!IFaceFromPyObject(py_pFeatureClass, &IID_IFeatureClass, (void**)&ippFeatureClass))
        PyErr_SetString(PyExc_TypeError, "Argument pFeatureClass (position 1) is not IFeatureClass");
    
    if (PyErr_Occurred())
      goto iterrain2_extractfromembeddeddatasource_method_cleanup;
    
    if (!IFaceFromPyObject(py_pAOI, &IID_IEnvelope, (void**)&ippAOI))
        PyErr_SetString(PyExc_TypeError, "Argument pAOI (position 2) is not IEnvelope");
    
    if (PyErr_Occurred())
      goto iterrain2_extractfromembeddeddatasource_method_cleanup;
    
    // No setup for Resolution
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 4) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto iterrain2_extractfromembeddeddatasource_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pITerrain2->ExtractFromEmbeddedDataSource(lindex, ippFeatureClass, ippAOI, dResolution, ippTrackCancel);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITerrain2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITerrain2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITerrain2.ExtractFromEmbeddedDataSource() returned %ld", (long)hr);
        goto iterrain2_extractfromembeddeddatasource_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for index
    // No teardown for pFeatureClass
    // No teardown for pAOI
    // No teardown for Resolution
    // No teardown for pTrackCancel

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iterrain2_extractfromembeddeddatasource_method_cleanup;

    iterrain2_extractfromembeddeddatasource_method_cleanup:
    self->m_HR = hr;
    // No cleanup for index
    if (ippFeatureClass)
      ippFeatureClass->Release();
    if (ippAOI)
      ippAOI->Release();
    // No cleanup for Resolution
    if (ippTrackCancel)
      ippTrackCancel->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITerrain2.ExtractFromEmbeddedDataSource");
    return return_tuple;
}


PyMethodDef PyITerrain2Methods[] = {
    {"supports", (PyCFunction)PyITerrain2_SupportsInterface, METH_O, ""},
    {"GetEmbeddedDataSourceShapeFieldName", (PyCFunction)ITerrain2Method_GetEmbeddedDataSourceShapeFieldName, METH_VARARGS, ""},
    {"SearchFromEmbeddedDataSource", (PyCFunction)ITerrain2Method_SearchFromEmbeddedDataSource, METH_VARARGS, ""},
    {"get_Name", (PyCFunction)ITerrain2Method_get_Name, METH_VARARGS, ""},
    {"get_ID", (PyCFunction)ITerrain2Method_get_ID, METH_VARARGS, ""},
    {"get_Size", (PyCFunction)ITerrain2Method_get_Size, METH_VARARGS, ""},
    {"get_IsValid", (PyCFunction)ITerrain2Method_get_IsValid, METH_VARARGS, ""},
    {"get_IsDirty", (PyCFunction)ITerrain2Method_get_IsDirty, METH_VARARGS, ""},
    {"get_SpatialReference", (PyCFunction)ITerrain2Method_get_SpatialReference, METH_VARARGS, ""},
    {"get_Extent", (PyCFunction)ITerrain2Method_get_Extent, METH_VARARGS, ""},
    {"get_FeatureDataset", (PyCFunction)ITerrain2Method_get_FeatureDataset, METH_VARARGS, ""},
    {"get_DataSourceCount", (PyCFunction)ITerrain2Method_get_DataSourceCount, METH_VARARGS, ""},
    {"get_DataSource", (PyCFunction)ITerrain2Method_get_DataSource, METH_VARARGS, ""},
    {"get_PyramidLevelCount", (PyCFunction)ITerrain2Method_get_PyramidLevelCount, METH_VARARGS, ""},
    {"get_PyramidLevel", (PyCFunction)ITerrain2Method_get_PyramidLevel, METH_VARARGS, ""},
    {"get_TileSize", (PyCFunction)ITerrain2Method_get_TileSize, METH_VARARGS, ""},
    {"get_PyramidType", (PyCFunction)ITerrain2Method_get_PyramidType, METH_VARARGS, ""},
    {"get_MaxOverviewTerrainPoints", (PyCFunction)ITerrain2Method_get_MaxOverviewTerrainPoints, METH_VARARGS, ""},
    {"get_MaxPointsPerShape", (PyCFunction)ITerrain2Method_get_MaxPointsPerShape, METH_VARARGS, ""},
    {"QueryTileInfo", (PyCFunction)ITerrain2Method_QueryTileInfo, METH_VARARGS, ""},
    {"GetDirtyTiles", (PyCFunction)ITerrain2Method_GetDirtyTiles, METH_VARARGS, ""},
    {"GetPointCount", (PyCFunction)ITerrain2Method_GetPointCount, METH_VARARGS, ""},
    {"CreateDynamicSurface", (PyCFunction)ITerrain2Method_CreateDynamicSurface, METH_VARARGS, ""},
    {"ExtractFromEmbeddedDataSource", (PyCFunction)ITerrain2Method_ExtractFromEmbeddedDataSource, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyITerrain2GetSet[] = {
  {"_pUnk", (getter)PyITerrain2_GetpUnk, NULL, "Get opaque pointer to an Unknown from ITerrain2", NULL},
  {"_pointer", (getter)PyITerrain2_GetPointer, NULL, "Get memory address for ITerrain2", NULL},
  {"_IID", (getter)PyITerrain2_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyITerrain2_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyITerrain2_GetIgnoreFailures, (setter)PyITerrain2_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyITerrain2Object_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.ITerrain2Object",                          
                                              /* tp_name */
  sizeof(PyITerrain2Object),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyITerrain2Object_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyITerrain2Methods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyITerrain2GetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyITerrain2Object_new,                      
                                              /* tp_new */
};

// Interface IDynamicSurface2

typedef struct PyIDynamicSurface2Object {
    PyObject_HEAD
    IDynamicSurface2* m_pIDynamicSurface2;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIDynamicSurface2Object;

static PyObject*
PyIDynamicSurface2Object_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIDynamicSurface2Object* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IDynamicSurface2* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IDynamicSurface2, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IDynamicSurface2 with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIDynamicSurface2Object *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IDynamicSurface2");
            return NULL;
        }
        self->m_pIDynamicSurface2 = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IDynamicSurface2");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IDynamicSurface2");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IDynamicSurface2* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IDynamicSurface2, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IDynamicSurface2");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIDynamicSurface2Object *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IDynamicSurface2");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIDynamicSurface2 = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIDynamicSurface2Object_dealloc(PyIDynamicSurface2Object* self)
{
    if (self->m_pIDynamicSurface2)
        self->m_pIDynamicSurface2->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIDynamicSurface2_GetpUnk(PyIDynamicSurface2Object* self)
{
    if (!self->m_pIDynamicSurface2)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIDynamicSurface2->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IDynamicSurface2 to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIDynamicSurface2_GetPointer(PyIDynamicSurface2Object* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIDynamicSurface2);
}

static PyObject*
PyIDynamicSurface2_GetIID(PyIDynamicSurface2Object* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "d7de4992-54f7-4f46-8310-c9d991937c3c");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIDynamicSurface2_GetHR(PyIDynamicSurface2Object* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIDynamicSurface2_GetIgnoreFailures(PyIDynamicSurface2Object* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIDynamicSurface2_SetIgnoreFailures(PyIDynamicSurface2Object* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIDynamicSurface2_SupportsInterface(PyIDynamicSurface2Object* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIDynamicSurface2->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IDynamicSurface2Method_put_MinimizeResourceUsage(PyIDynamicSurface2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pbMinimize = VARIANT_FALSE;
    PyObject* pyvar_pbMinimize = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pbMinimize))
      goto idynamicsurface2_put_minimizeresourceusage_method_cleanup;

    // Set up initial variable values as needed
    b_pbMinimize = ((PyObject_IsTrue(pyvar_pbMinimize) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto idynamicsurface2_put_minimizeresourceusage_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIDynamicSurface2->put_MinimizeResourceUsage(b_pbMinimize);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDynamicSurface2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDynamicSurface2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDynamicSurface2.put_MinimizeResourceUsage() returned %ld", (long)hr);
        goto idynamicsurface2_put_minimizeresourceusage_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pbMinimize

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idynamicsurface2_put_minimizeresourceusage_method_cleanup;

    idynamicsurface2_put_minimizeresourceusage_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pbMinimize
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDynamicSurface2.put_MinimizeResourceUsage");
    return return_tuple;
}

static PyObject*
IDynamicSurface2Method_get_MinimizeResourceUsage(PyIDynamicSurface2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pbMinimize = VARIANT_FALSE;
    PyObject* pyvar_pbMinimize = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pbMinimize

    // Call method on actual COM interface
    hr = self->m_pIDynamicSurface2->get_MinimizeResourceUsage(&b_pbMinimize);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDynamicSurface2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDynamicSurface2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDynamicSurface2.get_MinimizeResourceUsage() returned %ld", (long)hr);
        goto idynamicsurface2_get_minimizeresourceusage_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pbMinimize = ((b_pbMinimize == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto idynamicsurface2_get_minimizeresourceusage_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pbMinimize);
    goto idynamicsurface2_get_minimizeresourceusage_method_cleanup;

    idynamicsurface2_get_minimizeresourceusage_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pbMinimize
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDynamicSurface2.get_MinimizeResourceUsage");
    return return_tuple;
}

static PyObject*
IDynamicSurface2Method_put_RefineBoundaryMatching(PyIDynamicSurface2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pbRefine = VARIANT_FALSE;
    PyObject* pyvar_pbRefine = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pbRefine))
      goto idynamicsurface2_put_refineboundarymatching_method_cleanup;

    // Set up initial variable values as needed
    b_pbRefine = ((PyObject_IsTrue(pyvar_pbRefine) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto idynamicsurface2_put_refineboundarymatching_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIDynamicSurface2->put_RefineBoundaryMatching(b_pbRefine);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDynamicSurface2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDynamicSurface2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDynamicSurface2.put_RefineBoundaryMatching() returned %ld", (long)hr);
        goto idynamicsurface2_put_refineboundarymatching_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pbRefine

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idynamicsurface2_put_refineboundarymatching_method_cleanup;

    idynamicsurface2_put_refineboundarymatching_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pbRefine
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDynamicSurface2.put_RefineBoundaryMatching");
    return return_tuple;
}

static PyObject*
IDynamicSurface2Method_get_RefineBoundaryMatching(PyIDynamicSurface2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pbRefine = VARIANT_FALSE;
    PyObject* pyvar_pbRefine = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pbRefine

    // Call method on actual COM interface
    hr = self->m_pIDynamicSurface2->get_RefineBoundaryMatching(&b_pbRefine);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDynamicSurface2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDynamicSurface2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDynamicSurface2.get_RefineBoundaryMatching() returned %ld", (long)hr);
        goto idynamicsurface2_get_refineboundarymatching_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pbRefine = ((b_pbRefine == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto idynamicsurface2_get_refineboundarymatching_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pbRefine);
    goto idynamicsurface2_get_refineboundarymatching_method_cleanup;

    idynamicsurface2_get_refineboundarymatching_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pbRefine
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDynamicSurface2.get_RefineBoundaryMatching");
    return return_tuple;
}

static PyObject*
IDynamicSurface2Method_InterpolateShape(PyIDynamicSurface2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IGeometry* ippInShape = NULL;
    PyObject* py_pInShape;
    double dResolution = 0;
    esriSurfaceInterpolationType eType;
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;
    IGeometry* ipppOutShape = NULL;
    PyObject* py_ppOutShape = NULL;
    VARIANT vpStepSize;
    ::VariantInit(&vpStepSize);
    PyObject* pyvar_pStepSize = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OdiOO", &py_pInShape, &dResolution, (int *)&eType, &py_pTrackCancel, &pyvar_pStepSize))
      goto idynamicsurface2_interpolateshape_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pInShape, &IID_IGeometry, (void**)&ippInShape))
        PyErr_SetString(PyExc_TypeError, "Argument pInShape (position 0) is not IGeometry");
    
    if (PyErr_Occurred())
      goto idynamicsurface2_interpolateshape_method_cleanup;
    
    // No setup for Resolution
    // No setup for Type
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 3) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto idynamicsurface2_interpolateshape_method_cleanup;
    
    // No setup for ppOutShape
    PyObject_AsVariant(pyvar_pStepSize, &vpStepSize);
    
    if (PyErr_Occurred())
      goto idynamicsurface2_interpolateshape_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIDynamicSurface2->InterpolateShape(ippInShape, dResolution, eType, ippTrackCancel, &ipppOutShape, &vpStepSize);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDynamicSurface2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDynamicSurface2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDynamicSurface2.InterpolateShape() returned %ld", (long)hr);
        goto idynamicsurface2_interpolateshape_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pInShape
    // No teardown for Resolution
    // No teardown for Type
    // No teardown for pTrackCancel
    Py_XDECREF(py_ppOutShape);
    if (ipppOutShape)
    {
        IUnknown* pUnk = NULL;
        ipppOutShape->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppOutShape = IUnknownToPythonIIDObject(pUnk, &IID_IGeometry);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppOutShape)
    {
        if (py_ppOutShape)
           Py_DECREF(py_ppOutShape);
        py_ppOutShape = Py_None;
        Py_INCREF(py_ppOutShape);
    }
    if (PyErr_Occurred())
      goto idynamicsurface2_interpolateshape_method_cleanup;
    
    // No teardown for pStepSize

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppOutShape);
    goto idynamicsurface2_interpolateshape_method_cleanup;

    idynamicsurface2_interpolateshape_method_cleanup:
    self->m_HR = hr;
    if (ippInShape)
      ippInShape->Release();
    // No cleanup for Resolution
    // No cleanup for Type
    if (ippTrackCancel)
      ippTrackCancel->Release();
    Py_XDECREF(py_ppOutShape);
    if (ipppOutShape)
      ipppOutShape->Release();
    ::VariantClear(&vpStepSize);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDynamicSurface2.InterpolateShape");
    return return_tuple;
}

static PyObject*
IDynamicSurface2Method_InterpolateShapeVertices(PyIDynamicSurface2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IGeometry* ippInShape = NULL;
    PyObject* py_pInShape;
    double dResolution = 0;
    esriSurfaceInterpolationType eType;
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;
    IGeometry* ipppOutShape = NULL;
    PyObject* py_ppOutShape = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OdiO", &py_pInShape, &dResolution, (int *)&eType, &py_pTrackCancel))
      goto idynamicsurface2_interpolateshapevertices_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pInShape, &IID_IGeometry, (void**)&ippInShape))
        PyErr_SetString(PyExc_TypeError, "Argument pInShape (position 0) is not IGeometry");
    
    if (PyErr_Occurred())
      goto idynamicsurface2_interpolateshapevertices_method_cleanup;
    
    // No setup for Resolution
    // No setup for Type
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 3) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto idynamicsurface2_interpolateshapevertices_method_cleanup;
    
    // No setup for ppOutShape

    // Call method on actual COM interface
    hr = self->m_pIDynamicSurface2->InterpolateShapeVertices(ippInShape, dResolution, eType, ippTrackCancel, &ipppOutShape);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDynamicSurface2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDynamicSurface2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDynamicSurface2.InterpolateShapeVertices() returned %ld", (long)hr);
        goto idynamicsurface2_interpolateshapevertices_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pInShape
    // No teardown for Resolution
    // No teardown for Type
    // No teardown for pTrackCancel
    Py_XDECREF(py_ppOutShape);
    if (ipppOutShape)
    {
        IUnknown* pUnk = NULL;
        ipppOutShape->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppOutShape = IUnknownToPythonIIDObject(pUnk, &IID_IGeometry);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppOutShape)
    {
        if (py_ppOutShape)
           Py_DECREF(py_ppOutShape);
        py_ppOutShape = Py_None;
        Py_INCREF(py_ppOutShape);
    }
    if (PyErr_Occurred())
      goto idynamicsurface2_interpolateshapevertices_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppOutShape);
    goto idynamicsurface2_interpolateshapevertices_method_cleanup;

    idynamicsurface2_interpolateshapevertices_method_cleanup:
    self->m_HR = hr;
    if (ippInShape)
      ippInShape->Release();
    // No cleanup for Resolution
    // No cleanup for Type
    if (ippTrackCancel)
      ippTrackCancel->Release();
    Py_XDECREF(py_ppOutShape);
    if (ipppOutShape)
      ipppOutShape->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDynamicSurface2.InterpolateShapeVertices");
    return return_tuple;
}

static PyObject*
IDynamicSurface2Method_InterpolateFeatureClass(PyIDynamicSurface2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IFeatureClass* ippInFeatureClass = NULL;
    PyObject* py_pInFeatureClass;
    IQueryFilter* ippFilter = NULL;
    PyObject* py_pFilter;
    double dResolution = 0;
    esriSurfaceInterpolationType eType;
    IFeatureClass* ippOutFeatureClass = NULL;
    PyObject* py_pOutFeatureClass;
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;
    VARIANT vpStepSize;
    ::VariantInit(&vpStepSize);
    PyObject* pyvar_pStepSize = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOdiOOO", &py_pInFeatureClass, &py_pFilter, &dResolution, (int *)&eType, &py_pOutFeatureClass, &py_pTrackCancel, &pyvar_pStepSize))
      goto idynamicsurface2_interpolatefeatureclass_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pInFeatureClass, &IID_IFeatureClass, (void**)&ippInFeatureClass))
        PyErr_SetString(PyExc_TypeError, "Argument pInFeatureClass (position 0) is not IFeatureClass");
    
    if (PyErr_Occurred())
      goto idynamicsurface2_interpolatefeatureclass_method_cleanup;
    
    if (!IFaceFromPyObject(py_pFilter, &IID_IQueryFilter, (void**)&ippFilter))
        PyErr_SetString(PyExc_TypeError, "Argument pFilter (position 1) is not IQueryFilter");
    
    if (PyErr_Occurred())
      goto idynamicsurface2_interpolatefeatureclass_method_cleanup;
    
    // No setup for Resolution
    // No setup for Type
    if (!IFaceFromPyObject(py_pOutFeatureClass, &IID_IFeatureClass, (void**)&ippOutFeatureClass))
        PyErr_SetString(PyExc_TypeError, "Argument pOutFeatureClass (position 4) is not IFeatureClass");
    
    if (PyErr_Occurred())
      goto idynamicsurface2_interpolatefeatureclass_method_cleanup;
    
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 5) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto idynamicsurface2_interpolatefeatureclass_method_cleanup;
    
    PyObject_AsVariant(pyvar_pStepSize, &vpStepSize);
    
    if (PyErr_Occurred())
      goto idynamicsurface2_interpolatefeatureclass_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIDynamicSurface2->InterpolateFeatureClass(ippInFeatureClass, ippFilter, dResolution, eType, ippOutFeatureClass, ippTrackCancel, &vpStepSize);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDynamicSurface2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDynamicSurface2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDynamicSurface2.InterpolateFeatureClass() returned %ld", (long)hr);
        goto idynamicsurface2_interpolatefeatureclass_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pInFeatureClass
    // No teardown for pFilter
    // No teardown for Resolution
    // No teardown for Type
    // No teardown for pOutFeatureClass
    // No teardown for pTrackCancel
    // No teardown for pStepSize

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idynamicsurface2_interpolatefeatureclass_method_cleanup;

    idynamicsurface2_interpolatefeatureclass_method_cleanup:
    self->m_HR = hr;
    if (ippInFeatureClass)
      ippInFeatureClass->Release();
    if (ippFilter)
      ippFilter->Release();
    // No cleanup for Resolution
    // No cleanup for Type
    if (ippOutFeatureClass)
      ippOutFeatureClass->Release();
    if (ippTrackCancel)
      ippTrackCancel->Release();
    ::VariantClear(&vpStepSize);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDynamicSurface2.InterpolateFeatureClass");
    return return_tuple;
}

static PyObject*
IDynamicSurface2Method_InterpolateFeatureCursor(PyIDynamicSurface2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IFeatureCursor* ippCursor = NULL;
    PyObject* py_pCursor;
    double dResolution = 0;
    esriSurfaceInterpolationType eType;
    IFeatureClass* ippOutFeatureClass = NULL;
    PyObject* py_pOutFeatureClass;
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;
    VARIANT vpStepSize;
    ::VariantInit(&vpStepSize);
    PyObject* pyvar_pStepSize = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OdiOOO", &py_pCursor, &dResolution, (int *)&eType, &py_pOutFeatureClass, &py_pTrackCancel, &pyvar_pStepSize))
      goto idynamicsurface2_interpolatefeaturecursor_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pCursor, &IID_IFeatureCursor, (void**)&ippCursor))
        PyErr_SetString(PyExc_TypeError, "Argument pCursor (position 0) is not IFeatureCursor");
    
    if (PyErr_Occurred())
      goto idynamicsurface2_interpolatefeaturecursor_method_cleanup;
    
    // No setup for Resolution
    // No setup for Type
    if (!IFaceFromPyObject(py_pOutFeatureClass, &IID_IFeatureClass, (void**)&ippOutFeatureClass))
        PyErr_SetString(PyExc_TypeError, "Argument pOutFeatureClass (position 3) is not IFeatureClass");
    
    if (PyErr_Occurred())
      goto idynamicsurface2_interpolatefeaturecursor_method_cleanup;
    
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 4) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto idynamicsurface2_interpolatefeaturecursor_method_cleanup;
    
    PyObject_AsVariant(pyvar_pStepSize, &vpStepSize);
    
    if (PyErr_Occurred())
      goto idynamicsurface2_interpolatefeaturecursor_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIDynamicSurface2->InterpolateFeatureCursor(ippCursor, dResolution, eType, ippOutFeatureClass, ippTrackCancel, &vpStepSize);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDynamicSurface2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDynamicSurface2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDynamicSurface2.InterpolateFeatureCursor() returned %ld", (long)hr);
        goto idynamicsurface2_interpolatefeaturecursor_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pCursor
    // No teardown for Resolution
    // No teardown for Type
    // No teardown for pOutFeatureClass
    // No teardown for pTrackCancel
    // No teardown for pStepSize

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idynamicsurface2_interpolatefeaturecursor_method_cleanup;

    idynamicsurface2_interpolatefeaturecursor_method_cleanup:
    self->m_HR = hr;
    if (ippCursor)
      ippCursor->Release();
    // No cleanup for Resolution
    // No cleanup for Type
    if (ippOutFeatureClass)
      ippOutFeatureClass->Release();
    if (ippTrackCancel)
      ippTrackCancel->Release();
    ::VariantClear(&vpStepSize);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDynamicSurface2.InterpolateFeatureCursor");
    return return_tuple;
}

static PyObject*
IDynamicSurface2Method_InterpolateFeatureClassVertices(PyIDynamicSurface2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IFeatureClass* ippInFeatureClass = NULL;
    PyObject* py_pInFeatureClass;
    IQueryFilter* ippFilter = NULL;
    PyObject* py_pFilter;
    double dResolution = 0;
    esriSurfaceInterpolationType eType;
    IFeatureClass* ippOutFeatureClass = NULL;
    PyObject* py_pOutFeatureClass;
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOdiOO", &py_pInFeatureClass, &py_pFilter, &dResolution, (int *)&eType, &py_pOutFeatureClass, &py_pTrackCancel))
      goto idynamicsurface2_interpolatefeatureclassvertices_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pInFeatureClass, &IID_IFeatureClass, (void**)&ippInFeatureClass))
        PyErr_SetString(PyExc_TypeError, "Argument pInFeatureClass (position 0) is not IFeatureClass");
    
    if (PyErr_Occurred())
      goto idynamicsurface2_interpolatefeatureclassvertices_method_cleanup;
    
    if (!IFaceFromPyObject(py_pFilter, &IID_IQueryFilter, (void**)&ippFilter))
        PyErr_SetString(PyExc_TypeError, "Argument pFilter (position 1) is not IQueryFilter");
    
    if (PyErr_Occurred())
      goto idynamicsurface2_interpolatefeatureclassvertices_method_cleanup;
    
    // No setup for Resolution
    // No setup for Type
    if (!IFaceFromPyObject(py_pOutFeatureClass, &IID_IFeatureClass, (void**)&ippOutFeatureClass))
        PyErr_SetString(PyExc_TypeError, "Argument pOutFeatureClass (position 4) is not IFeatureClass");
    
    if (PyErr_Occurred())
      goto idynamicsurface2_interpolatefeatureclassvertices_method_cleanup;
    
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 5) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto idynamicsurface2_interpolatefeatureclassvertices_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIDynamicSurface2->InterpolateFeatureClassVertices(ippInFeatureClass, ippFilter, dResolution, eType, ippOutFeatureClass, ippTrackCancel);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDynamicSurface2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDynamicSurface2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDynamicSurface2.InterpolateFeatureClassVertices() returned %ld", (long)hr);
        goto idynamicsurface2_interpolatefeatureclassvertices_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pInFeatureClass
    // No teardown for pFilter
    // No teardown for Resolution
    // No teardown for Type
    // No teardown for pOutFeatureClass
    // No teardown for pTrackCancel

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idynamicsurface2_interpolatefeatureclassvertices_method_cleanup;

    idynamicsurface2_interpolatefeatureclassvertices_method_cleanup:
    self->m_HR = hr;
    if (ippInFeatureClass)
      ippInFeatureClass->Release();
    if (ippFilter)
      ippFilter->Release();
    // No cleanup for Resolution
    // No cleanup for Type
    if (ippOutFeatureClass)
      ippOutFeatureClass->Release();
    if (ippTrackCancel)
      ippTrackCancel->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDynamicSurface2.InterpolateFeatureClassVertices");
    return return_tuple;
}

static PyObject*
IDynamicSurface2Method_InterpolateFeatureCursorVertices(PyIDynamicSurface2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IFeatureCursor* ippCursor = NULL;
    PyObject* py_pCursor;
    double dResolution = 0;
    esriSurfaceInterpolationType eType;
    IFeatureClass* ippOutFeatureClass = NULL;
    PyObject* py_pOutFeatureClass;
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OdiOO", &py_pCursor, &dResolution, (int *)&eType, &py_pOutFeatureClass, &py_pTrackCancel))
      goto idynamicsurface2_interpolatefeaturecursorvertices_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pCursor, &IID_IFeatureCursor, (void**)&ippCursor))
        PyErr_SetString(PyExc_TypeError, "Argument pCursor (position 0) is not IFeatureCursor");
    
    if (PyErr_Occurred())
      goto idynamicsurface2_interpolatefeaturecursorvertices_method_cleanup;
    
    // No setup for Resolution
    // No setup for Type
    if (!IFaceFromPyObject(py_pOutFeatureClass, &IID_IFeatureClass, (void**)&ippOutFeatureClass))
        PyErr_SetString(PyExc_TypeError, "Argument pOutFeatureClass (position 3) is not IFeatureClass");
    
    if (PyErr_Occurred())
      goto idynamicsurface2_interpolatefeaturecursorvertices_method_cleanup;
    
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 4) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto idynamicsurface2_interpolatefeaturecursorvertices_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIDynamicSurface2->InterpolateFeatureCursorVertices(ippCursor, dResolution, eType, ippOutFeatureClass, ippTrackCancel);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDynamicSurface2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDynamicSurface2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDynamicSurface2.InterpolateFeatureCursorVertices() returned %ld", (long)hr);
        goto idynamicsurface2_interpolatefeaturecursorvertices_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pCursor
    // No teardown for Resolution
    // No teardown for Type
    // No teardown for pOutFeatureClass
    // No teardown for pTrackCancel

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idynamicsurface2_interpolatefeaturecursorvertices_method_cleanup;

    idynamicsurface2_interpolatefeaturecursorvertices_method_cleanup:
    self->m_HR = hr;
    if (ippCursor)
      ippCursor->Release();
    // No cleanup for Resolution
    // No cleanup for Type
    if (ippOutFeatureClass)
      ippOutFeatureClass->Release();
    if (ippTrackCancel)
      ippTrackCancel->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDynamicSurface2.InterpolateFeatureCursorVertices");
    return return_tuple;
}

static PyObject*
IDynamicSurface2Method_get_CanDoCurvature(PyIDynamicSurface2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pbCanDo = VARIANT_FALSE;
    PyObject* pyvar_pbCanDo = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pbCanDo

    // Call method on actual COM interface
    hr = self->m_pIDynamicSurface2->get_CanDoCurvature(&b_pbCanDo);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDynamicSurface2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDynamicSurface2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDynamicSurface2.get_CanDoCurvature() returned %ld", (long)hr);
        goto idynamicsurface2_get_candocurvature_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pbCanDo = ((b_pbCanDo == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto idynamicsurface2_get_candocurvature_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pbCanDo);
    goto idynamicsurface2_get_candocurvature_method_cleanup;

    idynamicsurface2_get_candocurvature_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pbCanDo
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDynamicSurface2.get_CanDoCurvature");
    return return_tuple;
}

static PyObject*
IDynamicSurface2Method_GetLineOfSight(PyIDynamicSurface2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IPoint* ippObserver = NULL;
    PyObject* py_pObserver;
    IPoint* ippTarget = NULL;
    PyObject* py_pTarget;
    double dResolution = 0;
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;
    IPoint* ipppObstruction = NULL;
    PyObject* py_ppObstruction = NULL;
    IPolyline* ipppVisibleLines = NULL;
    PyObject* py_ppVisibleLines = NULL;
    IPolyline* ipppInvisibleLines = NULL;
    PyObject* py_ppInvisibleLines = NULL;
    VARIANT_BOOL b_pbIsVisible = VARIANT_FALSE;
    PyObject* pyvar_pbIsVisible = Py_False;
    VARIANT_BOOL b_bApplyCurvature = VARIANT_FALSE;
    PyObject* pyvar_bApplyCurvature = NULL;
    VARIANT_BOOL b_bApplyRefraction = VARIANT_FALSE;
    PyObject* pyvar_bApplyRefraction = NULL;
    VARIANT vpRefractionFactor;
    ::VariantInit(&vpRefractionFactor);
    PyObject* pyvar_pRefractionFactor = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOdOOOO", &py_pObserver, &py_pTarget, &dResolution, &py_pTrackCancel, &pyvar_bApplyCurvature, &pyvar_bApplyRefraction, &pyvar_pRefractionFactor))
      goto idynamicsurface2_getlineofsight_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pObserver, &IID_IPoint, (void**)&ippObserver))
        PyErr_SetString(PyExc_TypeError, "Argument pObserver (position 0) is not IPoint");
    
    if (PyErr_Occurred())
      goto idynamicsurface2_getlineofsight_method_cleanup;
    
    if (!IFaceFromPyObject(py_pTarget, &IID_IPoint, (void**)&ippTarget))
        PyErr_SetString(PyExc_TypeError, "Argument pTarget (position 1) is not IPoint");
    
    if (PyErr_Occurred())
      goto idynamicsurface2_getlineofsight_method_cleanup;
    
    // No setup for Resolution
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 3) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto idynamicsurface2_getlineofsight_method_cleanup;
    
    // No setup for ppObstruction
    // No setup for ppVisibleLines
    // No setup for ppInvisibleLines
    // No setup for pbIsVisible
    b_bApplyCurvature = ((PyObject_IsTrue(pyvar_bApplyCurvature) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto idynamicsurface2_getlineofsight_method_cleanup;
    
    b_bApplyRefraction = ((PyObject_IsTrue(pyvar_bApplyRefraction) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto idynamicsurface2_getlineofsight_method_cleanup;
    
    PyObject_AsVariant(pyvar_pRefractionFactor, &vpRefractionFactor);
    
    if (PyErr_Occurred())
      goto idynamicsurface2_getlineofsight_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIDynamicSurface2->GetLineOfSight(ippObserver, ippTarget, dResolution, ippTrackCancel, &ipppObstruction, &ipppVisibleLines, &ipppInvisibleLines, &b_pbIsVisible, b_bApplyCurvature, b_bApplyRefraction, &vpRefractionFactor);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDynamicSurface2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDynamicSurface2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDynamicSurface2.GetLineOfSight() returned %ld", (long)hr);
        goto idynamicsurface2_getlineofsight_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pObserver
    // No teardown for pTarget
    // No teardown for Resolution
    // No teardown for pTrackCancel
    Py_XDECREF(py_ppObstruction);
    if (ipppObstruction)
    {
        IUnknown* pUnk = NULL;
        ipppObstruction->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppObstruction = IUnknownToPythonIIDObject(pUnk, &IID_IPoint);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppObstruction)
    {
        if (py_ppObstruction)
           Py_DECREF(py_ppObstruction);
        py_ppObstruction = Py_None;
        Py_INCREF(py_ppObstruction);
    }
    if (PyErr_Occurred())
      goto idynamicsurface2_getlineofsight_method_cleanup;
    
    Py_XDECREF(py_ppVisibleLines);
    if (ipppVisibleLines)
    {
        IUnknown* pUnk = NULL;
        ipppVisibleLines->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppVisibleLines = IUnknownToPythonIIDObject(pUnk, &IID_IPolyline);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppVisibleLines)
    {
        if (py_ppVisibleLines)
           Py_DECREF(py_ppVisibleLines);
        py_ppVisibleLines = Py_None;
        Py_INCREF(py_ppVisibleLines);
    }
    if (PyErr_Occurred())
      goto idynamicsurface2_getlineofsight_method_cleanup;
    
    Py_XDECREF(py_ppInvisibleLines);
    if (ipppInvisibleLines)
    {
        IUnknown* pUnk = NULL;
        ipppInvisibleLines->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppInvisibleLines = IUnknownToPythonIIDObject(pUnk, &IID_IPolyline);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppInvisibleLines)
    {
        if (py_ppInvisibleLines)
           Py_DECREF(py_ppInvisibleLines);
        py_ppInvisibleLines = Py_None;
        Py_INCREF(py_ppInvisibleLines);
    }
    if (PyErr_Occurred())
      goto idynamicsurface2_getlineofsight_method_cleanup;
    
    pyvar_pbIsVisible = ((b_pbIsVisible == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto idynamicsurface2_getlineofsight_method_cleanup;
    
    // No teardown for bApplyCurvature
    // No teardown for bApplyRefraction
    // No teardown for pRefractionFactor

    // Initialize output tuple
    return_tuple = Py_BuildValue("OOOO",
                                            py_ppObstruction, py_ppVisibleLines, py_ppInvisibleLines, pyvar_pbIsVisible);
    goto idynamicsurface2_getlineofsight_method_cleanup;

    idynamicsurface2_getlineofsight_method_cleanup:
    self->m_HR = hr;
    if (ippObserver)
      ippObserver->Release();
    if (ippTarget)
      ippTarget->Release();
    // No cleanup for Resolution
    if (ippTrackCancel)
      ippTrackCancel->Release();
    Py_XDECREF(py_ppObstruction);
    if (ipppObstruction)
      ipppObstruction->Release();
    Py_XDECREF(py_ppVisibleLines);
    if (ipppVisibleLines)
      ipppVisibleLines->Release();
    Py_XDECREF(py_ppInvisibleLines);
    if (ipppInvisibleLines)
      ipppInvisibleLines->Release();
    // No cleanup for pbIsVisible
    // No cleanup for bApplyCurvature
    // No cleanup for bApplyRefraction
    ::VariantClear(&vpRefractionFactor);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDynamicSurface2.GetLineOfSight");
    return return_tuple;
}

static PyObject*
IDynamicSurface2Method_GetLineOfSightFeatureCursor(PyIDynamicSurface2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IFeatureCursor* ippCursor = NULL;
    PyObject* py_pCursor;
    double dResolution = 0;
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;
    IFeatureClass* ippOutputLines = NULL;
    PyObject* py_pOutputLines;
    IFeatureClass* ippObstructionPoints = NULL;
    PyObject* py_pObstructionPoints;
    VARIANT_BOOL b_bApplyCurvature = VARIANT_FALSE;
    PyObject* pyvar_bApplyCurvature = NULL;
    VARIANT_BOOL b_bApplyRefraction = VARIANT_FALSE;
    PyObject* pyvar_bApplyRefraction = NULL;
    VARIANT vpRefractionFactor;
    ::VariantInit(&vpRefractionFactor);
    PyObject* pyvar_pRefractionFactor = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OdOOOOOO", &py_pCursor, &dResolution, &py_pTrackCancel, &py_pOutputLines, &py_pObstructionPoints, &pyvar_bApplyCurvature, &pyvar_bApplyRefraction, &pyvar_pRefractionFactor))
      goto idynamicsurface2_getlineofsightfeaturecursor_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pCursor, &IID_IFeatureCursor, (void**)&ippCursor))
        PyErr_SetString(PyExc_TypeError, "Argument pCursor (position 0) is not IFeatureCursor");
    
    if (PyErr_Occurred())
      goto idynamicsurface2_getlineofsightfeaturecursor_method_cleanup;
    
    // No setup for Resolution
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 2) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto idynamicsurface2_getlineofsightfeaturecursor_method_cleanup;
    
    if (!IFaceFromPyObject(py_pOutputLines, &IID_IFeatureClass, (void**)&ippOutputLines))
        PyErr_SetString(PyExc_TypeError, "Argument pOutputLines (position 3) is not IFeatureClass");
    
    if (PyErr_Occurred())
      goto idynamicsurface2_getlineofsightfeaturecursor_method_cleanup;
    
    if (!IFaceFromPyObject(py_pObstructionPoints, &IID_IFeatureClass, (void**)&ippObstructionPoints))
        PyErr_SetString(PyExc_TypeError, "Argument pObstructionPoints (position 4) is not IFeatureClass");
    
    if (PyErr_Occurred())
      goto idynamicsurface2_getlineofsightfeaturecursor_method_cleanup;
    
    b_bApplyCurvature = ((PyObject_IsTrue(pyvar_bApplyCurvature) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto idynamicsurface2_getlineofsightfeaturecursor_method_cleanup;
    
    b_bApplyRefraction = ((PyObject_IsTrue(pyvar_bApplyRefraction) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto idynamicsurface2_getlineofsightfeaturecursor_method_cleanup;
    
    PyObject_AsVariant(pyvar_pRefractionFactor, &vpRefractionFactor);
    
    if (PyErr_Occurred())
      goto idynamicsurface2_getlineofsightfeaturecursor_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIDynamicSurface2->GetLineOfSightFeatureCursor(ippCursor, dResolution, ippTrackCancel, ippOutputLines, ippObstructionPoints, b_bApplyCurvature, b_bApplyRefraction, &vpRefractionFactor);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDynamicSurface2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDynamicSurface2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDynamicSurface2.GetLineOfSightFeatureCursor() returned %ld", (long)hr);
        goto idynamicsurface2_getlineofsightfeaturecursor_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pCursor
    // No teardown for Resolution
    // No teardown for pTrackCancel
    // No teardown for pOutputLines
    // No teardown for pObstructionPoints
    // No teardown for bApplyCurvature
    // No teardown for bApplyRefraction
    // No teardown for pRefractionFactor

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idynamicsurface2_getlineofsightfeaturecursor_method_cleanup;

    idynamicsurface2_getlineofsightfeaturecursor_method_cleanup:
    self->m_HR = hr;
    if (ippCursor)
      ippCursor->Release();
    // No cleanup for Resolution
    if (ippTrackCancel)
      ippTrackCancel->Release();
    if (ippOutputLines)
      ippOutputLines->Release();
    if (ippObstructionPoints)
      ippObstructionPoints->Release();
    // No cleanup for bApplyCurvature
    // No cleanup for bApplyRefraction
    ::VariantClear(&vpRefractionFactor);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDynamicSurface2.GetLineOfSightFeatureCursor");
    return return_tuple;
}

static PyObject*
IDynamicSurface2Method_GetTileBasedDataArea(PyIDynamicSurface2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;
    IPolygon* ipppDataArea = NULL;
    PyObject* py_ppDataArea = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_pTrackCancel))
      goto idynamicsurface2_gettilebaseddataarea_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 0) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto idynamicsurface2_gettilebaseddataarea_method_cleanup;
    
    // No setup for ppDataArea

    // Call method on actual COM interface
    hr = self->m_pIDynamicSurface2->GetTileBasedDataArea(ippTrackCancel, &ipppDataArea);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDynamicSurface2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDynamicSurface2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDynamicSurface2.GetTileBasedDataArea() returned %ld", (long)hr);
        goto idynamicsurface2_gettilebaseddataarea_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pTrackCancel
    Py_XDECREF(py_ppDataArea);
    if (ipppDataArea)
    {
        IUnknown* pUnk = NULL;
        ipppDataArea->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppDataArea = IUnknownToPythonIIDObject(pUnk, &IID_IPolygon);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppDataArea)
    {
        if (py_ppDataArea)
           Py_DECREF(py_ppDataArea);
        py_ppDataArea = Py_None;
        Py_INCREF(py_ppDataArea);
    }
    if (PyErr_Occurred())
      goto idynamicsurface2_gettilebaseddataarea_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppDataArea);
    goto idynamicsurface2_gettilebaseddataarea_method_cleanup;

    idynamicsurface2_gettilebaseddataarea_method_cleanup:
    self->m_HR = hr;
    if (ippTrackCancel)
      ippTrackCancel->Release();
    Py_XDECREF(py_ppDataArea);
    if (ipppDataArea)
      ipppDataArea->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDynamicSurface2.GetTileBasedDataArea");
    return return_tuple;
}

static PyObject*
IDynamicSurface2Method_put_RasterBlockSize(PyIDynamicSurface2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpSize = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lpSize))
      goto idynamicsurface2_put_rasterblocksize_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pSize

    // Call method on actual COM interface
    hr = self->m_pIDynamicSurface2->put_RasterBlockSize(lpSize);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDynamicSurface2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDynamicSurface2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDynamicSurface2.put_RasterBlockSize() returned %ld", (long)hr);
        goto idynamicsurface2_put_rasterblocksize_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pSize

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idynamicsurface2_put_rasterblocksize_method_cleanup;

    idynamicsurface2_put_rasterblocksize_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pSize
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDynamicSurface2.put_RasterBlockSize");
    return return_tuple;
}

static PyObject*
IDynamicSurface2Method_get_RasterBlockSize(PyIDynamicSurface2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpSize = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pSize

    // Call method on actual COM interface
    hr = self->m_pIDynamicSurface2->get_RasterBlockSize(&lpSize);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDynamicSurface2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDynamicSurface2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDynamicSurface2.get_RasterBlockSize() returned %ld", (long)hr);
        goto idynamicsurface2_get_rasterblocksize_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pSize

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpSize);
    goto idynamicsurface2_get_rasterblocksize_method_cleanup;

    idynamicsurface2_get_rasterblocksize_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pSize
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDynamicSurface2.get_RasterBlockSize");
    return return_tuple;
}

static PyObject*
IDynamicSurface2Method_get_Terrain(PyIDynamicSurface2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ITerrain* ipppTerrain = NULL;
    PyObject* py_ppTerrain = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppTerrain

    // Call method on actual COM interface
    hr = self->m_pIDynamicSurface2->get_Terrain(&ipppTerrain);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDynamicSurface2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDynamicSurface2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDynamicSurface2.get_Terrain() returned %ld", (long)hr);
        goto idynamicsurface2_get_terrain_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppTerrain);
    if (ipppTerrain)
    {
        IUnknown* pUnk = NULL;
        ipppTerrain->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppTerrain = IUnknownToPythonIIDObject(pUnk, &IID_ITerrain);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppTerrain)
    {
        if (py_ppTerrain)
           Py_DECREF(py_ppTerrain);
        py_ppTerrain = Py_None;
        Py_INCREF(py_ppTerrain);
    }
    if (PyErr_Occurred())
      goto idynamicsurface2_get_terrain_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppTerrain);
    goto idynamicsurface2_get_terrain_method_cleanup;

    idynamicsurface2_get_terrain_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppTerrain);
    if (ipppTerrain)
      ipppTerrain->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDynamicSurface2.get_Terrain");
    return return_tuple;
}

static PyObject*
IDynamicSurface2Method_GetTin(PyIDynamicSurface2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IEnvelope* ippAreaOfInterest = NULL;
    PyObject* py_pAreaOfInterest;
    double dResolution = 0;
    VARIANT_BOOL b_bClipWithAOI = VARIANT_FALSE;
    PyObject* pyvar_bClipWithAOI = NULL;
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;
    ITin* ipppTin = NULL;
    PyObject* py_ppTin = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OdOO", &py_pAreaOfInterest, &dResolution, &pyvar_bClipWithAOI, &py_pTrackCancel))
      goto idynamicsurface2_gettin_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pAreaOfInterest, &IID_IEnvelope, (void**)&ippAreaOfInterest))
        PyErr_SetString(PyExc_TypeError, "Argument pAreaOfInterest (position 0) is not IEnvelope");
    
    if (PyErr_Occurred())
      goto idynamicsurface2_gettin_method_cleanup;
    
    // No setup for Resolution
    b_bClipWithAOI = ((PyObject_IsTrue(pyvar_bClipWithAOI) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto idynamicsurface2_gettin_method_cleanup;
    
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 3) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto idynamicsurface2_gettin_method_cleanup;
    
    // No setup for ppTin

    // Call method on actual COM interface
    hr = self->m_pIDynamicSurface2->GetTin(ippAreaOfInterest, dResolution, b_bClipWithAOI, ippTrackCancel, &ipppTin);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDynamicSurface2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDynamicSurface2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDynamicSurface2.GetTin() returned %ld", (long)hr);
        goto idynamicsurface2_gettin_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pAreaOfInterest
    // No teardown for Resolution
    // No teardown for bClipWithAOI
    // No teardown for pTrackCancel
    Py_XDECREF(py_ppTin);
    if (ipppTin)
    {
        IUnknown* pUnk = NULL;
        ipppTin->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppTin = IUnknownToPythonIIDObject(pUnk, &IID_ITin);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppTin)
    {
        if (py_ppTin)
           Py_DECREF(py_ppTin);
        py_ppTin = Py_None;
        Py_INCREF(py_ppTin);
    }
    if (PyErr_Occurred())
      goto idynamicsurface2_gettin_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppTin);
    goto idynamicsurface2_gettin_method_cleanup;

    idynamicsurface2_gettin_method_cleanup:
    self->m_HR = hr;
    if (ippAreaOfInterest)
      ippAreaOfInterest->Release();
    // No cleanup for Resolution
    // No cleanup for bClipWithAOI
    if (ippTrackCancel)
      ippTrackCancel->Release();
    Py_XDECREF(py_ppTin);
    if (ipppTin)
      ipppTin->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDynamicSurface2.GetTin");
    return return_tuple;
}

static PyObject*
IDynamicSurface2Method_QueryRaster(PyIDynamicSurface2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IRasterDataset* ippDataset = NULL;
    PyObject* py_pDataset;
    IEnvelope* ippAreaOfInterest = NULL;
    PyObject* py_pAreaOfInterest;
    double dResolution = 0;
    esriSurfaceInterpolationType eMethod;
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOdiO", &py_pDataset, &py_pAreaOfInterest, &dResolution, (int *)&eMethod, &py_pTrackCancel))
      goto idynamicsurface2_queryraster_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pDataset, &IID_IRasterDataset, (void**)&ippDataset))
        PyErr_SetString(PyExc_TypeError, "Argument pDataset (position 0) is not IRasterDataset");
    
    if (PyErr_Occurred())
      goto idynamicsurface2_queryraster_method_cleanup;
    
    if (!IFaceFromPyObject(py_pAreaOfInterest, &IID_IEnvelope, (void**)&ippAreaOfInterest))
        PyErr_SetString(PyExc_TypeError, "Argument pAreaOfInterest (position 1) is not IEnvelope");
    
    if (PyErr_Occurred())
      goto idynamicsurface2_queryraster_method_cleanup;
    
    // No setup for Resolution
    // No setup for Method
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 4) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto idynamicsurface2_queryraster_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIDynamicSurface2->QueryRaster(ippDataset, ippAreaOfInterest, dResolution, eMethod, ippTrackCancel);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDynamicSurface2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDynamicSurface2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDynamicSurface2.QueryRaster() returned %ld", (long)hr);
        goto idynamicsurface2_queryraster_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pDataset
    // No teardown for pAreaOfInterest
    // No teardown for Resolution
    // No teardown for Method
    // No teardown for pTrackCancel

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idynamicsurface2_queryraster_method_cleanup;

    idynamicsurface2_queryraster_method_cleanup:
    self->m_HR = hr;
    if (ippDataset)
      ippDataset->Release();
    if (ippAreaOfInterest)
      ippAreaOfInterest->Release();
    // No cleanup for Resolution
    // No cleanup for Method
    if (ippTrackCancel)
      ippTrackCancel->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDynamicSurface2.QueryRaster");
    return return_tuple;
}

static PyObject*
IDynamicSurface2Method_QueryAsFeatureClass(PyIDynamicSurface2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IFeatureClass* ippFeatureClass = NULL;
    PyObject* py_pFeatureClass;
    IEnvelope* ippAreaOfInterest = NULL;
    PyObject* py_pAreaOfInterest;
    double dResolution = 0;
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOdO", &py_pFeatureClass, &py_pAreaOfInterest, &dResolution, &py_pTrackCancel))
      goto idynamicsurface2_queryasfeatureclass_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pFeatureClass, &IID_IFeatureClass, (void**)&ippFeatureClass))
        PyErr_SetString(PyExc_TypeError, "Argument pFeatureClass (position 0) is not IFeatureClass");
    
    if (PyErr_Occurred())
      goto idynamicsurface2_queryasfeatureclass_method_cleanup;
    
    if (!IFaceFromPyObject(py_pAreaOfInterest, &IID_IEnvelope, (void**)&ippAreaOfInterest))
        PyErr_SetString(PyExc_TypeError, "Argument pAreaOfInterest (position 1) is not IEnvelope");
    
    if (PyErr_Occurred())
      goto idynamicsurface2_queryasfeatureclass_method_cleanup;
    
    // No setup for Resolution
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 3) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto idynamicsurface2_queryasfeatureclass_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIDynamicSurface2->QueryAsFeatureClass(ippFeatureClass, ippAreaOfInterest, dResolution, ippTrackCancel);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDynamicSurface2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDynamicSurface2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDynamicSurface2.QueryAsFeatureClass() returned %ld", (long)hr);
        goto idynamicsurface2_queryasfeatureclass_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pFeatureClass
    // No teardown for pAreaOfInterest
    // No teardown for Resolution
    // No teardown for pTrackCancel

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idynamicsurface2_queryasfeatureclass_method_cleanup;

    idynamicsurface2_queryasfeatureclass_method_cleanup:
    self->m_HR = hr;
    if (ippFeatureClass)
      ippFeatureClass->Release();
    if (ippAreaOfInterest)
      ippAreaOfInterest->Release();
    // No cleanup for Resolution
    if (ippTrackCancel)
      ippTrackCancel->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDynamicSurface2.QueryAsFeatureClass");
    return return_tuple;
}


PyMethodDef PyIDynamicSurface2Methods[] = {
    {"supports", (PyCFunction)PyIDynamicSurface2_SupportsInterface, METH_O, ""},
    {"put_MinimizeResourceUsage", (PyCFunction)IDynamicSurface2Method_put_MinimizeResourceUsage, METH_VARARGS, ""},
    {"get_MinimizeResourceUsage", (PyCFunction)IDynamicSurface2Method_get_MinimizeResourceUsage, METH_VARARGS, ""},
    {"put_RefineBoundaryMatching", (PyCFunction)IDynamicSurface2Method_put_RefineBoundaryMatching, METH_VARARGS, ""},
    {"get_RefineBoundaryMatching", (PyCFunction)IDynamicSurface2Method_get_RefineBoundaryMatching, METH_VARARGS, ""},
    {"InterpolateShape", (PyCFunction)IDynamicSurface2Method_InterpolateShape, METH_VARARGS, ""},
    {"InterpolateShapeVertices", (PyCFunction)IDynamicSurface2Method_InterpolateShapeVertices, METH_VARARGS, ""},
    {"InterpolateFeatureClass", (PyCFunction)IDynamicSurface2Method_InterpolateFeatureClass, METH_VARARGS, ""},
    {"InterpolateFeatureCursor", (PyCFunction)IDynamicSurface2Method_InterpolateFeatureCursor, METH_VARARGS, ""},
    {"InterpolateFeatureClassVertices", (PyCFunction)IDynamicSurface2Method_InterpolateFeatureClassVertices, METH_VARARGS, ""},
    {"InterpolateFeatureCursorVertices", (PyCFunction)IDynamicSurface2Method_InterpolateFeatureCursorVertices, METH_VARARGS, ""},
    {"get_CanDoCurvature", (PyCFunction)IDynamicSurface2Method_get_CanDoCurvature, METH_VARARGS, ""},
    {"GetLineOfSight", (PyCFunction)IDynamicSurface2Method_GetLineOfSight, METH_VARARGS, ""},
    {"GetLineOfSightFeatureCursor", (PyCFunction)IDynamicSurface2Method_GetLineOfSightFeatureCursor, METH_VARARGS, ""},
    {"GetTileBasedDataArea", (PyCFunction)IDynamicSurface2Method_GetTileBasedDataArea, METH_VARARGS, ""},
    {"put_RasterBlockSize", (PyCFunction)IDynamicSurface2Method_put_RasterBlockSize, METH_VARARGS, ""},
    {"get_RasterBlockSize", (PyCFunction)IDynamicSurface2Method_get_RasterBlockSize, METH_VARARGS, ""},
    {"get_Terrain", (PyCFunction)IDynamicSurface2Method_get_Terrain, METH_VARARGS, ""},
    {"GetTin", (PyCFunction)IDynamicSurface2Method_GetTin, METH_VARARGS, ""},
    {"QueryRaster", (PyCFunction)IDynamicSurface2Method_QueryRaster, METH_VARARGS, ""},
    {"QueryAsFeatureClass", (PyCFunction)IDynamicSurface2Method_QueryAsFeatureClass, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIDynamicSurface2GetSet[] = {
  {"_pUnk", (getter)PyIDynamicSurface2_GetpUnk, NULL, "Get opaque pointer to an Unknown from IDynamicSurface2", NULL},
  {"_pointer", (getter)PyIDynamicSurface2_GetPointer, NULL, "Get memory address for IDynamicSurface2", NULL},
  {"_IID", (getter)PyIDynamicSurface2_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIDynamicSurface2_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIDynamicSurface2_GetIgnoreFailures, (setter)PyIDynamicSurface2_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIDynamicSurface2Object_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.IDynamicSurface2Object",                          
                                              /* tp_name */
  sizeof(PyIDynamicSurface2Object),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIDynamicSurface2Object_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIDynamicSurface2Methods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIDynamicSurface2GetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIDynamicSurface2Object_new,                      
                                              /* tp_new */
};

// Interface IDynamicSurface3

typedef struct PyIDynamicSurface3Object {
    PyObject_HEAD
    IDynamicSurface3* m_pIDynamicSurface3;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIDynamicSurface3Object;

static PyObject*
PyIDynamicSurface3Object_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIDynamicSurface3Object* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IDynamicSurface3* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IDynamicSurface3, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IDynamicSurface3 with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIDynamicSurface3Object *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IDynamicSurface3");
            return NULL;
        }
        self->m_pIDynamicSurface3 = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IDynamicSurface3");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IDynamicSurface3");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IDynamicSurface3* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IDynamicSurface3, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IDynamicSurface3");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIDynamicSurface3Object *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IDynamicSurface3");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIDynamicSurface3 = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIDynamicSurface3Object_dealloc(PyIDynamicSurface3Object* self)
{
    if (self->m_pIDynamicSurface3)
        self->m_pIDynamicSurface3->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIDynamicSurface3_GetpUnk(PyIDynamicSurface3Object* self)
{
    if (!self->m_pIDynamicSurface3)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIDynamicSurface3->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IDynamicSurface3 to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIDynamicSurface3_GetPointer(PyIDynamicSurface3Object* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIDynamicSurface3);
}

static PyObject*
PyIDynamicSurface3_GetIID(PyIDynamicSurface3Object* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "9dc0a59e-494e-41b6-be82-f283e3431577");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIDynamicSurface3_GetHR(PyIDynamicSurface3Object* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIDynamicSurface3_GetIgnoreFailures(PyIDynamicSurface3Object* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIDynamicSurface3_SetIgnoreFailures(PyIDynamicSurface3Object* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIDynamicSurface3_SupportsInterface(PyIDynamicSurface3Object* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIDynamicSurface3->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IDynamicSurface3Method_CreateBlockCursor(PyIDynamicSurface3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IGeometry* ippAOI = NULL;
    PyObject* py_pAOI;
    double dResolution = 0;
    VARIANT_BOOL b_bSingleTileOnly = VARIANT_FALSE;
    PyObject* pyvar_bSingleTileOnly = NULL;
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;
    ITerrainBlockCursor* ippCursor = NULL;
    PyObject* py_pCursor = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OdOO", &py_pAOI, &dResolution, &pyvar_bSingleTileOnly, &py_pTrackCancel))
      goto idynamicsurface3_createblockcursor_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pAOI, &IID_IGeometry, (void**)&ippAOI))
        PyErr_SetString(PyExc_TypeError, "Argument pAOI (position 0) is not IGeometry");
    
    if (PyErr_Occurred())
      goto idynamicsurface3_createblockcursor_method_cleanup;
    
    // No setup for Resolution
    b_bSingleTileOnly = ((PyObject_IsTrue(pyvar_bSingleTileOnly) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto idynamicsurface3_createblockcursor_method_cleanup;
    
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 3) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto idynamicsurface3_createblockcursor_method_cleanup;
    
    // No setup for pCursor

    // Call method on actual COM interface
    hr = self->m_pIDynamicSurface3->CreateBlockCursor(ippAOI, dResolution, b_bSingleTileOnly, ippTrackCancel, &ippCursor);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDynamicSurface3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDynamicSurface3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDynamicSurface3.CreateBlockCursor() returned %ld", (long)hr);
        goto idynamicsurface3_createblockcursor_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pAOI
    // No teardown for Resolution
    // No teardown for bSingleTileOnly
    // No teardown for pTrackCancel
    Py_XDECREF(py_pCursor);
    if (ippCursor)
    {
        IUnknown* pUnk = NULL;
        ippCursor->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_pCursor = IUnknownToPythonIIDObject(pUnk, &IID_ITerrainBlockCursor);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_pCursor)
    {
        if (py_pCursor)
           Py_DECREF(py_pCursor);
        py_pCursor = Py_None;
        Py_INCREF(py_pCursor);
    }
    if (PyErr_Occurred())
      goto idynamicsurface3_createblockcursor_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_pCursor);
    goto idynamicsurface3_createblockcursor_method_cleanup;

    idynamicsurface3_createblockcursor_method_cleanup:
    self->m_HR = hr;
    if (ippAOI)
      ippAOI->Release();
    // No cleanup for Resolution
    // No cleanup for bSingleTileOnly
    if (ippTrackCancel)
      ippTrackCancel->Release();
    Py_XDECREF(py_pCursor);
    if (ippCursor)
      ippCursor->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDynamicSurface3.CreateBlockCursor");
    return return_tuple;
}

static PyObject*
IDynamicSurface3Method_ConvertToExtent(PyIDynamicSurface3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lrowBegin = 0;
    long lrowEnd = 0;
    long lcolBegin = 0;
    long lcolEnd = 0;
    IEnvelope* ipppExtent = NULL;
    PyObject* py_ppExtent = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "llll", &lrowBegin, &lrowEnd, &lcolBegin, &lcolEnd))
      goto idynamicsurface3_converttoextent_method_cleanup;

    // Set up initial variable values as needed
    // No setup for rowBegin
    // No setup for rowEnd
    // No setup for colBegin
    // No setup for colEnd
    // No setup for ppExtent

    // Call method on actual COM interface
    hr = self->m_pIDynamicSurface3->ConvertToExtent(lrowBegin, lrowEnd, lcolBegin, lcolEnd, &ipppExtent);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDynamicSurface3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDynamicSurface3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDynamicSurface3.ConvertToExtent() returned %ld", (long)hr);
        goto idynamicsurface3_converttoextent_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for rowBegin
    // No teardown for rowEnd
    // No teardown for colBegin
    // No teardown for colEnd
    Py_XDECREF(py_ppExtent);
    if (ipppExtent)
    {
        IUnknown* pUnk = NULL;
        ipppExtent->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppExtent = IUnknownToPythonIIDObject(pUnk, &IID_IEnvelope);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppExtent)
    {
        if (py_ppExtent)
           Py_DECREF(py_ppExtent);
        py_ppExtent = Py_None;
        Py_INCREF(py_ppExtent);
    }
    if (PyErr_Occurred())
      goto idynamicsurface3_converttoextent_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppExtent);
    goto idynamicsurface3_converttoextent_method_cleanup;

    idynamicsurface3_converttoextent_method_cleanup:
    self->m_HR = hr;
    // No cleanup for rowBegin
    // No cleanup for rowEnd
    // No cleanup for colBegin
    // No cleanup for colEnd
    Py_XDECREF(py_ppExtent);
    if (ipppExtent)
      ipppExtent->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDynamicSurface3.ConvertToExtent");
    return return_tuple;
}

static PyObject*
IDynamicSurface3Method_ContourList(PyIDynamicSurface3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IEnvelope* ippAOI = NULL;
    PyObject* py_pAOI;
    double dResolution = 0;
    IDoubleArray* ippBreaks = NULL;
    PyObject* py_pBreaks;
    IFeatureClass* ippOutFeatureClass = NULL;
    PyObject* py_pOutFeatureClass;
    BSTR bsFieldName = 0;
    PyObject* pyvar_FieldName;
    PyObject* unicodeFieldName = NULL;
    long ldigitsAfterDecimalPoint = 0;
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OdOOOlO", &py_pAOI, &dResolution, &py_pBreaks, &py_pOutFeatureClass, &pyvar_FieldName, &ldigitsAfterDecimalPoint, &py_pTrackCancel))
      goto idynamicsurface3_contourlist_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pAOI, &IID_IEnvelope, (void**)&ippAOI))
        PyErr_SetString(PyExc_TypeError, "Argument pAOI (position 0) is not IEnvelope");
    
    if (PyErr_Occurred())
      goto idynamicsurface3_contourlist_method_cleanup;
    
    // No setup for Resolution
    if (!IFaceFromPyObject(py_pBreaks, &IID_IDoubleArray, (void**)&ippBreaks))
        PyErr_SetString(PyExc_TypeError, "Argument pBreaks (position 2) is not IDoubleArray");
    
    if (PyErr_Occurred())
      goto idynamicsurface3_contourlist_method_cleanup;
    
    if (!IFaceFromPyObject(py_pOutFeatureClass, &IID_IFeatureClass, (void**)&ippOutFeatureClass))
        PyErr_SetString(PyExc_TypeError, "Argument pOutFeatureClass (position 3) is not IFeatureClass");
    
    if (PyErr_Occurred())
      goto idynamicsurface3_contourlist_method_cleanup;
    
    if (PyString_Check(pyvar_FieldName))
        unicodeFieldName = PyUnicode_FromObject(pyvar_FieldName);
    else if (PyUnicode_Check(pyvar_FieldName))
    {
        unicodeFieldName = pyvar_FieldName;
        Py_INCREF(unicodeFieldName);
    }
    else if (pyvar_FieldName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter FieldName at index 4");
    if (unicodeFieldName)
        bsFieldName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeFieldName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeFieldName));
    
    if (PyErr_Occurred())
      goto idynamicsurface3_contourlist_method_cleanup;
    
    // No setup for digitsAfterDecimalPoint
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 6) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto idynamicsurface3_contourlist_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIDynamicSurface3->ContourList(ippAOI, dResolution, ippBreaks, ippOutFeatureClass, bsFieldName, ldigitsAfterDecimalPoint, ippTrackCancel);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDynamicSurface3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDynamicSurface3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDynamicSurface3.ContourList() returned %ld", (long)hr);
        goto idynamicsurface3_contourlist_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pAOI
    // No teardown for Resolution
    // No teardown for pBreaks
    // No teardown for pOutFeatureClass
    // No teardown for FieldName
    // No teardown for digitsAfterDecimalPoint
    // No teardown for pTrackCancel

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idynamicsurface3_contourlist_method_cleanup;

    idynamicsurface3_contourlist_method_cleanup:
    self->m_HR = hr;
    if (ippAOI)
      ippAOI->Release();
    // No cleanup for Resolution
    if (ippBreaks)
      ippBreaks->Release();
    if (ippOutFeatureClass)
      ippOutFeatureClass->Release();
    if (bsFieldName)
        ::SysFreeString(bsFieldName);
    
    // No cleanup for digitsAfterDecimalPoint
    if (ippTrackCancel)
      ippTrackCancel->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDynamicSurface3.ContourList");
    return return_tuple;
}

static PyObject*
IDynamicSurface3Method_Contour(PyIDynamicSurface3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IEnvelope* ippAOI = NULL;
    PyObject* py_pAOI;
    double dResolution = 0;
    double dreferenceContourHeight = 0;
    double dinterval = 0;
    BSTR bselevationFieldName = 0;
    PyObject* pyvar_elevationFieldName;
    PyObject* unicodeelevationFieldName = NULL;
    long lindexContourFactor = 0;
    BSTR bsindexContourFieldName = 0;
    PyObject* pyvar_indexContourFieldName;
    PyObject* unicodeindexContourFieldName = NULL;
    long ldigitsAfterDecimalPoint = 0;
    IFeatureClass* ippOutFeatureClass = NULL;
    PyObject* py_pOutFeatureClass;
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OdddOlOlOO", &py_pAOI, &dResolution, &dreferenceContourHeight, &dinterval, &pyvar_elevationFieldName, &lindexContourFactor, &pyvar_indexContourFieldName, &ldigitsAfterDecimalPoint, &py_pOutFeatureClass, &py_pTrackCancel))
      goto idynamicsurface3_contour_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pAOI, &IID_IEnvelope, (void**)&ippAOI))
        PyErr_SetString(PyExc_TypeError, "Argument pAOI (position 0) is not IEnvelope");
    
    if (PyErr_Occurred())
      goto idynamicsurface3_contour_method_cleanup;
    
    // No setup for Resolution
    // No setup for referenceContourHeight
    // No setup for interval
    if (PyString_Check(pyvar_elevationFieldName))
        unicodeelevationFieldName = PyUnicode_FromObject(pyvar_elevationFieldName);
    else if (PyUnicode_Check(pyvar_elevationFieldName))
    {
        unicodeelevationFieldName = pyvar_elevationFieldName;
        Py_INCREF(unicodeelevationFieldName);
    }
    else if (pyvar_elevationFieldName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter elevationFieldName at index 4");
    if (unicodeelevationFieldName)
        bselevationFieldName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeelevationFieldName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeelevationFieldName));
    
    if (PyErr_Occurred())
      goto idynamicsurface3_contour_method_cleanup;
    
    // No setup for indexContourFactor
    if (PyString_Check(pyvar_indexContourFieldName))
        unicodeindexContourFieldName = PyUnicode_FromObject(pyvar_indexContourFieldName);
    else if (PyUnicode_Check(pyvar_indexContourFieldName))
    {
        unicodeindexContourFieldName = pyvar_indexContourFieldName;
        Py_INCREF(unicodeindexContourFieldName);
    }
    else if (pyvar_indexContourFieldName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter indexContourFieldName at index 6");
    if (unicodeindexContourFieldName)
        bsindexContourFieldName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeindexContourFieldName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeindexContourFieldName));
    
    if (PyErr_Occurred())
      goto idynamicsurface3_contour_method_cleanup;
    
    // No setup for digitsAfterDecimalPoint
    if (!IFaceFromPyObject(py_pOutFeatureClass, &IID_IFeatureClass, (void**)&ippOutFeatureClass))
        PyErr_SetString(PyExc_TypeError, "Argument pOutFeatureClass (position 8) is not IFeatureClass");
    
    if (PyErr_Occurred())
      goto idynamicsurface3_contour_method_cleanup;
    
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 9) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto idynamicsurface3_contour_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIDynamicSurface3->Contour(ippAOI, dResolution, dreferenceContourHeight, dinterval, bselevationFieldName, lindexContourFactor, bsindexContourFieldName, ldigitsAfterDecimalPoint, ippOutFeatureClass, ippTrackCancel);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDynamicSurface3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDynamicSurface3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDynamicSurface3.Contour() returned %ld", (long)hr);
        goto idynamicsurface3_contour_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pAOI
    // No teardown for Resolution
    // No teardown for referenceContourHeight
    // No teardown for interval
    // No teardown for elevationFieldName
    // No teardown for indexContourFactor
    // No teardown for indexContourFieldName
    // No teardown for digitsAfterDecimalPoint
    // No teardown for pOutFeatureClass
    // No teardown for pTrackCancel

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idynamicsurface3_contour_method_cleanup;

    idynamicsurface3_contour_method_cleanup:
    self->m_HR = hr;
    if (ippAOI)
      ippAOI->Release();
    // No cleanup for Resolution
    // No cleanup for referenceContourHeight
    // No cleanup for interval
    if (bselevationFieldName)
        ::SysFreeString(bselevationFieldName);
    
    // No cleanup for indexContourFactor
    if (bsindexContourFieldName)
        ::SysFreeString(bsindexContourFieldName);
    
    // No cleanup for digitsAfterDecimalPoint
    if (ippOutFeatureClass)
      ippOutFeatureClass->Release();
    if (ippTrackCancel)
      ippTrackCancel->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDynamicSurface3.Contour");
    return return_tuple;
}

static PyObject*
IDynamicSurface3Method_GetVolumeAndArea(PyIDynamicSurface3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IGeometry* ippAOI = NULL;
    PyObject* py_pAOI;
    double dResolution = 0;
    double dreference = 0;
    esriPlaneReferenceType eType;
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;
    VARIANT_BOOL b_pbIsOutsideDataArea = VARIANT_FALSE;
    PyObject* pyvar_pbIsOutsideDataArea = Py_False;
    VARIANT vpVolume;
    ::VariantInit(&vpVolume);
    PyObject* pyvar_pVolume = NULL;
    VARIANT vpSurfaceArea;
    ::VariantInit(&vpSurfaceArea);
    PyObject* pyvar_pSurfaceArea = NULL;
    VARIANT vpProjectedArea;
    ::VariantInit(&vpProjectedArea);
    PyObject* pyvar_pProjectedArea = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OddiOOOO", &py_pAOI, &dResolution, &dreference, (int *)&eType, &py_pTrackCancel, &pyvar_pVolume, &pyvar_pSurfaceArea, &pyvar_pProjectedArea))
      goto idynamicsurface3_getvolumeandarea_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pAOI, &IID_IGeometry, (void**)&ippAOI))
        PyErr_SetString(PyExc_TypeError, "Argument pAOI (position 0) is not IGeometry");
    
    if (PyErr_Occurred())
      goto idynamicsurface3_getvolumeandarea_method_cleanup;
    
    // No setup for Resolution
    // No setup for reference
    // No setup for Type
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 4) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto idynamicsurface3_getvolumeandarea_method_cleanup;
    
    // No setup for pbIsOutsideDataArea
    PyObject_AsVariant(pyvar_pVolume, &vpVolume);
    
    if (PyErr_Occurred())
      goto idynamicsurface3_getvolumeandarea_method_cleanup;
    
    PyObject_AsVariant(pyvar_pSurfaceArea, &vpSurfaceArea);
    
    if (PyErr_Occurred())
      goto idynamicsurface3_getvolumeandarea_method_cleanup;
    
    PyObject_AsVariant(pyvar_pProjectedArea, &vpProjectedArea);
    
    if (PyErr_Occurred())
      goto idynamicsurface3_getvolumeandarea_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIDynamicSurface3->GetVolumeAndArea(ippAOI, dResolution, dreference, eType, ippTrackCancel, &b_pbIsOutsideDataArea, &vpVolume, &vpSurfaceArea, &vpProjectedArea);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDynamicSurface3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDynamicSurface3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDynamicSurface3.GetVolumeAndArea() returned %ld", (long)hr);
        goto idynamicsurface3_getvolumeandarea_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pAOI
    // No teardown for Resolution
    // No teardown for reference
    // No teardown for Type
    // No teardown for pTrackCancel
    pyvar_pbIsOutsideDataArea = ((b_pbIsOutsideDataArea == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto idynamicsurface3_getvolumeandarea_method_cleanup;
    
    // No teardown for pVolume
    // No teardown for pSurfaceArea
    // No teardown for pProjectedArea

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pbIsOutsideDataArea);
    goto idynamicsurface3_getvolumeandarea_method_cleanup;

    idynamicsurface3_getvolumeandarea_method_cleanup:
    self->m_HR = hr;
    if (ippAOI)
      ippAOI->Release();
    // No cleanup for Resolution
    // No cleanup for reference
    // No cleanup for Type
    if (ippTrackCancel)
      ippTrackCancel->Release();
    // No cleanup for pbIsOutsideDataArea
    ::VariantClear(&vpVolume);
    ::VariantClear(&vpSurfaceArea);
    ::VariantClear(&vpProjectedArea);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDynamicSurface3.GetVolumeAndArea");
    return return_tuple;
}

static PyObject*
IDynamicSurface3Method_Intersect(PyIDynamicSurface3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IGeometry* ippAOI = NULL;
    PyObject* py_pAOI;
    double dResolution = 0;
    IUnknown* ippReferenceSurface = NULL;
    PyObject* py_pReferenceSurface;
    double dreferenceRsolution = 0;
    VARIANT_BOOL b_bReverse = VARIANT_FALSE;
    PyObject* pyvar_bReverse = NULL;
    IFeatureClass* ippOutFeatureClass = NULL;
    PyObject* py_pOutFeatureClass;
    BSTR bsvolumeFieldName = 0;
    PyObject* pyvar_volumeFieldName;
    PyObject* unicodevolumeFieldName = NULL;
    BSTR bssurfaceAreaFieldName = 0;
    PyObject* pyvar_surfaceAreaFieldName;
    PyObject* unicodesurfaceAreaFieldName = NULL;
    BSTR bscodeFieldName = 0;
    PyObject* pyvar_codeFieldName;
    PyObject* unicodecodeFieldName = NULL;
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OdOdOOOOOO", &py_pAOI, &dResolution, &py_pReferenceSurface, &dreferenceRsolution, &pyvar_bReverse, &py_pOutFeatureClass, &pyvar_volumeFieldName, &pyvar_surfaceAreaFieldName, &pyvar_codeFieldName, &py_pTrackCancel))
      goto idynamicsurface3_intersect_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pAOI, &IID_IGeometry, (void**)&ippAOI))
        PyErr_SetString(PyExc_TypeError, "Argument pAOI (position 0) is not IGeometry");
    
    if (PyErr_Occurred())
      goto idynamicsurface3_intersect_method_cleanup;
    
    // No setup for Resolution
    if (!IFaceFromPyObject(py_pReferenceSurface, &IID_IUnknown, (void**)&ippReferenceSurface))
        PyErr_SetString(PyExc_TypeError, "Argument pReferenceSurface (position 2) is not IUnknown");
    
    if (PyErr_Occurred())
      goto idynamicsurface3_intersect_method_cleanup;
    
    // No setup for referenceRsolution
    b_bReverse = ((PyObject_IsTrue(pyvar_bReverse) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto idynamicsurface3_intersect_method_cleanup;
    
    if (!IFaceFromPyObject(py_pOutFeatureClass, &IID_IFeatureClass, (void**)&ippOutFeatureClass))
        PyErr_SetString(PyExc_TypeError, "Argument pOutFeatureClass (position 5) is not IFeatureClass");
    
    if (PyErr_Occurred())
      goto idynamicsurface3_intersect_method_cleanup;
    
    if (PyString_Check(pyvar_volumeFieldName))
        unicodevolumeFieldName = PyUnicode_FromObject(pyvar_volumeFieldName);
    else if (PyUnicode_Check(pyvar_volumeFieldName))
    {
        unicodevolumeFieldName = pyvar_volumeFieldName;
        Py_INCREF(unicodevolumeFieldName);
    }
    else if (pyvar_volumeFieldName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter volumeFieldName at index 6");
    if (unicodevolumeFieldName)
        bsvolumeFieldName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodevolumeFieldName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodevolumeFieldName));
    
    if (PyErr_Occurred())
      goto idynamicsurface3_intersect_method_cleanup;
    
    if (PyString_Check(pyvar_surfaceAreaFieldName))
        unicodesurfaceAreaFieldName = PyUnicode_FromObject(pyvar_surfaceAreaFieldName);
    else if (PyUnicode_Check(pyvar_surfaceAreaFieldName))
    {
        unicodesurfaceAreaFieldName = pyvar_surfaceAreaFieldName;
        Py_INCREF(unicodesurfaceAreaFieldName);
    }
    else if (pyvar_surfaceAreaFieldName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter surfaceAreaFieldName at index 7");
    if (unicodesurfaceAreaFieldName)
        bssurfaceAreaFieldName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodesurfaceAreaFieldName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodesurfaceAreaFieldName));
    
    if (PyErr_Occurred())
      goto idynamicsurface3_intersect_method_cleanup;
    
    if (PyString_Check(pyvar_codeFieldName))
        unicodecodeFieldName = PyUnicode_FromObject(pyvar_codeFieldName);
    else if (PyUnicode_Check(pyvar_codeFieldName))
    {
        unicodecodeFieldName = pyvar_codeFieldName;
        Py_INCREF(unicodecodeFieldName);
    }
    else if (pyvar_codeFieldName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter codeFieldName at index 8");
    if (unicodecodeFieldName)
        bscodeFieldName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodecodeFieldName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodecodeFieldName));
    
    if (PyErr_Occurred())
      goto idynamicsurface3_intersect_method_cleanup;
    
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 9) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto idynamicsurface3_intersect_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIDynamicSurface3->Intersect(ippAOI, dResolution, ippReferenceSurface, dreferenceRsolution, b_bReverse, ippOutFeatureClass, bsvolumeFieldName, bssurfaceAreaFieldName, bscodeFieldName, ippTrackCancel);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDynamicSurface3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDynamicSurface3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDynamicSurface3.Intersect() returned %ld", (long)hr);
        goto idynamicsurface3_intersect_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pAOI
    // No teardown for Resolution
    // No teardown for pReferenceSurface
    // No teardown for referenceRsolution
    // No teardown for bReverse
    // No teardown for pOutFeatureClass
    // No teardown for volumeFieldName
    // No teardown for surfaceAreaFieldName
    // No teardown for codeFieldName
    // No teardown for pTrackCancel

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idynamicsurface3_intersect_method_cleanup;

    idynamicsurface3_intersect_method_cleanup:
    self->m_HR = hr;
    if (ippAOI)
      ippAOI->Release();
    // No cleanup for Resolution
    if (ippReferenceSurface)
      ippReferenceSurface->Release();
    // No cleanup for referenceRsolution
    // No cleanup for bReverse
    if (ippOutFeatureClass)
      ippOutFeatureClass->Release();
    if (bsvolumeFieldName)
        ::SysFreeString(bsvolumeFieldName);
    
    if (bssurfaceAreaFieldName)
        ::SysFreeString(bssurfaceAreaFieldName);
    
    if (bscodeFieldName)
        ::SysFreeString(bscodeFieldName);
    
    if (ippTrackCancel)
      ippTrackCancel->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDynamicSurface3.Intersect");
    return return_tuple;
}

static PyObject*
IDynamicSurface3Method_put_ProfileWeedTolerance(PyIDynamicSurface3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dpTolerance = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "d", &dpTolerance))
      goto idynamicsurface3_put_profileweedtolerance_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pTolerance

    // Call method on actual COM interface
    hr = self->m_pIDynamicSurface3->put_ProfileWeedTolerance(dpTolerance);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDynamicSurface3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDynamicSurface3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDynamicSurface3.put_ProfileWeedTolerance() returned %ld", (long)hr);
        goto idynamicsurface3_put_profileweedtolerance_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pTolerance

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idynamicsurface3_put_profileweedtolerance_method_cleanup;

    idynamicsurface3_put_profileweedtolerance_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pTolerance
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDynamicSurface3.put_ProfileWeedTolerance");
    return return_tuple;
}

static PyObject*
IDynamicSurface3Method_get_ProfileWeedTolerance(PyIDynamicSurface3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dpTolerance = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pTolerance

    // Call method on actual COM interface
    hr = self->m_pIDynamicSurface3->get_ProfileWeedTolerance(&dpTolerance);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDynamicSurface3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDynamicSurface3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDynamicSurface3.get_ProfileWeedTolerance() returned %ld", (long)hr);
        goto idynamicsurface3_get_profileweedtolerance_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pTolerance

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dpTolerance);
    goto idynamicsurface3_get_profileweedtolerance_method_cleanup;

    idynamicsurface3_get_profileweedtolerance_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pTolerance
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDynamicSurface3.get_ProfileWeedTolerance");
    return return_tuple;
}

static PyObject*
IDynamicSurface3Method_get_ZFactor(PyIDynamicSurface3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dpFactor = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pFactor

    // Call method on actual COM interface
    hr = self->m_pIDynamicSurface3->get_ZFactor(&dpFactor);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDynamicSurface3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDynamicSurface3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDynamicSurface3.get_ZFactor() returned %ld", (long)hr);
        goto idynamicsurface3_get_zfactor_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pFactor

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dpFactor);
    goto idynamicsurface3_get_zfactor_method_cleanup;

    idynamicsurface3_get_zfactor_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pFactor
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDynamicSurface3.get_ZFactor");
    return return_tuple;
}

static PyObject*
IDynamicSurface3Method_put_ZFactor(PyIDynamicSurface3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dpFactor = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "d", &dpFactor))
      goto idynamicsurface3_put_zfactor_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pFactor

    // Call method on actual COM interface
    hr = self->m_pIDynamicSurface3->put_ZFactor(dpFactor);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDynamicSurface3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDynamicSurface3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDynamicSurface3.put_ZFactor() returned %ld", (long)hr);
        goto idynamicsurface3_put_zfactor_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pFactor

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idynamicsurface3_put_zfactor_method_cleanup;

    idynamicsurface3_put_zfactor_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pFactor
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDynamicSurface3.put_ZFactor");
    return return_tuple;
}

static PyObject*
IDynamicSurface3Method_put_MinimizeResourceUsage(PyIDynamicSurface3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pbMinimize = VARIANT_FALSE;
    PyObject* pyvar_pbMinimize = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pbMinimize))
      goto idynamicsurface3_put_minimizeresourceusage_method_cleanup;

    // Set up initial variable values as needed
    b_pbMinimize = ((PyObject_IsTrue(pyvar_pbMinimize) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto idynamicsurface3_put_minimizeresourceusage_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIDynamicSurface3->put_MinimizeResourceUsage(b_pbMinimize);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDynamicSurface3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDynamicSurface3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDynamicSurface3.put_MinimizeResourceUsage() returned %ld", (long)hr);
        goto idynamicsurface3_put_minimizeresourceusage_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pbMinimize

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idynamicsurface3_put_minimizeresourceusage_method_cleanup;

    idynamicsurface3_put_minimizeresourceusage_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pbMinimize
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDynamicSurface3.put_MinimizeResourceUsage");
    return return_tuple;
}

static PyObject*
IDynamicSurface3Method_get_MinimizeResourceUsage(PyIDynamicSurface3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pbMinimize = VARIANT_FALSE;
    PyObject* pyvar_pbMinimize = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pbMinimize

    // Call method on actual COM interface
    hr = self->m_pIDynamicSurface3->get_MinimizeResourceUsage(&b_pbMinimize);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDynamicSurface3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDynamicSurface3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDynamicSurface3.get_MinimizeResourceUsage() returned %ld", (long)hr);
        goto idynamicsurface3_get_minimizeresourceusage_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pbMinimize = ((b_pbMinimize == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto idynamicsurface3_get_minimizeresourceusage_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pbMinimize);
    goto idynamicsurface3_get_minimizeresourceusage_method_cleanup;

    idynamicsurface3_get_minimizeresourceusage_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pbMinimize
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDynamicSurface3.get_MinimizeResourceUsage");
    return return_tuple;
}

static PyObject*
IDynamicSurface3Method_put_RefineBoundaryMatching(PyIDynamicSurface3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pbRefine = VARIANT_FALSE;
    PyObject* pyvar_pbRefine = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pbRefine))
      goto idynamicsurface3_put_refineboundarymatching_method_cleanup;

    // Set up initial variable values as needed
    b_pbRefine = ((PyObject_IsTrue(pyvar_pbRefine) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto idynamicsurface3_put_refineboundarymatching_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIDynamicSurface3->put_RefineBoundaryMatching(b_pbRefine);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDynamicSurface3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDynamicSurface3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDynamicSurface3.put_RefineBoundaryMatching() returned %ld", (long)hr);
        goto idynamicsurface3_put_refineboundarymatching_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pbRefine

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idynamicsurface3_put_refineboundarymatching_method_cleanup;

    idynamicsurface3_put_refineboundarymatching_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pbRefine
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDynamicSurface3.put_RefineBoundaryMatching");
    return return_tuple;
}

static PyObject*
IDynamicSurface3Method_get_RefineBoundaryMatching(PyIDynamicSurface3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pbRefine = VARIANT_FALSE;
    PyObject* pyvar_pbRefine = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pbRefine

    // Call method on actual COM interface
    hr = self->m_pIDynamicSurface3->get_RefineBoundaryMatching(&b_pbRefine);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDynamicSurface3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDynamicSurface3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDynamicSurface3.get_RefineBoundaryMatching() returned %ld", (long)hr);
        goto idynamicsurface3_get_refineboundarymatching_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pbRefine = ((b_pbRefine == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto idynamicsurface3_get_refineboundarymatching_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pbRefine);
    goto idynamicsurface3_get_refineboundarymatching_method_cleanup;

    idynamicsurface3_get_refineboundarymatching_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pbRefine
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDynamicSurface3.get_RefineBoundaryMatching");
    return return_tuple;
}

static PyObject*
IDynamicSurface3Method_InterpolateShape(PyIDynamicSurface3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IGeometry* ippInShape = NULL;
    PyObject* py_pInShape;
    double dResolution = 0;
    esriSurfaceInterpolationType eType;
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;
    IGeometry* ipppOutShape = NULL;
    PyObject* py_ppOutShape = NULL;
    VARIANT vpStepSize;
    ::VariantInit(&vpStepSize);
    PyObject* pyvar_pStepSize = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OdiOO", &py_pInShape, &dResolution, (int *)&eType, &py_pTrackCancel, &pyvar_pStepSize))
      goto idynamicsurface3_interpolateshape_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pInShape, &IID_IGeometry, (void**)&ippInShape))
        PyErr_SetString(PyExc_TypeError, "Argument pInShape (position 0) is not IGeometry");
    
    if (PyErr_Occurred())
      goto idynamicsurface3_interpolateshape_method_cleanup;
    
    // No setup for Resolution
    // No setup for Type
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 3) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto idynamicsurface3_interpolateshape_method_cleanup;
    
    // No setup for ppOutShape
    PyObject_AsVariant(pyvar_pStepSize, &vpStepSize);
    
    if (PyErr_Occurred())
      goto idynamicsurface3_interpolateshape_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIDynamicSurface3->InterpolateShape(ippInShape, dResolution, eType, ippTrackCancel, &ipppOutShape, &vpStepSize);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDynamicSurface3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDynamicSurface3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDynamicSurface3.InterpolateShape() returned %ld", (long)hr);
        goto idynamicsurface3_interpolateshape_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pInShape
    // No teardown for Resolution
    // No teardown for Type
    // No teardown for pTrackCancel
    Py_XDECREF(py_ppOutShape);
    if (ipppOutShape)
    {
        IUnknown* pUnk = NULL;
        ipppOutShape->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppOutShape = IUnknownToPythonIIDObject(pUnk, &IID_IGeometry);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppOutShape)
    {
        if (py_ppOutShape)
           Py_DECREF(py_ppOutShape);
        py_ppOutShape = Py_None;
        Py_INCREF(py_ppOutShape);
    }
    if (PyErr_Occurred())
      goto idynamicsurface3_interpolateshape_method_cleanup;
    
    // No teardown for pStepSize

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppOutShape);
    goto idynamicsurface3_interpolateshape_method_cleanup;

    idynamicsurface3_interpolateshape_method_cleanup:
    self->m_HR = hr;
    if (ippInShape)
      ippInShape->Release();
    // No cleanup for Resolution
    // No cleanup for Type
    if (ippTrackCancel)
      ippTrackCancel->Release();
    Py_XDECREF(py_ppOutShape);
    if (ipppOutShape)
      ipppOutShape->Release();
    ::VariantClear(&vpStepSize);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDynamicSurface3.InterpolateShape");
    return return_tuple;
}

static PyObject*
IDynamicSurface3Method_InterpolateShapeVertices(PyIDynamicSurface3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IGeometry* ippInShape = NULL;
    PyObject* py_pInShape;
    double dResolution = 0;
    esriSurfaceInterpolationType eType;
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;
    IGeometry* ipppOutShape = NULL;
    PyObject* py_ppOutShape = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OdiO", &py_pInShape, &dResolution, (int *)&eType, &py_pTrackCancel))
      goto idynamicsurface3_interpolateshapevertices_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pInShape, &IID_IGeometry, (void**)&ippInShape))
        PyErr_SetString(PyExc_TypeError, "Argument pInShape (position 0) is not IGeometry");
    
    if (PyErr_Occurred())
      goto idynamicsurface3_interpolateshapevertices_method_cleanup;
    
    // No setup for Resolution
    // No setup for Type
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 3) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto idynamicsurface3_interpolateshapevertices_method_cleanup;
    
    // No setup for ppOutShape

    // Call method on actual COM interface
    hr = self->m_pIDynamicSurface3->InterpolateShapeVertices(ippInShape, dResolution, eType, ippTrackCancel, &ipppOutShape);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDynamicSurface3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDynamicSurface3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDynamicSurface3.InterpolateShapeVertices() returned %ld", (long)hr);
        goto idynamicsurface3_interpolateshapevertices_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pInShape
    // No teardown for Resolution
    // No teardown for Type
    // No teardown for pTrackCancel
    Py_XDECREF(py_ppOutShape);
    if (ipppOutShape)
    {
        IUnknown* pUnk = NULL;
        ipppOutShape->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppOutShape = IUnknownToPythonIIDObject(pUnk, &IID_IGeometry);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppOutShape)
    {
        if (py_ppOutShape)
           Py_DECREF(py_ppOutShape);
        py_ppOutShape = Py_None;
        Py_INCREF(py_ppOutShape);
    }
    if (PyErr_Occurred())
      goto idynamicsurface3_interpolateshapevertices_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppOutShape);
    goto idynamicsurface3_interpolateshapevertices_method_cleanup;

    idynamicsurface3_interpolateshapevertices_method_cleanup:
    self->m_HR = hr;
    if (ippInShape)
      ippInShape->Release();
    // No cleanup for Resolution
    // No cleanup for Type
    if (ippTrackCancel)
      ippTrackCancel->Release();
    Py_XDECREF(py_ppOutShape);
    if (ipppOutShape)
      ipppOutShape->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDynamicSurface3.InterpolateShapeVertices");
    return return_tuple;
}

static PyObject*
IDynamicSurface3Method_InterpolateFeatureClass(PyIDynamicSurface3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IFeatureClass* ippInFeatureClass = NULL;
    PyObject* py_pInFeatureClass;
    IQueryFilter* ippFilter = NULL;
    PyObject* py_pFilter;
    double dResolution = 0;
    esriSurfaceInterpolationType eType;
    IFeatureClass* ippOutFeatureClass = NULL;
    PyObject* py_pOutFeatureClass;
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;
    VARIANT vpStepSize;
    ::VariantInit(&vpStepSize);
    PyObject* pyvar_pStepSize = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOdiOOO", &py_pInFeatureClass, &py_pFilter, &dResolution, (int *)&eType, &py_pOutFeatureClass, &py_pTrackCancel, &pyvar_pStepSize))
      goto idynamicsurface3_interpolatefeatureclass_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pInFeatureClass, &IID_IFeatureClass, (void**)&ippInFeatureClass))
        PyErr_SetString(PyExc_TypeError, "Argument pInFeatureClass (position 0) is not IFeatureClass");
    
    if (PyErr_Occurred())
      goto idynamicsurface3_interpolatefeatureclass_method_cleanup;
    
    if (!IFaceFromPyObject(py_pFilter, &IID_IQueryFilter, (void**)&ippFilter))
        PyErr_SetString(PyExc_TypeError, "Argument pFilter (position 1) is not IQueryFilter");
    
    if (PyErr_Occurred())
      goto idynamicsurface3_interpolatefeatureclass_method_cleanup;
    
    // No setup for Resolution
    // No setup for Type
    if (!IFaceFromPyObject(py_pOutFeatureClass, &IID_IFeatureClass, (void**)&ippOutFeatureClass))
        PyErr_SetString(PyExc_TypeError, "Argument pOutFeatureClass (position 4) is not IFeatureClass");
    
    if (PyErr_Occurred())
      goto idynamicsurface3_interpolatefeatureclass_method_cleanup;
    
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 5) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto idynamicsurface3_interpolatefeatureclass_method_cleanup;
    
    PyObject_AsVariant(pyvar_pStepSize, &vpStepSize);
    
    if (PyErr_Occurred())
      goto idynamicsurface3_interpolatefeatureclass_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIDynamicSurface3->InterpolateFeatureClass(ippInFeatureClass, ippFilter, dResolution, eType, ippOutFeatureClass, ippTrackCancel, &vpStepSize);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDynamicSurface3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDynamicSurface3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDynamicSurface3.InterpolateFeatureClass() returned %ld", (long)hr);
        goto idynamicsurface3_interpolatefeatureclass_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pInFeatureClass
    // No teardown for pFilter
    // No teardown for Resolution
    // No teardown for Type
    // No teardown for pOutFeatureClass
    // No teardown for pTrackCancel
    // No teardown for pStepSize

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idynamicsurface3_interpolatefeatureclass_method_cleanup;

    idynamicsurface3_interpolatefeatureclass_method_cleanup:
    self->m_HR = hr;
    if (ippInFeatureClass)
      ippInFeatureClass->Release();
    if (ippFilter)
      ippFilter->Release();
    // No cleanup for Resolution
    // No cleanup for Type
    if (ippOutFeatureClass)
      ippOutFeatureClass->Release();
    if (ippTrackCancel)
      ippTrackCancel->Release();
    ::VariantClear(&vpStepSize);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDynamicSurface3.InterpolateFeatureClass");
    return return_tuple;
}

static PyObject*
IDynamicSurface3Method_InterpolateFeatureCursor(PyIDynamicSurface3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IFeatureCursor* ippCursor = NULL;
    PyObject* py_pCursor;
    double dResolution = 0;
    esriSurfaceInterpolationType eType;
    IFeatureClass* ippOutFeatureClass = NULL;
    PyObject* py_pOutFeatureClass;
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;
    VARIANT vpStepSize;
    ::VariantInit(&vpStepSize);
    PyObject* pyvar_pStepSize = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OdiOOO", &py_pCursor, &dResolution, (int *)&eType, &py_pOutFeatureClass, &py_pTrackCancel, &pyvar_pStepSize))
      goto idynamicsurface3_interpolatefeaturecursor_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pCursor, &IID_IFeatureCursor, (void**)&ippCursor))
        PyErr_SetString(PyExc_TypeError, "Argument pCursor (position 0) is not IFeatureCursor");
    
    if (PyErr_Occurred())
      goto idynamicsurface3_interpolatefeaturecursor_method_cleanup;
    
    // No setup for Resolution
    // No setup for Type
    if (!IFaceFromPyObject(py_pOutFeatureClass, &IID_IFeatureClass, (void**)&ippOutFeatureClass))
        PyErr_SetString(PyExc_TypeError, "Argument pOutFeatureClass (position 3) is not IFeatureClass");
    
    if (PyErr_Occurred())
      goto idynamicsurface3_interpolatefeaturecursor_method_cleanup;
    
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 4) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto idynamicsurface3_interpolatefeaturecursor_method_cleanup;
    
    PyObject_AsVariant(pyvar_pStepSize, &vpStepSize);
    
    if (PyErr_Occurred())
      goto idynamicsurface3_interpolatefeaturecursor_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIDynamicSurface3->InterpolateFeatureCursor(ippCursor, dResolution, eType, ippOutFeatureClass, ippTrackCancel, &vpStepSize);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDynamicSurface3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDynamicSurface3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDynamicSurface3.InterpolateFeatureCursor() returned %ld", (long)hr);
        goto idynamicsurface3_interpolatefeaturecursor_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pCursor
    // No teardown for Resolution
    // No teardown for Type
    // No teardown for pOutFeatureClass
    // No teardown for pTrackCancel
    // No teardown for pStepSize

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idynamicsurface3_interpolatefeaturecursor_method_cleanup;

    idynamicsurface3_interpolatefeaturecursor_method_cleanup:
    self->m_HR = hr;
    if (ippCursor)
      ippCursor->Release();
    // No cleanup for Resolution
    // No cleanup for Type
    if (ippOutFeatureClass)
      ippOutFeatureClass->Release();
    if (ippTrackCancel)
      ippTrackCancel->Release();
    ::VariantClear(&vpStepSize);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDynamicSurface3.InterpolateFeatureCursor");
    return return_tuple;
}

static PyObject*
IDynamicSurface3Method_InterpolateFeatureClassVertices(PyIDynamicSurface3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IFeatureClass* ippInFeatureClass = NULL;
    PyObject* py_pInFeatureClass;
    IQueryFilter* ippFilter = NULL;
    PyObject* py_pFilter;
    double dResolution = 0;
    esriSurfaceInterpolationType eType;
    IFeatureClass* ippOutFeatureClass = NULL;
    PyObject* py_pOutFeatureClass;
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOdiOO", &py_pInFeatureClass, &py_pFilter, &dResolution, (int *)&eType, &py_pOutFeatureClass, &py_pTrackCancel))
      goto idynamicsurface3_interpolatefeatureclassvertices_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pInFeatureClass, &IID_IFeatureClass, (void**)&ippInFeatureClass))
        PyErr_SetString(PyExc_TypeError, "Argument pInFeatureClass (position 0) is not IFeatureClass");
    
    if (PyErr_Occurred())
      goto idynamicsurface3_interpolatefeatureclassvertices_method_cleanup;
    
    if (!IFaceFromPyObject(py_pFilter, &IID_IQueryFilter, (void**)&ippFilter))
        PyErr_SetString(PyExc_TypeError, "Argument pFilter (position 1) is not IQueryFilter");
    
    if (PyErr_Occurred())
      goto idynamicsurface3_interpolatefeatureclassvertices_method_cleanup;
    
    // No setup for Resolution
    // No setup for Type
    if (!IFaceFromPyObject(py_pOutFeatureClass, &IID_IFeatureClass, (void**)&ippOutFeatureClass))
        PyErr_SetString(PyExc_TypeError, "Argument pOutFeatureClass (position 4) is not IFeatureClass");
    
    if (PyErr_Occurred())
      goto idynamicsurface3_interpolatefeatureclassvertices_method_cleanup;
    
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 5) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto idynamicsurface3_interpolatefeatureclassvertices_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIDynamicSurface3->InterpolateFeatureClassVertices(ippInFeatureClass, ippFilter, dResolution, eType, ippOutFeatureClass, ippTrackCancel);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDynamicSurface3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDynamicSurface3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDynamicSurface3.InterpolateFeatureClassVertices() returned %ld", (long)hr);
        goto idynamicsurface3_interpolatefeatureclassvertices_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pInFeatureClass
    // No teardown for pFilter
    // No teardown for Resolution
    // No teardown for Type
    // No teardown for pOutFeatureClass
    // No teardown for pTrackCancel

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idynamicsurface3_interpolatefeatureclassvertices_method_cleanup;

    idynamicsurface3_interpolatefeatureclassvertices_method_cleanup:
    self->m_HR = hr;
    if (ippInFeatureClass)
      ippInFeatureClass->Release();
    if (ippFilter)
      ippFilter->Release();
    // No cleanup for Resolution
    // No cleanup for Type
    if (ippOutFeatureClass)
      ippOutFeatureClass->Release();
    if (ippTrackCancel)
      ippTrackCancel->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDynamicSurface3.InterpolateFeatureClassVertices");
    return return_tuple;
}

static PyObject*
IDynamicSurface3Method_InterpolateFeatureCursorVertices(PyIDynamicSurface3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IFeatureCursor* ippCursor = NULL;
    PyObject* py_pCursor;
    double dResolution = 0;
    esriSurfaceInterpolationType eType;
    IFeatureClass* ippOutFeatureClass = NULL;
    PyObject* py_pOutFeatureClass;
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OdiOO", &py_pCursor, &dResolution, (int *)&eType, &py_pOutFeatureClass, &py_pTrackCancel))
      goto idynamicsurface3_interpolatefeaturecursorvertices_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pCursor, &IID_IFeatureCursor, (void**)&ippCursor))
        PyErr_SetString(PyExc_TypeError, "Argument pCursor (position 0) is not IFeatureCursor");
    
    if (PyErr_Occurred())
      goto idynamicsurface3_interpolatefeaturecursorvertices_method_cleanup;
    
    // No setup for Resolution
    // No setup for Type
    if (!IFaceFromPyObject(py_pOutFeatureClass, &IID_IFeatureClass, (void**)&ippOutFeatureClass))
        PyErr_SetString(PyExc_TypeError, "Argument pOutFeatureClass (position 3) is not IFeatureClass");
    
    if (PyErr_Occurred())
      goto idynamicsurface3_interpolatefeaturecursorvertices_method_cleanup;
    
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 4) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto idynamicsurface3_interpolatefeaturecursorvertices_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIDynamicSurface3->InterpolateFeatureCursorVertices(ippCursor, dResolution, eType, ippOutFeatureClass, ippTrackCancel);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDynamicSurface3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDynamicSurface3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDynamicSurface3.InterpolateFeatureCursorVertices() returned %ld", (long)hr);
        goto idynamicsurface3_interpolatefeaturecursorvertices_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pCursor
    // No teardown for Resolution
    // No teardown for Type
    // No teardown for pOutFeatureClass
    // No teardown for pTrackCancel

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idynamicsurface3_interpolatefeaturecursorvertices_method_cleanup;

    idynamicsurface3_interpolatefeaturecursorvertices_method_cleanup:
    self->m_HR = hr;
    if (ippCursor)
      ippCursor->Release();
    // No cleanup for Resolution
    // No cleanup for Type
    if (ippOutFeatureClass)
      ippOutFeatureClass->Release();
    if (ippTrackCancel)
      ippTrackCancel->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDynamicSurface3.InterpolateFeatureCursorVertices");
    return return_tuple;
}

static PyObject*
IDynamicSurface3Method_get_CanDoCurvature(PyIDynamicSurface3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pbCanDo = VARIANT_FALSE;
    PyObject* pyvar_pbCanDo = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pbCanDo

    // Call method on actual COM interface
    hr = self->m_pIDynamicSurface3->get_CanDoCurvature(&b_pbCanDo);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDynamicSurface3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDynamicSurface3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDynamicSurface3.get_CanDoCurvature() returned %ld", (long)hr);
        goto idynamicsurface3_get_candocurvature_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pbCanDo = ((b_pbCanDo == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto idynamicsurface3_get_candocurvature_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pbCanDo);
    goto idynamicsurface3_get_candocurvature_method_cleanup;

    idynamicsurface3_get_candocurvature_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pbCanDo
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDynamicSurface3.get_CanDoCurvature");
    return return_tuple;
}

static PyObject*
IDynamicSurface3Method_GetLineOfSight(PyIDynamicSurface3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IPoint* ippObserver = NULL;
    PyObject* py_pObserver;
    IPoint* ippTarget = NULL;
    PyObject* py_pTarget;
    double dResolution = 0;
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;
    IPoint* ipppObstruction = NULL;
    PyObject* py_ppObstruction = NULL;
    IPolyline* ipppVisibleLines = NULL;
    PyObject* py_ppVisibleLines = NULL;
    IPolyline* ipppInvisibleLines = NULL;
    PyObject* py_ppInvisibleLines = NULL;
    VARIANT_BOOL b_pbIsVisible = VARIANT_FALSE;
    PyObject* pyvar_pbIsVisible = Py_False;
    VARIANT_BOOL b_bApplyCurvature = VARIANT_FALSE;
    PyObject* pyvar_bApplyCurvature = NULL;
    VARIANT_BOOL b_bApplyRefraction = VARIANT_FALSE;
    PyObject* pyvar_bApplyRefraction = NULL;
    VARIANT vpRefractionFactor;
    ::VariantInit(&vpRefractionFactor);
    PyObject* pyvar_pRefractionFactor = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOdOOOO", &py_pObserver, &py_pTarget, &dResolution, &py_pTrackCancel, &pyvar_bApplyCurvature, &pyvar_bApplyRefraction, &pyvar_pRefractionFactor))
      goto idynamicsurface3_getlineofsight_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pObserver, &IID_IPoint, (void**)&ippObserver))
        PyErr_SetString(PyExc_TypeError, "Argument pObserver (position 0) is not IPoint");
    
    if (PyErr_Occurred())
      goto idynamicsurface3_getlineofsight_method_cleanup;
    
    if (!IFaceFromPyObject(py_pTarget, &IID_IPoint, (void**)&ippTarget))
        PyErr_SetString(PyExc_TypeError, "Argument pTarget (position 1) is not IPoint");
    
    if (PyErr_Occurred())
      goto idynamicsurface3_getlineofsight_method_cleanup;
    
    // No setup for Resolution
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 3) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto idynamicsurface3_getlineofsight_method_cleanup;
    
    // No setup for ppObstruction
    // No setup for ppVisibleLines
    // No setup for ppInvisibleLines
    // No setup for pbIsVisible
    b_bApplyCurvature = ((PyObject_IsTrue(pyvar_bApplyCurvature) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto idynamicsurface3_getlineofsight_method_cleanup;
    
    b_bApplyRefraction = ((PyObject_IsTrue(pyvar_bApplyRefraction) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto idynamicsurface3_getlineofsight_method_cleanup;
    
    PyObject_AsVariant(pyvar_pRefractionFactor, &vpRefractionFactor);
    
    if (PyErr_Occurred())
      goto idynamicsurface3_getlineofsight_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIDynamicSurface3->GetLineOfSight(ippObserver, ippTarget, dResolution, ippTrackCancel, &ipppObstruction, &ipppVisibleLines, &ipppInvisibleLines, &b_pbIsVisible, b_bApplyCurvature, b_bApplyRefraction, &vpRefractionFactor);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDynamicSurface3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDynamicSurface3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDynamicSurface3.GetLineOfSight() returned %ld", (long)hr);
        goto idynamicsurface3_getlineofsight_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pObserver
    // No teardown for pTarget
    // No teardown for Resolution
    // No teardown for pTrackCancel
    Py_XDECREF(py_ppObstruction);
    if (ipppObstruction)
    {
        IUnknown* pUnk = NULL;
        ipppObstruction->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppObstruction = IUnknownToPythonIIDObject(pUnk, &IID_IPoint);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppObstruction)
    {
        if (py_ppObstruction)
           Py_DECREF(py_ppObstruction);
        py_ppObstruction = Py_None;
        Py_INCREF(py_ppObstruction);
    }
    if (PyErr_Occurred())
      goto idynamicsurface3_getlineofsight_method_cleanup;
    
    Py_XDECREF(py_ppVisibleLines);
    if (ipppVisibleLines)
    {
        IUnknown* pUnk = NULL;
        ipppVisibleLines->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppVisibleLines = IUnknownToPythonIIDObject(pUnk, &IID_IPolyline);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppVisibleLines)
    {
        if (py_ppVisibleLines)
           Py_DECREF(py_ppVisibleLines);
        py_ppVisibleLines = Py_None;
        Py_INCREF(py_ppVisibleLines);
    }
    if (PyErr_Occurred())
      goto idynamicsurface3_getlineofsight_method_cleanup;
    
    Py_XDECREF(py_ppInvisibleLines);
    if (ipppInvisibleLines)
    {
        IUnknown* pUnk = NULL;
        ipppInvisibleLines->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppInvisibleLines = IUnknownToPythonIIDObject(pUnk, &IID_IPolyline);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppInvisibleLines)
    {
        if (py_ppInvisibleLines)
           Py_DECREF(py_ppInvisibleLines);
        py_ppInvisibleLines = Py_None;
        Py_INCREF(py_ppInvisibleLines);
    }
    if (PyErr_Occurred())
      goto idynamicsurface3_getlineofsight_method_cleanup;
    
    pyvar_pbIsVisible = ((b_pbIsVisible == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto idynamicsurface3_getlineofsight_method_cleanup;
    
    // No teardown for bApplyCurvature
    // No teardown for bApplyRefraction
    // No teardown for pRefractionFactor

    // Initialize output tuple
    return_tuple = Py_BuildValue("OOOO",
                                            py_ppObstruction, py_ppVisibleLines, py_ppInvisibleLines, pyvar_pbIsVisible);
    goto idynamicsurface3_getlineofsight_method_cleanup;

    idynamicsurface3_getlineofsight_method_cleanup:
    self->m_HR = hr;
    if (ippObserver)
      ippObserver->Release();
    if (ippTarget)
      ippTarget->Release();
    // No cleanup for Resolution
    if (ippTrackCancel)
      ippTrackCancel->Release();
    Py_XDECREF(py_ppObstruction);
    if (ipppObstruction)
      ipppObstruction->Release();
    Py_XDECREF(py_ppVisibleLines);
    if (ipppVisibleLines)
      ipppVisibleLines->Release();
    Py_XDECREF(py_ppInvisibleLines);
    if (ipppInvisibleLines)
      ipppInvisibleLines->Release();
    // No cleanup for pbIsVisible
    // No cleanup for bApplyCurvature
    // No cleanup for bApplyRefraction
    ::VariantClear(&vpRefractionFactor);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDynamicSurface3.GetLineOfSight");
    return return_tuple;
}

static PyObject*
IDynamicSurface3Method_GetLineOfSightFeatureCursor(PyIDynamicSurface3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IFeatureCursor* ippCursor = NULL;
    PyObject* py_pCursor;
    double dResolution = 0;
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;
    IFeatureClass* ippOutputLines = NULL;
    PyObject* py_pOutputLines;
    IFeatureClass* ippObstructionPoints = NULL;
    PyObject* py_pObstructionPoints;
    VARIANT_BOOL b_bApplyCurvature = VARIANT_FALSE;
    PyObject* pyvar_bApplyCurvature = NULL;
    VARIANT_BOOL b_bApplyRefraction = VARIANT_FALSE;
    PyObject* pyvar_bApplyRefraction = NULL;
    VARIANT vpRefractionFactor;
    ::VariantInit(&vpRefractionFactor);
    PyObject* pyvar_pRefractionFactor = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OdOOOOOO", &py_pCursor, &dResolution, &py_pTrackCancel, &py_pOutputLines, &py_pObstructionPoints, &pyvar_bApplyCurvature, &pyvar_bApplyRefraction, &pyvar_pRefractionFactor))
      goto idynamicsurface3_getlineofsightfeaturecursor_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pCursor, &IID_IFeatureCursor, (void**)&ippCursor))
        PyErr_SetString(PyExc_TypeError, "Argument pCursor (position 0) is not IFeatureCursor");
    
    if (PyErr_Occurred())
      goto idynamicsurface3_getlineofsightfeaturecursor_method_cleanup;
    
    // No setup for Resolution
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 2) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto idynamicsurface3_getlineofsightfeaturecursor_method_cleanup;
    
    if (!IFaceFromPyObject(py_pOutputLines, &IID_IFeatureClass, (void**)&ippOutputLines))
        PyErr_SetString(PyExc_TypeError, "Argument pOutputLines (position 3) is not IFeatureClass");
    
    if (PyErr_Occurred())
      goto idynamicsurface3_getlineofsightfeaturecursor_method_cleanup;
    
    if (!IFaceFromPyObject(py_pObstructionPoints, &IID_IFeatureClass, (void**)&ippObstructionPoints))
        PyErr_SetString(PyExc_TypeError, "Argument pObstructionPoints (position 4) is not IFeatureClass");
    
    if (PyErr_Occurred())
      goto idynamicsurface3_getlineofsightfeaturecursor_method_cleanup;
    
    b_bApplyCurvature = ((PyObject_IsTrue(pyvar_bApplyCurvature) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto idynamicsurface3_getlineofsightfeaturecursor_method_cleanup;
    
    b_bApplyRefraction = ((PyObject_IsTrue(pyvar_bApplyRefraction) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto idynamicsurface3_getlineofsightfeaturecursor_method_cleanup;
    
    PyObject_AsVariant(pyvar_pRefractionFactor, &vpRefractionFactor);
    
    if (PyErr_Occurred())
      goto idynamicsurface3_getlineofsightfeaturecursor_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIDynamicSurface3->GetLineOfSightFeatureCursor(ippCursor, dResolution, ippTrackCancel, ippOutputLines, ippObstructionPoints, b_bApplyCurvature, b_bApplyRefraction, &vpRefractionFactor);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDynamicSurface3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDynamicSurface3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDynamicSurface3.GetLineOfSightFeatureCursor() returned %ld", (long)hr);
        goto idynamicsurface3_getlineofsightfeaturecursor_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pCursor
    // No teardown for Resolution
    // No teardown for pTrackCancel
    // No teardown for pOutputLines
    // No teardown for pObstructionPoints
    // No teardown for bApplyCurvature
    // No teardown for bApplyRefraction
    // No teardown for pRefractionFactor

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idynamicsurface3_getlineofsightfeaturecursor_method_cleanup;

    idynamicsurface3_getlineofsightfeaturecursor_method_cleanup:
    self->m_HR = hr;
    if (ippCursor)
      ippCursor->Release();
    // No cleanup for Resolution
    if (ippTrackCancel)
      ippTrackCancel->Release();
    if (ippOutputLines)
      ippOutputLines->Release();
    if (ippObstructionPoints)
      ippObstructionPoints->Release();
    // No cleanup for bApplyCurvature
    // No cleanup for bApplyRefraction
    ::VariantClear(&vpRefractionFactor);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDynamicSurface3.GetLineOfSightFeatureCursor");
    return return_tuple;
}

static PyObject*
IDynamicSurface3Method_GetTileBasedDataArea(PyIDynamicSurface3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;
    IPolygon* ipppDataArea = NULL;
    PyObject* py_ppDataArea = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_pTrackCancel))
      goto idynamicsurface3_gettilebaseddataarea_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 0) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto idynamicsurface3_gettilebaseddataarea_method_cleanup;
    
    // No setup for ppDataArea

    // Call method on actual COM interface
    hr = self->m_pIDynamicSurface3->GetTileBasedDataArea(ippTrackCancel, &ipppDataArea);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDynamicSurface3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDynamicSurface3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDynamicSurface3.GetTileBasedDataArea() returned %ld", (long)hr);
        goto idynamicsurface3_gettilebaseddataarea_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pTrackCancel
    Py_XDECREF(py_ppDataArea);
    if (ipppDataArea)
    {
        IUnknown* pUnk = NULL;
        ipppDataArea->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppDataArea = IUnknownToPythonIIDObject(pUnk, &IID_IPolygon);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppDataArea)
    {
        if (py_ppDataArea)
           Py_DECREF(py_ppDataArea);
        py_ppDataArea = Py_None;
        Py_INCREF(py_ppDataArea);
    }
    if (PyErr_Occurred())
      goto idynamicsurface3_gettilebaseddataarea_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppDataArea);
    goto idynamicsurface3_gettilebaseddataarea_method_cleanup;

    idynamicsurface3_gettilebaseddataarea_method_cleanup:
    self->m_HR = hr;
    if (ippTrackCancel)
      ippTrackCancel->Release();
    Py_XDECREF(py_ppDataArea);
    if (ipppDataArea)
      ipppDataArea->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDynamicSurface3.GetTileBasedDataArea");
    return return_tuple;
}

static PyObject*
IDynamicSurface3Method_put_RasterBlockSize(PyIDynamicSurface3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpSize = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lpSize))
      goto idynamicsurface3_put_rasterblocksize_method_cleanup;

    // Set up initial variable values as needed
    // No setup for pSize

    // Call method on actual COM interface
    hr = self->m_pIDynamicSurface3->put_RasterBlockSize(lpSize);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDynamicSurface3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDynamicSurface3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDynamicSurface3.put_RasterBlockSize() returned %ld", (long)hr);
        goto idynamicsurface3_put_rasterblocksize_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pSize

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idynamicsurface3_put_rasterblocksize_method_cleanup;

    idynamicsurface3_put_rasterblocksize_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pSize
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDynamicSurface3.put_RasterBlockSize");
    return return_tuple;
}

static PyObject*
IDynamicSurface3Method_get_RasterBlockSize(PyIDynamicSurface3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpSize = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pSize

    // Call method on actual COM interface
    hr = self->m_pIDynamicSurface3->get_RasterBlockSize(&lpSize);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDynamicSurface3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDynamicSurface3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDynamicSurface3.get_RasterBlockSize() returned %ld", (long)hr);
        goto idynamicsurface3_get_rasterblocksize_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pSize

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpSize);
    goto idynamicsurface3_get_rasterblocksize_method_cleanup;

    idynamicsurface3_get_rasterblocksize_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pSize
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDynamicSurface3.get_RasterBlockSize");
    return return_tuple;
}

static PyObject*
IDynamicSurface3Method_get_Terrain(PyIDynamicSurface3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ITerrain* ipppTerrain = NULL;
    PyObject* py_ppTerrain = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppTerrain

    // Call method on actual COM interface
    hr = self->m_pIDynamicSurface3->get_Terrain(&ipppTerrain);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDynamicSurface3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDynamicSurface3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDynamicSurface3.get_Terrain() returned %ld", (long)hr);
        goto idynamicsurface3_get_terrain_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppTerrain);
    if (ipppTerrain)
    {
        IUnknown* pUnk = NULL;
        ipppTerrain->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppTerrain = IUnknownToPythonIIDObject(pUnk, &IID_ITerrain);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppTerrain)
    {
        if (py_ppTerrain)
           Py_DECREF(py_ppTerrain);
        py_ppTerrain = Py_None;
        Py_INCREF(py_ppTerrain);
    }
    if (PyErr_Occurred())
      goto idynamicsurface3_get_terrain_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppTerrain);
    goto idynamicsurface3_get_terrain_method_cleanup;

    idynamicsurface3_get_terrain_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppTerrain);
    if (ipppTerrain)
      ipppTerrain->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDynamicSurface3.get_Terrain");
    return return_tuple;
}

static PyObject*
IDynamicSurface3Method_GetTin(PyIDynamicSurface3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IEnvelope* ippAreaOfInterest = NULL;
    PyObject* py_pAreaOfInterest;
    double dResolution = 0;
    VARIANT_BOOL b_bClipWithAOI = VARIANT_FALSE;
    PyObject* pyvar_bClipWithAOI = NULL;
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;
    ITin* ipppTin = NULL;
    PyObject* py_ppTin = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OdOO", &py_pAreaOfInterest, &dResolution, &pyvar_bClipWithAOI, &py_pTrackCancel))
      goto idynamicsurface3_gettin_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pAreaOfInterest, &IID_IEnvelope, (void**)&ippAreaOfInterest))
        PyErr_SetString(PyExc_TypeError, "Argument pAreaOfInterest (position 0) is not IEnvelope");
    
    if (PyErr_Occurred())
      goto idynamicsurface3_gettin_method_cleanup;
    
    // No setup for Resolution
    b_bClipWithAOI = ((PyObject_IsTrue(pyvar_bClipWithAOI) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto idynamicsurface3_gettin_method_cleanup;
    
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 3) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto idynamicsurface3_gettin_method_cleanup;
    
    // No setup for ppTin

    // Call method on actual COM interface
    hr = self->m_pIDynamicSurface3->GetTin(ippAreaOfInterest, dResolution, b_bClipWithAOI, ippTrackCancel, &ipppTin);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDynamicSurface3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDynamicSurface3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDynamicSurface3.GetTin() returned %ld", (long)hr);
        goto idynamicsurface3_gettin_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pAreaOfInterest
    // No teardown for Resolution
    // No teardown for bClipWithAOI
    // No teardown for pTrackCancel
    Py_XDECREF(py_ppTin);
    if (ipppTin)
    {
        IUnknown* pUnk = NULL;
        ipppTin->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppTin = IUnknownToPythonIIDObject(pUnk, &IID_ITin);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppTin)
    {
        if (py_ppTin)
           Py_DECREF(py_ppTin);
        py_ppTin = Py_None;
        Py_INCREF(py_ppTin);
    }
    if (PyErr_Occurred())
      goto idynamicsurface3_gettin_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppTin);
    goto idynamicsurface3_gettin_method_cleanup;

    idynamicsurface3_gettin_method_cleanup:
    self->m_HR = hr;
    if (ippAreaOfInterest)
      ippAreaOfInterest->Release();
    // No cleanup for Resolution
    // No cleanup for bClipWithAOI
    if (ippTrackCancel)
      ippTrackCancel->Release();
    Py_XDECREF(py_ppTin);
    if (ipppTin)
      ipppTin->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDynamicSurface3.GetTin");
    return return_tuple;
}

static PyObject*
IDynamicSurface3Method_QueryRaster(PyIDynamicSurface3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IRasterDataset* ippDataset = NULL;
    PyObject* py_pDataset;
    IEnvelope* ippAreaOfInterest = NULL;
    PyObject* py_pAreaOfInterest;
    double dResolution = 0;
    esriSurfaceInterpolationType eMethod;
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOdiO", &py_pDataset, &py_pAreaOfInterest, &dResolution, (int *)&eMethod, &py_pTrackCancel))
      goto idynamicsurface3_queryraster_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pDataset, &IID_IRasterDataset, (void**)&ippDataset))
        PyErr_SetString(PyExc_TypeError, "Argument pDataset (position 0) is not IRasterDataset");
    
    if (PyErr_Occurred())
      goto idynamicsurface3_queryraster_method_cleanup;
    
    if (!IFaceFromPyObject(py_pAreaOfInterest, &IID_IEnvelope, (void**)&ippAreaOfInterest))
        PyErr_SetString(PyExc_TypeError, "Argument pAreaOfInterest (position 1) is not IEnvelope");
    
    if (PyErr_Occurred())
      goto idynamicsurface3_queryraster_method_cleanup;
    
    // No setup for Resolution
    // No setup for Method
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 4) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto idynamicsurface3_queryraster_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIDynamicSurface3->QueryRaster(ippDataset, ippAreaOfInterest, dResolution, eMethod, ippTrackCancel);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDynamicSurface3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDynamicSurface3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDynamicSurface3.QueryRaster() returned %ld", (long)hr);
        goto idynamicsurface3_queryraster_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pDataset
    // No teardown for pAreaOfInterest
    // No teardown for Resolution
    // No teardown for Method
    // No teardown for pTrackCancel

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idynamicsurface3_queryraster_method_cleanup;

    idynamicsurface3_queryraster_method_cleanup:
    self->m_HR = hr;
    if (ippDataset)
      ippDataset->Release();
    if (ippAreaOfInterest)
      ippAreaOfInterest->Release();
    // No cleanup for Resolution
    // No cleanup for Method
    if (ippTrackCancel)
      ippTrackCancel->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDynamicSurface3.QueryRaster");
    return return_tuple;
}

static PyObject*
IDynamicSurface3Method_QueryAsFeatureClass(PyIDynamicSurface3Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IFeatureClass* ippFeatureClass = NULL;
    PyObject* py_pFeatureClass;
    IEnvelope* ippAreaOfInterest = NULL;
    PyObject* py_pAreaOfInterest;
    double dResolution = 0;
    ITrackCancel* ippTrackCancel = NULL;
    PyObject* py_pTrackCancel;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOdO", &py_pFeatureClass, &py_pAreaOfInterest, &dResolution, &py_pTrackCancel))
      goto idynamicsurface3_queryasfeatureclass_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pFeatureClass, &IID_IFeatureClass, (void**)&ippFeatureClass))
        PyErr_SetString(PyExc_TypeError, "Argument pFeatureClass (position 0) is not IFeatureClass");
    
    if (PyErr_Occurred())
      goto idynamicsurface3_queryasfeatureclass_method_cleanup;
    
    if (!IFaceFromPyObject(py_pAreaOfInterest, &IID_IEnvelope, (void**)&ippAreaOfInterest))
        PyErr_SetString(PyExc_TypeError, "Argument pAreaOfInterest (position 1) is not IEnvelope");
    
    if (PyErr_Occurred())
      goto idynamicsurface3_queryasfeatureclass_method_cleanup;
    
    // No setup for Resolution
    if (!IFaceFromPyObject(py_pTrackCancel, &IID_ITrackCancel, (void**)&ippTrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument pTrackCancel (position 3) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto idynamicsurface3_queryasfeatureclass_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIDynamicSurface3->QueryAsFeatureClass(ippFeatureClass, ippAreaOfInterest, dResolution, ippTrackCancel);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDynamicSurface3->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDynamicSurface3) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDynamicSurface3.QueryAsFeatureClass() returned %ld", (long)hr);
        goto idynamicsurface3_queryasfeatureclass_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pFeatureClass
    // No teardown for pAreaOfInterest
    // No teardown for Resolution
    // No teardown for pTrackCancel

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idynamicsurface3_queryasfeatureclass_method_cleanup;

    idynamicsurface3_queryasfeatureclass_method_cleanup:
    self->m_HR = hr;
    if (ippFeatureClass)
      ippFeatureClass->Release();
    if (ippAreaOfInterest)
      ippAreaOfInterest->Release();
    // No cleanup for Resolution
    if (ippTrackCancel)
      ippTrackCancel->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDynamicSurface3.QueryAsFeatureClass");
    return return_tuple;
}


PyMethodDef PyIDynamicSurface3Methods[] = {
    {"supports", (PyCFunction)PyIDynamicSurface3_SupportsInterface, METH_O, ""},
    {"CreateBlockCursor", (PyCFunction)IDynamicSurface3Method_CreateBlockCursor, METH_VARARGS, ""},
    {"ConvertToExtent", (PyCFunction)IDynamicSurface3Method_ConvertToExtent, METH_VARARGS, ""},
    {"ContourList", (PyCFunction)IDynamicSurface3Method_ContourList, METH_VARARGS, ""},
    {"Contour", (PyCFunction)IDynamicSurface3Method_Contour, METH_VARARGS, ""},
    {"GetVolumeAndArea", (PyCFunction)IDynamicSurface3Method_GetVolumeAndArea, METH_VARARGS, ""},
    {"Intersect", (PyCFunction)IDynamicSurface3Method_Intersect, METH_VARARGS, ""},
    {"put_ProfileWeedTolerance", (PyCFunction)IDynamicSurface3Method_put_ProfileWeedTolerance, METH_VARARGS, ""},
    {"get_ProfileWeedTolerance", (PyCFunction)IDynamicSurface3Method_get_ProfileWeedTolerance, METH_VARARGS, ""},
    {"get_ZFactor", (PyCFunction)IDynamicSurface3Method_get_ZFactor, METH_VARARGS, ""},
    {"put_ZFactor", (PyCFunction)IDynamicSurface3Method_put_ZFactor, METH_VARARGS, ""},
    {"put_MinimizeResourceUsage", (PyCFunction)IDynamicSurface3Method_put_MinimizeResourceUsage, METH_VARARGS, ""},
    {"get_MinimizeResourceUsage", (PyCFunction)IDynamicSurface3Method_get_MinimizeResourceUsage, METH_VARARGS, ""},
    {"put_RefineBoundaryMatching", (PyCFunction)IDynamicSurface3Method_put_RefineBoundaryMatching, METH_VARARGS, ""},
    {"get_RefineBoundaryMatching", (PyCFunction)IDynamicSurface3Method_get_RefineBoundaryMatching, METH_VARARGS, ""},
    {"InterpolateShape", (PyCFunction)IDynamicSurface3Method_InterpolateShape, METH_VARARGS, ""},
    {"InterpolateShapeVertices", (PyCFunction)IDynamicSurface3Method_InterpolateShapeVertices, METH_VARARGS, ""},
    {"InterpolateFeatureClass", (PyCFunction)IDynamicSurface3Method_InterpolateFeatureClass, METH_VARARGS, ""},
    {"InterpolateFeatureCursor", (PyCFunction)IDynamicSurface3Method_InterpolateFeatureCursor, METH_VARARGS, ""},
    {"InterpolateFeatureClassVertices", (PyCFunction)IDynamicSurface3Method_InterpolateFeatureClassVertices, METH_VARARGS, ""},
    {"InterpolateFeatureCursorVertices", (PyCFunction)IDynamicSurface3Method_InterpolateFeatureCursorVertices, METH_VARARGS, ""},
    {"get_CanDoCurvature", (PyCFunction)IDynamicSurface3Method_get_CanDoCurvature, METH_VARARGS, ""},
    {"GetLineOfSight", (PyCFunction)IDynamicSurface3Method_GetLineOfSight, METH_VARARGS, ""},
    {"GetLineOfSightFeatureCursor", (PyCFunction)IDynamicSurface3Method_GetLineOfSightFeatureCursor, METH_VARARGS, ""},
    {"GetTileBasedDataArea", (PyCFunction)IDynamicSurface3Method_GetTileBasedDataArea, METH_VARARGS, ""},
    {"put_RasterBlockSize", (PyCFunction)IDynamicSurface3Method_put_RasterBlockSize, METH_VARARGS, ""},
    {"get_RasterBlockSize", (PyCFunction)IDynamicSurface3Method_get_RasterBlockSize, METH_VARARGS, ""},
    {"get_Terrain", (PyCFunction)IDynamicSurface3Method_get_Terrain, METH_VARARGS, ""},
    {"GetTin", (PyCFunction)IDynamicSurface3Method_GetTin, METH_VARARGS, ""},
    {"QueryRaster", (PyCFunction)IDynamicSurface3Method_QueryRaster, METH_VARARGS, ""},
    {"QueryAsFeatureClass", (PyCFunction)IDynamicSurface3Method_QueryAsFeatureClass, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIDynamicSurface3GetSet[] = {
  {"_pUnk", (getter)PyIDynamicSurface3_GetpUnk, NULL, "Get opaque pointer to an Unknown from IDynamicSurface3", NULL},
  {"_pointer", (getter)PyIDynamicSurface3_GetPointer, NULL, "Get memory address for IDynamicSurface3", NULL},
  {"_IID", (getter)PyIDynamicSurface3_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIDynamicSurface3_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIDynamicSurface3_GetIgnoreFailures, (setter)PyIDynamicSurface3_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIDynamicSurface3Object_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.IDynamicSurface3Object",                          
                                              /* tp_name */
  sizeof(PyIDynamicSurface3Object),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIDynamicSurface3Object_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIDynamicSurface3Methods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIDynamicSurface3GetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIDynamicSurface3Object_new,                      
                                              /* tp_new */
};


// Struct RGB32

typedef struct PyRGB32StructObject {
    PyObject_HEAD
    RGB32 m_RGB32Struct;
} PyRGB32StructObject;

static PyObject*
PyRGB32StructObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyRGB32StructObject* self = NULL;
    if (!(self = ((PyRGB32StructObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate RGB32");
        return NULL;
    }
    if (args && PySequence_Length(args) == 1)
    {
        PyObject* bytes = PySequence_GetItem(args, 0);
        if (!PyByteArray_Check(bytes))
            bytes = PyObject_GetAttrString(bytes, "_bytes");
        else
            Py_INCREF(bytes);
        if (PyErr_Occurred())
        {
            Py_XDECREF(self);
            Py_XDECREF(bytes);
            return NULL;
        }
        if (!PyByteArray_Check(bytes) || PyByteArray_Size(bytes) < sizeof(RGB32))
        {
            PyErr_SetString(PyExc_ValueError, "Not a reference to a usable struct");
            Py_XDECREF(self);
            Py_XDECREF(bytes);
            return NULL;
        }
        memcpy((void *)&(self->m_RGB32Struct), 
               (void *)PyByteArray_AsString(bytes),
               sizeof(RGB32));
    }
    return (PyObject*)self;
}

static void
PyRGB32StructObject_dealloc(PyRGB32StructObject* self)
{
    self->ob_type->tp_free(self);    
}

// Field Red: long

static PyObject*
RGB32StructMethod_get_Red(PyRGB32StructObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;

    // Initialize variables
    long lRed = 0;

    // Set up initial variable values as needed
    
    if (PyErr_Occurred())
        goto RGB32struct_get_Red_cleanup;

    lRed = (self->m_RGB32Struct).Red;

    // Set up return values as needed
    
    if (PyErr_Occurred())
        goto RGB32struct_get_Red_cleanup;

    // Initialize output tuple
    return_tuple = Py_BuildValue("l", lRed);

    RGB32struct_get_Red_cleanup:

    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in RGB32Struct.get_Red");
    return return_tuple;
}


static PyObject*
RGB32StructMethod_put_Red(PyRGB32StructObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;

    // Initialize variables
    long lRed = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lRed))
        goto RGB32struct_put_Red_cleanup;

    // Set up initial variable values as needed
    
    if (PyErr_Occurred())
        goto RGB32struct_put_Red_cleanup;

    (self->m_RGB32Struct).Red = lRed;

    // Set up return values as needed
    
    if (PyErr_Occurred())
        goto RGB32struct_put_Red_cleanup;

    // Initialize output tuple
    return_tuple = Py_None;
    Py_INCREF(Py_None);

    RGB32struct_put_Red_cleanup:

    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in RGB32Struct.put_Red");
    return return_tuple;
}

// Field Green: long

static PyObject*
RGB32StructMethod_get_Green(PyRGB32StructObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;

    // Initialize variables
    long lGreen = 0;

    // Set up initial variable values as needed
    
    if (PyErr_Occurred())
        goto RGB32struct_get_Green_cleanup;

    lGreen = (self->m_RGB32Struct).Green;

    // Set up return values as needed
    
    if (PyErr_Occurred())
        goto RGB32struct_get_Green_cleanup;

    // Initialize output tuple
    return_tuple = Py_BuildValue("l", lGreen);

    RGB32struct_get_Green_cleanup:

    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in RGB32Struct.get_Green");
    return return_tuple;
}


static PyObject*
RGB32StructMethod_put_Green(PyRGB32StructObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;

    // Initialize variables
    long lGreen = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lGreen))
        goto RGB32struct_put_Green_cleanup;

    // Set up initial variable values as needed
    
    if (PyErr_Occurred())
        goto RGB32struct_put_Green_cleanup;

    (self->m_RGB32Struct).Green = lGreen;

    // Set up return values as needed
    
    if (PyErr_Occurred())
        goto RGB32struct_put_Green_cleanup;

    // Initialize output tuple
    return_tuple = Py_None;
    Py_INCREF(Py_None);

    RGB32struct_put_Green_cleanup:

    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in RGB32Struct.put_Green");
    return return_tuple;
}

// Field Blue: long

static PyObject*
RGB32StructMethod_get_Blue(PyRGB32StructObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;

    // Initialize variables
    long lBlue = 0;

    // Set up initial variable values as needed
    
    if (PyErr_Occurred())
        goto RGB32struct_get_Blue_cleanup;

    lBlue = (self->m_RGB32Struct).Blue;

    // Set up return values as needed
    
    if (PyErr_Occurred())
        goto RGB32struct_get_Blue_cleanup;

    // Initialize output tuple
    return_tuple = Py_BuildValue("l", lBlue);

    RGB32struct_get_Blue_cleanup:

    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in RGB32Struct.get_Blue");
    return return_tuple;
}


static PyObject*
RGB32StructMethod_put_Blue(PyRGB32StructObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;

    // Initialize variables
    long lBlue = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lBlue))
        goto RGB32struct_put_Blue_cleanup;

    // Set up initial variable values as needed
    
    if (PyErr_Occurred())
        goto RGB32struct_put_Blue_cleanup;

    (self->m_RGB32Struct).Blue = lBlue;

    // Set up return values as needed
    
    if (PyErr_Occurred())
        goto RGB32struct_put_Blue_cleanup;

    // Initialize output tuple
    return_tuple = Py_None;
    Py_INCREF(Py_None);

    RGB32struct_put_Blue_cleanup:

    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in RGB32Struct.put_Blue");
    return return_tuple;
}


static PyObject*
PyRGB32_GetBytes(PyRGB32StructObject* self)
{
    return PyByteArray_FromStringAndSize((char*)&(self->m_RGB32Struct), sizeof(RGB32));
}

static int
PyRGB32_SetBytes(PyRGB32StructObject* self, PyObject* bytes, void*)
{
    if (!PyByteArray_Check(bytes) || PyByteArray_Size(bytes) < sizeof(RGB32))
    {
        PyErr_SetString(PyExc_ValueError, "Not a reference to a usable struct");
        return -1;
    }
    memcpy((void *)&(self->m_RGB32Struct), 
           (void *)PyByteArray_AsString(bytes),
           sizeof(RGB32));
    return 0;
}

PyMethodDef PyRGB32StructMethods[] = {
    {"get_Red", (PyCFunction)RGB32StructMethod_get_Red, METH_NOARGS, ""},
    {"put_Red", (PyCFunction)RGB32StructMethod_put_Red, METH_VARARGS, ""},
    {"get_Green", (PyCFunction)RGB32StructMethod_get_Green, METH_NOARGS, ""},
    {"put_Green", (PyCFunction)RGB32StructMethod_put_Green, METH_VARARGS, ""},
    {"get_Blue", (PyCFunction)RGB32StructMethod_get_Blue, METH_NOARGS, ""},
    {"put_Blue", (PyCFunction)RGB32StructMethod_put_Blue, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyRGB32StructGetSet[] = {
  {"_bytes", (getter)PyRGB32_GetBytes, (setter)PyRGB32_SetBytes, "Get a copy of the data used in this RGB32", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyRGB32StructObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriGeoDatabaseExtensions.RGB32StructObject",                          
                                              /* tp_name */
  sizeof(PyRGB32StructObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyRGB32StructObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "RGB32 Struct",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyRGB32StructMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyRGB32StructGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyRGB32StructObject_new,                      
                                              /* tp_new */
};



static PyObject*
CoCreateTerrainWorkspaceExtension(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_TerrainWorkspaceExtension, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of TerrainWorkspaceExtension");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("d472bd51-30dc-4e57-a5f6-469e92d934b3")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "d472bd51-30dc-4e57-a5f6-469e92d934b3");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateTerrainName(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_TerrainName, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of TerrainName");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("4ced9311-6566-44f6-b135-657d6f48143e")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "4ced9311-6566-44f6-b135-657d6f48143e");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateTerrainDataSource(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_TerrainDataSource, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of TerrainDataSource");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("2fbea8fd-19f5-4cc6-8d99-fb921fcae57d")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "2fbea8fd-19f5-4cc6-8d99-fb921fcae57d");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateTerrainPyramidLevelZTolerance(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_TerrainPyramidLevelZTolerance, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of TerrainPyramidLevelZTolerance");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("211d08c6-6f1d-490d-bb84-68e699b54a15")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "211d08c6-6f1d-490d-bb84-68e699b54a15");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateTerrainPyramidLevelWindowSize(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_TerrainPyramidLevelWindowSize, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of TerrainPyramidLevelWindowSize");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("47724afe-3fb9-4fc3-b96b-55f56ef9dede")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "47724afe-3fb9-4fc3-b96b-55f56ef9dede");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateDETerrain(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_DETerrain, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of DETerrain");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("546543b6-327a-4d3c-ac15-8122c8b6680a")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "546543b6-327a-4d3c-ac15-8122c8b6680a");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateTerrainLasDataImporter(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_TerrainLasDataImporter, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of TerrainLasDataImporter");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("e0879549-ca26-41ab-a9c6-463ec3b1b1ca")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "e0879549-ca26-41ab-a9c6-463ec3b1b1ca");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateTerrainAsciiDataImporter(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_TerrainAsciiDataImporter, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of TerrainAsciiDataImporter");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("eeb6b206-c144-496c-88d2-b6e2da4d37e7")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "eeb6b206-c144-496c-88d2-b6e2da4d37e7");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateTerrainBlobReader(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_TerrainBlobReader, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of TerrainBlobReader");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("564bba1a-9f3a-40c5-b4bf-e8e534388944")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "564bba1a-9f3a-40c5-b4bf-e8e534388944");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateTerrainBlobWriter(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_TerrainBlobWriter, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of TerrainBlobWriter");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("0ea06d19-aeec-4110-a231-2705a08b9366")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "0ea06d19-aeec-4110-a231-2705a08b9366");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateTerrainBlockCursor(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_TerrainBlockCursor, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of TerrainBlockCursor");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("ad220bb5-bd26-435e-9dbc-28fe5bac9171")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "ad220bb5-bd26-435e-9dbc-28fe5bac9171");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateTerrainFieldStatistics(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_TerrainFieldStatistics, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of TerrainFieldStatistics");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("ce7821b4-04ae-4518-842b-07d66ff6e605")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "ce7821b4-04ae-4518-842b-07d66ff6e605");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateGPTerrainMembership(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_GPTerrainMembership, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of GPTerrainMembership");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("242a9245-015f-4fdf-a16a-fae4d24b45d6")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "242a9245-015f-4fdf-a16a-fae4d24b45d6");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateDETerrainType(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_DETerrainType, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of DETerrainType");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("2d9d8047-6490-41e5-85da-ecb5926582a2")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "2d9d8047-6490-41e5-85da-ecb5926582a2");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateTerrainFeatureDatasetExtension(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_TerrainFeatureDatasetExtension, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of TerrainFeatureDatasetExtension");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("9a88d1b2-a418-4ad7-9107-fe41de647faf")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "9a88d1b2-a418-4ad7-9107-fe41de647faf");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateTerrain(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_Terrain, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of Terrain");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("ea9eb4a1-77b3-433c-a7dd-bb4436fa0e98")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "ea9eb4a1-77b3-433c-a7dd-bb4436fa0e98");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateDynamicSurface(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_DynamicSurface, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of DynamicSurface");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("7c3b1045-dfad-4f31-9d55-bf743da91648")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "7c3b1045-dfad-4f31-9d55-bf743da91648");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateLasDatasetWorkspaceFactory(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_LasDatasetWorkspaceFactory, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of LasDatasetWorkspaceFactory");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("7ab01d9a-fdfe-4dfb-9209-86603ee9aec6")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "7ab01d9a-fdfe-4dfb-9209-86603ee9aec6");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateLasDatasetName(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_LasDatasetName, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of LasDatasetName");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("2029a994-9bc0-4094-a1c7-e5381869e4e3")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "2029a994-9bc0-4094-a1c7-e5381869e4e3");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateLasDataset(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_LasDataset, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of LasDataset");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("711e7d01-2a82-4b7f-8d77-061c51baf8dd")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "711e7d01-2a82-4b7f-8d77-061c51baf8dd");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateLasFilter(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_LasFilter, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of LasFilter");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("6aa74d41-734b-4bad-87ea-245977e51ee1")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "6aa74d41-734b-4bad-87ea-245977e51ee1");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateLasPointInfo(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_LasPointInfo, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of LasPointInfo");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("fd112eb0-4a24-4135-ad29-98ec25e37821")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "fd112eb0-4a24-4135-ad29-98ec25e37821");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateLasHeaderInfo(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_LasHeaderInfo, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of LasHeaderInfo");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("8463e10e-689a-45c1-b468-f660b5ec1dd1")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "8463e10e-689a-45c1-b468-f660b5ec1dd1");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateLasFile(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_LasFile, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of LasFile");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("767b20c5-40c4-4875-a3d8-d6de321c62bf")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "767b20c5-40c4-4875-a3d8-d6de321c62bf");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateLasSurface(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_LasSurface, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of LasSurface");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("a83fb64e-0b76-43e0-b8ae-6c96a9913147")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "a83fb64e-0b76-43e0-b8ae-6c96a9913147");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateLasStatistics(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_LasStatistics, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of LasStatistics");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("a3cb49f5-6cdb-4911-bb7b-7e4b39c4d2ee")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "a3cb49f5-6cdb-4911-bb7b-7e4b39c4d2ee");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateLasAttributeStatistics(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_LasAttributeStatistics, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of LasAttributeStatistics");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("cbef81ba-43fd-4ae5-a235-7e69724bee49")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "cbef81ba-43fd-4ae5-a235-7e69724bee49");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateLasReturnStatistics(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_LasReturnStatistics, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of LasReturnStatistics");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("0135c452-608b-4831-9262-1c6c772f300e")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "0135c452-608b-4831-9262-1c6c772f300e");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateLasClassCodeStatistics(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_LasClassCodeStatistics, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of LasClassCodeStatistics");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("421e5140-a9be-4215-9357-c4a9852f8cab")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "421e5140-a9be-4215-9357-c4a9852f8cab");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateLasPointEnumerator(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_LasPointEnumerator, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of LasPointEnumerator");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("ddb996e0-31df-4d77-b903-5295e60ac459")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "ddb996e0-31df-4d77-b903-5295e60ac459");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateLasToRasterFunction(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_LasToRasterFunction, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of LasToRasterFunction");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("9889d8fb-93f6-49b1-b352-d8e2b331c797")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "9889d8fb-93f6-49b1-b352-d8e2b331c797");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateLasToRasterFunctionArguments(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_LasToRasterFunctionArguments, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of LasToRasterFunctionArguments");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("fb8e343b-8014-4ce9-b457-e72389d2b339")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "fb8e343b-8014-4ce9-b457-e72389d2b339");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateTerrainToRasterFunction(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_TerrainToRasterFunction, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of TerrainToRasterFunction");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("d4d3a0bb-3770-40ef-acf1-bb3c1c98a38e")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "d4d3a0bb-3770-40ef-acf1-bb3c1c98a38e");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateTerrainToRasterFunctionArguments(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_TerrainToRasterFunctionArguments, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of TerrainToRasterFunctionArguments");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("8bf576ca-96c8-4106-9020-a2d78d221dc4")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "8bf576ca-96c8-4106-9020-a2d78d221dc4");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateLasDatasetToRasterFunction(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_LasDatasetToRasterFunction, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of LasDatasetToRasterFunction");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("06a78a67-ba8a-4592-83e5-5dd4362f6636")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "06a78a67-ba8a-4592-83e5-5dd4362f6636");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateLasDatasetToRasterFunctionArguments(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_LasDatasetToRasterFunctionArguments, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of LasDatasetToRasterFunctionArguments");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("67876aa0-40eb-470a-abc9-036085756c53")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "67876aa0-40eb-470a-abc9-036085756c53");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateCadastralFabric(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_CadastralFabric, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of CadastralFabric");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("8081ca69-9711-4caf-bdd9-45daab4a4666")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "8081ca69-9711-4caf-bdd9-45daab4a4666");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateCadastralFabricName(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_CadastralFabricName, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of CadastralFabricName");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("5c947220-ffb5-4e71-a059-af201ae081a6")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "5c947220-ffb5-4e71-a059-af201ae081a6");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateCadastralWorkspaceDatasetExtension(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_CadastralWorkspaceDatasetExtension, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of CadastralWorkspaceDatasetExtension");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("be58e469-f14d-49c6-8080-0b027271ef91")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "be58e469-f14d-49c6-8080-0b027271ef91");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateDECadastralFabric(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_DECadastralFabric, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of DECadastralFabric");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("b0f868c0-bfbc-4669-b263-cd348d65d7ae")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "b0f868c0-bfbc-4669-b263-cd348d65d7ae");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateCadastralFabricFDExtension(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_CadastralFabricFDExtension, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of CadastralFabricFDExtension");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("0822e62d-8c8f-4483-8eb7-96dd0c343343")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "0822e62d-8c8f-4483-8eb7-96dd0c343343");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateCadastralJob(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_CadastralJob, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of CadastralJob");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("f8027b0a-a3fb-448a-8fe2-b1beadcf672e")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "f8027b0a-a3fb-448a-8fe2-b1beadcf672e");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateCadastralTransformationData(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_CadastralTransformationData, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of CadastralTransformationData");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("f0e92e5d-39fb-4ead-8192-1a027fab68c1")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "f0e92e5d-39fb-4ead-8192-1a027fab68c1");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateCadastralTableFieldEdits(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_CadastralTableFieldEdits, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of CadastralTableFieldEdits");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("dee35dfb-81a2-468e-aba8-2414e757a0d9")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "dee35dfb-81a2-468e-aba8-2414e757a0d9");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateDECadastralFabricType(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_DECadastralFabricType, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of DECadastralFabricType");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("931bf28c-b23d-4416-96ed-f653aa60524d")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "931bf28c-b23d-4416-96ed-f653aa60524d");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateParcelConstructionData(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_ParcelConstructionData, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of ParcelConstructionData");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("bcb1e8c9-1aa6-4012-aeaa-8fb4f62d85cb")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "bcb1e8c9-1aa6-4012-aeaa-8fb4f62d85cb");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateLineResequencer(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_LineResequencer, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of LineResequencer");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("dae9512c-77a7-4857-8624-225fc5294f46")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "dae9512c-77a7-4857-8624-225fc5294f46");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateCadastralFabricRegenerator(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_CadastralFabricRegenerator, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of CadastralFabricRegenerator");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("c3d97ce1-22f7-4f5a-942b-aa899f61ad34")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "c3d97ce1-22f7-4f5a-942b-aa899f61ad34");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateCadastralUnitConversion(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_CadastralUnitConversion, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of CadastralUnitConversion");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("c99a1138-f8b4-4113-862c-ec5407453301")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "c99a1138-f8b4-4113-862c-ec5407453301");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateCadastralDataTools(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_CadastralDataTools, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of CadastralDataTools");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("2faf44e5-2951-4021-a6e9-209fe3125a12")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "2faf44e5-2951-4021-a6e9-209fe3125a12");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyMethodDef _esriGeoDatabaseExtensionsMethods[] = {
    {"TerrainWorkspaceExtension", (PyCFunction)CoCreateTerrainWorkspaceExtension, METH_NOARGS,
     "Create instance of TerrainWorkspaceExtension\n"},
    {"TerrainName", (PyCFunction)CoCreateTerrainName, METH_NOARGS,
     "Create instance of TerrainName\n"},
    {"TerrainDataSource", (PyCFunction)CoCreateTerrainDataSource, METH_NOARGS,
     "Create instance of TerrainDataSource\n"},
    {"TerrainPyramidLevelZTolerance", (PyCFunction)CoCreateTerrainPyramidLevelZTolerance, METH_NOARGS,
     "Create instance of TerrainPyramidLevelZTolerance\n"},
    {"TerrainPyramidLevelWindowSize", (PyCFunction)CoCreateTerrainPyramidLevelWindowSize, METH_NOARGS,
     "Create instance of TerrainPyramidLevelWindowSize\n"},
    {"DETerrain", (PyCFunction)CoCreateDETerrain, METH_NOARGS,
     "Create instance of DETerrain\n"},
    {"TerrainLasDataImporter", (PyCFunction)CoCreateTerrainLasDataImporter, METH_NOARGS,
     "Create instance of TerrainLasDataImporter\n"},
    {"TerrainAsciiDataImporter", (PyCFunction)CoCreateTerrainAsciiDataImporter, METH_NOARGS,
     "Create instance of TerrainAsciiDataImporter\n"},
    {"TerrainBlobReader", (PyCFunction)CoCreateTerrainBlobReader, METH_NOARGS,
     "Create instance of TerrainBlobReader\n"},
    {"TerrainBlobWriter", (PyCFunction)CoCreateTerrainBlobWriter, METH_NOARGS,
     "Create instance of TerrainBlobWriter\n"},
    {"TerrainBlockCursor", (PyCFunction)CoCreateTerrainBlockCursor, METH_NOARGS,
     "Create instance of TerrainBlockCursor\n"},
    {"TerrainFieldStatistics", (PyCFunction)CoCreateTerrainFieldStatistics, METH_NOARGS,
     "Create instance of TerrainFieldStatistics\n"},
    {"GPTerrainMembership", (PyCFunction)CoCreateGPTerrainMembership, METH_NOARGS,
     "Create instance of GPTerrainMembership\n"},
    {"DETerrainType", (PyCFunction)CoCreateDETerrainType, METH_NOARGS,
     "Create instance of DETerrainType\n"},
    {"TerrainFeatureDatasetExtension", (PyCFunction)CoCreateTerrainFeatureDatasetExtension, METH_NOARGS,
     "Create instance of TerrainFeatureDatasetExtension\n"},
    {"Terrain", (PyCFunction)CoCreateTerrain, METH_NOARGS,
     "Create instance of Terrain\n"},
    {"DynamicSurface", (PyCFunction)CoCreateDynamicSurface, METH_NOARGS,
     "Create instance of DynamicSurface\n"},
    {"LasDatasetWorkspaceFactory", (PyCFunction)CoCreateLasDatasetWorkspaceFactory, METH_NOARGS,
     "Create instance of LasDatasetWorkspaceFactory\n"},
    {"LasDatasetName", (PyCFunction)CoCreateLasDatasetName, METH_NOARGS,
     "Create instance of LasDatasetName\n"},
    {"LasDataset", (PyCFunction)CoCreateLasDataset, METH_NOARGS,
     "Create instance of LasDataset\n"},
    {"LasFilter", (PyCFunction)CoCreateLasFilter, METH_NOARGS,
     "Create instance of LasFilter\n"},
    {"LasPointInfo", (PyCFunction)CoCreateLasPointInfo, METH_NOARGS,
     "Create instance of LasPointInfo\n"},
    {"LasHeaderInfo", (PyCFunction)CoCreateLasHeaderInfo, METH_NOARGS,
     "Create instance of LasHeaderInfo\n"},
    {"LasFile", (PyCFunction)CoCreateLasFile, METH_NOARGS,
     "Create instance of LasFile\n"},
    {"LasSurface", (PyCFunction)CoCreateLasSurface, METH_NOARGS,
     "Create instance of LasSurface\n"},
    {"LasStatistics", (PyCFunction)CoCreateLasStatistics, METH_NOARGS,
     "Create instance of LasStatistics\n"},
    {"LasAttributeStatistics", (PyCFunction)CoCreateLasAttributeStatistics, METH_NOARGS,
     "Create instance of LasAttributeStatistics\n"},
    {"LasReturnStatistics", (PyCFunction)CoCreateLasReturnStatistics, METH_NOARGS,
     "Create instance of LasReturnStatistics\n"},
    {"LasClassCodeStatistics", (PyCFunction)CoCreateLasClassCodeStatistics, METH_NOARGS,
     "Create instance of LasClassCodeStatistics\n"},
    {"LasPointEnumerator", (PyCFunction)CoCreateLasPointEnumerator, METH_NOARGS,
     "Create instance of LasPointEnumerator\n"},
    {"LasToRasterFunction", (PyCFunction)CoCreateLasToRasterFunction, METH_NOARGS,
     "Create instance of LasToRasterFunction\n"},
    {"LasToRasterFunctionArguments", (PyCFunction)CoCreateLasToRasterFunctionArguments, METH_NOARGS,
     "Create instance of LasToRasterFunctionArguments\n"},
    {"TerrainToRasterFunction", (PyCFunction)CoCreateTerrainToRasterFunction, METH_NOARGS,
     "Create instance of TerrainToRasterFunction\n"},
    {"TerrainToRasterFunctionArguments", (PyCFunction)CoCreateTerrainToRasterFunctionArguments, METH_NOARGS,
     "Create instance of TerrainToRasterFunctionArguments\n"},
    {"LasDatasetToRasterFunction", (PyCFunction)CoCreateLasDatasetToRasterFunction, METH_NOARGS,
     "Create instance of LasDatasetToRasterFunction\n"},
    {"LasDatasetToRasterFunctionArguments", (PyCFunction)CoCreateLasDatasetToRasterFunctionArguments, METH_NOARGS,
     "Create instance of LasDatasetToRasterFunctionArguments\n"},
    {"CadastralFabric", (PyCFunction)CoCreateCadastralFabric, METH_NOARGS,
     "Create instance of CadastralFabric\n"},
    {"CadastralFabricName", (PyCFunction)CoCreateCadastralFabricName, METH_NOARGS,
     "Create instance of CadastralFabricName\n"},
    {"CadastralWorkspaceDatasetExtension", (PyCFunction)CoCreateCadastralWorkspaceDatasetExtension, METH_NOARGS,
     "Create instance of CadastralWorkspaceDatasetExtension\n"},
    {"DECadastralFabric", (PyCFunction)CoCreateDECadastralFabric, METH_NOARGS,
     "Create instance of DECadastralFabric\n"},
    {"CadastralFabricFDExtension", (PyCFunction)CoCreateCadastralFabricFDExtension, METH_NOARGS,
     "Create instance of CadastralFabricFDExtension\n"},
    {"CadastralJob", (PyCFunction)CoCreateCadastralJob, METH_NOARGS,
     "Create instance of CadastralJob\n"},
    {"CadastralTransformationData", (PyCFunction)CoCreateCadastralTransformationData, METH_NOARGS,
     "Create instance of CadastralTransformationData\n"},
    {"CadastralTableFieldEdits", (PyCFunction)CoCreateCadastralTableFieldEdits, METH_NOARGS,
     "Create instance of CadastralTableFieldEdits\n"},
    {"DECadastralFabricType", (PyCFunction)CoCreateDECadastralFabricType, METH_NOARGS,
     "Create instance of DECadastralFabricType\n"},
    {"ParcelConstructionData", (PyCFunction)CoCreateParcelConstructionData, METH_NOARGS,
     "Create instance of ParcelConstructionData\n"},
    {"LineResequencer", (PyCFunction)CoCreateLineResequencer, METH_NOARGS,
     "Create instance of LineResequencer\n"},
    {"CadastralFabricRegenerator", (PyCFunction)CoCreateCadastralFabricRegenerator, METH_NOARGS,
     "Create instance of CadastralFabricRegenerator\n"},
    {"CadastralUnitConversion", (PyCFunction)CoCreateCadastralUnitConversion, METH_NOARGS,
     "Create instance of CadastralUnitConversion\n"},
    {"CadastralDataTools", (PyCFunction)CoCreateCadastralDataTools, METH_NOARGS,
     "Create instance of CadastralDataTools\n"},
    {NULL, NULL, 0, NULL}
};

extern "C" {

    PyMODINIT_FUNC
    init_esriGeoDatabaseExtensions(void)
    {
        // Import UUID module and keep a global pointer to the UUID object
        PyObject* uuid_module = PyImport_ImportModuleNoBlock("uuid");
        if (!uuid_module)
        {
            PyErr_SetString(PyExc_ImportError, "Could not import UUID module");
            return;
        }
        if (g_pUUID_type)
            Py_DECREF(g_pUUID_type);
        g_pUUID_type = PyObject_GetAttrString(uuid_module, "UUID");

        // Initialize module, make it show up in the right place
        PyObject* module;
        module = Py_InitModule3("cartocomutils._esriGeoDatabaseExtensions",
                                 _esriGeoDatabaseExtensionsMethods,
                                "Type library");
        Py_INCREF(module);

        // Add IUnknown base type to parent module so every typelib is using the same
        // Py_Type pointer when typechecking.
        PyObject* parent = PyImport_ImportModuleNoBlock("cartocomutils");
        if (parent)
        {
            if (!PyObject_HasAttrString(parent, "IUnknown"))
            {
                // Bootstrapping
                PyType_Ready(&IUnknownObject_Type);
                PyModule_AddObject(parent, "IUnknown", (PyObject*)(&IUnknownObject_Type));
                // Also probably means we need to coinitialize
                ::CoInitialize(NULL);
            }
            g_pUnk_type = PyObject_GetAttrString(parent, "IUnknown");
            if (!PyObject_HasAttrString(parent, "_IIDMap"))
                PyModule_AddObject(parent, "_IIDMap", PyDict_New());
            if (!PyObject_HasAttrString(parent, "_CLSIDMap"))
                PyModule_AddObject(parent, "_CLSIDMap", PyDict_New());
            g_pIIDMap = PyObject_GetAttrString(parent, "_IIDMap");
            Py_XINCREF(g_pIIDMap);
            // Set global unknown object
            if (g_pUnk_type && g_pIIDMap)
                PyDict_SetItem(g_pIIDMap, PyObject_CallFunction(g_pUUID_type, "s", "{00000000-0000-0000-C000-000000000046}"), g_pUnk_type);
            g_pCLSIDMap = PyObject_GetAttrString(parent, "_CLSIDMap");
            Py_XINCREF(g_pCLSIDMap);
            g_pRecordMap = PyObject_GetAttrString(parent, "_RecordMap");
            Py_XINCREF(g_pRecordMap);
            PyErr_Clear();
        }

        // Bulk add all interfaces as objects
        // IDETerrain
        PyType_Ready(&PyIDETerrainObject_Type);
        Py_INCREF((PyObject* )&PyIDETerrainObject_Type);
        PyModule_AddObject(module, "IDETerrain", 
                           (PyObject *)&PyIDETerrainObject_Type);

        // IDETerrainWindowSize
        PyType_Ready(&PyIDETerrainWindowSizeObject_Type);
        Py_INCREF((PyObject* )&PyIDETerrainWindowSizeObject_Type);
        PyModule_AddObject(module, "IDETerrainWindowSize", 
                           (PyObject *)&PyIDETerrainWindowSizeObject_Type);

        // ITerrainDataSource
        PyType_Ready(&PyITerrainDataSourceObject_Type);
        Py_INCREF((PyObject* )&PyITerrainDataSourceObject_Type);
        PyModule_AddObject(module, "ITerrainDataSource", 
                           (PyObject *)&PyITerrainDataSourceObject_Type);

        // ITerrainPyramidLevel
        PyType_Ready(&PyITerrainPyramidLevelObject_Type);
        Py_INCREF((PyObject* )&PyITerrainPyramidLevelObject_Type);
        PyModule_AddObject(module, "ITerrainPyramidLevel", 
                           (PyObject *)&PyITerrainPyramidLevelObject_Type);

        // IEnumEnvelope
        PyType_Ready(&PyIEnumEnvelopeObject_Type);
        Py_INCREF((PyObject* )&PyIEnumEnvelopeObject_Type);
        PyModule_AddObject(module, "IEnumEnvelope", 
                           (PyObject *)&PyIEnumEnvelopeObject_Type);

        // ITerrainEdit
        PyType_Ready(&PyITerrainEditObject_Type);
        Py_INCREF((PyObject* )&PyITerrainEditObject_Type);
        PyModule_AddObject(module, "ITerrainEdit", 
                           (PyObject *)&PyITerrainEditObject_Type);

        // ITerrainEdit2
        PyType_Ready(&PyITerrainEdit2Object_Type);
        Py_INCREF((PyObject* )&PyITerrainEdit2Object_Type);
        PyModule_AddObject(module, "ITerrainEdit2", 
                           (PyObject *)&PyITerrainEdit2Object_Type);

        // ITerrainEdit3
        PyType_Ready(&PyITerrainEdit3Object_Type);
        Py_INCREF((PyObject* )&PyITerrainEdit3Object_Type);
        PyModule_AddObject(module, "ITerrainEdit3", 
                           (PyObject *)&PyITerrainEdit3Object_Type);

        // ITerrainName
        PyType_Ready(&PyITerrainNameObject_Type);
        Py_INCREF((PyObject* )&PyITerrainNameObject_Type);
        PyModule_AddObject(module, "ITerrainName", 
                           (PyObject *)&PyITerrainNameObject_Type);

        // ITerrainDataSource2
        PyType_Ready(&PyITerrainDataSource2Object_Type);
        Py_INCREF((PyObject* )&PyITerrainDataSource2Object_Type);
        PyModule_AddObject(module, "ITerrainDataSource2", 
                           (PyObject *)&PyITerrainDataSource2Object_Type);

        // ITerrainEmbeddedDataSource
        PyType_Ready(&PyITerrainEmbeddedDataSourceObject_Type);
        Py_INCREF((PyObject* )&PyITerrainEmbeddedDataSourceObject_Type);
        PyModule_AddObject(module, "ITerrainEmbeddedDataSource", 
                           (PyObject *)&PyITerrainEmbeddedDataSourceObject_Type);

        // ITerrainFieldStatistics
        PyType_Ready(&PyITerrainFieldStatisticsObject_Type);
        Py_INCREF((PyObject* )&PyITerrainFieldStatisticsObject_Type);
        PyModule_AddObject(module, "ITerrainFieldStatistics", 
                           (PyObject *)&PyITerrainFieldStatisticsObject_Type);

        // ITerrainEmbeddedDataSource2
        PyType_Ready(&PyITerrainEmbeddedDataSource2Object_Type);
        Py_INCREF((PyObject* )&PyITerrainEmbeddedDataSource2Object_Type);
        PyModule_AddObject(module, "ITerrainEmbeddedDataSource2", 
                           (PyObject *)&PyITerrainEmbeddedDataSource2Object_Type);

        // ITerrainBlockCursor
        PyType_Ready(&PyITerrainBlockCursorObject_Type);
        Py_INCREF((PyObject* )&PyITerrainBlockCursorObject_Type);
        PyModule_AddObject(module, "ITerrainBlockCursor", 
                           (PyObject *)&PyITerrainBlockCursorObject_Type);

        // ITerrainDataImporter
        PyType_Ready(&PyITerrainDataImporterObject_Type);
        Py_INCREF((PyObject* )&PyITerrainDataImporterObject_Type);
        PyModule_AddObject(module, "ITerrainDataImporter", 
                           (PyObject *)&PyITerrainDataImporterObject_Type);

        // ITerrainLasDataImporter
        PyType_Ready(&PyITerrainLasDataImporterObject_Type);
        Py_INCREF((PyObject* )&PyITerrainLasDataImporterObject_Type);
        PyModule_AddObject(module, "ITerrainLasDataImporter", 
                           (PyObject *)&PyITerrainLasDataImporterObject_Type);

        // ITerrainAsciiDataImporter
        PyType_Ready(&PyITerrainAsciiDataImporterObject_Type);
        Py_INCREF((PyObject* )&PyITerrainAsciiDataImporterObject_Type);
        PyModule_AddObject(module, "ITerrainAsciiDataImporter", 
                           (PyObject *)&PyITerrainAsciiDataImporterObject_Type);

        // ITerrainAsciiDataImporter2
        PyType_Ready(&PyITerrainAsciiDataImporter2Object_Type);
        Py_INCREF((PyObject* )&PyITerrainAsciiDataImporter2Object_Type);
        PyModule_AddObject(module, "ITerrainAsciiDataImporter2", 
                           (PyObject *)&PyITerrainAsciiDataImporter2Object_Type);

        // ITerrainLasDataInfo
        PyType_Ready(&PyITerrainLasDataInfoObject_Type);
        Py_INCREF((PyObject* )&PyITerrainLasDataInfoObject_Type);
        PyModule_AddObject(module, "ITerrainLasDataInfo", 
                           (PyObject *)&PyITerrainLasDataInfoObject_Type);

        // ITerrainBlobReader
        PyType_Ready(&PyITerrainBlobReaderObject_Type);
        Py_INCREF((PyObject* )&PyITerrainBlobReaderObject_Type);
        PyModule_AddObject(module, "ITerrainBlobReader", 
                           (PyObject *)&PyITerrainBlobReaderObject_Type);

        // ITerrainBlobWriter
        PyType_Ready(&PyITerrainBlobWriterObject_Type);
        Py_INCREF((PyObject* )&PyITerrainBlobWriterObject_Type);
        PyModule_AddObject(module, "ITerrainBlobWriter", 
                           (PyObject *)&PyITerrainBlobWriterObject_Type);

        // ITerrainEditEvents
        PyType_Ready(&PyITerrainEditEventsObject_Type);
        Py_INCREF((PyObject* )&PyITerrainEditEventsObject_Type);
        PyModule_AddObject(module, "ITerrainEditEvents", 
                           (PyObject *)&PyITerrainEditEventsObject_Type);

        // ITerrainLasDataInfo2
        PyType_Ready(&PyITerrainLasDataInfo2Object_Type);
        Py_INCREF((PyObject* )&PyITerrainLasDataInfo2Object_Type);
        PyModule_AddObject(module, "ITerrainLasDataInfo2", 
                           (PyObject *)&PyITerrainLasDataInfo2Object_Type);

        // IGPTerrainMembership
        PyType_Ready(&PyIGPTerrainMembershipObject_Type);
        Py_INCREF((PyObject* )&PyIGPTerrainMembershipObject_Type);
        PyModule_AddObject(module, "IGPTerrainMembership", 
                           (PyObject *)&PyIGPTerrainMembershipObject_Type);

        // ISimpleStatistics
        PyType_Ready(&PyISimpleStatisticsObject_Type);
        Py_INCREF((PyObject* )&PyISimpleStatisticsObject_Type);
        PyModule_AddObject(module, "ISimpleStatistics", 
                           (PyObject *)&PyISimpleStatisticsObject_Type);

        // ILasReturnStatistics
        PyType_Ready(&PyILasReturnStatisticsObject_Type);
        Py_INCREF((PyObject* )&PyILasReturnStatisticsObject_Type);
        PyModule_AddObject(module, "ILasReturnStatistics", 
                           (PyObject *)&PyILasReturnStatisticsObject_Type);

        // ILasClassCodeStatistics
        PyType_Ready(&PyILasClassCodeStatisticsObject_Type);
        Py_INCREF((PyObject* )&PyILasClassCodeStatisticsObject_Type);
        PyModule_AddObject(module, "ILasClassCodeStatistics", 
                           (PyObject *)&PyILasClassCodeStatisticsObject_Type);

        // ILasStatistics
        PyType_Ready(&PyILasStatisticsObject_Type);
        Py_INCREF((PyObject* )&PyILasStatisticsObject_Type);
        PyModule_AddObject(module, "ILasStatistics", 
                           (PyObject *)&PyILasStatisticsObject_Type);

        // ILasHeaderInfo
        PyType_Ready(&PyILasHeaderInfoObject_Type);
        Py_INCREF((PyObject* )&PyILasHeaderInfoObject_Type);
        PyModule_AddObject(module, "ILasHeaderInfo", 
                           (PyObject *)&PyILasHeaderInfoObject_Type);

        // ILasFile
        PyType_Ready(&PyILasFileObject_Type);
        Py_INCREF((PyObject* )&PyILasFileObject_Type);
        PyModule_AddObject(module, "ILasFile", 
                           (PyObject *)&PyILasFileObject_Type);

        // ILasAttributeFilter
        PyType_Ready(&PyILasAttributeFilterObject_Type);
        Py_INCREF((PyObject* )&PyILasAttributeFilterObject_Type);
        PyModule_AddObject(module, "ILasAttributeFilter", 
                           (PyObject *)&PyILasAttributeFilterObject_Type);

        // ILasPointFilter
        PyType_Ready(&PyILasPointFilterObject_Type);
        Py_INCREF((PyObject* )&PyILasPointFilterObject_Type);
        PyModule_AddObject(module, "ILasPointFilter", 
                           (PyObject *)&PyILasPointFilterObject_Type);

        // ILasFilter
        PyType_Ready(&PyILasFilterObject_Type);
        Py_INCREF((PyObject* )&PyILasFilterObject_Type);
        PyModule_AddObject(module, "ILasFilter", 
                           (PyObject *)&PyILasFilterObject_Type);

        // ILasSurface
        PyType_Ready(&PyILasSurfaceObject_Type);
        Py_INCREF((PyObject* )&PyILasSurfaceObject_Type);
        PyModule_AddObject(module, "ILasSurface", 
                           (PyObject *)&PyILasSurfaceObject_Type);

        // ILasDataset
        PyType_Ready(&PyILasDatasetObject_Type);
        Py_INCREF((PyObject* )&PyILasDatasetObject_Type);
        PyModule_AddObject(module, "ILasDataset", 
                           (PyObject *)&PyILasDatasetObject_Type);

        // ILasDatasetEdit
        PyType_Ready(&PyILasDatasetEditObject_Type);
        Py_INCREF((PyObject* )&PyILasDatasetEditObject_Type);
        PyModule_AddObject(module, "ILasDatasetEdit", 
                           (PyObject *)&PyILasDatasetEditObject_Type);

        // IEnumLasPoint
        PyType_Ready(&PyIEnumLasPointObject_Type);
        Py_INCREF((PyObject* )&PyIEnumLasPointObject_Type);
        PyModule_AddObject(module, "IEnumLasPoint", 
                           (PyObject *)&PyIEnumLasPointObject_Type);

        // ILasPointInfo
        PyType_Ready(&PyILasPointInfoObject_Type);
        Py_INCREF((PyObject* )&PyILasPointInfoObject_Type);
        PyModule_AddObject(module, "ILasPointInfo", 
                           (PyObject *)&PyILasPointInfoObject_Type);

        // ILasPointCloud
        PyType_Ready(&PyILasPointCloudObject_Type);
        Py_INCREF((PyObject* )&PyILasPointCloudObject_Type);
        PyModule_AddObject(module, "ILasPointCloud", 
                           (PyObject *)&PyILasPointCloudObject_Type);

        // ILasDatasetWorkspace
        PyType_Ready(&PyILasDatasetWorkspaceObject_Type);
        Py_INCREF((PyObject* )&PyILasDatasetWorkspaceObject_Type);
        PyModule_AddObject(module, "ILasDatasetWorkspace", 
                           (PyObject *)&PyILasDatasetWorkspaceObject_Type);

        // ILasDataset2
        PyType_Ready(&PyILasDataset2Object_Type);
        Py_INCREF((PyObject* )&PyILasDataset2Object_Type);
        PyModule_AddObject(module, "ILasDataset2", 
                           (PyObject *)&PyILasDataset2Object_Type);

        // ILasPointEdit
        PyType_Ready(&PyILasPointEditObject_Type);
        Py_INCREF((PyObject* )&PyILasPointEditObject_Type);
        PyModule_AddObject(module, "ILasPointEdit", 
                           (PyObject *)&PyILasPointEditObject_Type);

        // ICadastralJob
        PyType_Ready(&PyICadastralJobObject_Type);
        Py_INCREF((PyObject* )&PyICadastralJobObject_Type);
        PyModule_AddObject(module, "ICadastralJob", 
                           (PyObject *)&PyICadastralJobObject_Type);

        // ICadastralFabric
        PyType_Ready(&PyICadastralFabricObject_Type);
        Py_INCREF((PyObject* )&PyICadastralFabricObject_Type);
        PyModule_AddObject(module, "ICadastralFabric", 
                           (PyObject *)&PyICadastralFabricObject_Type);

        // ICadastralFabric2
        PyType_Ready(&PyICadastralFabric2Object_Type);
        Py_INCREF((PyObject* )&PyICadastralFabric2Object_Type);
        PyModule_AddObject(module, "ICadastralFabric2", 
                           (PyObject *)&PyICadastralFabric2Object_Type);

        // ICadastralFabric3
        PyType_Ready(&PyICadastralFabric3Object_Type);
        Py_INCREF((PyObject* )&PyICadastralFabric3Object_Type);
        PyModule_AddObject(module, "ICadastralFabric3", 
                           (PyObject *)&PyICadastralFabric3Object_Type);

        // ICadastralFabricName
        PyType_Ready(&PyICadastralFabricNameObject_Type);
        Py_INCREF((PyObject* )&PyICadastralFabricNameObject_Type);
        PyModule_AddObject(module, "ICadastralFabricName", 
                           (PyObject *)&PyICadastralFabricNameObject_Type);

        // IDECadastralFabric
        PyType_Ready(&PyIDECadastralFabricObject_Type);
        Py_INCREF((PyObject* )&PyIDECadastralFabricObject_Type);
        PyModule_AddObject(module, "IDECadastralFabric", 
                           (PyObject *)&PyIDECadastralFabricObject_Type);

        // ICadastralTransformationData
        PyType_Ready(&PyICadastralTransformationDataObject_Type);
        Py_INCREF((PyObject* )&PyICadastralTransformationDataObject_Type);
        PyModule_AddObject(module, "ICadastralTransformationData", 
                           (PyObject *)&PyICadastralTransformationDataObject_Type);

        // ICadastralAdjustmentVectors
        PyType_Ready(&PyICadastralAdjustmentVectorsObject_Type);
        Py_INCREF((PyObject* )&PyICadastralAdjustmentVectorsObject_Type);
        PyModule_AddObject(module, "ICadastralAdjustmentVectors", 
                           (PyObject *)&PyICadastralAdjustmentVectorsObject_Type);

        // ICadastralFabricLocks
        PyType_Ready(&PyICadastralFabricLocksObject_Type);
        Py_INCREF((PyObject* )&PyICadastralFabricLocksObject_Type);
        PyModule_AddObject(module, "ICadastralFabricLocks", 
                           (PyObject *)&PyICadastralFabricLocksObject_Type);

        // ICadastralFabricLocks2
        PyType_Ready(&PyICadastralFabricLocks2Object_Type);
        Py_INCREF((PyObject* )&PyICadastralFabricLocks2Object_Type);
        PyModule_AddObject(module, "ICadastralFabricLocks2", 
                           (PyObject *)&PyICadastralFabricLocks2Object_Type);

        // ICadastralFabricSchemaEdit
        PyType_Ready(&PyICadastralFabricSchemaEditObject_Type);
        Py_INCREF((PyObject* )&PyICadastralFabricSchemaEditObject_Type);
        PyModule_AddObject(module, "ICadastralFabricSchemaEdit", 
                           (PyObject *)&PyICadastralFabricSchemaEditObject_Type);

        // ICadastralFabricSchemaEdit2
        PyType_Ready(&PyICadastralFabricSchemaEdit2Object_Type);
        Py_INCREF((PyObject* )&PyICadastralFabricSchemaEdit2Object_Type);
        PyModule_AddObject(module, "ICadastralFabricSchemaEdit2", 
                           (PyObject *)&PyICadastralFabricSchemaEdit2Object_Type);

        // ICadastralTableFieldEdits
        PyType_Ready(&PyICadastralTableFieldEditsObject_Type);
        Py_INCREF((PyObject* )&PyICadastralTableFieldEditsObject_Type);
        PyModule_AddObject(module, "ICadastralTableFieldEdits", 
                           (PyObject *)&PyICadastralTableFieldEditsObject_Type);

        // IDECadastralFabric2
        PyType_Ready(&PyIDECadastralFabric2Object_Type);
        Py_INCREF((PyObject* )&PyIDECadastralFabric2Object_Type);
        PyModule_AddObject(module, "IDECadastralFabric2", 
                           (PyObject *)&PyIDECadastralFabric2Object_Type);

        // IDECadastralFabric3
        PyType_Ready(&PyIDECadastralFabric3Object_Type);
        Py_INCREF((PyObject* )&PyIDECadastralFabric3Object_Type);
        PyModule_AddObject(module, "IDECadastralFabric3", 
                           (PyObject *)&PyIDECadastralFabric3Object_Type);

        // IParcelConstructionData
        PyType_Ready(&PyIParcelConstructionDataObject_Type);
        Py_INCREF((PyObject* )&PyIParcelConstructionDataObject_Type);
        PyModule_AddObject(module, "IParcelConstructionData", 
                           (PyObject *)&PyIParcelConstructionDataObject_Type);

        // IConstructionParentParcels
        PyType_Ready(&PyIConstructionParentParcelsObject_Type);
        Py_INCREF((PyObject* )&PyIConstructionParentParcelsObject_Type);
        PyModule_AddObject(module, "IConstructionParentParcels", 
                           (PyObject *)&PyIConstructionParentParcelsObject_Type);

        // IConstructionBreakPoints
        PyType_Ready(&PyIConstructionBreakPointsObject_Type);
        Py_INCREF((PyObject* )&PyIConstructionBreakPointsObject_Type);
        PyModule_AddObject(module, "IConstructionBreakPoints", 
                           (PyObject *)&PyIConstructionBreakPointsObject_Type);

        // IConstructionBasisOfBearing
        PyType_Ready(&PyIConstructionBasisOfBearingObject_Type);
        Py_INCREF((PyObject* )&PyIConstructionBasisOfBearingObject_Type);
        PyModule_AddObject(module, "IConstructionBasisOfBearing", 
                           (PyObject *)&PyIConstructionBasisOfBearingObject_Type);

        // IConstructionJoinLinks
        PyType_Ready(&PyIConstructionJoinLinksObject_Type);
        Py_INCREF((PyObject* )&PyIConstructionJoinLinksObject_Type);
        PyModule_AddObject(module, "IConstructionJoinLinks", 
                           (PyObject *)&PyIConstructionJoinLinksObject_Type);

        // IConstructionUnbuildableLines
        PyType_Ready(&PyIConstructionUnbuildableLinesObject_Type);
        Py_INCREF((PyObject* )&PyIConstructionUnbuildableLinesObject_Type);
        PyModule_AddObject(module, "IConstructionUnbuildableLines", 
                           (PyObject *)&PyIConstructionUnbuildableLinesObject_Type);

        // IConstructionPoints
        PyType_Ready(&PyIConstructionPointsObject_Type);
        Py_INCREF((PyObject* )&PyIConstructionPointsObject_Type);
        PyModule_AddObject(module, "IConstructionPoints", 
                           (PyObject *)&PyIConstructionPointsObject_Type);

        // IConstructionAdjustment
        PyType_Ready(&PyIConstructionAdjustmentObject_Type);
        Py_INCREF((PyObject* )&PyIConstructionAdjustmentObject_Type);
        PyModule_AddObject(module, "IConstructionAdjustment", 
                           (PyObject *)&PyIConstructionAdjustmentObject_Type);

        // ILineResequencer
        PyType_Ready(&PyILineResequencerObject_Type);
        Py_INCREF((PyObject* )&PyILineResequencerObject_Type);
        PyModule_AddObject(module, "ILineResequencer", 
                           (PyObject *)&PyILineResequencerObject_Type);

        // ICadastralFabricRegeneration
        PyType_Ready(&PyICadastralFabricRegenerationObject_Type);
        Py_INCREF((PyObject* )&PyICadastralFabricRegenerationObject_Type);
        PyModule_AddObject(module, "ICadastralFabricRegeneration", 
                           (PyObject *)&PyICadastralFabricRegenerationObject_Type);

        // ICadastralUnitConversion
        PyType_Ready(&PyICadastralUnitConversionObject_Type);
        Py_INCREF((PyObject* )&PyICadastralUnitConversionObject_Type);
        PyModule_AddObject(module, "ICadastralUnitConversion", 
                           (PyObject *)&PyICadastralUnitConversionObject_Type);

        // ICadastralGroundToGridTools
        PyType_Ready(&PyICadastralGroundToGridToolsObject_Type);
        Py_INCREF((PyObject* )&PyICadastralGroundToGridToolsObject_Type);
        PyModule_AddObject(module, "ICadastralGroundToGridTools", 
                           (PyObject *)&PyICadastralGroundToGridToolsObject_Type);

        // ICadastralUnitTools
        PyType_Ready(&PyICadastralUnitToolsObject_Type);
        Py_INCREF((PyObject* )&PyICadastralUnitToolsObject_Type);
        PyModule_AddObject(module, "ICadastralUnitTools", 
                           (PyObject *)&PyICadastralUnitToolsObject_Type);

        // ICadastralFabricEditControl
        PyType_Ready(&PyICadastralFabricEditControlObject_Type);
        Py_INCREF((PyObject* )&PyICadastralFabricEditControlObject_Type);
        PyModule_AddObject(module, "ICadastralFabricEditControl", 
                           (PyObject *)&PyICadastralFabricEditControlObject_Type);

        // IDataMessage
        PyType_Ready(&PyIDataMessageObject_Type);
        Py_INCREF((PyObject* )&PyIDataMessageObject_Type);
        PyModule_AddObject(module, "IDataMessage", 
                           (PyObject *)&PyIDataMessageObject_Type);

        // ITemporalOperator
        PyType_Ready(&PyITemporalOperatorObject_Type);
        Py_INCREF((PyObject* )&PyITemporalOperatorObject_Type);
        PyModule_AddObject(module, "ITemporalOperator", 
                           (PyObject *)&PyITemporalOperatorObject_Type);

        // ITrackingServiceDef
        PyType_Ready(&PyITrackingServiceDefObject_Type);
        Py_INCREF((PyObject* )&PyITrackingServiceDefObject_Type);
        PyModule_AddObject(module, "ITrackingServiceDef", 
                           (PyObject *)&PyITrackingServiceDefObject_Type);

        // _ITemporalFeatureClassEvents
        PyType_Ready(&Py_ITemporalFeatureClassEventsObject_Type);
        Py_INCREF((PyObject* )&Py_ITemporalFeatureClassEventsObject_Type);
        PyModule_AddObject(module, "_ITemporalFeatureClassEvents", 
                           (PyObject *)&Py_ITemporalFeatureClassEventsObject_Type);

        // ITemporalFeatureClass2
        PyType_Ready(&PyITemporalFeatureClass2Object_Type);
        Py_INCREF((PyObject* )&PyITemporalFeatureClass2Object_Type);
        PyModule_AddObject(module, "ITemporalFeatureClass2", 
                           (PyObject *)&PyITemporalFeatureClass2Object_Type);

        // ITemporalTable
        PyType_Ready(&PyITemporalTableObject_Type);
        Py_INCREF((PyObject* )&PyITemporalTableObject_Type);
        PyModule_AddObject(module, "ITemporalTable", 
                           (PyObject *)&PyITemporalTableObject_Type);

        // IInternalTable
        PyType_Ready(&PyIInternalTableObject_Type);
        Py_INCREF((PyObject* )&PyIInternalTableObject_Type);
        PyModule_AddObject(module, "IInternalTable", 
                           (PyObject *)&PyIInternalTableObject_Type);

        // ITemporalObservationsTable
        PyType_Ready(&PyITemporalObservationsTableObject_Type);
        Py_INCREF((PyObject* )&PyITemporalObservationsTableObject_Type);
        PyModule_AddObject(module, "ITemporalObservationsTable", 
                           (PyObject *)&PyITemporalObservationsTableObject_Type);

        // ITemporalObjectTable
        PyType_Ready(&PyITemporalObjectTableObject_Type);
        Py_INCREF((PyObject* )&PyITemporalObjectTableObject_Type);
        PyModule_AddObject(module, "ITemporalObjectTable", 
                           (PyObject *)&PyITemporalObjectTableObject_Type);

        // ITemporalObservationsTable2
        PyType_Ready(&PyITemporalObservationsTable2Object_Type);
        Py_INCREF((PyObject* )&PyITemporalObservationsTable2Object_Type);
        PyModule_AddObject(module, "ITemporalObservationsTable2", 
                           (PyObject *)&PyITemporalObservationsTable2Object_Type);

        // IExcludedEventIDs
        PyType_Ready(&PyIExcludedEventIDsObject_Type);
        Py_INCREF((PyObject* )&PyIExcludedEventIDsObject_Type);
        PyModule_AddObject(module, "IExcludedEventIDs", 
                           (PyObject *)&PyIExcludedEventIDsObject_Type);

        // ITemporalQueryFilter
        PyType_Ready(&PyITemporalQueryFilterObject_Type);
        Py_INCREF((PyObject* )&PyITemporalQueryFilterObject_Type);
        PyModule_AddObject(module, "ITemporalQueryFilter", 
                           (PyObject *)&PyITemporalQueryFilterObject_Type);

        // ITemporalQueryFilter2
        PyType_Ready(&PyITemporalQueryFilter2Object_Type);
        Py_INCREF((PyObject* )&PyITemporalQueryFilter2Object_Type);
        PyModule_AddObject(module, "ITemporalQueryFilter2", 
                           (PyObject *)&PyITemporalQueryFilter2Object_Type);

        // IListener
        PyType_Ready(&PyIListenerObject_Type);
        Py_INCREF((PyObject* )&PyIListenerObject_Type);
        PyModule_AddObject(module, "IListener", 
                           (PyObject *)&PyIListenerObject_Type);

        // ITemporalFeature
        PyType_Ready(&PyITemporalFeatureObject_Type);
        Py_INCREF((PyObject* )&PyITemporalFeatureObject_Type);
        PyModule_AddObject(module, "ITemporalFeature", 
                           (PyObject *)&PyITemporalFeatureObject_Type);

        // IAMSDatasetName
        PyType_Ready(&PyIAMSDatasetNameObject_Type);
        Py_INCREF((PyObject* )&PyIAMSDatasetNameObject_Type);
        PyModule_AddObject(module, "IAMSDatasetName", 
                           (PyObject *)&PyIAMSDatasetNameObject_Type);

        // ITemporalFeatureClassStatistics
        PyType_Ready(&PyITemporalFeatureClassStatisticsObject_Type);
        Py_INCREF((PyObject* )&PyITemporalFeatureClassStatisticsObject_Type);
        PyModule_AddObject(module, "ITemporalFeatureClassStatistics", 
                           (PyObject *)&PyITemporalFeatureClassStatisticsObject_Type);

        // ITemporalWorkspaceStatistics
        PyType_Ready(&PyITemporalWorkspaceStatisticsObject_Type);
        Py_INCREF((PyObject* )&PyITemporalWorkspaceStatisticsObject_Type);
        PyModule_AddObject(module, "ITemporalWorkspaceStatistics", 
                           (PyObject *)&PyITemporalWorkspaceStatisticsObject_Type);

        // ITemporalWorkspaceStatistics2
        PyType_Ready(&PyITemporalWorkspaceStatistics2Object_Type);
        Py_INCREF((PyObject* )&PyITemporalWorkspaceStatistics2Object_Type);
        PyModule_AddObject(module, "ITemporalWorkspaceStatistics2", 
                           (PyObject *)&PyITemporalWorkspaceStatistics2Object_Type);

        // ILockedFeatureSearch
        PyType_Ready(&PyILockedFeatureSearchObject_Type);
        Py_INCREF((PyObject* )&PyILockedFeatureSearchObject_Type);
        PyModule_AddObject(module, "ILockedFeatureSearch", 
                           (PyObject *)&PyILockedFeatureSearchObject_Type);

        // ITxWorkspaceEditor
        PyType_Ready(&PyITxWorkspaceEditorObject_Type);
        Py_INCREF((PyObject* )&PyITxWorkspaceEditorObject_Type);
        PyModule_AddObject(module, "ITxWorkspaceEditor", 
                           (PyObject *)&PyITxWorkspaceEditorObject_Type);

        // ITemporalRecordSet
        PyType_Ready(&PyITemporalRecordSetObject_Type);
        Py_INCREF((PyObject* )&PyITemporalRecordSetObject_Type);
        PyModule_AddObject(module, "ITemporalRecordSet", 
                           (PyObject *)&PyITemporalRecordSetObject_Type);

        // ITxFeatureClass
        PyType_Ready(&PyITxFeatureClassObject_Type);
        Py_INCREF((PyObject* )&PyITxFeatureClassObject_Type);
        PyModule_AddObject(module, "ITxFeatureClass", 
                           (PyObject *)&PyITxFeatureClassObject_Type);

        // ITxEnumTrackId
        PyType_Ready(&PyITxEnumTrackIdObject_Type);
        Py_INCREF((PyObject* )&PyITxEnumTrackIdObject_Type);
        PyModule_AddObject(module, "ITxEnumTrackId", 
                           (PyObject *)&PyITxEnumTrackIdObject_Type);

        // ITemporalCursor
        PyType_Ready(&PyITemporalCursorObject_Type);
        Py_INCREF((PyObject* )&PyITemporalCursorObject_Type);
        PyModule_AddObject(module, "ITemporalCursor", 
                           (PyObject *)&PyITemporalCursorObject_Type);

        // ITerrain
        PyType_Ready(&PyITerrainObject_Type);
        Py_INCREF((PyObject* )&PyITerrainObject_Type);
        PyModule_AddObject(module, "ITerrain", 
                           (PyObject *)&PyITerrainObject_Type);

        // IDynamicSurface
        PyType_Ready(&PyIDynamicSurfaceObject_Type);
        Py_INCREF((PyObject* )&PyIDynamicSurfaceObject_Type);
        PyModule_AddObject(module, "IDynamicSurface", 
                           (PyObject *)&PyIDynamicSurfaceObject_Type);

        // ITerrain2
        PyType_Ready(&PyITerrain2Object_Type);
        Py_INCREF((PyObject* )&PyITerrain2Object_Type);
        PyModule_AddObject(module, "ITerrain2", 
                           (PyObject *)&PyITerrain2Object_Type);

        // IDynamicSurface2
        PyType_Ready(&PyIDynamicSurface2Object_Type);
        Py_INCREF((PyObject* )&PyIDynamicSurface2Object_Type);
        PyModule_AddObject(module, "IDynamicSurface2", 
                           (PyObject *)&PyIDynamicSurface2Object_Type);

        // IDynamicSurface3
        PyType_Ready(&PyIDynamicSurface3Object_Type);
        Py_INCREF((PyObject* )&PyIDynamicSurface3Object_Type);
        PyModule_AddObject(module, "IDynamicSurface3", 
                           (PyObject *)&PyIDynamicSurface3Object_Type);
        // RGB32
        PyType_Ready(&PyRGB32StructObject_Type);
        Py_INCREF((PyObject* )&PyRGB32StructObject_Type);
        PyModule_AddObject(module, "RGB32", 
                           (PyObject *)&PyRGB32StructObject_Type);


        // Bulk add all the IID_* CLSID_* from this type lib
        if (g_pUUID_type)
        {
            // guids registration for interfaces
            if (g_pIIDMap)
            {
// Disabled for now, done in the .py file
            }

            // clsids registration for known coclasses
            if (g_pCLSIDMap)
            {
// Disabled for now, done in the .py file
            }
        }
        Py_XDECREF(g_pIIDMap);
        Py_XDECREF(g_pCLSIDMap);
    }

}
