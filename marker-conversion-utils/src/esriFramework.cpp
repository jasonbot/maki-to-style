// This source is all automatically generated. Editing it may very
// well be an exercise in futility and frustration.
#include "Python.h"
#include "datetime.h"

// imports
#import "c:\Program Files (x86)\Common Files\ArcGIS\bin\ArcGISVersion.dll" raw_interfaces_only, raw_native_types, no_namespace, named_guids, rename("esriProductCode", "esriVersionProductCode"), rename("VersionManager", "ArcGISVersionManager")
#import "C:\Program Files (x86)\ArcGIS\Desktop10.2\com\esriSystem.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids, exclude("OLE_COLOR", "OLE_HANDLE", "VARTYPE")
#import "C:\Program Files (x86)\ArcGIS\Desktop10.2\com\esriSystemUI.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "C:\Program Files (x86)\ArcGIS\Desktop10.2\com\esriGeometry.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "C:\Program Files (x86)\ArcGIS\Desktop10.2\com\esriGraphicsCore.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "C:\Program Files (x86)\ArcGIS\Desktop10.2\com\esriGraphicsSymbols.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "C:\Program Files (x86)\ArcGIS\Desktop10.2\com\esriDisplay.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "C:\Program Files (x86)\ArcGIS\Desktop10.2\com\esriServer.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "C:\Program Files (x86)\ArcGIS\Desktop10.2\com\esriGeoDatabase.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "C:\Program Files (x86)\ArcGIS\Desktop10.2\com\esriGISClient.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids
#import "C:\Program Files (x86)\ArcGIS\Desktop10.2\com\esriCarto.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids, exclude("UINT_PTR")
#import "C:\Program Files (x86)\ArcGIS\Desktop10.2\com\esriFramework.olb" raw_interfaces_only, raw_native_types, no_namespace, named_guids, exclude("UINT_PTR")


// Globals we need to keep around -- a reference to the UUID class for mapping
// GUIDs to Python-usable UUIDs and the IUnknown type we'll be using across the
// board.
static PyObject* g_pUUID_type = NULL;
static PyObject* g_pUnk_type = NULL;
static PyObject* g_pIIDMap = NULL;
static PyObject* g_pCLSIDMap = NULL;
static PyObject* g_pRecordMap = NULL;

// PyObject destructor for PyCObjects that hold IUnknown* in them
static void
destr_unknown(void* pvUnk)
{
    IUnknown* pUnk = (IUnknown*)pvUnk;
    if (pUnk)
        pUnk->Release();
}

// Checker/caster to see if we can get a GUID from a Python object, either
// by  checking if the object is an instance of the uuid.UUID type, or if
// it is a string, coercing it with the constructor and seeing if it accepts
// it.
//
// def GuidFromPyObject(potentialIID, GUID*):
//     if isinstance(potentialIID, basestring):
//         try:
//             potentialIID = uuid.UUID(potentialIID)
//         except:
//             return False
//     if isinstance(potentialIID, uuid.UUID):
//         if (<copy raw bytes of UUID data in object to out GUID*>):
//             return True
//     return False
//
static bool
GuidFromPyObject(PyObject* potentialIID, GUID* pOutGUID)
{
    if (!g_pUUID_type)
        return false;

    // See if we can cast a string into a UUID instance, if that's what we've got.
    if (PyString_Check(potentialIID) || PyUnicode_Check(potentialIID))
    {
        PyObject* piid_object = PyObject_CallFunction(g_pUUID_type, "O", potentialIID);
        bool retval = (piid_object)?GuidFromPyObject(piid_object, pOutGUID): false;
        Py_XDECREF(piid_object);
        if (!piid_object || PyErr_Occurred())
        {
            PyErr_Clear();
            PyObject* unicodearg = NULL;
            if (PyString_Check(potentialIID))
                unicodearg = PyUnicode_FromObject(potentialIID);
            else if (PyUnicode_Check(potentialIID))
            {
                unicodearg = potentialIID;
                Py_INCREF(unicodearg);
            }
            if (unicodearg)
            {
                BSTR classname = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodearg),
                                                     (UINT)PyUnicode_GET_SIZE(unicodearg));
                CLSID clsid;
                if (CLSIDFromProgID(classname, &clsid) == S_OK)
                {
                    retval = true;
                    if (memcpy_s((void *)pOutGUID, sizeof(GUID), (void *)&clsid, 16))
                        retval = false;
                }
                ::SysFreeString(classname);
            }
            Py_XDECREF(unicodearg);
        }
        return retval;
    }
    else if (PyObject_IsInstance(potentialIID, g_pUUID_type))
    {
        // Fetch raw bytes string -- need to fetch "bytes" on big-endian, 
        // "bytes_le" on little-endian architectures
        const int i = 1;
        PyObject* pBytes = NULL;
        if ( (*(char*)&i) == 0 )        
            pBytes = PyObject_GetAttrString(potentialIID, "bytes");
        else
            pBytes = PyObject_GetAttrString(potentialIID, "bytes_le");
        if (pBytes)
        {
            bool retval = true;
            // Pointer to raw data
            char* pRawBytes = PyString_AsString(pBytes);
            if (memcpy_s((void *)pOutGUID, sizeof(GUID), (void *)pRawBytes, 16))
                retval = false;
            Py_XDECREF(pBytes);
            return retval;
        }
        PyErr_Clear();
    }
    return false;
}

static PyObject*
GUIDToPythonUUID(const GUID* UUID)
{
    if (UUID)
    {
        // Lie to Python and tell it that our GUID is a 16-byte string
        PyObject* PyUUIDString = PyString_FromStringAndSize((char *)UUID, sizeof(GUID));
        if (!PyUUIDString)
            return NULL;
        // Args, varargs
        PyObject* PyArgs = PyTuple_New(0);
        PyObject* PyKWArgs = PyDict_New();
        PyObject* RetVal = NULL;
        // Dict with single value: the keyword argument bytes_le.
        const int i = 1;
        PyObject* pBytes = NULL;
        if ( (*(char*)&i) == 0 )
            PyDict_SetItemString(PyKWArgs, "bytes", PyUUIDString);
        else
            PyDict_SetItemString(PyKWArgs, "bytes_le", PyUUIDString);
        // New UUID with KW
        if (g_pUUID_type)
            RetVal = PyObject_Call(g_pUUID_type, PyArgs, PyKWArgs);
        else
            PyErr_SetString(PyExc_ImportError, "UUID module import failed");

        Py_DECREF(PyUUIDString);
        Py_DECREF(PyArgs);
        Py_DECREF(PyKWArgs);
        return RetVal;
    }
    else
    {
        PyErr_SetString(PyExc_ValueError, "Bad GUID");
        return NULL;
    }
}

static PyObject*
IUnknownToPythonIIDObject(IUnknown* pUnk, const GUID* IID)
{
    PyObject* RetVal = NULL;
    pUnk->AddRef();
    PyObject* PyUnk = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    //return PyUnk;

    PyObject* pCall = NULL;

    PyObject* pGuidObject = GUIDToPythonUUID(IID);
    if (!pGuidObject || !g_pIIDMap)
        return PyUnk;

    if (PyDict_Contains(g_pIIDMap, pGuidObject) == 1)
        pCall = PyDict_GetItem(g_pIIDMap, pGuidObject);
    if (!pCall)
        pCall = g_pUnk_type;
    if (pCall)
        RetVal = PyObject_CallFunction(pCall, "O", PyUnk);

    if (!RetVal)
        RetVal = PyUnk;
    else
        Py_DECREF(PyUnk);

    Py_XDECREF(pGuidObject);
    return RetVal;
}

static PyObject*
DATE_AsPyObject(DATE in_date)
{
  PyDateTime_IMPORT;
  // Round to even number of days
  int days = (int)in_date;
  // Convert what's left (after the decimal) to seconds; 86400 seconds per day.
  int seconds = (int)((in_date - (double)days) * 86400.0);
  if (in_date < 0)
    seconds *= -1;
  // TimeDelta to add to the date representing the start of all Variant VT_DATEs
  PyObject* pDelta = PyDelta_FromDSU(days, seconds, 0);
  // Midnight 30 December 1899
  PyObject* pStartOfVariantTime = PyDateTime_FromDateAndTime(1899, 12, 30, 0, 0, 0, 0);
  // Do addition of computed delta to 1899-12-30 00:00:00
  PyObject* pRetVal = PyObject_CallMethod(pStartOfVariantTime, "__add__", "O", pDelta);

  Py_XDECREF(pDelta);
  Py_XDECREF(pStartOfVariantTime);

  return pRetVal;
}

static DATE
PyObject_AsDATE(PyObject* in_date)
{
  PyDateTime_IMPORT;
  if (!PyDateTime_Check(in_date))
  {
    PyErr_SetString(PyExc_ValueError, "Cannot convert this Python object to a datetime");
    return (DATE)0.0;
  }

  double out_date;

  PyObject* pStartOfVariantTime = PyDateTime_FromDateAndTime(1899, 12, 30, 0, 0, 0, 0);
  PyDateTime_Delta* pDelta = (PyDateTime_Delta *)PyObject_CallMethod(in_date, "__sub__", "O", pStartOfVariantTime);
  Py_XDECREF(pStartOfVariantTime);
  
  if (pDelta && PyDelta_Check((PyObject *)pDelta))
  {
    out_date = (double)pDelta->days;
    out_date += (double)(pDelta->seconds) / 86400.0;
  }
  
  Py_XDECREF(pDelta);
  return (DATE)out_date;
}

static bool
PyObject_AsVariant(PyObject* in_object, VARIANT* out_variant)
{
  ::VariantClear(out_variant);
  PyDateTime_IMPORT;

  if (in_object == Py_None)
    return true;
  else if (PyUnicode_Check(in_object))
  {
    out_variant->vt = VT_BSTR;
    BSTR out_string = ::SysAllocStringLen(PyUnicode_AS_UNICODE(in_object), 
                                          (UINT)PyUnicode_GET_SIZE(in_object));
    out_variant->bstrVal = out_string;
    return true;
  }
  else if (PyString_Check(in_object))
  {
    PyObject* pUnicode = PyUnicode_FromObject(in_object);
    if (pUnicode)
    {
      out_variant->vt = VT_BSTR;
      BSTR out_string = ::SysAllocStringLen(PyUnicode_AS_UNICODE(pUnicode), 
                                            (UINT)PyUnicode_GET_SIZE(pUnicode));
      out_variant->bstrVal = out_string;
      Py_DECREF(pUnicode);
      return true;
    }
    return false;
  }
  else if (PyFloat_Check(in_object))
  {
    out_variant->vt = VT_R8;
    out_variant->dblVal = PyFloat_AsDouble(in_object);
    return true;
  }
  else if (PyInt_Check(in_object))
  {
    out_variant->vt = VT_I8;
    out_variant->llVal = PyInt_AsLong(in_object);
    return true;
  }
  else if (PyLong_Check(in_object))
  {
    out_variant->vt = VT_I8;
    out_variant->llVal = PyLong_AsLongLong(in_object);
    if (PyErr_Occurred())
    {
      PyErr_Clear();
      PyObject* strval = PyObject_Str(in_object);
      if (strval)
      {
        PyObject* unival = PyUnicode_FromObject(strval);
        out_variant->vt = VT_BSTR;
        BSTR out_string = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unival), 
                                              (UINT)PyUnicode_GET_SIZE(unival));
        out_variant->bstrVal = out_string;
        Py_DecRef(unival);
        Py_DecRef(strval);
        return true;
      }
      return false;
    }
    else
      return true;
  }
  else if (PyDateTime_Check(in_object))
  {
    out_variant->vt = VT_DATE;
    out_variant->date = PyObject_AsDATE(in_object);

    return true;
  }
  else if (PyObject_HasAttrString(in_object, "_pUnk"))
  {
    PyObject* pUnk = PyObject_GetAttrString(in_object, "_pUnk");
    if (pUnk && PyCObject_Check(pUnk))
    {
      IUnknown* pIUnknown = (IUnknown*)PyCObject_AsVoidPtr(pUnk);
      pIUnknown->AddRef();
      out_variant->vt = VT_UNKNOWN;
      out_variant->punkVal = pIUnknown;
      Py_DecRef(pUnk);
      return true;
    }
    Py_XDECREF(pUnk);
  }
  PyObject* repr = PyObject_Repr(in_object);
  PyErr_Format(PyExc_ValueError, "Can't convert %s to Variant.", repr?PyString_AsString(repr):"<Undef>", NULL);
  Py_XDECREF(repr);
  return false;
}

// Forward decl!
static PyObject* SAFEARRAYToPyObject(SAFEARRAY*, VARTYPE);

static PyObject*
Variant_AsPyObject(VARIANT* in_variant)
{
  if (in_variant->vt == VT_EMPTY)
    Py_RETURN_NONE;
  else if (in_variant->vt  == (VT_BYREF|VT_I1))
    return PyInt_FromLong(*(in_variant->pcVal)); //CHAR                *
  else if (in_variant->vt == (VT_BYREF|VT_UI2))
    return PyInt_FromLong(*(in_variant->puiVal)); //USHORT              *
  else if (in_variant->vt == (VT_BYREF|VT_UI4))
    return PyInt_FromLong(*(in_variant->pulVal)); //ULONG               *
  else if (in_variant->vt == (VT_BYREF|VT_UI8))
    return PyLong_FromUnsignedLongLong(*(in_variant->pullVal)); //ULONGLONG           *
  else if (in_variant->vt == (VT_BYREF|VT_INT))
    return PyInt_FromLong(*(in_variant->pintVal)); //INT                 *
  else if (in_variant->vt == (VT_BYREF|VT_UINT))
    return PyInt_FromLong(*(in_variant->puintVal)); //UINT                *
  else if (in_variant->vt == (VT_BYREF|VT_UI1))
    return PyInt_FromLong(*(in_variant->pbVal)); //BYTE                *
  else if (in_variant->vt == (VT_BYREF|VT_I2))
    return PyInt_FromLong(*(in_variant->piVal)); //SHORT               *
  else if (in_variant->vt == (VT_BYREF|VT_I4))
    return PyInt_FromLong(*(in_variant->plVal)); //LONG                *
  else if (in_variant->vt == (VT_BYREF|VT_I8))
    return PyLong_FromLongLong(*(in_variant->pllVal)); //LONGLONG            *
  else if (in_variant->vt == (VT_BYREF|VT_R4))
    return PyFloat_FromDouble((double)*(in_variant->pfltVal)); //FLOAT               *
  else if (in_variant->vt == (VT_BYREF|VT_R8))
    return PyFloat_FromDouble((double)*(in_variant->pdblVal)); //DOUBLE              *
  else if (in_variant->vt == (VT_BYREF|VT_BOOL))
    if ((*(in_variant->pboolVal)) == VARIANT_TRUE)
      Py_RETURN_TRUE;
    else
      Py_RETURN_FALSE;
  else if (in_variant->vt == (VT_BYREF|VT_BSTR))
    return PyUnicode_FromWideChar(*(in_variant->pbstrVal),::SysStringLen(*(in_variant->pbstrVal)));  //BSTR                *
  else if (in_variant->vt == (VT_BYREF|VT_UNKNOWN))
  {
    IUnknown* pUnk = *(in_variant->ppunkVal);
    return IUnknownToPythonIIDObject(pUnk, &IID_IUnknown);
  }
  else if (in_variant->vt == (VT_BYREF|VT_DISPATCH))
  {
    IDispatch* pDisp = *(in_variant->ppdispVal);
    return IUnknownToPythonIIDObject(pDisp, &IID_IUnknown);
  }
  else if (in_variant->vt == (VT_BYREF|VT_VARIANT))
    return Variant_AsPyObject(in_variant->pvarVal); //VARIANT             *
  else if (in_variant->vt  == VT_I8)
    return PyLong_FromLongLong(in_variant->llVal); //LONGLONG           
  else if (in_variant->vt == VT_I4)
    return PyInt_FromLong(in_variant->lVal); //LONG               
  else if (in_variant->vt == VT_UI1)
    return PyInt_FromLong((unsigned)in_variant->bVal); //BYTE               
  else if (in_variant->vt == VT_I2)
    return PyInt_FromLong(in_variant->iVal); //SHORT              
  else if (in_variant->vt == VT_R4)
    return PyFloat_FromDouble((double)(in_variant->fltVal)); //FLOAT              
  else if (in_variant->vt == VT_R8)
    return PyFloat_FromDouble((double)(in_variant->dblVal)); //DOUBLE             
  else if (in_variant->vt == VT_BOOL)
    if ((in_variant->boolVal) == VARIANT_TRUE)
      Py_RETURN_TRUE;
    else
      Py_RETURN_FALSE;              
  else if (in_variant->vt == VT_BSTR)
    return PyUnicode_FromWideChar(in_variant->bstrVal, ::SysStringLen(in_variant->bstrVal)); //BSTR               
  else if (in_variant->vt == VT_UNKNOWN)
  {
    IUnknown* pUnk = in_variant->punkVal;
    return IUnknownToPythonIIDObject(pUnk, &IID_IUnknown);
  }
  else if (in_variant->vt == VT_DISPATCH)
  {
    IDispatch* pDisp = in_variant->pdispVal;
    return IUnknownToPythonIIDObject(pDisp, &IID_IUnknown);
  }
  else if (in_variant->vt == VT_I1)
    return PyInt_FromLong(in_variant->cVal); //CHAR               
  else if (in_variant->vt == VT_UI2)
    return PyInt_FromLong(in_variant->uiVal); //USHORT             
  else if (in_variant->vt == VT_UI4)
    return PyInt_FromLong(in_variant->ulVal); //ULONG              
  else if (in_variant->vt == VT_UI8)
    return PyLong_FromUnsignedLongLong(in_variant->ullVal); //ULONGLONG          
  else if (in_variant->vt == VT_INT)
    return PyInt_FromLong(in_variant->intVal); //INT                
  else if (in_variant->vt == VT_UINT)
    return PyInt_FromLong(in_variant->uintVal); //UINT               
  else if ((in_variant->vt & VT_DATE) == VT_DATE)
  {
    DATE in_date = (in_variant->vt & VT_BYREF)?(*(in_variant->pdate)):in_variant->date;
    return DATE_AsPyObject(in_date);
  }
  else if (in_variant->vt & VT_ARRAY)
  {
    return SAFEARRAYToPyObject((in_variant->vt & VT_BYREF) ? 
                                        *(in_variant->pparray) : 
                                        in_variant->parray,
                                (in_variant->vt));
  }

  PyErr_SetString(PyExc_ValueError, "Cannot convert this variant to a Python object");
  return NULL;
}

static PyObject*
SAFEARRAYToPyObject(SAFEARRAY* pArray, VARTYPE vt)
{
  if (!pArray)
    Py_RETURN_NONE;
  PyObject* return_array(NULL);
  long entry_count(1);
  for (ssize_t dimension(0); dimension < pArray->cDims; ++dimension)
    entry_count *= (pArray->rgsabound[dimension]).cElements;
  if (pArray->fFeatures & FADF_BSTR)
  {
    return_array = PyList_New(0);
    BSTR* barray = (BSTR*)pArray->pvData;
    for (long string_index = 0; string_index < entry_count; ++string_index)
    {
      PyObject* new_string = PyUnicode_FromWideChar(barray[string_index], ::SysStringLen(barray[string_index]));
      PyList_Append(return_array, new_string);
      Py_DECREF(new_string);
    }
  }
  else if (pArray->fFeatures & FADF_VARIANT)
  {
    return_array = PyList_New(0);
    VARIANT* varray = (VARIANT*)pArray->pvData;
    for (long variant_index(0); variant_index < entry_count; ++variant_index)
    {
      PyObject* new_variant = Variant_AsPyObject(&varray[variant_index]);
      if (new_variant)
      {
        PyList_Append(return_array, new_variant);
        Py_DECREF(new_variant);
      }
      else
      {
        PyErr_Clear();
        PyList_Append(return_array, Py_None);
      }
    }
  }
  else if (pArray->fFeatures & FADF_UNKNOWN)
  {
    return_array = PyList_New(0);
    IUnknown** oarray = (IUnknown**)pArray->pvData;
    for (long object_index(0); object_index < entry_count; ++object_index)
    {
      PyObject* new_object = IUnknownToPythonIIDObject(oarray[object_index], &IID_IUnknown);
      PyList_Append(return_array, new_object);
      Py_DECREF(new_object);
    }
  }
  else if (vt == (VT_UI1 | VT_ARRAY))
  {
    return_array = PyByteArray_FromStringAndSize((char*)(pArray->pvData), entry_count);
  }

  if (!return_array)
  {
    if (PyErr_WarnEx(PyExc_Warning, "conversion for this error type not implemented", -1) != 0)
      return 0;

    return_array = Py_BuildValue("(HHNK)", (unsigned short)vt,
                                           (unsigned short)pArray->fFeatures,
                                           PyByteArray_FromStringAndSize((char*)(pArray->pvData), 
                                                                         sizeof(pArray->pvData)),
                                           (unsigned long long)pArray->pvData);
  }
  return return_array;
}

// Attempt to get an interface pointer from a Python object
static bool
IFaceFromPyObject(PyObject* pIn, const GUID* pOutGuid, void** pOutIFace)
{
    IUnknown* pUnk = NULL;

    if (pIn == Py_None)
    {
        *pOutIFace = NULL;
        return true;
    }
    else if (PyCObject_Check(pIn))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(pIn);
    }
    else
    {
        bool need_decref(false);
        if (PyObject_HasAttrString(pIn, "_arc_object"))
        {
          pIn = PyObject_GetAttrString(pIn, "_arc_object");
          if (pIn)
            need_decref = true;
        }
        PyObject* pObject = PyObject_GetAttrString(pIn, "_pUnk");
        if (!pObject)
            return false;
        if (!PyCObject_Check(pObject))
            return false;
        else
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(pObject);
        if (need_decref)
            Py_DECREF(pIn);
        Py_XDECREF(pObject);
    }
    if (pUnk && SUCCEEDED(pUnk->QueryInterface(*pOutGuid, pOutIFace)))
        return true;

    return false;
}



// Every module implements this IUnknown thing but only one reference to the 
// _Type struct will be used between them, so type checking will still work.
// This has the happy side effect of letting us pick and choose which of the
// OLBs that are offered as wrappers (and just plain remove them) without 
// needing to worry about it. Whichever of the C modules in the suite that gets
// imported first is fully capable and will do its best to bootstrap the system.

typedef struct IUnknownObject {
    PyObject_HEAD
    IUnknown* m_pUnk;
} IUnknownObject;

static PyObject*
IUnknownObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    IUnknownObject* self;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {        
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IUnknown with provided CLSID");
            return NULL;
        }
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        pUnk->AddRef();
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IUnknown");
            return NULL;
        }
        if (!PyCObject_Check(argument))
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IUnknown");
            return NULL;
        }
        else
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
            pUnk->AddRef();
        }
        if (argument)
            Py_DECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    if (!(self = ((IUnknownObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IUnknown");
        return NULL;
    }

    self->m_pUnk = pUnk;
    return (PyObject *)self;
}

static void
IUnknownObject_dealloc(IUnknownObject* self)
{
    if (self->m_pUnk)
        self->m_pUnk->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
IUnknown_GetpUnk(IUnknownObject* self)
{
    if (!self->m_pUnk)
        Py_RETURN_NONE;
    self->m_pUnk->AddRef();
    return PyCObject_FromVoidPtr((void*)self->m_pUnk, destr_unknown);
}

static PyObject*
IUnknown_GetPointer(IUnknownObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pUnk);
}

static PyObject*
IUnknown_GetIID(IUnknownObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "{00000000-0000-0000-C000-000000000046}");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
IUnknown_SupportsInterface(IUnknownObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pUnk->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}

PyMethodDef IUnknownMethods[] = {
    {"supports", (PyCFunction)IUnknown_SupportsInterface, METH_O, ""},
};

PyGetSetDef IUnknownGetSet[] = {
  {"_IID", (getter)IUnknown_GetIID, NULL, "Get IID for Unknown", NULL},
  {"_pUnk", (getter)IUnknown_GetpUnk, NULL, "Get opaque pointer to Unknown", NULL},
  {"_pointer", (getter)IUnknown_GetPointer, NULL, "Get long pointer to Unknown", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject IUnknownObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "cartocomutils.IUnknown",
                                              /* tp_name */
  sizeof(IUnknownObject),                     /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)IUnknownObject_dealloc,         /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "IUnknown",                                 /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  IUnknownMethods,                            /* tp_methods */
  0,                                          /* tp_members */
  IUnknownGetSet,                             /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  IUnknownObject_new,                         /* tp_new */
};




// Interface IProtectNameFramework

typedef struct PyIProtectNameFrameworkObject {
    PyObject_HEAD
    IProtectNameFramework* m_pIProtectNameFramework;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIProtectNameFrameworkObject;

static PyObject*
PyIProtectNameFrameworkObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIProtectNameFrameworkObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IProtectNameFramework* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IProtectNameFramework, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IProtectNameFramework with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIProtectNameFrameworkObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IProtectNameFramework");
            return NULL;
        }
        self->m_pIProtectNameFramework = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IProtectNameFramework");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IProtectNameFramework");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IProtectNameFramework* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IProtectNameFramework, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IProtectNameFramework");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIProtectNameFrameworkObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IProtectNameFramework");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIProtectNameFramework = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIProtectNameFrameworkObject_dealloc(PyIProtectNameFrameworkObject* self)
{
    if (self->m_pIProtectNameFramework)
        self->m_pIProtectNameFramework->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIProtectNameFramework_GetpUnk(PyIProtectNameFrameworkObject* self)
{
    if (!self->m_pIProtectNameFramework)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIProtectNameFramework->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IProtectNameFramework to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIProtectNameFramework_GetPointer(PyIProtectNameFrameworkObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIProtectNameFramework);
}

static PyObject*
PyIProtectNameFramework_GetIID(PyIProtectNameFrameworkObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "454cea50-bda0-443f-b55f-0297c8712e72");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIProtectNameFramework_GetHR(PyIProtectNameFrameworkObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIProtectNameFramework_GetIgnoreFailures(PyIProtectNameFrameworkObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIProtectNameFramework_SetIgnoreFailures(PyIProtectNameFrameworkObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIProtectNameFramework_SupportsInterface(PyIProtectNameFrameworkObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIProtectNameFramework->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IProtectNameFrameworkMethod_ProtectOLE_HANDLE(PyIProtectNameFrameworkObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    OLE_HANDLE HaHandle = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "I", &HaHandle))
      goto iprotectnameframework_protectole_handle_method_cleanup;

    // Set up initial variable values as needed
    // No setup for aHandle

    // Call method on actual COM interface
    hr = self->m_pIProtectNameFramework->ProtectOLE_HANDLE(HaHandle);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIProtectNameFramework->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IProtectNameFramework) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IProtectNameFramework.ProtectOLE_HANDLE() returned %ld", (long)hr);
        goto iprotectnameframework_protectole_handle_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for aHandle

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iprotectnameframework_protectole_handle_method_cleanup;

    iprotectnameframework_protectole_handle_method_cleanup:
    self->m_HR = hr;
    // No cleanup for aHandle
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IProtectNameFramework.ProtectOLE_HANDLE");
    return return_tuple;
}

static PyObject*
IProtectNameFrameworkMethod_ProtectOLE_COLOR(PyIProtectNameFrameworkObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    OLE_COLOR HaColor = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "I", &HaColor))
      goto iprotectnameframework_protectole_color_method_cleanup;

    // Set up initial variable values as needed
    // No setup for aColor

    // Call method on actual COM interface
    hr = self->m_pIProtectNameFramework->ProtectOLE_COLOR(HaColor);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIProtectNameFramework->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IProtectNameFramework) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IProtectNameFramework.ProtectOLE_COLOR() returned %ld", (long)hr);
        goto iprotectnameframework_protectole_color_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for aColor

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iprotectnameframework_protectole_color_method_cleanup;

    iprotectnameframework_protectole_color_method_cleanup:
    self->m_HR = hr;
    // No cleanup for aColor
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IProtectNameFramework.ProtectOLE_COLOR");
    return return_tuple;
}


PyMethodDef PyIProtectNameFrameworkMethods[] = {
    {"supports", (PyCFunction)PyIProtectNameFramework_SupportsInterface, METH_O, ""},
    {"ProtectOLE_HANDLE", (PyCFunction)IProtectNameFrameworkMethod_ProtectOLE_HANDLE, METH_VARARGS, ""},
    {"ProtectOLE_COLOR", (PyCFunction)IProtectNameFrameworkMethod_ProtectOLE_COLOR, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIProtectNameFrameworkGetSet[] = {
  {"_pUnk", (getter)PyIProtectNameFramework_GetpUnk, NULL, "Get opaque pointer to an Unknown from IProtectNameFramework", NULL},
  {"_pointer", (getter)PyIProtectNameFramework_GetPointer, NULL, "Get memory address for IProtectNameFramework", NULL},
  {"_IID", (getter)PyIProtectNameFramework_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIProtectNameFramework_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIProtectNameFramework_GetIgnoreFailures, (setter)PyIProtectNameFramework_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIProtectNameFrameworkObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriFramework.IProtectNameFrameworkObject",                          
                                              /* tp_name */
  sizeof(PyIProtectNameFrameworkObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIProtectNameFrameworkObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIProtectNameFrameworkMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIProtectNameFrameworkGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIProtectNameFrameworkObject_new,                      
                                              /* tp_new */
};

// Interface IAccelerator

typedef struct PyIAcceleratorObject {
    PyObject_HEAD
    IAccelerator* m_pIAccelerator;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIAcceleratorObject;

static PyObject*
PyIAcceleratorObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIAcceleratorObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IAccelerator* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IAccelerator, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IAccelerator with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIAcceleratorObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IAccelerator");
            return NULL;
        }
        self->m_pIAccelerator = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IAccelerator");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IAccelerator");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IAccelerator* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IAccelerator, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IAccelerator");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIAcceleratorObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IAccelerator");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIAccelerator = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIAcceleratorObject_dealloc(PyIAcceleratorObject* self)
{
    if (self->m_pIAccelerator)
        self->m_pIAccelerator->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIAccelerator_GetpUnk(PyIAcceleratorObject* self)
{
    if (!self->m_pIAccelerator)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIAccelerator->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IAccelerator to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIAccelerator_GetPointer(PyIAcceleratorObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIAccelerator);
}

static PyObject*
PyIAccelerator_GetIID(PyIAcceleratorObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "08300de1-27fd-11d2-aa2f-000000000000");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIAccelerator_GetHR(PyIAcceleratorObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIAccelerator_GetIgnoreFailures(PyIAcceleratorObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIAccelerator_SetIgnoreFailures(PyIAcceleratorObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIAccelerator_SupportsInterface(PyIAcceleratorObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIAccelerator->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IAcceleratorMethod_put_Shift(PyIAcceleratorObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_bShift = VARIANT_FALSE;
    PyObject* pyvar_bShift = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_bShift))
      goto iaccelerator_put_shift_method_cleanup;

    // Set up initial variable values as needed
    b_bShift = ((PyObject_IsTrue(pyvar_bShift) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iaccelerator_put_shift_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIAccelerator->put_Shift(b_bShift);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAccelerator->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAccelerator) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAccelerator.put_Shift() returned %ld", (long)hr);
        goto iaccelerator_put_shift_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for bShift

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iaccelerator_put_shift_method_cleanup;

    iaccelerator_put_shift_method_cleanup:
    self->m_HR = hr;
    // No cleanup for bShift
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAccelerator.put_Shift");
    return return_tuple;
}

static PyObject*
IAcceleratorMethod_get_Shift(PyIAcceleratorObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_bShift = VARIANT_FALSE;
    PyObject* pyvar_bShift = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for bShift

    // Call method on actual COM interface
    hr = self->m_pIAccelerator->get_Shift(&b_bShift);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAccelerator->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAccelerator) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAccelerator.get_Shift() returned %ld", (long)hr);
        goto iaccelerator_get_shift_method_cleanup;
    }

    // Set up return values as needed
    pyvar_bShift = ((b_bShift == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto iaccelerator_get_shift_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_bShift);
    goto iaccelerator_get_shift_method_cleanup;

    iaccelerator_get_shift_method_cleanup:
    self->m_HR = hr;
    // No cleanup for bShift
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAccelerator.get_Shift");
    return return_tuple;
}

static PyObject*
IAcceleratorMethod_put_Alt(PyIAcceleratorObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_bAlt = VARIANT_FALSE;
    PyObject* pyvar_bAlt = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_bAlt))
      goto iaccelerator_put_alt_method_cleanup;

    // Set up initial variable values as needed
    b_bAlt = ((PyObject_IsTrue(pyvar_bAlt) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iaccelerator_put_alt_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIAccelerator->put_Alt(b_bAlt);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAccelerator->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAccelerator) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAccelerator.put_Alt() returned %ld", (long)hr);
        goto iaccelerator_put_alt_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for bAlt

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iaccelerator_put_alt_method_cleanup;

    iaccelerator_put_alt_method_cleanup:
    self->m_HR = hr;
    // No cleanup for bAlt
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAccelerator.put_Alt");
    return return_tuple;
}

static PyObject*
IAcceleratorMethod_get_Alt(PyIAcceleratorObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_bAlt = VARIANT_FALSE;
    PyObject* pyvar_bAlt = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for bAlt

    // Call method on actual COM interface
    hr = self->m_pIAccelerator->get_Alt(&b_bAlt);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAccelerator->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAccelerator) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAccelerator.get_Alt() returned %ld", (long)hr);
        goto iaccelerator_get_alt_method_cleanup;
    }

    // Set up return values as needed
    pyvar_bAlt = ((b_bAlt == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto iaccelerator_get_alt_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_bAlt);
    goto iaccelerator_get_alt_method_cleanup;

    iaccelerator_get_alt_method_cleanup:
    self->m_HR = hr;
    // No cleanup for bAlt
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAccelerator.get_Alt");
    return return_tuple;
}

static PyObject*
IAcceleratorMethod_put_Ctrl(PyIAcceleratorObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_bCtrl = VARIANT_FALSE;
    PyObject* pyvar_bCtrl = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_bCtrl))
      goto iaccelerator_put_ctrl_method_cleanup;

    // Set up initial variable values as needed
    b_bCtrl = ((PyObject_IsTrue(pyvar_bCtrl) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iaccelerator_put_ctrl_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIAccelerator->put_Ctrl(b_bCtrl);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAccelerator->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAccelerator) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAccelerator.put_Ctrl() returned %ld", (long)hr);
        goto iaccelerator_put_ctrl_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for bCtrl

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iaccelerator_put_ctrl_method_cleanup;

    iaccelerator_put_ctrl_method_cleanup:
    self->m_HR = hr;
    // No cleanup for bCtrl
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAccelerator.put_Ctrl");
    return return_tuple;
}

static PyObject*
IAcceleratorMethod_get_Ctrl(PyIAcceleratorObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_bCtrl = VARIANT_FALSE;
    PyObject* pyvar_bCtrl = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for bCtrl

    // Call method on actual COM interface
    hr = self->m_pIAccelerator->get_Ctrl(&b_bCtrl);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAccelerator->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAccelerator) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAccelerator.get_Ctrl() returned %ld", (long)hr);
        goto iaccelerator_get_ctrl_method_cleanup;
    }

    // Set up return values as needed
    pyvar_bCtrl = ((b_bCtrl == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto iaccelerator_get_ctrl_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_bCtrl);
    goto iaccelerator_get_ctrl_method_cleanup;

    iaccelerator_get_ctrl_method_cleanup:
    self->m_HR = hr;
    // No cleanup for bCtrl
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAccelerator.get_Ctrl");
    return return_tuple;
}

static PyObject*
IAcceleratorMethod_put_Key(PyIAcceleratorObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lkeyCode = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lkeyCode))
      goto iaccelerator_put_key_method_cleanup;

    // Set up initial variable values as needed
    // No setup for keyCode

    // Call method on actual COM interface
    hr = self->m_pIAccelerator->put_Key(lkeyCode);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAccelerator->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAccelerator) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAccelerator.put_Key() returned %ld", (long)hr);
        goto iaccelerator_put_key_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for keyCode

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iaccelerator_put_key_method_cleanup;

    iaccelerator_put_key_method_cleanup:
    self->m_HR = hr;
    // No cleanup for keyCode
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAccelerator.put_Key");
    return return_tuple;
}

static PyObject*
IAcceleratorMethod_get_Key(PyIAcceleratorObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lkeyCode = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for keyCode

    // Call method on actual COM interface
    hr = self->m_pIAccelerator->get_Key(&lkeyCode);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAccelerator->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAccelerator) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAccelerator.get_Key() returned %ld", (long)hr);
        goto iaccelerator_get_key_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for keyCode

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lkeyCode);
    goto iaccelerator_get_key_method_cleanup;

    iaccelerator_get_key_method_cleanup:
    self->m_HR = hr;
    // No cleanup for keyCode
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAccelerator.get_Key");
    return return_tuple;
}

static PyObject*
IAcceleratorMethod_put_CommandID(PyIAcceleratorObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT vcmdID;
    ::VariantInit(&vcmdID);
    PyObject* pyvar_cmdID = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_cmdID))
      goto iaccelerator_put_commandid_method_cleanup;

    // Set up initial variable values as needed
    PyObject_AsVariant(pyvar_cmdID, &vcmdID);
    
    if (PyErr_Occurred())
      goto iaccelerator_put_commandid_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIAccelerator->put_CommandID(vcmdID);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAccelerator->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAccelerator) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAccelerator.put_CommandID() returned %ld", (long)hr);
        goto iaccelerator_put_commandid_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for cmdID

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iaccelerator_put_commandid_method_cleanup;

    iaccelerator_put_commandid_method_cleanup:
    self->m_HR = hr;
    ::VariantClear(&vcmdID);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAccelerator.put_CommandID");
    return return_tuple;
}

static PyObject*
IAcceleratorMethod_get_CommandID(PyIAcceleratorObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT vcmdID;
    ::VariantInit(&vcmdID);
    PyObject* pyvar_cmdID = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for cmdID

    // Call method on actual COM interface
    hr = self->m_pIAccelerator->get_CommandID(&vcmdID);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAccelerator->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAccelerator) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAccelerator.get_CommandID() returned %ld", (long)hr);
        goto iaccelerator_get_commandid_method_cleanup;
    }

    // Set up return values as needed
    pyvar_cmdID = Variant_AsPyObject(&vcmdID);
    if (PyErr_Occurred())
      goto iaccelerator_get_commandid_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_cmdID);
    goto iaccelerator_get_commandid_method_cleanup;

    iaccelerator_get_commandid_method_cleanup:
    self->m_HR = hr;
    ::VariantClear(&vcmdID);
    Py_XDECREF(pyvar_cmdID);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAccelerator.get_CommandID");
    return return_tuple;
}

static PyObject*
IAcceleratorMethod_Delete(PyIAcceleratorObject* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pIAccelerator->Delete();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAccelerator->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAccelerator) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAccelerator.Delete() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}


PyMethodDef PyIAcceleratorMethods[] = {
    {"supports", (PyCFunction)PyIAccelerator_SupportsInterface, METH_O, ""},
    {"put_Shift", (PyCFunction)IAcceleratorMethod_put_Shift, METH_VARARGS, ""},
    {"get_Shift", (PyCFunction)IAcceleratorMethod_get_Shift, METH_VARARGS, ""},
    {"put_Alt", (PyCFunction)IAcceleratorMethod_put_Alt, METH_VARARGS, ""},
    {"get_Alt", (PyCFunction)IAcceleratorMethod_get_Alt, METH_VARARGS, ""},
    {"put_Ctrl", (PyCFunction)IAcceleratorMethod_put_Ctrl, METH_VARARGS, ""},
    {"get_Ctrl", (PyCFunction)IAcceleratorMethod_get_Ctrl, METH_VARARGS, ""},
    {"put_Key", (PyCFunction)IAcceleratorMethod_put_Key, METH_VARARGS, ""},
    {"get_Key", (PyCFunction)IAcceleratorMethod_get_Key, METH_VARARGS, ""},
    {"put_CommandID", (PyCFunction)IAcceleratorMethod_put_CommandID, METH_VARARGS, ""},
    {"get_CommandID", (PyCFunction)IAcceleratorMethod_get_CommandID, METH_VARARGS, ""},
    {"Delete", (PyCFunction)IAcceleratorMethod_Delete, METH_NOARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIAcceleratorGetSet[] = {
  {"_pUnk", (getter)PyIAccelerator_GetpUnk, NULL, "Get opaque pointer to an Unknown from IAccelerator", NULL},
  {"_pointer", (getter)PyIAccelerator_GetPointer, NULL, "Get memory address for IAccelerator", NULL},
  {"_IID", (getter)PyIAccelerator_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIAccelerator_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIAccelerator_GetIgnoreFailures, (setter)PyIAccelerator_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIAcceleratorObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriFramework.IAcceleratorObject",                          
                                              /* tp_name */
  sizeof(PyIAcceleratorObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIAcceleratorObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIAcceleratorMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIAcceleratorGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIAcceleratorObject_new,                      
                                              /* tp_new */
};

// Interface IAcceleratorTable

typedef struct PyIAcceleratorTableObject {
    PyObject_HEAD
    IAcceleratorTable* m_pIAcceleratorTable;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIAcceleratorTableObject;

static PyObject*
PyIAcceleratorTableObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIAcceleratorTableObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IAcceleratorTable* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IAcceleratorTable, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IAcceleratorTable with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIAcceleratorTableObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IAcceleratorTable");
            return NULL;
        }
        self->m_pIAcceleratorTable = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IAcceleratorTable");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IAcceleratorTable");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IAcceleratorTable* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IAcceleratorTable, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IAcceleratorTable");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIAcceleratorTableObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IAcceleratorTable");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIAcceleratorTable = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIAcceleratorTableObject_dealloc(PyIAcceleratorTableObject* self)
{
    if (self->m_pIAcceleratorTable)
        self->m_pIAcceleratorTable->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIAcceleratorTable_GetpUnk(PyIAcceleratorTableObject* self)
{
    if (!self->m_pIAcceleratorTable)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIAcceleratorTable->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IAcceleratorTable to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIAcceleratorTable_GetPointer(PyIAcceleratorTableObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIAcceleratorTable);
}

static PyObject*
PyIAcceleratorTable_GetIID(PyIAcceleratorTableObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "08300de2-27fd-11d2-aa2f-000000000000");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIAcceleratorTable_GetHR(PyIAcceleratorTableObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIAcceleratorTable_GetIgnoreFailures(PyIAcceleratorTableObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIAcceleratorTable_SetIgnoreFailures(PyIAcceleratorTableObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIAcceleratorTable_SupportsInterface(PyIAcceleratorTableObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIAcceleratorTable->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IAcceleratorTableMethod_get_Count(PyIAcceleratorTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Count

    // Call method on actual COM interface
    hr = self->m_pIAcceleratorTable->get_Count(&lCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAcceleratorTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAcceleratorTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAcceleratorTable.get_Count() returned %ld", (long)hr);
        goto iacceleratortable_get_count_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Count

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lCount);
    goto iacceleratortable_get_count_method_cleanup;

    iacceleratortable_get_count_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Count
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAcceleratorTable.get_Count");
    return return_tuple;
}

static PyObject*
IAcceleratorTableMethod_get_Item(PyIAcceleratorTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lIndex = 0;
    IAccelerator* ipAccelerator = NULL;
    PyObject* py_Accelerator = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lIndex))
      goto iacceleratortable_get_item_method_cleanup;

    // Set up initial variable values as needed
    // No setup for Index
    // No setup for Accelerator

    // Call method on actual COM interface
    hr = self->m_pIAcceleratorTable->get_Item(lIndex, &ipAccelerator);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAcceleratorTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAcceleratorTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAcceleratorTable.get_Item() returned %ld", (long)hr);
        goto iacceleratortable_get_item_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Index
    Py_XDECREF(py_Accelerator);
    if (ipAccelerator)
    {
        IUnknown* pUnk = NULL;
        ipAccelerator->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_Accelerator = IUnknownToPythonIIDObject(pUnk, &IID_IAccelerator);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_Accelerator)
    {
        if (py_Accelerator)
           Py_DECREF(py_Accelerator);
        py_Accelerator = Py_None;
        Py_INCREF(py_Accelerator);
    }
    if (PyErr_Occurred())
      goto iacceleratortable_get_item_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_Accelerator);
    goto iacceleratortable_get_item_method_cleanup;

    iacceleratortable_get_item_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Index
    Py_XDECREF(py_Accelerator);
    if (ipAccelerator)
      ipAccelerator->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAcceleratorTable.get_Item");
    return return_tuple;
}

static PyObject*
IAcceleratorTableMethod_Add(PyIAcceleratorTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT vID;
    ::VariantInit(&vID);
    PyObject* pyvar_ID = NULL;
    long lKey = 0;
    VARIANT_BOOL b_bCtrl = VARIANT_FALSE;
    PyObject* pyvar_bCtrl = NULL;
    VARIANT_BOOL b_bAlt = VARIANT_FALSE;
    PyObject* pyvar_bAlt = NULL;
    VARIANT_BOOL b_bShift = VARIANT_FALSE;
    PyObject* pyvar_bShift = NULL;
    VARIANT_BOOL b_bSucceeded = VARIANT_FALSE;
    PyObject* pyvar_bSucceeded = Py_False;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OlOOO", &pyvar_ID, &lKey, &pyvar_bCtrl, &pyvar_bAlt, &pyvar_bShift))
      goto iacceleratortable_add_method_cleanup;

    // Set up initial variable values as needed
    PyObject_AsVariant(pyvar_ID, &vID);
    
    if (PyErr_Occurred())
      goto iacceleratortable_add_method_cleanup;
    
    // No setup for Key
    b_bCtrl = ((PyObject_IsTrue(pyvar_bCtrl) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iacceleratortable_add_method_cleanup;
    
    b_bAlt = ((PyObject_IsTrue(pyvar_bAlt) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iacceleratortable_add_method_cleanup;
    
    b_bShift = ((PyObject_IsTrue(pyvar_bShift) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iacceleratortable_add_method_cleanup;
    
    // No setup for bSucceeded

    // Call method on actual COM interface
    hr = self->m_pIAcceleratorTable->Add(vID, lKey, b_bCtrl, b_bAlt, b_bShift, &b_bSucceeded);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAcceleratorTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAcceleratorTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAcceleratorTable.Add() returned %ld", (long)hr);
        goto iacceleratortable_add_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ID
    // No teardown for Key
    // No teardown for bCtrl
    // No teardown for bAlt
    // No teardown for bShift
    pyvar_bSucceeded = ((b_bSucceeded == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto iacceleratortable_add_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_bSucceeded);
    goto iacceleratortable_add_method_cleanup;

    iacceleratortable_add_method_cleanup:
    self->m_HR = hr;
    ::VariantClear(&vID);
    // No cleanup for Key
    // No cleanup for bCtrl
    // No cleanup for bAlt
    // No cleanup for bShift
    // No cleanup for bSucceeded
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAcceleratorTable.Add");
    return return_tuple;
}

static PyObject*
IAcceleratorTableMethod_Find(PyIAcceleratorTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT vID;
    ::VariantInit(&vID);
    PyObject* pyvar_ID = NULL;
    IArray* ipaccelArray = NULL;
    PyObject* py_accelArray = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_ID))
      goto iacceleratortable_find_method_cleanup;

    // Set up initial variable values as needed
    PyObject_AsVariant(pyvar_ID, &vID);
    
    if (PyErr_Occurred())
      goto iacceleratortable_find_method_cleanup;
    
    // No setup for accelArray

    // Call method on actual COM interface
    hr = self->m_pIAcceleratorTable->Find(vID, &ipaccelArray);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAcceleratorTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAcceleratorTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAcceleratorTable.Find() returned %ld", (long)hr);
        goto iacceleratortable_find_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ID
    Py_XDECREF(py_accelArray);
    if (ipaccelArray)
    {
        IUnknown* pUnk = NULL;
        ipaccelArray->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_accelArray = IUnknownToPythonIIDObject(pUnk, &IID_IArray);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_accelArray)
    {
        if (py_accelArray)
           Py_DECREF(py_accelArray);
        py_accelArray = Py_None;
        Py_INCREF(py_accelArray);
    }
    if (PyErr_Occurred())
      goto iacceleratortable_find_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_accelArray);
    goto iacceleratortable_find_method_cleanup;

    iacceleratortable_find_method_cleanup:
    self->m_HR = hr;
    ::VariantClear(&vID);
    Py_XDECREF(py_accelArray);
    if (ipaccelArray)
      ipaccelArray->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAcceleratorTable.Find");
    return return_tuple;
}

static PyObject*
IAcceleratorTableMethod_FindByKey(PyIAcceleratorTableObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lKey = 0;
    VARIANT_BOOL b_bCtrl = VARIANT_FALSE;
    PyObject* pyvar_bCtrl = NULL;
    VARIANT_BOOL b_bAlt = VARIANT_FALSE;
    PyObject* pyvar_bAlt = NULL;
    VARIANT_BOOL b_bShift = VARIANT_FALSE;
    PyObject* pyvar_bShift = NULL;
    IAccelerator* ipAccelerator = NULL;
    PyObject* py_Accelerator = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "lOOO", &lKey, &pyvar_bCtrl, &pyvar_bAlt, &pyvar_bShift))
      goto iacceleratortable_findbykey_method_cleanup;

    // Set up initial variable values as needed
    // No setup for Key
    b_bCtrl = ((PyObject_IsTrue(pyvar_bCtrl) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iacceleratortable_findbykey_method_cleanup;
    
    b_bAlt = ((PyObject_IsTrue(pyvar_bAlt) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iacceleratortable_findbykey_method_cleanup;
    
    b_bShift = ((PyObject_IsTrue(pyvar_bShift) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iacceleratortable_findbykey_method_cleanup;
    
    // No setup for Accelerator

    // Call method on actual COM interface
    hr = self->m_pIAcceleratorTable->FindByKey(lKey, b_bCtrl, b_bAlt, b_bShift, &ipAccelerator);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAcceleratorTable->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAcceleratorTable) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAcceleratorTable.FindByKey() returned %ld", (long)hr);
        goto iacceleratortable_findbykey_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Key
    // No teardown for bCtrl
    // No teardown for bAlt
    // No teardown for bShift
    Py_XDECREF(py_Accelerator);
    if (ipAccelerator)
    {
        IUnknown* pUnk = NULL;
        ipAccelerator->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_Accelerator = IUnknownToPythonIIDObject(pUnk, &IID_IAccelerator);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_Accelerator)
    {
        if (py_Accelerator)
           Py_DECREF(py_Accelerator);
        py_Accelerator = Py_None;
        Py_INCREF(py_Accelerator);
    }
    if (PyErr_Occurred())
      goto iacceleratortable_findbykey_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_Accelerator);
    goto iacceleratortable_findbykey_method_cleanup;

    iacceleratortable_findbykey_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Key
    // No cleanup for bCtrl
    // No cleanup for bAlt
    // No cleanup for bShift
    Py_XDECREF(py_Accelerator);
    if (ipAccelerator)
      ipAccelerator->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAcceleratorTable.FindByKey");
    return return_tuple;
}


PyMethodDef PyIAcceleratorTableMethods[] = {
    {"supports", (PyCFunction)PyIAcceleratorTable_SupportsInterface, METH_O, ""},
    {"get_Count", (PyCFunction)IAcceleratorTableMethod_get_Count, METH_VARARGS, ""},
    {"get_Item", (PyCFunction)IAcceleratorTableMethod_get_Item, METH_VARARGS, ""},
    {"Add", (PyCFunction)IAcceleratorTableMethod_Add, METH_VARARGS, ""},
    {"Find", (PyCFunction)IAcceleratorTableMethod_Find, METH_VARARGS, ""},
    {"FindByKey", (PyCFunction)IAcceleratorTableMethod_FindByKey, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIAcceleratorTableGetSet[] = {
  {"_pUnk", (getter)PyIAcceleratorTable_GetpUnk, NULL, "Get opaque pointer to an Unknown from IAcceleratorTable", NULL},
  {"_pointer", (getter)PyIAcceleratorTable_GetPointer, NULL, "Get memory address for IAcceleratorTable", NULL},
  {"_IID", (getter)PyIAcceleratorTable_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIAcceleratorTable_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIAcceleratorTable_GetIgnoreFailures, (setter)PyIAcceleratorTable_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIAcceleratorTableObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriFramework.IAcceleratorTableObject",                          
                                              /* tp_name */
  sizeof(PyIAcceleratorTableObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIAcceleratorTableObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIAcceleratorTableMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIAcceleratorTableGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIAcceleratorTableObject_new,                      
                                              /* tp_new */
};

// Interface ICustomizationFilter

typedef struct PyICustomizationFilterObject {
    PyObject_HEAD
    ICustomizationFilter* m_pICustomizationFilter;
    HRESULT m_HR;
    int m_ignore_failures;
} PyICustomizationFilterObject;

static PyObject*
PyICustomizationFilterObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyICustomizationFilterObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ICustomizationFilter* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ICustomizationFilter, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ICustomizationFilter with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyICustomizationFilterObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ICustomizationFilter");
            return NULL;
        }
        self->m_pICustomizationFilter = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ICustomizationFilter");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ICustomizationFilter");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ICustomizationFilter* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ICustomizationFilter, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ICustomizationFilter");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyICustomizationFilterObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ICustomizationFilter");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pICustomizationFilter = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyICustomizationFilterObject_dealloc(PyICustomizationFilterObject* self)
{
    if (self->m_pICustomizationFilter)
        self->m_pICustomizationFilter->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyICustomizationFilter_GetpUnk(PyICustomizationFilterObject* self)
{
    if (!self->m_pICustomizationFilter)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pICustomizationFilter->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ICustomizationFilter to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyICustomizationFilter_GetPointer(PyICustomizationFilterObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pICustomizationFilter);
}

static PyObject*
PyICustomizationFilter_GetIID(PyICustomizationFilterObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "792d7e87-7993-11d2-a2d1-0000f8774fb5");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyICustomizationFilter_GetHR(PyICustomizationFilterObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyICustomizationFilter_GetIgnoreFailures(PyICustomizationFilterObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyICustomizationFilter_SetIgnoreFailures(PyICustomizationFilterObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyICustomizationFilter_SupportsInterface(PyICustomizationFilterObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pICustomizationFilter->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ICustomizationFilterMethod_OnCustomizationEvent(PyICustomizationFilterObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriCustomizationEvent ecustEventType;
    VARIANT veventCtx;
    ::VariantInit(&veventCtx);
    PyObject* pyvar_eventCtx = NULL;
    VARIANT_BOOL b_bDeny = VARIANT_FALSE;
    PyObject* pyvar_bDeny = Py_False;

    // Unpack values
    if (!PyArg_ParseTuple(args, "iO", (int *)&ecustEventType, &pyvar_eventCtx))
      goto icustomizationfilter_oncustomizationevent_method_cleanup;

    // Set up initial variable values as needed
    // No setup for custEventType
    PyObject_AsVariant(pyvar_eventCtx, &veventCtx);
    
    if (PyErr_Occurred())
      goto icustomizationfilter_oncustomizationevent_method_cleanup;
    
    // No setup for bDeny

    // Call method on actual COM interface
    hr = self->m_pICustomizationFilter->OnCustomizationEvent(ecustEventType, veventCtx, &b_bDeny);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICustomizationFilter->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICustomizationFilter) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICustomizationFilter.OnCustomizationEvent() returned %ld", (long)hr);
        goto icustomizationfilter_oncustomizationevent_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for custEventType
    // No teardown for eventCtx
    pyvar_bDeny = ((b_bDeny == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto icustomizationfilter_oncustomizationevent_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_bDeny);
    goto icustomizationfilter_oncustomizationevent_method_cleanup;

    icustomizationfilter_oncustomizationevent_method_cleanup:
    self->m_HR = hr;
    // No cleanup for custEventType
    ::VariantClear(&veventCtx);
    // No cleanup for bDeny
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICustomizationFilter.OnCustomizationEvent");
    return return_tuple;
}


PyMethodDef PyICustomizationFilterMethods[] = {
    {"supports", (PyCFunction)PyICustomizationFilter_SupportsInterface, METH_O, ""},
    {"OnCustomizationEvent", (PyCFunction)ICustomizationFilterMethod_OnCustomizationEvent, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyICustomizationFilterGetSet[] = {
  {"_pUnk", (getter)PyICustomizationFilter_GetpUnk, NULL, "Get opaque pointer to an Unknown from ICustomizationFilter", NULL},
  {"_pointer", (getter)PyICustomizationFilter_GetPointer, NULL, "Get memory address for ICustomizationFilter", NULL},
  {"_IID", (getter)PyICustomizationFilter_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyICustomizationFilter_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyICustomizationFilter_GetIgnoreFailures, (setter)PyICustomizationFilter_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyICustomizationFilterObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriFramework.ICustomizationFilterObject",                          
                                              /* tp_name */
  sizeof(PyICustomizationFilterObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyICustomizationFilterObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyICustomizationFilterMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyICustomizationFilterGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyICustomizationFilterObject_new,                      
                                              /* tp_new */
};

// Interface ITemplates

typedef struct PyITemplatesObject {
    PyObject_HEAD
    ITemplates* m_pITemplates;
    HRESULT m_HR;
    int m_ignore_failures;
} PyITemplatesObject;

static PyObject*
PyITemplatesObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyITemplatesObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ITemplates* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ITemplates, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ITemplates with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyITemplatesObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ITemplates");
            return NULL;
        }
        self->m_pITemplates = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ITemplates");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ITemplates");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ITemplates* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ITemplates, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ITemplates");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyITemplatesObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ITemplates");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pITemplates = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyITemplatesObject_dealloc(PyITemplatesObject* self)
{
    if (self->m_pITemplates)
        self->m_pITemplates->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyITemplates_GetpUnk(PyITemplatesObject* self)
{
    if (!self->m_pITemplates)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pITemplates->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ITemplates to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyITemplates_GetPointer(PyITemplatesObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pITemplates);
}

static PyObject*
PyITemplates_GetIID(PyITemplatesObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "ce7c5749-3921-11d2-94cf-080009eebecb");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyITemplates_GetHR(PyITemplatesObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyITemplates_GetIgnoreFailures(PyITemplatesObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyITemplates_SetIgnoreFailures(PyITemplatesObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyITemplates_SupportsInterface(PyITemplatesObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pITemplates->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ITemplatesMethod_get_Count(PyITemplatesObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Count

    // Call method on actual COM interface
    hr = self->m_pITemplates->get_Count(&lCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemplates->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemplates) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemplates.get_Count() returned %ld", (long)hr);
        goto itemplates_get_count_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Count

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lCount);
    goto itemplates_get_count_method_cleanup;

    itemplates_get_count_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Count
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemplates.get_Count");
    return return_tuple;
}

static PyObject*
ITemplatesMethod_get_Item(PyITemplatesObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lIndex = 0;
    BSTR bspathName;
    PyObject* pyvar_pathName = Py_None;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lIndex))
      goto itemplates_get_item_method_cleanup;

    // Set up initial variable values as needed
    // No setup for Index
    // No setup for pathName

    // Call method on actual COM interface
    hr = self->m_pITemplates->get_Item(lIndex, &bspathName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pITemplates->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ITemplates) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ITemplates.get_Item() returned %ld", (long)hr);
        goto itemplates_get_item_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Index
    pyvar_pathName = PyUnicode_FromWideChar(bspathName,::SysStringLen(bspathName));
    ::SysFreeString(bspathName);
    
    if (PyErr_Occurred())
      goto itemplates_get_item_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pathName);
    goto itemplates_get_item_method_cleanup;

    itemplates_get_item_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Index
    if (pyvar_pathName != Py_None)
        Py_XDECREF(pyvar_pathName);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ITemplates.get_Item");
    return return_tuple;
}


PyMethodDef PyITemplatesMethods[] = {
    {"supports", (PyCFunction)PyITemplates_SupportsInterface, METH_O, ""},
    {"get_Count", (PyCFunction)ITemplatesMethod_get_Count, METH_VARARGS, ""},
    {"get_Item", (PyCFunction)ITemplatesMethod_get_Item, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyITemplatesGetSet[] = {
  {"_pUnk", (getter)PyITemplates_GetpUnk, NULL, "Get opaque pointer to an Unknown from ITemplates", NULL},
  {"_pointer", (getter)PyITemplates_GetPointer, NULL, "Get memory address for ITemplates", NULL},
  {"_IID", (getter)PyITemplates_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyITemplates_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyITemplates_GetIgnoreFailures, (setter)PyITemplates_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyITemplatesObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriFramework.ITemplatesObject",                          
                                              /* tp_name */
  sizeof(PyITemplatesObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyITemplatesObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyITemplatesMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyITemplatesGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyITemplatesObject_new,                      
                                              /* tp_new */
};

// Interface IAcceleratorHook

typedef struct PyIAcceleratorHookObject {
    PyObject_HEAD
    IAcceleratorHook* m_pIAcceleratorHook;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIAcceleratorHookObject;

static PyObject*
PyIAcceleratorHookObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIAcceleratorHookObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IAcceleratorHook* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IAcceleratorHook, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IAcceleratorHook with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIAcceleratorHookObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IAcceleratorHook");
            return NULL;
        }
        self->m_pIAcceleratorHook = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IAcceleratorHook");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IAcceleratorHook");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IAcceleratorHook* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IAcceleratorHook, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IAcceleratorHook");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIAcceleratorHookObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IAcceleratorHook");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIAcceleratorHook = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIAcceleratorHookObject_dealloc(PyIAcceleratorHookObject* self)
{
    if (self->m_pIAcceleratorHook)
        self->m_pIAcceleratorHook->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIAcceleratorHook_GetpUnk(PyIAcceleratorHookObject* self)
{
    if (!self->m_pIAcceleratorHook)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIAcceleratorHook->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IAcceleratorHook to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIAcceleratorHook_GetPointer(PyIAcceleratorHookObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIAcceleratorHook);
}

static PyObject*
PyIAcceleratorHook_GetIID(PyIAcceleratorHookObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "d4511a0e-1d47-461e-bc44-2475545ee2d9");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIAcceleratorHook_GetHR(PyIAcceleratorHookObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIAcceleratorHook_GetIgnoreFailures(PyIAcceleratorHookObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIAcceleratorHook_SetIgnoreFailures(PyIAcceleratorHookObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIAcceleratorHook_SupportsInterface(PyIAcceleratorHookObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIAcceleratorHook->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IAcceleratorHookMethod_CheckAccelerator(PyIAcceleratorHookObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lvkey = 0;
    VARIANT_BOOL b_check = VARIANT_FALSE;
    PyObject* pyvar_check = Py_False;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lvkey))
      goto iacceleratorhook_checkaccelerator_method_cleanup;

    // Set up initial variable values as needed
    // No setup for vkey
    // No setup for check

    // Call method on actual COM interface
    hr = self->m_pIAcceleratorHook->CheckAccelerator(lvkey, &b_check);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAcceleratorHook->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAcceleratorHook) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAcceleratorHook.CheckAccelerator() returned %ld", (long)hr);
        goto iacceleratorhook_checkaccelerator_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for vkey
    pyvar_check = ((b_check == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto iacceleratorhook_checkaccelerator_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_check);
    goto iacceleratorhook_checkaccelerator_method_cleanup;

    iacceleratorhook_checkaccelerator_method_cleanup:
    self->m_HR = hr;
    // No cleanup for vkey
    // No cleanup for check
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAcceleratorHook.CheckAccelerator");
    return return_tuple;
}


PyMethodDef PyIAcceleratorHookMethods[] = {
    {"supports", (PyCFunction)PyIAcceleratorHook_SupportsInterface, METH_O, ""},
    {"CheckAccelerator", (PyCFunction)IAcceleratorHookMethod_CheckAccelerator, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIAcceleratorHookGetSet[] = {
  {"_pUnk", (getter)PyIAcceleratorHook_GetpUnk, NULL, "Get opaque pointer to an Unknown from IAcceleratorHook", NULL},
  {"_pointer", (getter)PyIAcceleratorHook_GetPointer, NULL, "Get memory address for IAcceleratorHook", NULL},
  {"_IID", (getter)PyIAcceleratorHook_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIAcceleratorHook_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIAcceleratorHook_GetIgnoreFailures, (setter)PyIAcceleratorHook_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIAcceleratorHookObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriFramework.IAcceleratorHookObject",                          
                                              /* tp_name */
  sizeof(PyIAcceleratorHookObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIAcceleratorHookObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIAcceleratorHookMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIAcceleratorHookGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIAcceleratorHookObject_new,                      
                                              /* tp_new */
};

// Interface IPaletteEvents

typedef struct PyIPaletteEventsObject {
    PyObject_HEAD
    IPaletteEvents* m_pIPaletteEvents;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIPaletteEventsObject;

static PyObject*
PyIPaletteEventsObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIPaletteEventsObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IPaletteEvents* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IPaletteEvents, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IPaletteEvents with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIPaletteEventsObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IPaletteEvents");
            return NULL;
        }
        self->m_pIPaletteEvents = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IPaletteEvents");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IPaletteEvents");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IPaletteEvents* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IPaletteEvents, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IPaletteEvents");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIPaletteEventsObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IPaletteEvents");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIPaletteEvents = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIPaletteEventsObject_dealloc(PyIPaletteEventsObject* self)
{
    if (self->m_pIPaletteEvents)
        self->m_pIPaletteEvents->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIPaletteEvents_GetpUnk(PyIPaletteEventsObject* self)
{
    if (!self->m_pIPaletteEvents)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIPaletteEvents->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IPaletteEvents to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIPaletteEvents_GetPointer(PyIPaletteEventsObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIPaletteEvents);
}

static PyObject*
PyIPaletteEvents_GetIID(PyIPaletteEventsObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "ceb59b81-d86d-11d1-a21c-080009b6f22b");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIPaletteEvents_GetHR(PyIPaletteEventsObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIPaletteEvents_GetIgnoreFailures(PyIPaletteEventsObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIPaletteEvents_SetIgnoreFailures(PyIPaletteEventsObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIPaletteEvents_SupportsInterface(PyIPaletteEventsObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIPaletteEvents->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IPaletteEventsMethod_ContentsChanged(PyIPaletteEventsObject* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pIPaletteEvents->ContentsChanged();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPaletteEvents->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPaletteEvents) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPaletteEvents.ContentsChanged() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}


PyMethodDef PyIPaletteEventsMethods[] = {
    {"supports", (PyCFunction)PyIPaletteEvents_SupportsInterface, METH_O, ""},
    {"ContentsChanged", (PyCFunction)IPaletteEventsMethod_ContentsChanged, METH_NOARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIPaletteEventsGetSet[] = {
  {"_pUnk", (getter)PyIPaletteEvents_GetpUnk, NULL, "Get opaque pointer to an Unknown from IPaletteEvents", NULL},
  {"_pointer", (getter)PyIPaletteEvents_GetPointer, NULL, "Get memory address for IPaletteEvents", NULL},
  {"_IID", (getter)PyIPaletteEvents_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIPaletteEvents_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIPaletteEvents_GetIgnoreFailures, (setter)PyIPaletteEvents_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIPaletteEventsObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriFramework.IPaletteEventsObject",                          
                                              /* tp_name */
  sizeof(PyIPaletteEventsObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIPaletteEventsObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIPaletteEventsMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIPaletteEventsGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIPaletteEventsObject_new,                      
                                              /* tp_new */
};

// Interface ISelectionPalette

typedef struct PyISelectionPaletteObject {
    PyObject_HEAD
    ISelectionPalette* m_pISelectionPalette;
    HRESULT m_HR;
    int m_ignore_failures;
} PyISelectionPaletteObject;

static PyObject*
PyISelectionPaletteObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyISelectionPaletteObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ISelectionPalette* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ISelectionPalette, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ISelectionPalette with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyISelectionPaletteObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ISelectionPalette");
            return NULL;
        }
        self->m_pISelectionPalette = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ISelectionPalette");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ISelectionPalette");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ISelectionPalette* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ISelectionPalette, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ISelectionPalette");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyISelectionPaletteObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ISelectionPalette");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pISelectionPalette = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyISelectionPaletteObject_dealloc(PyISelectionPaletteObject* self)
{
    if (self->m_pISelectionPalette)
        self->m_pISelectionPalette->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyISelectionPalette_GetpUnk(PyISelectionPaletteObject* self)
{
    if (!self->m_pISelectionPalette)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pISelectionPalette->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ISelectionPalette to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyISelectionPalette_GetPointer(PyISelectionPaletteObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pISelectionPalette);
}

static PyObject*
PyISelectionPalette_GetIID(PyISelectionPaletteObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "5fdd7101-8e9f-11d1-a1b2-080009b6f22b");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyISelectionPalette_GetHR(PyISelectionPaletteObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyISelectionPalette_GetIgnoreFailures(PyISelectionPaletteObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyISelectionPalette_SetIgnoreFailures(PyISelectionPaletteObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyISelectionPalette_SupportsInterface(PyISelectionPaletteObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pISelectionPalette->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ISelectionPaletteMethod_get_Enabled(PyISelectionPaletteObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_Enabled = VARIANT_FALSE;
    PyObject* pyvar_Enabled = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Enabled

    // Call method on actual COM interface
    hr = self->m_pISelectionPalette->get_Enabled(&b_Enabled);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISelectionPalette->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISelectionPalette) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISelectionPalette.get_Enabled() returned %ld", (long)hr);
        goto iselectionpalette_get_enabled_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Enabled = ((b_Enabled == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto iselectionpalette_get_enabled_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Enabled);
    goto iselectionpalette_get_enabled_method_cleanup;

    iselectionpalette_get_enabled_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Enabled
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISelectionPalette.get_Enabled");
    return return_tuple;
}

static PyObject*
ISelectionPaletteMethod_get_Name(PyISelectionPaletteObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName;
    PyObject* pyvar_Name = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Name

    // Call method on actual COM interface
    hr = self->m_pISelectionPalette->get_Name(&bsName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISelectionPalette->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISelectionPalette) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISelectionPalette.get_Name() returned %ld", (long)hr);
        goto iselectionpalette_get_name_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Name = PyUnicode_FromWideChar(bsName,::SysStringLen(bsName));
    ::SysFreeString(bsName);
    
    if (PyErr_Occurred())
      goto iselectionpalette_get_name_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Name);
    goto iselectionpalette_get_name_method_cleanup;

    iselectionpalette_get_name_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Name != Py_None)
        Py_XDECREF(pyvar_Name);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISelectionPalette.get_Name");
    return return_tuple;
}

static PyObject*
ISelectionPaletteMethod_get_ItemCount(PyISelectionPaletteObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lItemCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ItemCount

    // Call method on actual COM interface
    hr = self->m_pISelectionPalette->get_ItemCount(&lItemCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISelectionPalette->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISelectionPalette) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISelectionPalette.get_ItemCount() returned %ld", (long)hr);
        goto iselectionpalette_get_itemcount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ItemCount

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lItemCount);
    goto iselectionpalette_get_itemcount_method_cleanup;

    iselectionpalette_get_itemcount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for ItemCount
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISelectionPalette.get_ItemCount");
    return return_tuple;
}

static PyObject*
ISelectionPaletteMethod_QueryItem(PyISelectionPaletteObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lIndex = 0;
    OLE_HANDLE HBitmap = 0;
    BSTR bsTooltip;
    PyObject* pyvar_Tooltip = Py_None;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lIndex))
      goto iselectionpalette_queryitem_method_cleanup;

    // Set up initial variable values as needed
    // No setup for Index
    // No setup for Bitmap
    // No setup for Tooltip

    // Call method on actual COM interface
    hr = self->m_pISelectionPalette->QueryItem(lIndex, &HBitmap, &bsTooltip);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISelectionPalette->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISelectionPalette) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISelectionPalette.QueryItem() returned %ld", (long)hr);
        goto iselectionpalette_queryitem_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Index
    // No teardown for Bitmap
    pyvar_Tooltip = PyUnicode_FromWideChar(bsTooltip,::SysStringLen(bsTooltip));
    ::SysFreeString(bsTooltip);
    
    if (PyErr_Occurred())
      goto iselectionpalette_queryitem_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("IO",
                                            HBitmap, pyvar_Tooltip);
    goto iselectionpalette_queryitem_method_cleanup;

    iselectionpalette_queryitem_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Index
    // No cleanup for Bitmap
    if (pyvar_Tooltip != Py_None)
        Py_XDECREF(pyvar_Tooltip);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISelectionPalette.QueryItem");
    return return_tuple;
}

static PyObject*
ISelectionPaletteMethod_get_MoreButtonCount(PyISelectionPaletteObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lMoreButtonCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for MoreButtonCount

    // Call method on actual COM interface
    hr = self->m_pISelectionPalette->get_MoreButtonCount(&lMoreButtonCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISelectionPalette->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISelectionPalette) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISelectionPalette.get_MoreButtonCount() returned %ld", (long)hr);
        goto iselectionpalette_get_morebuttoncount_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for MoreButtonCount

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lMoreButtonCount);
    goto iselectionpalette_get_morebuttoncount_method_cleanup;

    iselectionpalette_get_morebuttoncount_method_cleanup:
    self->m_HR = hr;
    // No cleanup for MoreButtonCount
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISelectionPalette.get_MoreButtonCount");
    return return_tuple;
}

static PyObject*
ISelectionPaletteMethod_QueryMoreButton(PyISelectionPaletteObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lIndex = 0;
    BSTR bsTooltip;
    PyObject* pyvar_Tooltip = Py_None;
    BSTR bsName;
    PyObject* pyvar_Name = Py_None;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lIndex))
      goto iselectionpalette_querymorebutton_method_cleanup;

    // Set up initial variable values as needed
    // No setup for Index
    // No setup for Tooltip
    // No setup for Name

    // Call method on actual COM interface
    hr = self->m_pISelectionPalette->QueryMoreButton(lIndex, &bsTooltip, &bsName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISelectionPalette->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISelectionPalette) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISelectionPalette.QueryMoreButton() returned %ld", (long)hr);
        goto iselectionpalette_querymorebutton_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Index
    pyvar_Tooltip = PyUnicode_FromWideChar(bsTooltip,::SysStringLen(bsTooltip));
    ::SysFreeString(bsTooltip);
    
    if (PyErr_Occurred())
      goto iselectionpalette_querymorebutton_method_cleanup;
    
    pyvar_Name = PyUnicode_FromWideChar(bsName,::SysStringLen(bsName));
    ::SysFreeString(bsName);
    
    if (PyErr_Occurred())
      goto iselectionpalette_querymorebutton_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("OO",
                                            pyvar_Tooltip, pyvar_Name);
    goto iselectionpalette_querymorebutton_method_cleanup;

    iselectionpalette_querymorebutton_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Index
    if (pyvar_Tooltip != Py_None)
        Py_XDECREF(pyvar_Tooltip);
    if (pyvar_Name != Py_None)
        Py_XDECREF(pyvar_Name);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISelectionPalette.QueryMoreButton");
    return return_tuple;
}

static PyObject*
ISelectionPaletteMethod_get_Category(PyISelectionPaletteObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsCategory;
    PyObject* pyvar_Category = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Category

    // Call method on actual COM interface
    hr = self->m_pISelectionPalette->get_Category(&bsCategory);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISelectionPalette->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISelectionPalette) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISelectionPalette.get_Category() returned %ld", (long)hr);
        goto iselectionpalette_get_category_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Category = PyUnicode_FromWideChar(bsCategory,::SysStringLen(bsCategory));
    ::SysFreeString(bsCategory);
    
    if (PyErr_Occurred())
      goto iselectionpalette_get_category_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Category);
    goto iselectionpalette_get_category_method_cleanup;

    iselectionpalette_get_category_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Category != Py_None)
        Py_XDECREF(pyvar_Category);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISelectionPalette.get_Category");
    return return_tuple;
}

static PyObject*
ISelectionPaletteMethod_get_ShortCutKey(PyISelectionPaletteObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsshortCutText;
    PyObject* pyvar_shortCutText = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for shortCutText

    // Call method on actual COM interface
    hr = self->m_pISelectionPalette->get_ShortCutKey(&bsshortCutText);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISelectionPalette->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISelectionPalette) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISelectionPalette.get_ShortCutKey() returned %ld", (long)hr);
        goto iselectionpalette_get_shortcutkey_method_cleanup;
    }

    // Set up return values as needed
    pyvar_shortCutText = PyUnicode_FromWideChar(bsshortCutText,::SysStringLen(bsshortCutText));
    ::SysFreeString(bsshortCutText);
    
    if (PyErr_Occurred())
      goto iselectionpalette_get_shortcutkey_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_shortCutText);
    goto iselectionpalette_get_shortcutkey_method_cleanup;

    iselectionpalette_get_shortcutkey_method_cleanup:
    self->m_HR = hr;
    if (pyvar_shortCutText != Py_None)
        Py_XDECREF(pyvar_shortCutText);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISelectionPalette.get_ShortCutKey");
    return return_tuple;
}

static PyObject*
ISelectionPaletteMethod_get_NumColumns(PyISelectionPaletteObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lNumColumns = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for NumColumns

    // Call method on actual COM interface
    hr = self->m_pISelectionPalette->get_NumColumns(&lNumColumns);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISelectionPalette->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISelectionPalette) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISelectionPalette.get_NumColumns() returned %ld", (long)hr);
        goto iselectionpalette_get_numcolumns_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for NumColumns

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lNumColumns);
    goto iselectionpalette_get_numcolumns_method_cleanup;

    iselectionpalette_get_numcolumns_method_cleanup:
    self->m_HR = hr;
    // No cleanup for NumColumns
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISelectionPalette.get_NumColumns");
    return return_tuple;
}

static PyObject*
ISelectionPaletteMethod_put_NumColumns(PyISelectionPaletteObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lNumColumns = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lNumColumns))
      goto iselectionpalette_put_numcolumns_method_cleanup;

    // Set up initial variable values as needed
    // No setup for NumColumns

    // Call method on actual COM interface
    hr = self->m_pISelectionPalette->put_NumColumns(lNumColumns);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISelectionPalette->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISelectionPalette) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISelectionPalette.put_NumColumns() returned %ld", (long)hr);
        goto iselectionpalette_put_numcolumns_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for NumColumns

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iselectionpalette_put_numcolumns_method_cleanup;

    iselectionpalette_put_numcolumns_method_cleanup:
    self->m_HR = hr;
    // No cleanup for NumColumns
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISelectionPalette.put_NumColumns");
    return return_tuple;
}

static PyObject*
ISelectionPaletteMethod_get_NumRows(PyISelectionPaletteObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lNumRows = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for NumRows

    // Call method on actual COM interface
    hr = self->m_pISelectionPalette->get_NumRows(&lNumRows);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISelectionPalette->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISelectionPalette) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISelectionPalette.get_NumRows() returned %ld", (long)hr);
        goto iselectionpalette_get_numrows_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for NumRows

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lNumRows);
    goto iselectionpalette_get_numrows_method_cleanup;

    iselectionpalette_get_numrows_method_cleanup:
    self->m_HR = hr;
    // No cleanup for NumRows
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISelectionPalette.get_NumRows");
    return return_tuple;
}

static PyObject*
ISelectionPaletteMethod_put_NumRows(PyISelectionPaletteObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lNumRows = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lNumRows))
      goto iselectionpalette_put_numrows_method_cleanup;

    // Set up initial variable values as needed
    // No setup for NumRows

    // Call method on actual COM interface
    hr = self->m_pISelectionPalette->put_NumRows(lNumRows);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISelectionPalette->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISelectionPalette) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISelectionPalette.put_NumRows() returned %ld", (long)hr);
        goto iselectionpalette_put_numrows_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for NumRows

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iselectionpalette_put_numrows_method_cleanup;

    iselectionpalette_put_numrows_method_cleanup:
    self->m_HR = hr;
    // No cleanup for NumRows
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISelectionPalette.put_NumRows");
    return return_tuple;
}

static PyObject*
ISelectionPaletteMethod_get_LastSelected(PyISelectionPaletteObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lIndex = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Index

    // Call method on actual COM interface
    hr = self->m_pISelectionPalette->get_LastSelected(&lIndex);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISelectionPalette->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISelectionPalette) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISelectionPalette.get_LastSelected() returned %ld", (long)hr);
        goto iselectionpalette_get_lastselected_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Index

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lIndex);
    goto iselectionpalette_get_lastselected_method_cleanup;

    iselectionpalette_get_lastselected_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Index
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISelectionPalette.get_LastSelected");
    return return_tuple;
}

static PyObject*
ISelectionPaletteMethod_put_LastSelected(PyISelectionPaletteObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lIndex = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lIndex))
      goto iselectionpalette_put_lastselected_method_cleanup;

    // Set up initial variable values as needed
    // No setup for Index

    // Call method on actual COM interface
    hr = self->m_pISelectionPalette->put_LastSelected(lIndex);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISelectionPalette->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISelectionPalette) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISelectionPalette.put_LastSelected() returned %ld", (long)hr);
        goto iselectionpalette_put_lastselected_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Index

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iselectionpalette_put_lastselected_method_cleanup;

    iselectionpalette_put_lastselected_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Index
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISelectionPalette.put_LastSelected");
    return return_tuple;
}

static PyObject*
ISelectionPaletteMethod_OnCreate(PyISelectionPaletteObject* self, PyObject* args)
{
    /* Param types that are unhandleable: 
       INPUT [u'IDispatch', u'*']
    */
    PyErr_SetString(PyExc_NotImplementedError, "Wrapper for ISelectionPalette.OnCreate not implemented.");
    return NULL;
}

static PyObject*
ISelectionPaletteMethod_OnClick(PyISelectionPaletteObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lIndex = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lIndex))
      goto iselectionpalette_onclick_method_cleanup;

    // Set up initial variable values as needed
    // No setup for Index

    // Call method on actual COM interface
    hr = self->m_pISelectionPalette->OnClick(lIndex);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISelectionPalette->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISelectionPalette) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISelectionPalette.OnClick() returned %ld", (long)hr);
        goto iselectionpalette_onclick_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Index

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iselectionpalette_onclick_method_cleanup;

    iselectionpalette_onclick_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Index
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISelectionPalette.OnClick");
    return return_tuple;
}


PyMethodDef PyISelectionPaletteMethods[] = {
    {"supports", (PyCFunction)PyISelectionPalette_SupportsInterface, METH_O, ""},
    {"get_Enabled", (PyCFunction)ISelectionPaletteMethod_get_Enabled, METH_VARARGS, ""},
    {"get_Name", (PyCFunction)ISelectionPaletteMethod_get_Name, METH_VARARGS, ""},
    {"get_ItemCount", (PyCFunction)ISelectionPaletteMethod_get_ItemCount, METH_VARARGS, ""},
    {"QueryItem", (PyCFunction)ISelectionPaletteMethod_QueryItem, METH_VARARGS, ""},
    {"get_MoreButtonCount", (PyCFunction)ISelectionPaletteMethod_get_MoreButtonCount, METH_VARARGS, ""},
    {"QueryMoreButton", (PyCFunction)ISelectionPaletteMethod_QueryMoreButton, METH_VARARGS, ""},
    {"get_Category", (PyCFunction)ISelectionPaletteMethod_get_Category, METH_VARARGS, ""},
    {"get_ShortCutKey", (PyCFunction)ISelectionPaletteMethod_get_ShortCutKey, METH_VARARGS, ""},
    {"get_NumColumns", (PyCFunction)ISelectionPaletteMethod_get_NumColumns, METH_VARARGS, ""},
    {"put_NumColumns", (PyCFunction)ISelectionPaletteMethod_put_NumColumns, METH_VARARGS, ""},
    {"get_NumRows", (PyCFunction)ISelectionPaletteMethod_get_NumRows, METH_VARARGS, ""},
    {"put_NumRows", (PyCFunction)ISelectionPaletteMethod_put_NumRows, METH_VARARGS, ""},
    {"get_LastSelected", (PyCFunction)ISelectionPaletteMethod_get_LastSelected, METH_VARARGS, ""},
    {"put_LastSelected", (PyCFunction)ISelectionPaletteMethod_put_LastSelected, METH_VARARGS, ""},
    {"OnCreate", (PyCFunction)ISelectionPaletteMethod_OnCreate, METH_VARARGS, ""},
    {"OnClick", (PyCFunction)ISelectionPaletteMethod_OnClick, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyISelectionPaletteGetSet[] = {
  {"_pUnk", (getter)PyISelectionPalette_GetpUnk, NULL, "Get opaque pointer to an Unknown from ISelectionPalette", NULL},
  {"_pointer", (getter)PyISelectionPalette_GetPointer, NULL, "Get memory address for ISelectionPalette", NULL},
  {"_IID", (getter)PyISelectionPalette_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyISelectionPalette_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyISelectionPalette_GetIgnoreFailures, (setter)PyISelectionPalette_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyISelectionPaletteObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriFramework.ISelectionPaletteObject",                          
                                              /* tp_name */
  sizeof(PyISelectionPaletteObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyISelectionPaletteObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyISelectionPaletteMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyISelectionPaletteGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyISelectionPaletteObject_new,                      
                                              /* tp_new */
};

// Interface IApplicationStatus

typedef struct PyIApplicationStatusObject {
    PyObject_HEAD
    IApplicationStatus* m_pIApplicationStatus;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIApplicationStatusObject;

static PyObject*
PyIApplicationStatusObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIApplicationStatusObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IApplicationStatus* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IApplicationStatus, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IApplicationStatus with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIApplicationStatusObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IApplicationStatus");
            return NULL;
        }
        self->m_pIApplicationStatus = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IApplicationStatus");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IApplicationStatus");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IApplicationStatus* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IApplicationStatus, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IApplicationStatus");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIApplicationStatusObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IApplicationStatus");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIApplicationStatus = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIApplicationStatusObject_dealloc(PyIApplicationStatusObject* self)
{
    if (self->m_pIApplicationStatus)
        self->m_pIApplicationStatus->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIApplicationStatus_GetpUnk(PyIApplicationStatusObject* self)
{
    if (!self->m_pIApplicationStatus)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIApplicationStatus->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IApplicationStatus to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIApplicationStatus_GetPointer(PyIApplicationStatusObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIApplicationStatus);
}

static PyObject*
PyIApplicationStatus_GetIID(PyIApplicationStatusObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "0573d2f5-a2a0-4ef6-bdf7-416097472c8d");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIApplicationStatus_GetHR(PyIApplicationStatusObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIApplicationStatus_GetIgnoreFailures(PyIApplicationStatusObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIApplicationStatus_SetIgnoreFailures(PyIApplicationStatusObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIApplicationStatus_SupportsInterface(PyIApplicationStatusObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIApplicationStatus->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IApplicationStatusMethod_get_Initialized(PyIApplicationStatusObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_pOut = VARIANT_FALSE;
    PyObject* pyvar_pOut = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pOut

    // Call method on actual COM interface
    hr = self->m_pIApplicationStatus->get_Initialized(&b_pOut);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIApplicationStatus->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IApplicationStatus) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IApplicationStatus.get_Initialized() returned %ld", (long)hr);
        goto iapplicationstatus_get_initialized_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pOut = ((b_pOut == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto iapplicationstatus_get_initialized_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pOut);
    goto iapplicationstatus_get_initialized_method_cleanup;

    iapplicationstatus_get_initialized_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pOut
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IApplicationStatus.get_Initialized");
    return return_tuple;
}


PyMethodDef PyIApplicationStatusMethods[] = {
    {"supports", (PyCFunction)PyIApplicationStatus_SupportsInterface, METH_O, ""},
    {"get_Initialized", (PyCFunction)IApplicationStatusMethod_get_Initialized, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIApplicationStatusGetSet[] = {
  {"_pUnk", (getter)PyIApplicationStatus_GetpUnk, NULL, "Get opaque pointer to an Unknown from IApplicationStatus", NULL},
  {"_pointer", (getter)PyIApplicationStatus_GetPointer, NULL, "Get memory address for IApplicationStatus", NULL},
  {"_IID", (getter)PyIApplicationStatus_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIApplicationStatus_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIApplicationStatus_GetIgnoreFailures, (setter)PyIApplicationStatus_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIApplicationStatusObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriFramework.IApplicationStatusObject",                          
                                              /* tp_name */
  sizeof(PyIApplicationStatusObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIApplicationStatusObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIApplicationStatusMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIApplicationStatusGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIApplicationStatusObject_new,                      
                                              /* tp_new */
};

// Interface IWindowPosition

typedef struct PyIWindowPositionObject {
    PyObject_HEAD
    IWindowPosition* m_pIWindowPosition;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIWindowPositionObject;

static PyObject*
PyIWindowPositionObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIWindowPositionObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IWindowPosition* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IWindowPosition, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IWindowPosition with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIWindowPositionObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IWindowPosition");
            return NULL;
        }
        self->m_pIWindowPosition = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IWindowPosition");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IWindowPosition");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IWindowPosition* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IWindowPosition, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IWindowPosition");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIWindowPositionObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IWindowPosition");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIWindowPosition = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIWindowPositionObject_dealloc(PyIWindowPositionObject* self)
{
    if (self->m_pIWindowPosition)
        self->m_pIWindowPosition->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIWindowPosition_GetpUnk(PyIWindowPositionObject* self)
{
    if (!self->m_pIWindowPosition)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIWindowPosition->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IWindowPosition to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIWindowPosition_GetPointer(PyIWindowPositionObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIWindowPosition);
}

static PyObject*
PyIWindowPosition_GetIID(PyIWindowPositionObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "88c995ae-64a7-43f5-bf12-88ac179b25a6");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIWindowPosition_GetHR(PyIWindowPositionObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIWindowPosition_GetIgnoreFailures(PyIWindowPositionObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIWindowPosition_SetIgnoreFailures(PyIWindowPositionObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIWindowPosition_SupportsInterface(PyIWindowPositionObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIWindowPosition->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IWindowPositionMethod_put_Left(PyIWindowPositionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lLeft = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lLeft))
      goto iwindowposition_put_left_method_cleanup;

    // Set up initial variable values as needed
    // No setup for Left

    // Call method on actual COM interface
    hr = self->m_pIWindowPosition->put_Left(lLeft);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWindowPosition->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWindowPosition) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWindowPosition.put_Left() returned %ld", (long)hr);
        goto iwindowposition_put_left_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Left

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iwindowposition_put_left_method_cleanup;

    iwindowposition_put_left_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Left
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWindowPosition.put_Left");
    return return_tuple;
}

static PyObject*
IWindowPositionMethod_get_Left(PyIWindowPositionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lLeft = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Left

    // Call method on actual COM interface
    hr = self->m_pIWindowPosition->get_Left(&lLeft);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWindowPosition->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWindowPosition) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWindowPosition.get_Left() returned %ld", (long)hr);
        goto iwindowposition_get_left_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Left

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lLeft);
    goto iwindowposition_get_left_method_cleanup;

    iwindowposition_get_left_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Left
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWindowPosition.get_Left");
    return return_tuple;
}

static PyObject*
IWindowPositionMethod_put_Top(PyIWindowPositionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lTop = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lTop))
      goto iwindowposition_put_top_method_cleanup;

    // Set up initial variable values as needed
    // No setup for Top

    // Call method on actual COM interface
    hr = self->m_pIWindowPosition->put_Top(lTop);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWindowPosition->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWindowPosition) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWindowPosition.put_Top() returned %ld", (long)hr);
        goto iwindowposition_put_top_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Top

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iwindowposition_put_top_method_cleanup;

    iwindowposition_put_top_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Top
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWindowPosition.put_Top");
    return return_tuple;
}

static PyObject*
IWindowPositionMethod_get_Top(PyIWindowPositionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lTop = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Top

    // Call method on actual COM interface
    hr = self->m_pIWindowPosition->get_Top(&lTop);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWindowPosition->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWindowPosition) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWindowPosition.get_Top() returned %ld", (long)hr);
        goto iwindowposition_get_top_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Top

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lTop);
    goto iwindowposition_get_top_method_cleanup;

    iwindowposition_get_top_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Top
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWindowPosition.get_Top");
    return return_tuple;
}

static PyObject*
IWindowPositionMethod_put_Width(PyIWindowPositionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lWidth = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lWidth))
      goto iwindowposition_put_width_method_cleanup;

    // Set up initial variable values as needed
    // No setup for Width

    // Call method on actual COM interface
    hr = self->m_pIWindowPosition->put_Width(lWidth);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWindowPosition->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWindowPosition) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWindowPosition.put_Width() returned %ld", (long)hr);
        goto iwindowposition_put_width_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Width

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iwindowposition_put_width_method_cleanup;

    iwindowposition_put_width_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Width
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWindowPosition.put_Width");
    return return_tuple;
}

static PyObject*
IWindowPositionMethod_get_Width(PyIWindowPositionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lWidth = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Width

    // Call method on actual COM interface
    hr = self->m_pIWindowPosition->get_Width(&lWidth);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWindowPosition->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWindowPosition) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWindowPosition.get_Width() returned %ld", (long)hr);
        goto iwindowposition_get_width_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Width

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lWidth);
    goto iwindowposition_get_width_method_cleanup;

    iwindowposition_get_width_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Width
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWindowPosition.get_Width");
    return return_tuple;
}

static PyObject*
IWindowPositionMethod_put_Height(PyIWindowPositionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lHeight = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lHeight))
      goto iwindowposition_put_height_method_cleanup;

    // Set up initial variable values as needed
    // No setup for Height

    // Call method on actual COM interface
    hr = self->m_pIWindowPosition->put_Height(lHeight);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWindowPosition->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWindowPosition) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWindowPosition.put_Height() returned %ld", (long)hr);
        goto iwindowposition_put_height_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Height

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iwindowposition_put_height_method_cleanup;

    iwindowposition_put_height_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Height
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWindowPosition.put_Height");
    return return_tuple;
}

static PyObject*
IWindowPositionMethod_get_Height(PyIWindowPositionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lHeight = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Height

    // Call method on actual COM interface
    hr = self->m_pIWindowPosition->get_Height(&lHeight);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWindowPosition->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWindowPosition) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWindowPosition.get_Height() returned %ld", (long)hr);
        goto iwindowposition_get_height_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Height

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lHeight);
    goto iwindowposition_get_height_method_cleanup;

    iwindowposition_get_height_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Height
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWindowPosition.get_Height");
    return return_tuple;
}

static PyObject*
IWindowPositionMethod_Move(PyIWindowPositionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lLeft = 0;
    long lTop = 0;
    long lWidth = 0;
    long lHeight = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "llll", &lLeft, &lTop, &lWidth, &lHeight))
      goto iwindowposition_move_method_cleanup;

    // Set up initial variable values as needed
    // No setup for Left
    // No setup for Top
    // No setup for Width
    // No setup for Height

    // Call method on actual COM interface
    hr = self->m_pIWindowPosition->Move(lLeft, lTop, lWidth, lHeight);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWindowPosition->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWindowPosition) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWindowPosition.Move() returned %ld", (long)hr);
        goto iwindowposition_move_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Left
    // No teardown for Top
    // No teardown for Width
    // No teardown for Height

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iwindowposition_move_method_cleanup;

    iwindowposition_move_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Left
    // No cleanup for Top
    // No cleanup for Width
    // No cleanup for Height
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWindowPosition.Move");
    return return_tuple;
}

static PyObject*
IWindowPositionMethod_put_State(PyIWindowPositionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriWindowState ewindowState;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&ewindowState))
      goto iwindowposition_put_state_method_cleanup;

    // Set up initial variable values as needed
    // No setup for windowState

    // Call method on actual COM interface
    hr = self->m_pIWindowPosition->put_State(ewindowState);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWindowPosition->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWindowPosition) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWindowPosition.put_State() returned %ld", (long)hr);
        goto iwindowposition_put_state_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for windowState

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iwindowposition_put_state_method_cleanup;

    iwindowposition_put_state_method_cleanup:
    self->m_HR = hr;
    // No cleanup for windowState
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWindowPosition.put_State");
    return return_tuple;
}

static PyObject*
IWindowPositionMethod_get_State(PyIWindowPositionObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriWindowState ewindowState;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for windowState

    // Call method on actual COM interface
    hr = self->m_pIWindowPosition->get_State(&ewindowState);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIWindowPosition->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IWindowPosition) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IWindowPosition.get_State() returned %ld", (long)hr);
        goto iwindowposition_get_state_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for windowState

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)ewindowState);
    goto iwindowposition_get_state_method_cleanup;

    iwindowposition_get_state_method_cleanup:
    self->m_HR = hr;
    // No cleanup for windowState
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IWindowPosition.get_State");
    return return_tuple;
}


PyMethodDef PyIWindowPositionMethods[] = {
    {"supports", (PyCFunction)PyIWindowPosition_SupportsInterface, METH_O, ""},
    {"put_Left", (PyCFunction)IWindowPositionMethod_put_Left, METH_VARARGS, ""},
    {"get_Left", (PyCFunction)IWindowPositionMethod_get_Left, METH_VARARGS, ""},
    {"put_Top", (PyCFunction)IWindowPositionMethod_put_Top, METH_VARARGS, ""},
    {"get_Top", (PyCFunction)IWindowPositionMethod_get_Top, METH_VARARGS, ""},
    {"put_Width", (PyCFunction)IWindowPositionMethod_put_Width, METH_VARARGS, ""},
    {"get_Width", (PyCFunction)IWindowPositionMethod_get_Width, METH_VARARGS, ""},
    {"put_Height", (PyCFunction)IWindowPositionMethod_put_Height, METH_VARARGS, ""},
    {"get_Height", (PyCFunction)IWindowPositionMethod_get_Height, METH_VARARGS, ""},
    {"Move", (PyCFunction)IWindowPositionMethod_Move, METH_VARARGS, ""},
    {"put_State", (PyCFunction)IWindowPositionMethod_put_State, METH_VARARGS, ""},
    {"get_State", (PyCFunction)IWindowPositionMethod_get_State, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIWindowPositionGetSet[] = {
  {"_pUnk", (getter)PyIWindowPosition_GetpUnk, NULL, "Get opaque pointer to an Unknown from IWindowPosition", NULL},
  {"_pointer", (getter)PyIWindowPosition_GetPointer, NULL, "Get memory address for IWindowPosition", NULL},
  {"_IID", (getter)PyIWindowPosition_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIWindowPosition_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIWindowPosition_GetIgnoreFailures, (setter)PyIWindowPosition_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIWindowPositionObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriFramework.IWindowPositionObject",                          
                                              /* tp_name */
  sizeof(PyIWindowPositionObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIWindowPositionObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIWindowPositionMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIWindowPositionGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIWindowPositionObject_new,                      
                                              /* tp_new */
};

// Interface IMouseCursor

typedef struct PyIMouseCursorObject {
    PyObject_HEAD
    IMouseCursor* m_pIMouseCursor;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIMouseCursorObject;

static PyObject*
PyIMouseCursorObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIMouseCursorObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IMouseCursor* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IMouseCursor, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IMouseCursor with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIMouseCursorObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IMouseCursor");
            return NULL;
        }
        self->m_pIMouseCursor = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IMouseCursor");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IMouseCursor");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IMouseCursor* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IMouseCursor, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IMouseCursor");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIMouseCursorObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IMouseCursor");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIMouseCursor = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIMouseCursorObject_dealloc(PyIMouseCursorObject* self)
{
    if (self->m_pIMouseCursor)
        self->m_pIMouseCursor->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIMouseCursor_GetpUnk(PyIMouseCursorObject* self)
{
    if (!self->m_pIMouseCursor)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIMouseCursor->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IMouseCursor to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIMouseCursor_GetPointer(PyIMouseCursorObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIMouseCursor);
}

static PyObject*
PyIMouseCursor_GetIID(PyIMouseCursorObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "f91752ef-3339-482f-ad92-4b752c98e744");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIMouseCursor_GetHR(PyIMouseCursorObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIMouseCursor_GetIgnoreFailures(PyIMouseCursorObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIMouseCursor_SetIgnoreFailures(PyIMouseCursorObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIMouseCursor_SupportsInterface(PyIMouseCursorObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIMouseCursor->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IMouseCursorMethod_SetCursor(PyIMouseCursorObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT vcursorID;
    ::VariantInit(&vcursorID);
    PyObject* pyvar_cursorID = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_cursorID))
      goto imousecursor_setcursor_method_cleanup;

    // Set up initial variable values as needed
    PyObject_AsVariant(pyvar_cursorID, &vcursorID);
    
    if (PyErr_Occurred())
      goto imousecursor_setcursor_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIMouseCursor->SetCursor(vcursorID);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIMouseCursor->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IMouseCursor) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IMouseCursor.SetCursor() returned %ld", (long)hr);
        goto imousecursor_setcursor_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for cursorID

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto imousecursor_setcursor_method_cleanup;

    imousecursor_setcursor_method_cleanup:
    self->m_HR = hr;
    ::VariantClear(&vcursorID);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IMouseCursor.SetCursor");
    return return_tuple;
}


PyMethodDef PyIMouseCursorMethods[] = {
    {"supports", (PyCFunction)PyIMouseCursor_SupportsInterface, METH_O, ""},
    {"SetCursor", (PyCFunction)IMouseCursorMethod_SetCursor, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIMouseCursorGetSet[] = {
  {"_pUnk", (getter)PyIMouseCursor_GetpUnk, NULL, "Get opaque pointer to an Unknown from IMouseCursor", NULL},
  {"_pointer", (getter)PyIMouseCursor_GetPointer, NULL, "Get memory address for IMouseCursor", NULL},
  {"_IID", (getter)PyIMouseCursor_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIMouseCursor_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIMouseCursor_GetIgnoreFailures, (setter)PyIMouseCursor_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIMouseCursorObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriFramework.IMouseCursorObject",                          
                                              /* tp_name */
  sizeof(PyIMouseCursorObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIMouseCursorObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIMouseCursorMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIMouseCursorGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIMouseCursorObject_new,                      
                                              /* tp_new */
};

// Interface IObjectFactory

typedef struct PyIObjectFactoryObject {
    PyObject_HEAD
    IObjectFactory* m_pIObjectFactory;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIObjectFactoryObject;

static PyObject*
PyIObjectFactoryObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIObjectFactoryObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IObjectFactory* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IObjectFactory, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IObjectFactory with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIObjectFactoryObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IObjectFactory");
            return NULL;
        }
        self->m_pIObjectFactory = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IObjectFactory");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IObjectFactory");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IObjectFactory* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IObjectFactory, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IObjectFactory");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIObjectFactoryObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IObjectFactory");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIObjectFactory = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIObjectFactoryObject_dealloc(PyIObjectFactoryObject* self)
{
    if (self->m_pIObjectFactory)
        self->m_pIObjectFactory->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIObjectFactory_GetpUnk(PyIObjectFactoryObject* self)
{
    if (!self->m_pIObjectFactory)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIObjectFactory->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IObjectFactory to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIObjectFactory_GetPointer(PyIObjectFactoryObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIObjectFactory);
}

static PyObject*
PyIObjectFactory_GetIID(PyIObjectFactoryObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "60a1409b-9b67-431b-b428-e2c17be36e9a");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIObjectFactory_GetHR(PyIObjectFactoryObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIObjectFactory_GetIgnoreFailures(PyIObjectFactoryObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIObjectFactory_SetIgnoreFailures(PyIObjectFactoryObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIObjectFactory_SupportsInterface(PyIObjectFactoryObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIObjectFactory->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IObjectFactoryMethod_Create(PyIObjectFactoryObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT vobjectID;
    ::VariantInit(&vobjectID);
    PyObject* pyvar_objectID = NULL;
    IUnknown* ipppObj = NULL;
    PyObject* py_ppObj = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_objectID))
      goto iobjectfactory_create_method_cleanup;

    // Set up initial variable values as needed
    PyObject_AsVariant(pyvar_objectID, &vobjectID);
    
    if (PyErr_Occurred())
      goto iobjectfactory_create_method_cleanup;
    
    // No setup for ppObj

    // Call method on actual COM interface
    hr = self->m_pIObjectFactory->Create(vobjectID, &ipppObj);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIObjectFactory->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IObjectFactory) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IObjectFactory.Create() returned %ld", (long)hr);
        goto iobjectfactory_create_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for objectID
    Py_XDECREF(py_ppObj);
    if (ipppObj)
    {
        IUnknown* pUnk = NULL;
        ipppObj->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppObj = IUnknownToPythonIIDObject(pUnk, &IID_IUnknown);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppObj)
    {
        if (py_ppObj)
           Py_DECREF(py_ppObj);
        py_ppObj = Py_None;
        Py_INCREF(py_ppObj);
    }
    if (PyErr_Occurred())
      goto iobjectfactory_create_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppObj);
    goto iobjectfactory_create_method_cleanup;

    iobjectfactory_create_method_cleanup:
    self->m_HR = hr;
    ::VariantClear(&vobjectID);
    Py_XDECREF(py_ppObj);
    if (ipppObj)
      ipppObj->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IObjectFactory.Create");
    return return_tuple;
}


PyMethodDef PyIObjectFactoryMethods[] = {
    {"supports", (PyCFunction)PyIObjectFactory_SupportsInterface, METH_O, ""},
    {"Create", (PyCFunction)IObjectFactoryMethod_Create, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIObjectFactoryGetSet[] = {
  {"_pUnk", (getter)PyIObjectFactory_GetpUnk, NULL, "Get opaque pointer to an Unknown from IObjectFactory", NULL},
  {"_pointer", (getter)PyIObjectFactory_GetPointer, NULL, "Get memory address for IObjectFactory", NULL},
  {"_IID", (getter)PyIObjectFactory_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIObjectFactory_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIObjectFactory_GetIgnoreFailures, (setter)PyIObjectFactory_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIObjectFactoryObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriFramework.IObjectFactoryObject",                          
                                              /* tp_name */
  sizeof(PyIObjectFactoryObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIObjectFactoryObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIObjectFactoryMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIObjectFactoryGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIObjectFactoryObject_new,                      
                                              /* tp_new */
};

// Interface IVbaApplication

typedef struct PyIVbaApplicationObject {
    PyObject_HEAD
    IVbaApplication* m_pIVbaApplication;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIVbaApplicationObject;

static PyObject*
PyIVbaApplicationObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIVbaApplicationObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IVbaApplication* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IVbaApplication, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IVbaApplication with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIVbaApplicationObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IVbaApplication");
            return NULL;
        }
        self->m_pIVbaApplication = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IVbaApplication");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IVbaApplication");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IVbaApplication* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IVbaApplication, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IVbaApplication");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIVbaApplicationObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IVbaApplication");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIVbaApplication = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIVbaApplicationObject_dealloc(PyIVbaApplicationObject* self)
{
    if (self->m_pIVbaApplication)
        self->m_pIVbaApplication->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIVbaApplication_GetpUnk(PyIVbaApplicationObject* self)
{
    if (!self->m_pIVbaApplication)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIVbaApplication->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IVbaApplication to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIVbaApplication_GetPointer(PyIVbaApplicationObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIVbaApplication);
}

static PyObject*
PyIVbaApplication_GetIID(PyIVbaApplicationObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "d7ee3483-004d-11d4-9fe7-00c04f6bc78e");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIVbaApplication_GetHR(PyIVbaApplicationObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIVbaApplication_GetIgnoreFailures(PyIVbaApplicationObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIVbaApplication_SetIgnoreFailures(PyIVbaApplicationObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIVbaApplication_SupportsInterface(PyIVbaApplicationObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIVbaApplication->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IVbaApplicationMethod_RunVBAMacro(PyIVbaApplicationObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsdocName = 0;
    PyObject* pyvar_docName;
    PyObject* unicodedocName = NULL;
    BSTR bsmoduleName = 0;
    PyObject* pyvar_moduleName;
    PyObject* unicodemoduleName = NULL;
    BSTR bsmacroName = 0;
    PyObject* pyvar_macroName;
    PyObject* unicodemacroName = NULL;
    VARIANT varguments;
    ::VariantInit(&varguments);
    PyObject* pyvar_arguments = NULL;
    VARIANT vreturnValue;
    ::VariantInit(&vreturnValue);
    PyObject* pyvar_returnValue = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOOO", &pyvar_docName, &pyvar_moduleName, &pyvar_macroName, &pyvar_arguments))
      goto ivbaapplication_runvbamacro_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_docName))
        unicodedocName = PyUnicode_FromObject(pyvar_docName);
    else if (PyUnicode_Check(pyvar_docName))
    {
        unicodedocName = pyvar_docName;
        Py_INCREF(unicodedocName);
    }
    else if (pyvar_docName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter docName at index 0");
    if (unicodedocName)
        bsdocName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodedocName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodedocName));
    
    if (PyErr_Occurred())
      goto ivbaapplication_runvbamacro_method_cleanup;
    
    if (PyString_Check(pyvar_moduleName))
        unicodemoduleName = PyUnicode_FromObject(pyvar_moduleName);
    else if (PyUnicode_Check(pyvar_moduleName))
    {
        unicodemoduleName = pyvar_moduleName;
        Py_INCREF(unicodemoduleName);
    }
    else if (pyvar_moduleName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter moduleName at index 1");
    if (unicodemoduleName)
        bsmoduleName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodemoduleName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodemoduleName));
    
    if (PyErr_Occurred())
      goto ivbaapplication_runvbamacro_method_cleanup;
    
    if (PyString_Check(pyvar_macroName))
        unicodemacroName = PyUnicode_FromObject(pyvar_macroName);
    else if (PyUnicode_Check(pyvar_macroName))
    {
        unicodemacroName = pyvar_macroName;
        Py_INCREF(unicodemacroName);
    }
    else if (pyvar_macroName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter macroName at index 2");
    if (unicodemacroName)
        bsmacroName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodemacroName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodemacroName));
    
    if (PyErr_Occurred())
      goto ivbaapplication_runvbamacro_method_cleanup;
    
    PyObject_AsVariant(pyvar_arguments, &varguments);
    
    if (PyErr_Occurred())
      goto ivbaapplication_runvbamacro_method_cleanup;
    
    // No setup for returnValue

    // Call method on actual COM interface
    hr = self->m_pIVbaApplication->RunVBAMacro(bsdocName, bsmoduleName, bsmacroName, &varguments, &vreturnValue);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIVbaApplication->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IVbaApplication) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IVbaApplication.RunVBAMacro() returned %ld", (long)hr);
        goto ivbaapplication_runvbamacro_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for docName
    // No teardown for moduleName
    // No teardown for macroName
    // No teardown for arguments
    pyvar_returnValue = Variant_AsPyObject(&vreturnValue);
    if (PyErr_Occurred())
      goto ivbaapplication_runvbamacro_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_returnValue);
    goto ivbaapplication_runvbamacro_method_cleanup;

    ivbaapplication_runvbamacro_method_cleanup:
    self->m_HR = hr;
    if (bsdocName)
        ::SysFreeString(bsdocName);
    
    if (bsmoduleName)
        ::SysFreeString(bsmoduleName);
    
    if (bsmacroName)
        ::SysFreeString(bsmacroName);
    
    ::VariantClear(&varguments);
    ::VariantClear(&vreturnValue);
    Py_XDECREF(pyvar_returnValue);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IVbaApplication.RunVBAMacro");
    return return_tuple;
}

static PyObject*
IVbaApplicationMethod_CreateCodeModule(PyIVbaApplicationObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsdocName = 0;
    PyObject* pyvar_docName;
    PyObject* unicodedocName = NULL;
    BSTR bsmoduleName = 0;
    PyObject* pyvar_moduleName;
    PyObject* unicodemoduleName = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OO", &pyvar_docName, &pyvar_moduleName))
      goto ivbaapplication_createcodemodule_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_docName))
        unicodedocName = PyUnicode_FromObject(pyvar_docName);
    else if (PyUnicode_Check(pyvar_docName))
    {
        unicodedocName = pyvar_docName;
        Py_INCREF(unicodedocName);
    }
    else if (pyvar_docName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter docName at index 0");
    if (unicodedocName)
        bsdocName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodedocName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodedocName));
    
    if (PyErr_Occurred())
      goto ivbaapplication_createcodemodule_method_cleanup;
    
    if (PyString_Check(pyvar_moduleName))
        unicodemoduleName = PyUnicode_FromObject(pyvar_moduleName);
    else if (PyUnicode_Check(pyvar_moduleName))
    {
        unicodemoduleName = pyvar_moduleName;
        Py_INCREF(unicodemoduleName);
    }
    else if (pyvar_moduleName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter moduleName at index 1");
    if (unicodemoduleName)
        bsmoduleName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodemoduleName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodemoduleName));
    
    if (PyErr_Occurred())
      goto ivbaapplication_createcodemodule_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIVbaApplication->CreateCodeModule(bsdocName, bsmoduleName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIVbaApplication->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IVbaApplication) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IVbaApplication.CreateCodeModule() returned %ld", (long)hr);
        goto ivbaapplication_createcodemodule_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for docName
    // No teardown for moduleName

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ivbaapplication_createcodemodule_method_cleanup;

    ivbaapplication_createcodemodule_method_cleanup:
    self->m_HR = hr;
    if (bsdocName)
        ::SysFreeString(bsdocName);
    
    if (bsmoduleName)
        ::SysFreeString(bsmoduleName);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IVbaApplication.CreateCodeModule");
    return return_tuple;
}

static PyObject*
IVbaApplicationMethod_RemoveCodeModule(PyIVbaApplicationObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsdocName = 0;
    PyObject* pyvar_docName;
    PyObject* unicodedocName = NULL;
    BSTR bsmoduleName = 0;
    PyObject* pyvar_moduleName;
    PyObject* unicodemoduleName = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OO", &pyvar_docName, &pyvar_moduleName))
      goto ivbaapplication_removecodemodule_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_docName))
        unicodedocName = PyUnicode_FromObject(pyvar_docName);
    else if (PyUnicode_Check(pyvar_docName))
    {
        unicodedocName = pyvar_docName;
        Py_INCREF(unicodedocName);
    }
    else if (pyvar_docName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter docName at index 0");
    if (unicodedocName)
        bsdocName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodedocName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodedocName));
    
    if (PyErr_Occurred())
      goto ivbaapplication_removecodemodule_method_cleanup;
    
    if (PyString_Check(pyvar_moduleName))
        unicodemoduleName = PyUnicode_FromObject(pyvar_moduleName);
    else if (PyUnicode_Check(pyvar_moduleName))
    {
        unicodemoduleName = pyvar_moduleName;
        Py_INCREF(unicodemoduleName);
    }
    else if (pyvar_moduleName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter moduleName at index 1");
    if (unicodemoduleName)
        bsmoduleName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodemoduleName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodemoduleName));
    
    if (PyErr_Occurred())
      goto ivbaapplication_removecodemodule_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIVbaApplication->RemoveCodeModule(bsdocName, bsmoduleName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIVbaApplication->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IVbaApplication) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IVbaApplication.RemoveCodeModule() returned %ld", (long)hr);
        goto ivbaapplication_removecodemodule_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for docName
    // No teardown for moduleName

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ivbaapplication_removecodemodule_method_cleanup;

    ivbaapplication_removecodemodule_method_cleanup:
    self->m_HR = hr;
    if (bsdocName)
        ::SysFreeString(bsdocName);
    
    if (bsmoduleName)
        ::SysFreeString(bsmoduleName);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IVbaApplication.RemoveCodeModule");
    return return_tuple;
}

static PyObject*
IVbaApplicationMethod_InsertCode(PyIVbaApplicationObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsdocName = 0;
    PyObject* pyvar_docName;
    PyObject* unicodedocName = NULL;
    BSTR bsmoduleName = 0;
    PyObject* pyvar_moduleName;
    PyObject* unicodemoduleName = NULL;
    BSTR bscodeText = 0;
    PyObject* pyvar_codeText;
    PyObject* unicodecodeText = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOO", &pyvar_docName, &pyvar_moduleName, &pyvar_codeText))
      goto ivbaapplication_insertcode_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_docName))
        unicodedocName = PyUnicode_FromObject(pyvar_docName);
    else if (PyUnicode_Check(pyvar_docName))
    {
        unicodedocName = pyvar_docName;
        Py_INCREF(unicodedocName);
    }
    else if (pyvar_docName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter docName at index 0");
    if (unicodedocName)
        bsdocName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodedocName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodedocName));
    
    if (PyErr_Occurred())
      goto ivbaapplication_insertcode_method_cleanup;
    
    if (PyString_Check(pyvar_moduleName))
        unicodemoduleName = PyUnicode_FromObject(pyvar_moduleName);
    else if (PyUnicode_Check(pyvar_moduleName))
    {
        unicodemoduleName = pyvar_moduleName;
        Py_INCREF(unicodemoduleName);
    }
    else if (pyvar_moduleName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter moduleName at index 1");
    if (unicodemoduleName)
        bsmoduleName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodemoduleName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodemoduleName));
    
    if (PyErr_Occurred())
      goto ivbaapplication_insertcode_method_cleanup;
    
    if (PyString_Check(pyvar_codeText))
        unicodecodeText = PyUnicode_FromObject(pyvar_codeText);
    else if (PyUnicode_Check(pyvar_codeText))
    {
        unicodecodeText = pyvar_codeText;
        Py_INCREF(unicodecodeText);
    }
    else if (pyvar_codeText != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter codeText at index 2");
    if (unicodecodeText)
        bscodeText = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodecodeText), 
                                            (UINT)PyUnicode_GET_SIZE(unicodecodeText));
    
    if (PyErr_Occurred())
      goto ivbaapplication_insertcode_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIVbaApplication->InsertCode(bsdocName, bsmoduleName, bscodeText);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIVbaApplication->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IVbaApplication) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IVbaApplication.InsertCode() returned %ld", (long)hr);
        goto ivbaapplication_insertcode_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for docName
    // No teardown for moduleName
    // No teardown for codeText

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ivbaapplication_insertcode_method_cleanup;

    ivbaapplication_insertcode_method_cleanup:
    self->m_HR = hr;
    if (bsdocName)
        ::SysFreeString(bsdocName);
    
    if (bsmoduleName)
        ::SysFreeString(bsmoduleName);
    
    if (bscodeText)
        ::SysFreeString(bscodeText);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IVbaApplication.InsertCode");
    return return_tuple;
}


PyMethodDef PyIVbaApplicationMethods[] = {
    {"supports", (PyCFunction)PyIVbaApplication_SupportsInterface, METH_O, ""},
    {"RunVBAMacro", (PyCFunction)IVbaApplicationMethod_RunVBAMacro, METH_VARARGS, ""},
    {"CreateCodeModule", (PyCFunction)IVbaApplicationMethod_CreateCodeModule, METH_VARARGS, ""},
    {"RemoveCodeModule", (PyCFunction)IVbaApplicationMethod_RemoveCodeModule, METH_VARARGS, ""},
    {"InsertCode", (PyCFunction)IVbaApplicationMethod_InsertCode, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIVbaApplicationGetSet[] = {
  {"_pUnk", (getter)PyIVbaApplication_GetpUnk, NULL, "Get opaque pointer to an Unknown from IVbaApplication", NULL},
  {"_pointer", (getter)PyIVbaApplication_GetPointer, NULL, "Get memory address for IVbaApplication", NULL},
  {"_IID", (getter)PyIVbaApplication_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIVbaApplication_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIVbaApplication_GetIgnoreFailures, (setter)PyIVbaApplication_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIVbaApplicationObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriFramework.IVbaApplicationObject",                          
                                              /* tp_name */
  sizeof(PyIVbaApplicationObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIVbaApplicationObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIVbaApplicationMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIVbaApplicationGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIVbaApplicationObject_new,                      
                                              /* tp_new */
};

// Interface ISmallBitmapProvider

typedef struct PyISmallBitmapProviderObject {
    PyObject_HEAD
    ISmallBitmapProvider* m_pISmallBitmapProvider;
    HRESULT m_HR;
    int m_ignore_failures;
} PyISmallBitmapProviderObject;

static PyObject*
PyISmallBitmapProviderObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyISmallBitmapProviderObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ISmallBitmapProvider* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ISmallBitmapProvider, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ISmallBitmapProvider with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyISmallBitmapProviderObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ISmallBitmapProvider");
            return NULL;
        }
        self->m_pISmallBitmapProvider = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ISmallBitmapProvider");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ISmallBitmapProvider");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ISmallBitmapProvider* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ISmallBitmapProvider, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ISmallBitmapProvider");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyISmallBitmapProviderObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ISmallBitmapProvider");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pISmallBitmapProvider = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyISmallBitmapProviderObject_dealloc(PyISmallBitmapProviderObject* self)
{
    if (self->m_pISmallBitmapProvider)
        self->m_pISmallBitmapProvider->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyISmallBitmapProvider_GetpUnk(PyISmallBitmapProviderObject* self)
{
    if (!self->m_pISmallBitmapProvider)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pISmallBitmapProvider->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ISmallBitmapProvider to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyISmallBitmapProvider_GetPointer(PyISmallBitmapProviderObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pISmallBitmapProvider);
}

static PyObject*
PyISmallBitmapProvider_GetIID(PyISmallBitmapProviderObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "92c77db5-c995-11d1-876b-0000f8751720");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyISmallBitmapProvider_GetHR(PyISmallBitmapProviderObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyISmallBitmapProvider_GetIgnoreFailures(PyISmallBitmapProviderObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyISmallBitmapProvider_SetIgnoreFailures(PyISmallBitmapProviderObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyISmallBitmapProvider_SupportsInterface(PyISmallBitmapProviderObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pISmallBitmapProvider->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ISmallBitmapProviderMethod_get_SmallBitmap(PyISmallBitmapProviderObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    OLE_HANDLE HBitmap = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Bitmap

    // Call method on actual COM interface
    hr = self->m_pISmallBitmapProvider->get_SmallBitmap(&HBitmap);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISmallBitmapProvider->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISmallBitmapProvider) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISmallBitmapProvider.get_SmallBitmap() returned %ld", (long)hr);
        goto ismallbitmapprovider_get_smallbitmap_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Bitmap

    // Initialize output tuple
    return_tuple = Py_BuildValue("I",
                                            HBitmap);
    goto ismallbitmapprovider_get_smallbitmap_method_cleanup;

    ismallbitmapprovider_get_smallbitmap_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Bitmap
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISmallBitmapProvider.get_SmallBitmap");
    return return_tuple;
}


PyMethodDef PyISmallBitmapProviderMethods[] = {
    {"supports", (PyCFunction)PyISmallBitmapProvider_SupportsInterface, METH_O, ""},
    {"get_SmallBitmap", (PyCFunction)ISmallBitmapProviderMethod_get_SmallBitmap, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyISmallBitmapProviderGetSet[] = {
  {"_pUnk", (getter)PyISmallBitmapProvider_GetpUnk, NULL, "Get opaque pointer to an Unknown from ISmallBitmapProvider", NULL},
  {"_pointer", (getter)PyISmallBitmapProvider_GetPointer, NULL, "Get memory address for ISmallBitmapProvider", NULL},
  {"_IID", (getter)PyISmallBitmapProvider_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyISmallBitmapProvider_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyISmallBitmapProvider_GetIgnoreFailures, (setter)PyISmallBitmapProvider_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyISmallBitmapProviderObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriFramework.ISmallBitmapProviderObject",                          
                                              /* tp_name */
  sizeof(PyISmallBitmapProviderObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyISmallBitmapProviderObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyISmallBitmapProviderMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyISmallBitmapProviderGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyISmallBitmapProviderObject_new,                      
                                              /* tp_new */
};

// Interface IDockableWindowHelpNotify

typedef struct PyIDockableWindowHelpNotifyObject {
    PyObject_HEAD
    IDockableWindowHelpNotify* m_pIDockableWindowHelpNotify;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIDockableWindowHelpNotifyObject;

static PyObject*
PyIDockableWindowHelpNotifyObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIDockableWindowHelpNotifyObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IDockableWindowHelpNotify* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IDockableWindowHelpNotify, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IDockableWindowHelpNotify with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIDockableWindowHelpNotifyObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IDockableWindowHelpNotify");
            return NULL;
        }
        self->m_pIDockableWindowHelpNotify = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IDockableWindowHelpNotify");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IDockableWindowHelpNotify");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IDockableWindowHelpNotify* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IDockableWindowHelpNotify, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IDockableWindowHelpNotify");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIDockableWindowHelpNotifyObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IDockableWindowHelpNotify");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIDockableWindowHelpNotify = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIDockableWindowHelpNotifyObject_dealloc(PyIDockableWindowHelpNotifyObject* self)
{
    if (self->m_pIDockableWindowHelpNotify)
        self->m_pIDockableWindowHelpNotify->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIDockableWindowHelpNotify_GetpUnk(PyIDockableWindowHelpNotifyObject* self)
{
    if (!self->m_pIDockableWindowHelpNotify)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIDockableWindowHelpNotify->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IDockableWindowHelpNotify to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIDockableWindowHelpNotify_GetPointer(PyIDockableWindowHelpNotifyObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIDockableWindowHelpNotify);
}

static PyObject*
PyIDockableWindowHelpNotify_GetIID(PyIDockableWindowHelpNotifyObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "15379638-9153-4002-9b0d-7e8c4e8f1797");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIDockableWindowHelpNotify_GetHR(PyIDockableWindowHelpNotifyObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIDockableWindowHelpNotify_GetIgnoreFailures(PyIDockableWindowHelpNotifyObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIDockableWindowHelpNotify_SetIgnoreFailures(PyIDockableWindowHelpNotifyObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIDockableWindowHelpNotify_SupportsInterface(PyIDockableWindowHelpNotifyObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIDockableWindowHelpNotify->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IDockableWindowHelpNotifyMethod_OnHelpClick(PyIDockableWindowHelpNotifyObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lX = 0;
    long lY = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "ll", &lX, &lY))
      goto idockablewindowhelpnotify_onhelpclick_method_cleanup;

    // Set up initial variable values as needed
    // No setup for X
    // No setup for Y

    // Call method on actual COM interface
    hr = self->m_pIDockableWindowHelpNotify->OnHelpClick(lX, lY);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDockableWindowHelpNotify->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDockableWindowHelpNotify) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDockableWindowHelpNotify.OnHelpClick() returned %ld", (long)hr);
        goto idockablewindowhelpnotify_onhelpclick_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for X
    // No teardown for Y

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idockablewindowhelpnotify_onhelpclick_method_cleanup;

    idockablewindowhelpnotify_onhelpclick_method_cleanup:
    self->m_HR = hr;
    // No cleanup for X
    // No cleanup for Y
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDockableWindowHelpNotify.OnHelpClick");
    return return_tuple;
}


PyMethodDef PyIDockableWindowHelpNotifyMethods[] = {
    {"supports", (PyCFunction)PyIDockableWindowHelpNotify_SupportsInterface, METH_O, ""},
    {"OnHelpClick", (PyCFunction)IDockableWindowHelpNotifyMethod_OnHelpClick, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIDockableWindowHelpNotifyGetSet[] = {
  {"_pUnk", (getter)PyIDockableWindowHelpNotify_GetpUnk, NULL, "Get opaque pointer to an Unknown from IDockableWindowHelpNotify", NULL},
  {"_pointer", (getter)PyIDockableWindowHelpNotify_GetPointer, NULL, "Get memory address for IDockableWindowHelpNotify", NULL},
  {"_IID", (getter)PyIDockableWindowHelpNotify_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIDockableWindowHelpNotify_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIDockableWindowHelpNotify_GetIgnoreFailures, (setter)PyIDockableWindowHelpNotify_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIDockableWindowHelpNotifyObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriFramework.IDockableWindowHelpNotifyObject",                          
                                              /* tp_name */
  sizeof(PyIDockableWindowHelpNotifyObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIDockableWindowHelpNotifyObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIDockableWindowHelpNotifyMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIDockableWindowHelpNotifyGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIDockableWindowHelpNotifyObject_new,                      
                                              /* tp_new */
};

// Interface IDockableWindow

typedef struct PyIDockableWindowObject {
    PyObject_HEAD
    IDockableWindow* m_pIDockableWindow;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIDockableWindowObject;

static PyObject*
PyIDockableWindowObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIDockableWindowObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IDockableWindow* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IDockableWindow, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IDockableWindow with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIDockableWindowObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IDockableWindow");
            return NULL;
        }
        self->m_pIDockableWindow = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IDockableWindow");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IDockableWindow");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IDockableWindow* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IDockableWindow, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IDockableWindow");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIDockableWindowObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IDockableWindow");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIDockableWindow = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIDockableWindowObject_dealloc(PyIDockableWindowObject* self)
{
    if (self->m_pIDockableWindow)
        self->m_pIDockableWindow->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIDockableWindow_GetpUnk(PyIDockableWindowObject* self)
{
    if (!self->m_pIDockableWindow)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIDockableWindow->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IDockableWindow to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIDockableWindow_GetPointer(PyIDockableWindowObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIDockableWindow);
}

static PyObject*
PyIDockableWindow_GetIID(PyIDockableWindowObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "3ee6d0c3-e3f2-11d3-a679-0008c7df97b9");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIDockableWindow_GetHR(PyIDockableWindowObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIDockableWindow_GetIgnoreFailures(PyIDockableWindowObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIDockableWindow_SetIgnoreFailures(PyIDockableWindowObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIDockableWindow_SupportsInterface(PyIDockableWindowObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIDockableWindow->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IDockableWindowMethod_get_Name(PyIDockableWindowObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName;
    PyObject* pyvar_Name = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Name

    // Call method on actual COM interface
    hr = self->m_pIDockableWindow->get_Name(&bsName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDockableWindow->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDockableWindow) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDockableWindow.get_Name() returned %ld", (long)hr);
        goto idockablewindow_get_name_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Name = PyUnicode_FromWideChar(bsName,::SysStringLen(bsName));
    ::SysFreeString(bsName);
    
    if (PyErr_Occurred())
      goto idockablewindow_get_name_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Name);
    goto idockablewindow_get_name_method_cleanup;

    idockablewindow_get_name_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Name != Py_None)
        Py_XDECREF(pyvar_Name);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDockableWindow.get_Name");
    return return_tuple;
}

static PyObject*
IDockableWindowMethod_get_Caption(PyIDockableWindowObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsCaption;
    PyObject* pyvar_Caption = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Caption

    // Call method on actual COM interface
    hr = self->m_pIDockableWindow->get_Caption(&bsCaption);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDockableWindow->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDockableWindow) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDockableWindow.get_Caption() returned %ld", (long)hr);
        goto idockablewindow_get_caption_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Caption = PyUnicode_FromWideChar(bsCaption,::SysStringLen(bsCaption));
    ::SysFreeString(bsCaption);
    
    if (PyErr_Occurred())
      goto idockablewindow_get_caption_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Caption);
    goto idockablewindow_get_caption_method_cleanup;

    idockablewindow_get_caption_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Caption != Py_None)
        Py_XDECREF(pyvar_Caption);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDockableWindow.get_Caption");
    return return_tuple;
}

static PyObject*
IDockableWindowMethod_put_Caption(PyIDockableWindowObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsCaption = 0;
    PyObject* pyvar_Caption;
    PyObject* unicodeCaption = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_Caption))
      goto idockablewindow_put_caption_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_Caption))
        unicodeCaption = PyUnicode_FromObject(pyvar_Caption);
    else if (PyUnicode_Check(pyvar_Caption))
    {
        unicodeCaption = pyvar_Caption;
        Py_INCREF(unicodeCaption);
    }
    else if (pyvar_Caption != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Caption at index 0");
    if (unicodeCaption)
        bsCaption = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeCaption), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeCaption));
    
    if (PyErr_Occurred())
      goto idockablewindow_put_caption_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIDockableWindow->put_Caption(bsCaption);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDockableWindow->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDockableWindow) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDockableWindow.put_Caption() returned %ld", (long)hr);
        goto idockablewindow_put_caption_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Caption

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idockablewindow_put_caption_method_cleanup;

    idockablewindow_put_caption_method_cleanup:
    self->m_HR = hr;
    if (bsCaption)
        ::SysFreeString(bsCaption);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDockableWindow.put_Caption");
    return return_tuple;
}

static PyObject*
IDockableWindowMethod_get_ID(PyIDockableWindowObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IUID* ipID = NULL;
    PyObject* py_ID = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ID

    // Call method on actual COM interface
    hr = self->m_pIDockableWindow->get_ID(&ipID);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDockableWindow->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDockableWindow) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDockableWindow.get_ID() returned %ld", (long)hr);
        goto idockablewindow_get_id_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ID);
    if (ipID)
    {
        IUnknown* pUnk = NULL;
        ipID->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ID = IUnknownToPythonIIDObject(pUnk, &IID_IUID);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ID)
    {
        if (py_ID)
           Py_DECREF(py_ID);
        py_ID = Py_None;
        Py_INCREF(py_ID);
    }
    if (PyErr_Occurred())
      goto idockablewindow_get_id_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ID);
    goto idockablewindow_get_id_method_cleanup;

    idockablewindow_get_id_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ID);
    if (ipID)
      ipID->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDockableWindow.get_ID");
    return return_tuple;
}

static PyObject*
IDockableWindowMethod_Show(PyIDockableWindowObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_Show = VARIANT_FALSE;
    PyObject* pyvar_Show = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_Show))
      goto idockablewindow_show_method_cleanup;

    // Set up initial variable values as needed
    b_Show = ((PyObject_IsTrue(pyvar_Show) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto idockablewindow_show_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIDockableWindow->Show(b_Show);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDockableWindow->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDockableWindow) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDockableWindow.Show() returned %ld", (long)hr);
        goto idockablewindow_show_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Show

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idockablewindow_show_method_cleanup;

    idockablewindow_show_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Show
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDockableWindow.Show");
    return return_tuple;
}

static PyObject*
IDockableWindowMethod_IsVisible(PyIDockableWindowObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_bVisible = VARIANT_FALSE;
    PyObject* pyvar_bVisible = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for bVisible

    // Call method on actual COM interface
    hr = self->m_pIDockableWindow->IsVisible(&b_bVisible);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDockableWindow->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDockableWindow) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDockableWindow.IsVisible() returned %ld", (long)hr);
        goto idockablewindow_isvisible_method_cleanup;
    }

    // Set up return values as needed
    pyvar_bVisible = ((b_bVisible == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto idockablewindow_isvisible_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_bVisible);
    goto idockablewindow_isvisible_method_cleanup;

    idockablewindow_isvisible_method_cleanup:
    self->m_HR = hr;
    // No cleanup for bVisible
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDockableWindow.IsVisible");
    return return_tuple;
}

static PyObject*
IDockableWindowMethod_Dock(PyIDockableWindowObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriDockFlags edockFlags;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&edockFlags))
      goto idockablewindow_dock_method_cleanup;

    // Set up initial variable values as needed
    // No setup for dockFlags

    // Call method on actual COM interface
    hr = self->m_pIDockableWindow->Dock(edockFlags);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDockableWindow->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDockableWindow) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDockableWindow.Dock() returned %ld", (long)hr);
        goto idockablewindow_dock_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for dockFlags

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto idockablewindow_dock_method_cleanup;

    idockablewindow_dock_method_cleanup:
    self->m_HR = hr;
    // No cleanup for dockFlags
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDockableWindow.Dock");
    return return_tuple;
}

static PyObject*
IDockableWindowMethod_get_UserData(PyIDockableWindowObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT vdata;
    ::VariantInit(&vdata);
    PyObject* pyvar_data = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for data

    // Call method on actual COM interface
    hr = self->m_pIDockableWindow->get_UserData(&vdata);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDockableWindow->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDockableWindow) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDockableWindow.get_UserData() returned %ld", (long)hr);
        goto idockablewindow_get_userdata_method_cleanup;
    }

    // Set up return values as needed
    pyvar_data = Variant_AsPyObject(&vdata);
    if (PyErr_Occurred())
      goto idockablewindow_get_userdata_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_data);
    goto idockablewindow_get_userdata_method_cleanup;

    idockablewindow_get_userdata_method_cleanup:
    self->m_HR = hr;
    ::VariantClear(&vdata);
    Py_XDECREF(pyvar_data);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDockableWindow.get_UserData");
    return return_tuple;
}


PyMethodDef PyIDockableWindowMethods[] = {
    {"supports", (PyCFunction)PyIDockableWindow_SupportsInterface, METH_O, ""},
    {"get_Name", (PyCFunction)IDockableWindowMethod_get_Name, METH_VARARGS, ""},
    {"get_Caption", (PyCFunction)IDockableWindowMethod_get_Caption, METH_VARARGS, ""},
    {"put_Caption", (PyCFunction)IDockableWindowMethod_put_Caption, METH_VARARGS, ""},
    {"get_ID", (PyCFunction)IDockableWindowMethod_get_ID, METH_VARARGS, ""},
    {"Show", (PyCFunction)IDockableWindowMethod_Show, METH_VARARGS, ""},
    {"IsVisible", (PyCFunction)IDockableWindowMethod_IsVisible, METH_VARARGS, ""},
    {"Dock", (PyCFunction)IDockableWindowMethod_Dock, METH_VARARGS, ""},
    {"get_UserData", (PyCFunction)IDockableWindowMethod_get_UserData, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIDockableWindowGetSet[] = {
  {"_pUnk", (getter)PyIDockableWindow_GetpUnk, NULL, "Get opaque pointer to an Unknown from IDockableWindow", NULL},
  {"_pointer", (getter)PyIDockableWindow_GetPointer, NULL, "Get memory address for IDockableWindow", NULL},
  {"_IID", (getter)PyIDockableWindow_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIDockableWindow_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIDockableWindow_GetIgnoreFailures, (setter)PyIDockableWindow_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIDockableWindowObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriFramework.IDockableWindowObject",                          
                                              /* tp_name */
  sizeof(PyIDockableWindowObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIDockableWindowObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIDockableWindowMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIDockableWindowGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIDockableWindowObject_new,                      
                                              /* tp_new */
};

// Interface IDockableWindowImageDef

typedef struct PyIDockableWindowImageDefObject {
    PyObject_HEAD
    IDockableWindowImageDef* m_pIDockableWindowImageDef;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIDockableWindowImageDefObject;

static PyObject*
PyIDockableWindowImageDefObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIDockableWindowImageDefObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IDockableWindowImageDef* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IDockableWindowImageDef, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IDockableWindowImageDef with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIDockableWindowImageDefObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IDockableWindowImageDef");
            return NULL;
        }
        self->m_pIDockableWindowImageDef = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IDockableWindowImageDef");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IDockableWindowImageDef");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IDockableWindowImageDef* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IDockableWindowImageDef, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IDockableWindowImageDef");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIDockableWindowImageDefObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IDockableWindowImageDef");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIDockableWindowImageDef = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIDockableWindowImageDefObject_dealloc(PyIDockableWindowImageDefObject* self)
{
    if (self->m_pIDockableWindowImageDef)
        self->m_pIDockableWindowImageDef->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIDockableWindowImageDef_GetpUnk(PyIDockableWindowImageDefObject* self)
{
    if (!self->m_pIDockableWindowImageDef)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIDockableWindowImageDef->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IDockableWindowImageDef to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIDockableWindowImageDef_GetPointer(PyIDockableWindowImageDefObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIDockableWindowImageDef);
}

static PyObject*
PyIDockableWindowImageDef_GetIID(PyIDockableWindowImageDefObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "08f4fc5d-c23f-4210-b289-1350ed5632ed");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIDockableWindowImageDef_GetHR(PyIDockableWindowImageDefObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIDockableWindowImageDef_GetIgnoreFailures(PyIDockableWindowImageDefObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIDockableWindowImageDef_SetIgnoreFailures(PyIDockableWindowImageDefObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIDockableWindowImageDef_SupportsInterface(PyIDockableWindowImageDefObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIDockableWindowImageDef->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IDockableWindowImageDefMethod_get_Bitmap(PyIDockableWindowImageDefObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    OLE_HANDLE HBitmap = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Bitmap

    // Call method on actual COM interface
    hr = self->m_pIDockableWindowImageDef->get_Bitmap(&HBitmap);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDockableWindowImageDef->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDockableWindowImageDef) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDockableWindowImageDef.get_Bitmap() returned %ld", (long)hr);
        goto idockablewindowimagedef_get_bitmap_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Bitmap

    // Initialize output tuple
    return_tuple = Py_BuildValue("I",
                                            HBitmap);
    goto idockablewindowimagedef_get_bitmap_method_cleanup;

    idockablewindowimagedef_get_bitmap_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Bitmap
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDockableWindowImageDef.get_Bitmap");
    return return_tuple;
}


PyMethodDef PyIDockableWindowImageDefMethods[] = {
    {"supports", (PyCFunction)PyIDockableWindowImageDef_SupportsInterface, METH_O, ""},
    {"get_Bitmap", (PyCFunction)IDockableWindowImageDefMethod_get_Bitmap, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIDockableWindowImageDefGetSet[] = {
  {"_pUnk", (getter)PyIDockableWindowImageDef_GetpUnk, NULL, "Get opaque pointer to an Unknown from IDockableWindowImageDef", NULL},
  {"_pointer", (getter)PyIDockableWindowImageDef_GetPointer, NULL, "Get memory address for IDockableWindowImageDef", NULL},
  {"_IID", (getter)PyIDockableWindowImageDef_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIDockableWindowImageDef_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIDockableWindowImageDef_GetIgnoreFailures, (setter)PyIDockableWindowImageDef_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIDockableWindowImageDefObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriFramework.IDockableWindowImageDefObject",                          
                                              /* tp_name */
  sizeof(PyIDockableWindowImageDefObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIDockableWindowImageDefObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIDockableWindowImageDefMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIDockableWindowImageDefGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIDockableWindowImageDefObject_new,                      
                                              /* tp_new */
};

// Interface IDockableWindowDef

typedef struct PyIDockableWindowDefObject {
    PyObject_HEAD
    IDockableWindowDef* m_pIDockableWindowDef;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIDockableWindowDefObject;

static PyObject*
PyIDockableWindowDefObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIDockableWindowDefObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IDockableWindowDef* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IDockableWindowDef, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IDockableWindowDef with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIDockableWindowDefObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IDockableWindowDef");
            return NULL;
        }
        self->m_pIDockableWindowDef = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IDockableWindowDef");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IDockableWindowDef");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IDockableWindowDef* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IDockableWindowDef, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IDockableWindowDef");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIDockableWindowDefObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IDockableWindowDef");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIDockableWindowDef = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIDockableWindowDefObject_dealloc(PyIDockableWindowDefObject* self)
{
    if (self->m_pIDockableWindowDef)
        self->m_pIDockableWindowDef->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIDockableWindowDef_GetpUnk(PyIDockableWindowDefObject* self)
{
    if (!self->m_pIDockableWindowDef)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIDockableWindowDef->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IDockableWindowDef to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIDockableWindowDef_GetPointer(PyIDockableWindowDefObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIDockableWindowDef);
}

static PyObject*
PyIDockableWindowDef_GetIID(PyIDockableWindowDefObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "3d1fa10a-f154-11d3-a67e-0008c7df97b9");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIDockableWindowDef_GetHR(PyIDockableWindowDefObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIDockableWindowDef_GetIgnoreFailures(PyIDockableWindowDefObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIDockableWindowDef_SetIgnoreFailures(PyIDockableWindowDefObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIDockableWindowDef_SupportsInterface(PyIDockableWindowDefObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIDockableWindowDef->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IDockableWindowDefMethod_OnCreate(PyIDockableWindowDefObject* self, PyObject* args)
{
    /* Param types that are unhandleable: 
       INPUT [u'IDispatch', u'*']
    */
    PyErr_SetString(PyExc_NotImplementedError, "Wrapper for IDockableWindowDef.OnCreate not implemented.");
    return NULL;
}

static PyObject*
IDockableWindowDefMethod_get_ChildHWND(PyIDockableWindowDefObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    OLE_HANDLE HhWnd = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for hWnd

    // Call method on actual COM interface
    hr = self->m_pIDockableWindowDef->get_ChildHWND(&HhWnd);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDockableWindowDef->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDockableWindowDef) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDockableWindowDef.get_ChildHWND() returned %ld", (long)hr);
        goto idockablewindowdef_get_childhwnd_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for hWnd

    // Initialize output tuple
    return_tuple = Py_BuildValue("I",
                                            HhWnd);
    goto idockablewindowdef_get_childhwnd_method_cleanup;

    idockablewindowdef_get_childhwnd_method_cleanup:
    self->m_HR = hr;
    // No cleanup for hWnd
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDockableWindowDef.get_ChildHWND");
    return return_tuple;
}

static PyObject*
IDockableWindowDefMethod_get_Name(PyIDockableWindowDefObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName;
    PyObject* pyvar_Name = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Name

    // Call method on actual COM interface
    hr = self->m_pIDockableWindowDef->get_Name(&bsName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDockableWindowDef->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDockableWindowDef) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDockableWindowDef.get_Name() returned %ld", (long)hr);
        goto idockablewindowdef_get_name_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Name = PyUnicode_FromWideChar(bsName,::SysStringLen(bsName));
    ::SysFreeString(bsName);
    
    if (PyErr_Occurred())
      goto idockablewindowdef_get_name_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Name);
    goto idockablewindowdef_get_name_method_cleanup;

    idockablewindowdef_get_name_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Name != Py_None)
        Py_XDECREF(pyvar_Name);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDockableWindowDef.get_Name");
    return return_tuple;
}

static PyObject*
IDockableWindowDefMethod_get_Caption(PyIDockableWindowDefObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsCaption;
    PyObject* pyvar_Caption = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Caption

    // Call method on actual COM interface
    hr = self->m_pIDockableWindowDef->get_Caption(&bsCaption);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDockableWindowDef->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDockableWindowDef) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDockableWindowDef.get_Caption() returned %ld", (long)hr);
        goto idockablewindowdef_get_caption_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Caption = PyUnicode_FromWideChar(bsCaption,::SysStringLen(bsCaption));
    ::SysFreeString(bsCaption);
    
    if (PyErr_Occurred())
      goto idockablewindowdef_get_caption_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Caption);
    goto idockablewindowdef_get_caption_method_cleanup;

    idockablewindowdef_get_caption_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Caption != Py_None)
        Py_XDECREF(pyvar_Caption);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDockableWindowDef.get_Caption");
    return return_tuple;
}

static PyObject*
IDockableWindowDefMethod_OnDestroy(PyIDockableWindowDefObject* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pIDockableWindowDef->OnDestroy();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDockableWindowDef->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDockableWindowDef) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDockableWindowDef.OnDestroy() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}

static PyObject*
IDockableWindowDefMethod_get_UserData(PyIDockableWindowDefObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT vdata;
    ::VariantInit(&vdata);
    PyObject* pyvar_data = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for data

    // Call method on actual COM interface
    hr = self->m_pIDockableWindowDef->get_UserData(&vdata);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDockableWindowDef->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDockableWindowDef) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDockableWindowDef.get_UserData() returned %ld", (long)hr);
        goto idockablewindowdef_get_userdata_method_cleanup;
    }

    // Set up return values as needed
    pyvar_data = Variant_AsPyObject(&vdata);
    if (PyErr_Occurred())
      goto idockablewindowdef_get_userdata_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_data);
    goto idockablewindowdef_get_userdata_method_cleanup;

    idockablewindowdef_get_userdata_method_cleanup:
    self->m_HR = hr;
    ::VariantClear(&vdata);
    Py_XDECREF(pyvar_data);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDockableWindowDef.get_UserData");
    return return_tuple;
}


PyMethodDef PyIDockableWindowDefMethods[] = {
    {"supports", (PyCFunction)PyIDockableWindowDef_SupportsInterface, METH_O, ""},
    {"OnCreate", (PyCFunction)IDockableWindowDefMethod_OnCreate, METH_VARARGS, ""},
    {"get_ChildHWND", (PyCFunction)IDockableWindowDefMethod_get_ChildHWND, METH_VARARGS, ""},
    {"get_Name", (PyCFunction)IDockableWindowDefMethod_get_Name, METH_VARARGS, ""},
    {"get_Caption", (PyCFunction)IDockableWindowDefMethod_get_Caption, METH_VARARGS, ""},
    {"OnDestroy", (PyCFunction)IDockableWindowDefMethod_OnDestroy, METH_NOARGS, ""},
    {"get_UserData", (PyCFunction)IDockableWindowDefMethod_get_UserData, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIDockableWindowDefGetSet[] = {
  {"_pUnk", (getter)PyIDockableWindowDef_GetpUnk, NULL, "Get opaque pointer to an Unknown from IDockableWindowDef", NULL},
  {"_pointer", (getter)PyIDockableWindowDef_GetPointer, NULL, "Get memory address for IDockableWindowDef", NULL},
  {"_IID", (getter)PyIDockableWindowDef_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIDockableWindowDef_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIDockableWindowDef_GetIgnoreFailures, (setter)PyIDockableWindowDef_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIDockableWindowDefObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriFramework.IDockableWindowDefObject",                          
                                              /* tp_name */
  sizeof(PyIDockableWindowDefObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIDockableWindowDefObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIDockableWindowDefMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIDockableWindowDefGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIDockableWindowDefObject_new,                      
                                              /* tp_new */
};

// Interface IDockableWindowInitialPlacement

typedef struct PyIDockableWindowInitialPlacementObject {
    PyObject_HEAD
    IDockableWindowInitialPlacement* m_pIDockableWindowInitialPlacement;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIDockableWindowInitialPlacementObject;

static PyObject*
PyIDockableWindowInitialPlacementObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIDockableWindowInitialPlacementObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IDockableWindowInitialPlacement* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IDockableWindowInitialPlacement, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IDockableWindowInitialPlacement with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIDockableWindowInitialPlacementObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IDockableWindowInitialPlacement");
            return NULL;
        }
        self->m_pIDockableWindowInitialPlacement = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IDockableWindowInitialPlacement");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IDockableWindowInitialPlacement");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IDockableWindowInitialPlacement* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IDockableWindowInitialPlacement, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IDockableWindowInitialPlacement");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIDockableWindowInitialPlacementObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IDockableWindowInitialPlacement");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIDockableWindowInitialPlacement = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIDockableWindowInitialPlacementObject_dealloc(PyIDockableWindowInitialPlacementObject* self)
{
    if (self->m_pIDockableWindowInitialPlacement)
        self->m_pIDockableWindowInitialPlacement->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIDockableWindowInitialPlacement_GetpUnk(PyIDockableWindowInitialPlacementObject* self)
{
    if (!self->m_pIDockableWindowInitialPlacement)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIDockableWindowInitialPlacement->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IDockableWindowInitialPlacement to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIDockableWindowInitialPlacement_GetPointer(PyIDockableWindowInitialPlacementObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIDockableWindowInitialPlacement);
}

static PyObject*
PyIDockableWindowInitialPlacement_GetIID(PyIDockableWindowInitialPlacementObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "1ec80980-7a02-426d-bd2b-c6d3beb2ed54");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIDockableWindowInitialPlacement_GetHR(PyIDockableWindowInitialPlacementObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIDockableWindowInitialPlacement_GetIgnoreFailures(PyIDockableWindowInitialPlacementObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIDockableWindowInitialPlacement_SetIgnoreFailures(PyIDockableWindowInitialPlacementObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIDockableWindowInitialPlacement_SupportsInterface(PyIDockableWindowInitialPlacementObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIDockableWindowInitialPlacement->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IDockableWindowInitialPlacementMethod_get_Height(PyIDockableWindowInitialPlacementObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lHeight = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Height

    // Call method on actual COM interface
    hr = self->m_pIDockableWindowInitialPlacement->get_Height(&lHeight);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDockableWindowInitialPlacement->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDockableWindowInitialPlacement) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDockableWindowInitialPlacement.get_Height() returned %ld", (long)hr);
        goto idockablewindowinitialplacement_get_height_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Height

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lHeight);
    goto idockablewindowinitialplacement_get_height_method_cleanup;

    idockablewindowinitialplacement_get_height_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Height
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDockableWindowInitialPlacement.get_Height");
    return return_tuple;
}

static PyObject*
IDockableWindowInitialPlacementMethod_get_Width(PyIDockableWindowInitialPlacementObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lWidth = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Width

    // Call method on actual COM interface
    hr = self->m_pIDockableWindowInitialPlacement->get_Width(&lWidth);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDockableWindowInitialPlacement->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDockableWindowInitialPlacement) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDockableWindowInitialPlacement.get_Width() returned %ld", (long)hr);
        goto idockablewindowinitialplacement_get_width_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Width

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lWidth);
    goto idockablewindowinitialplacement_get_width_method_cleanup;

    idockablewindowinitialplacement_get_width_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Width
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDockableWindowInitialPlacement.get_Width");
    return return_tuple;
}

static PyObject*
IDockableWindowInitialPlacementMethod_get_DockPosition(PyIDockableWindowInitialPlacementObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriDockFlags edockFlags;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for dockFlags

    // Call method on actual COM interface
    hr = self->m_pIDockableWindowInitialPlacement->get_DockPosition(&edockFlags);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDockableWindowInitialPlacement->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDockableWindowInitialPlacement) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDockableWindowInitialPlacement.get_DockPosition() returned %ld", (long)hr);
        goto idockablewindowinitialplacement_get_dockposition_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for dockFlags

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)edockFlags);
    goto idockablewindowinitialplacement_get_dockposition_method_cleanup;

    idockablewindowinitialplacement_get_dockposition_method_cleanup:
    self->m_HR = hr;
    // No cleanup for dockFlags
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDockableWindowInitialPlacement.get_DockPosition");
    return return_tuple;
}

static PyObject*
IDockableWindowInitialPlacementMethod_get_Neighbor(PyIDockableWindowInitialPlacementObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IUID* ipuid = NULL;
    PyObject* py_uid = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for uid

    // Call method on actual COM interface
    hr = self->m_pIDockableWindowInitialPlacement->get_Neighbor(&ipuid);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDockableWindowInitialPlacement->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDockableWindowInitialPlacement) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDockableWindowInitialPlacement.get_Neighbor() returned %ld", (long)hr);
        goto idockablewindowinitialplacement_get_neighbor_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_uid);
    if (ipuid)
    {
        IUnknown* pUnk = NULL;
        ipuid->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_uid = IUnknownToPythonIIDObject(pUnk, &IID_IUID);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_uid)
    {
        if (py_uid)
           Py_DECREF(py_uid);
        py_uid = Py_None;
        Py_INCREF(py_uid);
    }
    if (PyErr_Occurred())
      goto idockablewindowinitialplacement_get_neighbor_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_uid);
    goto idockablewindowinitialplacement_get_neighbor_method_cleanup;

    idockablewindowinitialplacement_get_neighbor_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_uid);
    if (ipuid)
      ipuid->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDockableWindowInitialPlacement.get_Neighbor");
    return return_tuple;
}


PyMethodDef PyIDockableWindowInitialPlacementMethods[] = {
    {"supports", (PyCFunction)PyIDockableWindowInitialPlacement_SupportsInterface, METH_O, ""},
    {"get_Height", (PyCFunction)IDockableWindowInitialPlacementMethod_get_Height, METH_VARARGS, ""},
    {"get_Width", (PyCFunction)IDockableWindowInitialPlacementMethod_get_Width, METH_VARARGS, ""},
    {"get_DockPosition", (PyCFunction)IDockableWindowInitialPlacementMethod_get_DockPosition, METH_VARARGS, ""},
    {"get_Neighbor", (PyCFunction)IDockableWindowInitialPlacementMethod_get_Neighbor, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIDockableWindowInitialPlacementGetSet[] = {
  {"_pUnk", (getter)PyIDockableWindowInitialPlacement_GetpUnk, NULL, "Get opaque pointer to an Unknown from IDockableWindowInitialPlacement", NULL},
  {"_pointer", (getter)PyIDockableWindowInitialPlacement_GetPointer, NULL, "Get memory address for IDockableWindowInitialPlacement", NULL},
  {"_IID", (getter)PyIDockableWindowInitialPlacement_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIDockableWindowInitialPlacement_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIDockableWindowInitialPlacement_GetIgnoreFailures, (setter)PyIDockableWindowInitialPlacement_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIDockableWindowInitialPlacementObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriFramework.IDockableWindowInitialPlacementObject",                          
                                              /* tp_name */
  sizeof(PyIDockableWindowInitialPlacementObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIDockableWindowInitialPlacementObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIDockableWindowInitialPlacementMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIDockableWindowInitialPlacementGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIDockableWindowInitialPlacementObject_new,                      
                                              /* tp_new */
};

// Interface IDockableWindowInitialPlacementNeighbors

typedef struct PyIDockableWindowInitialPlacementNeighborsObject {
    PyObject_HEAD
    IDockableWindowInitialPlacementNeighbors* m_pIDockableWindowInitialPlacementNeighbors;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIDockableWindowInitialPlacementNeighborsObject;

static PyObject*
PyIDockableWindowInitialPlacementNeighborsObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIDockableWindowInitialPlacementNeighborsObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IDockableWindowInitialPlacementNeighbors* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IDockableWindowInitialPlacementNeighbors, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IDockableWindowInitialPlacementNeighbors with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIDockableWindowInitialPlacementNeighborsObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IDockableWindowInitialPlacementNeighbors");
            return NULL;
        }
        self->m_pIDockableWindowInitialPlacementNeighbors = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IDockableWindowInitialPlacementNeighbors");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IDockableWindowInitialPlacementNeighbors");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IDockableWindowInitialPlacementNeighbors* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IDockableWindowInitialPlacementNeighbors, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IDockableWindowInitialPlacementNeighbors");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIDockableWindowInitialPlacementNeighborsObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IDockableWindowInitialPlacementNeighbors");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIDockableWindowInitialPlacementNeighbors = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIDockableWindowInitialPlacementNeighborsObject_dealloc(PyIDockableWindowInitialPlacementNeighborsObject* self)
{
    if (self->m_pIDockableWindowInitialPlacementNeighbors)
        self->m_pIDockableWindowInitialPlacementNeighbors->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIDockableWindowInitialPlacementNeighbors_GetpUnk(PyIDockableWindowInitialPlacementNeighborsObject* self)
{
    if (!self->m_pIDockableWindowInitialPlacementNeighbors)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIDockableWindowInitialPlacementNeighbors->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IDockableWindowInitialPlacementNeighbors to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIDockableWindowInitialPlacementNeighbors_GetPointer(PyIDockableWindowInitialPlacementNeighborsObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIDockableWindowInitialPlacementNeighbors);
}

static PyObject*
PyIDockableWindowInitialPlacementNeighbors_GetIID(PyIDockableWindowInitialPlacementNeighborsObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "bbf9e75e-3675-45c9-a6a6-0a3c6d0ad1b9");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIDockableWindowInitialPlacementNeighbors_GetHR(PyIDockableWindowInitialPlacementNeighborsObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIDockableWindowInitialPlacementNeighbors_GetIgnoreFailures(PyIDockableWindowInitialPlacementNeighborsObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIDockableWindowInitialPlacementNeighbors_SetIgnoreFailures(PyIDockableWindowInitialPlacementNeighborsObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIDockableWindowInitialPlacementNeighbors_SupportsInterface(PyIDockableWindowInitialPlacementNeighborsObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIDockableWindowInitialPlacementNeighbors->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IDockableWindowInitialPlacementNeighborsMethod_get_Count(PyIDockableWindowInitialPlacementNeighborsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Count

    // Call method on actual COM interface
    hr = self->m_pIDockableWindowInitialPlacementNeighbors->get_Count(&lCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDockableWindowInitialPlacementNeighbors->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDockableWindowInitialPlacementNeighbors) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDockableWindowInitialPlacementNeighbors.get_Count() returned %ld", (long)hr);
        goto idockablewindowinitialplacementneighbors_get_count_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Count

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lCount);
    goto idockablewindowinitialplacementneighbors_get_count_method_cleanup;

    idockablewindowinitialplacementneighbors_get_count_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Count
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDockableWindowInitialPlacementNeighbors.get_Count");
    return return_tuple;
}

static PyObject*
IDockableWindowInitialPlacementNeighborsMethod_get_NeighborAt(PyIDockableWindowInitialPlacementNeighborsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lIndex = 0;
    IUID* ipuid = NULL;
    PyObject* py_uid = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lIndex))
      goto idockablewindowinitialplacementneighbors_get_neighborat_method_cleanup;

    // Set up initial variable values as needed
    // No setup for Index
    // No setup for uid

    // Call method on actual COM interface
    hr = self->m_pIDockableWindowInitialPlacementNeighbors->get_NeighborAt(lIndex, &ipuid);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDockableWindowInitialPlacementNeighbors->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDockableWindowInitialPlacementNeighbors) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDockableWindowInitialPlacementNeighbors.get_NeighborAt() returned %ld", (long)hr);
        goto idockablewindowinitialplacementneighbors_get_neighborat_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Index
    Py_XDECREF(py_uid);
    if (ipuid)
    {
        IUnknown* pUnk = NULL;
        ipuid->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_uid = IUnknownToPythonIIDObject(pUnk, &IID_IUID);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_uid)
    {
        if (py_uid)
           Py_DECREF(py_uid);
        py_uid = Py_None;
        Py_INCREF(py_uid);
    }
    if (PyErr_Occurred())
      goto idockablewindowinitialplacementneighbors_get_neighborat_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_uid);
    goto idockablewindowinitialplacementneighbors_get_neighborat_method_cleanup;

    idockablewindowinitialplacementneighbors_get_neighborat_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Index
    Py_XDECREF(py_uid);
    if (ipuid)
      ipuid->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDockableWindowInitialPlacementNeighbors.get_NeighborAt");
    return return_tuple;
}


PyMethodDef PyIDockableWindowInitialPlacementNeighborsMethods[] = {
    {"supports", (PyCFunction)PyIDockableWindowInitialPlacementNeighbors_SupportsInterface, METH_O, ""},
    {"get_Count", (PyCFunction)IDockableWindowInitialPlacementNeighborsMethod_get_Count, METH_VARARGS, ""},
    {"get_NeighborAt", (PyCFunction)IDockableWindowInitialPlacementNeighborsMethod_get_NeighborAt, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIDockableWindowInitialPlacementNeighborsGetSet[] = {
  {"_pUnk", (getter)PyIDockableWindowInitialPlacementNeighbors_GetpUnk, NULL, "Get opaque pointer to an Unknown from IDockableWindowInitialPlacementNeighbors", NULL},
  {"_pointer", (getter)PyIDockableWindowInitialPlacementNeighbors_GetPointer, NULL, "Get memory address for IDockableWindowInitialPlacementNeighbors", NULL},
  {"_IID", (getter)PyIDockableWindowInitialPlacementNeighbors_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIDockableWindowInitialPlacementNeighbors_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIDockableWindowInitialPlacementNeighbors_GetIgnoreFailures, (setter)PyIDockableWindowInitialPlacementNeighbors_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIDockableWindowInitialPlacementNeighborsObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriFramework.IDockableWindowInitialPlacementNeighborsObject",                          
                                              /* tp_name */
  sizeof(PyIDockableWindowInitialPlacementNeighborsObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIDockableWindowInitialPlacementNeighborsObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIDockableWindowInitialPlacementNeighborsMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIDockableWindowInitialPlacementNeighborsGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIDockableWindowInitialPlacementNeighborsObject_new,                      
                                              /* tp_new */
};

// Interface IDockableWindowManager

typedef struct PyIDockableWindowManagerObject {
    PyObject_HEAD
    IDockableWindowManager* m_pIDockableWindowManager;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIDockableWindowManagerObject;

static PyObject*
PyIDockableWindowManagerObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIDockableWindowManagerObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IDockableWindowManager* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IDockableWindowManager, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IDockableWindowManager with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIDockableWindowManagerObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IDockableWindowManager");
            return NULL;
        }
        self->m_pIDockableWindowManager = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IDockableWindowManager");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IDockableWindowManager");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IDockableWindowManager* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IDockableWindowManager, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IDockableWindowManager");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIDockableWindowManagerObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IDockableWindowManager");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIDockableWindowManager = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIDockableWindowManagerObject_dealloc(PyIDockableWindowManagerObject* self)
{
    if (self->m_pIDockableWindowManager)
        self->m_pIDockableWindowManager->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIDockableWindowManager_GetpUnk(PyIDockableWindowManagerObject* self)
{
    if (!self->m_pIDockableWindowManager)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIDockableWindowManager->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IDockableWindowManager to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIDockableWindowManager_GetPointer(PyIDockableWindowManagerObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIDockableWindowManager);
}

static PyObject*
PyIDockableWindowManager_GetIID(PyIDockableWindowManagerObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "3ee6d0c2-e3f2-11d3-a679-0008c7df97b9");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIDockableWindowManager_GetHR(PyIDockableWindowManagerObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIDockableWindowManager_GetIgnoreFailures(PyIDockableWindowManagerObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIDockableWindowManager_SetIgnoreFailures(PyIDockableWindowManagerObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIDockableWindowManager_SupportsInterface(PyIDockableWindowManagerObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIDockableWindowManager->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IDockableWindowManagerMethod_GetDockableWindow(PyIDockableWindowManagerObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IUID* ipdockWnd = NULL;
    PyObject* py_dockWnd;
    IDockableWindow* ipItem = NULL;
    PyObject* py_Item = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_dockWnd))
      goto idockablewindowmanager_getdockablewindow_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_dockWnd, &IID_IUID, (void**)&ipdockWnd))
        PyErr_SetString(PyExc_TypeError, "Argument dockWnd (position 0) is not IUID");
    
    if (PyErr_Occurred())
      goto idockablewindowmanager_getdockablewindow_method_cleanup;
    
    // No setup for Item

    // Call method on actual COM interface
    hr = self->m_pIDockableWindowManager->GetDockableWindow(ipdockWnd, &ipItem);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDockableWindowManager->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDockableWindowManager) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDockableWindowManager.GetDockableWindow() returned %ld", (long)hr);
        goto idockablewindowmanager_getdockablewindow_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for dockWnd
    Py_XDECREF(py_Item);
    if (ipItem)
    {
        IUnknown* pUnk = NULL;
        ipItem->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_Item = IUnknownToPythonIIDObject(pUnk, &IID_IDockableWindow);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_Item)
    {
        if (py_Item)
           Py_DECREF(py_Item);
        py_Item = Py_None;
        Py_INCREF(py_Item);
    }
    if (PyErr_Occurred())
      goto idockablewindowmanager_getdockablewindow_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_Item);
    goto idockablewindowmanager_getdockablewindow_method_cleanup;

    idockablewindowmanager_getdockablewindow_method_cleanup:
    self->m_HR = hr;
    if (ipdockWnd)
      ipdockWnd->Release();
    Py_XDECREF(py_Item);
    if (ipItem)
      ipItem->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDockableWindowManager.GetDockableWindow");
    return return_tuple;
}


PyMethodDef PyIDockableWindowManagerMethods[] = {
    {"supports", (PyCFunction)PyIDockableWindowManager_SupportsInterface, METH_O, ""},
    {"GetDockableWindow", (PyCFunction)IDockableWindowManagerMethod_GetDockableWindow, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIDockableWindowManagerGetSet[] = {
  {"_pUnk", (getter)PyIDockableWindowManager_GetpUnk, NULL, "Get opaque pointer to an Unknown from IDockableWindowManager", NULL},
  {"_pointer", (getter)PyIDockableWindowManager_GetPointer, NULL, "Get memory address for IDockableWindowManager", NULL},
  {"_IID", (getter)PyIDockableWindowManager_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIDockableWindowManager_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIDockableWindowManager_GetIgnoreFailures, (setter)PyIDockableWindowManager_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIDockableWindowManagerObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriFramework.IDockableWindowManagerObject",                          
                                              /* tp_name */
  sizeof(PyIDockableWindowManagerObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIDockableWindowManagerObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIDockableWindowManagerMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIDockableWindowManagerGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIDockableWindowManagerObject_new,                      
                                              /* tp_new */
};

// Interface IDllThreadManager

typedef struct PyIDllThreadManagerObject {
    PyObject_HEAD
    IDllThreadManager* m_pIDllThreadManager;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIDllThreadManagerObject;

static PyObject*
PyIDllThreadManagerObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIDllThreadManagerObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IDllThreadManager* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IDllThreadManager, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IDllThreadManager with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIDllThreadManagerObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IDllThreadManager");
            return NULL;
        }
        self->m_pIDllThreadManager = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IDllThreadManager");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IDllThreadManager");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IDllThreadManager* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IDllThreadManager, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IDllThreadManager");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIDllThreadManagerObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IDllThreadManager");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIDllThreadManager = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIDllThreadManagerObject_dealloc(PyIDllThreadManagerObject* self)
{
    if (self->m_pIDllThreadManager)
        self->m_pIDllThreadManager->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIDllThreadManager_GetpUnk(PyIDllThreadManagerObject* self)
{
    if (!self->m_pIDllThreadManager)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIDllThreadManager->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IDllThreadManager to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIDllThreadManager_GetPointer(PyIDllThreadManagerObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIDllThreadManager);
}

static PyObject*
PyIDllThreadManager_GetIID(PyIDllThreadManagerObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "52bcff1b-6a36-49df-b14f-be227d8543ef");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIDllThreadManager_GetHR(PyIDllThreadManagerObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIDllThreadManager_GetIgnoreFailures(PyIDllThreadManagerObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIDllThreadManager_SetIgnoreFailures(PyIDllThreadManagerObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIDllThreadManager_SupportsInterface(PyIDllThreadManagerObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIDllThreadManager->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IDllThreadManagerMethod_OnShutdown(PyIDllThreadManagerObject* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pIDllThreadManager->OnShutdown();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDllThreadManager->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDllThreadManager) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDllThreadManager.OnShutdown() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}


PyMethodDef PyIDllThreadManagerMethods[] = {
    {"supports", (PyCFunction)PyIDllThreadManager_SupportsInterface, METH_O, ""},
    {"OnShutdown", (PyCFunction)IDllThreadManagerMethod_OnShutdown, METH_NOARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIDllThreadManagerGetSet[] = {
  {"_pUnk", (getter)PyIDllThreadManager_GetpUnk, NULL, "Get opaque pointer to an Unknown from IDllThreadManager", NULL},
  {"_pointer", (getter)PyIDllThreadManager_GetPointer, NULL, "Get memory address for IDllThreadManager", NULL},
  {"_IID", (getter)PyIDllThreadManager_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIDllThreadManager_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIDllThreadManager_GetIgnoreFailures, (setter)PyIDllThreadManager_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIDllThreadManagerObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriFramework.IDllThreadManagerObject",                          
                                              /* tp_name */
  sizeof(PyIDllThreadManagerObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIDllThreadManagerObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIDllThreadManagerMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIDllThreadManagerGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIDllThreadManagerObject_new,                      
                                              /* tp_new */
};

// Interface IMultiThreadedApplication

typedef struct PyIMultiThreadedApplicationObject {
    PyObject_HEAD
    IMultiThreadedApplication* m_pIMultiThreadedApplication;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIMultiThreadedApplicationObject;

static PyObject*
PyIMultiThreadedApplicationObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIMultiThreadedApplicationObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IMultiThreadedApplication* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IMultiThreadedApplication, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IMultiThreadedApplication with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIMultiThreadedApplicationObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IMultiThreadedApplication");
            return NULL;
        }
        self->m_pIMultiThreadedApplication = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IMultiThreadedApplication");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IMultiThreadedApplication");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IMultiThreadedApplication* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IMultiThreadedApplication, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IMultiThreadedApplication");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIMultiThreadedApplicationObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IMultiThreadedApplication");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIMultiThreadedApplication = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIMultiThreadedApplicationObject_dealloc(PyIMultiThreadedApplicationObject* self)
{
    if (self->m_pIMultiThreadedApplication)
        self->m_pIMultiThreadedApplication->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIMultiThreadedApplication_GetpUnk(PyIMultiThreadedApplicationObject* self)
{
    if (!self->m_pIMultiThreadedApplication)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIMultiThreadedApplication->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IMultiThreadedApplication to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIMultiThreadedApplication_GetPointer(PyIMultiThreadedApplicationObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIMultiThreadedApplication);
}

static PyObject*
PyIMultiThreadedApplication_GetIID(PyIMultiThreadedApplicationObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "34709a45-8e39-4397-a0cf-63963e5f52e4");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIMultiThreadedApplication_GetHR(PyIMultiThreadedApplicationObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIMultiThreadedApplication_GetIgnoreFailures(PyIMultiThreadedApplicationObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIMultiThreadedApplication_SetIgnoreFailures(PyIMultiThreadedApplicationObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIMultiThreadedApplication_SupportsInterface(PyIMultiThreadedApplicationObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIMultiThreadedApplication->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IMultiThreadedApplicationMethod_GetProcessID(PyIMultiThreadedApplicationObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lpid = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pid

    // Call method on actual COM interface
    hr = self->m_pIMultiThreadedApplication->GetProcessID(&lpid);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIMultiThreadedApplication->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IMultiThreadedApplication) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IMultiThreadedApplication.GetProcessID() returned %ld", (long)hr);
        goto imultithreadedapplication_getprocessid_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pid

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lpid);
    goto imultithreadedapplication_getprocessid_method_cleanup;

    imultithreadedapplication_getprocessid_method_cleanup:
    self->m_HR = hr;
    // No cleanup for pid
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IMultiThreadedApplication.GetProcessID");
    return return_tuple;
}

static PyObject*
IMultiThreadedApplicationMethod_RegisterThreadManager(PyIMultiThreadedApplicationObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IDllThreadManager* ippThreadMgr = NULL;
    PyObject* py_pThreadMgr;
    long lmgrCookie = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_pThreadMgr))
      goto imultithreadedapplication_registerthreadmanager_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pThreadMgr, &IID_IDllThreadManager, (void**)&ippThreadMgr))
        PyErr_SetString(PyExc_TypeError, "Argument pThreadMgr (position 0) is not IDllThreadManager");
    
    if (PyErr_Occurred())
      goto imultithreadedapplication_registerthreadmanager_method_cleanup;
    
    // No setup for mgrCookie

    // Call method on actual COM interface
    hr = self->m_pIMultiThreadedApplication->RegisterThreadManager(ippThreadMgr, &lmgrCookie);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIMultiThreadedApplication->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IMultiThreadedApplication) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IMultiThreadedApplication.RegisterThreadManager() returned %ld", (long)hr);
        goto imultithreadedapplication_registerthreadmanager_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pThreadMgr
    // No teardown for mgrCookie

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lmgrCookie);
    goto imultithreadedapplication_registerthreadmanager_method_cleanup;

    imultithreadedapplication_registerthreadmanager_method_cleanup:
    self->m_HR = hr;
    if (ippThreadMgr)
      ippThreadMgr->Release();
    // No cleanup for mgrCookie
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IMultiThreadedApplication.RegisterThreadManager");
    return return_tuple;
}

static PyObject*
IMultiThreadedApplicationMethod_UnregisterThreadManager(PyIMultiThreadedApplicationObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lmgrCookie = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lmgrCookie))
      goto imultithreadedapplication_unregisterthreadmanager_method_cleanup;

    // Set up initial variable values as needed
    // No setup for mgrCookie

    // Call method on actual COM interface
    hr = self->m_pIMultiThreadedApplication->UnregisterThreadManager(lmgrCookie);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIMultiThreadedApplication->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IMultiThreadedApplication) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IMultiThreadedApplication.UnregisterThreadManager() returned %ld", (long)hr);
        goto imultithreadedapplication_unregisterthreadmanager_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for mgrCookie

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto imultithreadedapplication_unregisterthreadmanager_method_cleanup;

    imultithreadedapplication_unregisterthreadmanager_method_cleanup:
    self->m_HR = hr;
    // No cleanup for mgrCookie
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IMultiThreadedApplication.UnregisterThreadManager");
    return return_tuple;
}


PyMethodDef PyIMultiThreadedApplicationMethods[] = {
    {"supports", (PyCFunction)PyIMultiThreadedApplication_SupportsInterface, METH_O, ""},
    {"GetProcessID", (PyCFunction)IMultiThreadedApplicationMethod_GetProcessID, METH_VARARGS, ""},
    {"RegisterThreadManager", (PyCFunction)IMultiThreadedApplicationMethod_RegisterThreadManager, METH_VARARGS, ""},
    {"UnregisterThreadManager", (PyCFunction)IMultiThreadedApplicationMethod_UnregisterThreadManager, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIMultiThreadedApplicationGetSet[] = {
  {"_pUnk", (getter)PyIMultiThreadedApplication_GetpUnk, NULL, "Get opaque pointer to an Unknown from IMultiThreadedApplication", NULL},
  {"_pointer", (getter)PyIMultiThreadedApplication_GetPointer, NULL, "Get memory address for IMultiThreadedApplication", NULL},
  {"_IID", (getter)PyIMultiThreadedApplication_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIMultiThreadedApplication_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIMultiThreadedApplication_GetIgnoreFailures, (setter)PyIMultiThreadedApplication_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIMultiThreadedApplicationObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriFramework.IMultiThreadedApplicationObject",                          
                                              /* tp_name */
  sizeof(PyIMultiThreadedApplicationObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIMultiThreadedApplicationObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIMultiThreadedApplicationMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIMultiThreadedApplicationGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIMultiThreadedApplicationObject_new,                      
                                              /* tp_new */
};

// Interface IDocumentDirty

typedef struct PyIDocumentDirtyObject {
    PyObject_HEAD
    IDocumentDirty* m_pIDocumentDirty;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIDocumentDirtyObject;

static PyObject*
PyIDocumentDirtyObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIDocumentDirtyObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IDocumentDirty* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IDocumentDirty, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IDocumentDirty with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIDocumentDirtyObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IDocumentDirty");
            return NULL;
        }
        self->m_pIDocumentDirty = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IDocumentDirty");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IDocumentDirty");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IDocumentDirty* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IDocumentDirty, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IDocumentDirty");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIDocumentDirtyObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IDocumentDirty");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIDocumentDirty = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIDocumentDirtyObject_dealloc(PyIDocumentDirtyObject* self)
{
    if (self->m_pIDocumentDirty)
        self->m_pIDocumentDirty->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIDocumentDirty_GetpUnk(PyIDocumentDirtyObject* self)
{
    if (!self->m_pIDocumentDirty)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIDocumentDirty->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IDocumentDirty to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIDocumentDirty_GetPointer(PyIDocumentDirtyObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIDocumentDirty);
}

static PyObject*
PyIDocumentDirty_GetIID(PyIDocumentDirtyObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "b26de0cf-5c0a-433d-9082-097004e13a0a");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIDocumentDirty_GetHR(PyIDocumentDirtyObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIDocumentDirty_GetIgnoreFailures(PyIDocumentDirtyObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIDocumentDirty_SetIgnoreFailures(PyIDocumentDirtyObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIDocumentDirty_SupportsInterface(PyIDocumentDirtyObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIDocumentDirty->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IDocumentDirtyMethod_SetDirty(PyIDocumentDirtyObject* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pIDocumentDirty->SetDirty();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDocumentDirty->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDocumentDirty) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDocumentDirty.SetDirty() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}


PyMethodDef PyIDocumentDirtyMethods[] = {
    {"supports", (PyCFunction)PyIDocumentDirty_SupportsInterface, METH_O, ""},
    {"SetDirty", (PyCFunction)IDocumentDirtyMethod_SetDirty, METH_NOARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIDocumentDirtyGetSet[] = {
  {"_pUnk", (getter)PyIDocumentDirty_GetpUnk, NULL, "Get opaque pointer to an Unknown from IDocumentDirty", NULL},
  {"_pointer", (getter)PyIDocumentDirty_GetPointer, NULL, "Get memory address for IDocumentDirty", NULL},
  {"_IID", (getter)PyIDocumentDirty_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIDocumentDirty_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIDocumentDirty_GetIgnoreFailures, (setter)PyIDocumentDirty_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIDocumentDirtyObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriFramework.IDocumentDirtyObject",                          
                                              /* tp_name */
  sizeof(PyIDocumentDirtyObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIDocumentDirtyObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIDocumentDirtyMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIDocumentDirtyGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIDocumentDirtyObject_new,                      
                                              /* tp_new */
};

// Interface IDocumentDirty2

typedef struct PyIDocumentDirty2Object {
    PyObject_HEAD
    IDocumentDirty2* m_pIDocumentDirty2;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIDocumentDirty2Object;

static PyObject*
PyIDocumentDirty2Object_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIDocumentDirty2Object* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IDocumentDirty2* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IDocumentDirty2, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IDocumentDirty2 with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIDocumentDirty2Object *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IDocumentDirty2");
            return NULL;
        }
        self->m_pIDocumentDirty2 = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IDocumentDirty2");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IDocumentDirty2");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IDocumentDirty2* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IDocumentDirty2, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IDocumentDirty2");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIDocumentDirty2Object *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IDocumentDirty2");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIDocumentDirty2 = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIDocumentDirty2Object_dealloc(PyIDocumentDirty2Object* self)
{
    if (self->m_pIDocumentDirty2)
        self->m_pIDocumentDirty2->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIDocumentDirty2_GetpUnk(PyIDocumentDirty2Object* self)
{
    if (!self->m_pIDocumentDirty2)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIDocumentDirty2->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IDocumentDirty2 to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIDocumentDirty2_GetPointer(PyIDocumentDirty2Object* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIDocumentDirty2);
}

static PyObject*
PyIDocumentDirty2_GetIID(PyIDocumentDirty2Object* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "a684089c-cde0-407c-92d8-811a3f8e850c");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIDocumentDirty2_GetHR(PyIDocumentDirty2Object* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIDocumentDirty2_GetIgnoreFailures(PyIDocumentDirty2Object* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIDocumentDirty2_SetIgnoreFailures(PyIDocumentDirty2Object* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIDocumentDirty2_SupportsInterface(PyIDocumentDirty2Object* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIDocumentDirty2->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IDocumentDirty2Method_SetClean(PyIDocumentDirty2Object* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pIDocumentDirty2->SetClean();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDocumentDirty2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDocumentDirty2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDocumentDirty2.SetClean() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}

static PyObject*
IDocumentDirty2Method_SetDirty(PyIDocumentDirty2Object* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pIDocumentDirty2->SetDirty();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDocumentDirty2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDocumentDirty2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDocumentDirty2.SetDirty() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}


PyMethodDef PyIDocumentDirty2Methods[] = {
    {"supports", (PyCFunction)PyIDocumentDirty2_SupportsInterface, METH_O, ""},
    {"SetClean", (PyCFunction)IDocumentDirty2Method_SetClean, METH_NOARGS, ""},
    {"SetDirty", (PyCFunction)IDocumentDirty2Method_SetDirty, METH_NOARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIDocumentDirty2GetSet[] = {
  {"_pUnk", (getter)PyIDocumentDirty2_GetpUnk, NULL, "Get opaque pointer to an Unknown from IDocumentDirty2", NULL},
  {"_pointer", (getter)PyIDocumentDirty2_GetPointer, NULL, "Get memory address for IDocumentDirty2", NULL},
  {"_IID", (getter)PyIDocumentDirty2_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIDocumentDirty2_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIDocumentDirty2_GetIgnoreFailures, (setter)PyIDocumentDirty2_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIDocumentDirty2Object_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriFramework.IDocumentDirty2Object",                          
                                              /* tp_name */
  sizeof(PyIDocumentDirty2Object),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIDocumentDirty2Object_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIDocumentDirty2Methods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIDocumentDirty2GetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIDocumentDirty2Object_new,                      
                                              /* tp_new */
};

// Interface IDDECommandHandler

typedef struct PyIDDECommandHandlerObject {
    PyObject_HEAD
    IDDECommandHandler* m_pIDDECommandHandler;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIDDECommandHandlerObject;

static PyObject*
PyIDDECommandHandlerObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIDDECommandHandlerObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IDDECommandHandler* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IDDECommandHandler, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IDDECommandHandler with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIDDECommandHandlerObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IDDECommandHandler");
            return NULL;
        }
        self->m_pIDDECommandHandler = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IDDECommandHandler");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IDDECommandHandler");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IDDECommandHandler* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IDDECommandHandler, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IDDECommandHandler");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIDDECommandHandlerObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IDDECommandHandler");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIDDECommandHandler = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIDDECommandHandlerObject_dealloc(PyIDDECommandHandlerObject* self)
{
    if (self->m_pIDDECommandHandler)
        self->m_pIDDECommandHandler->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIDDECommandHandler_GetpUnk(PyIDDECommandHandlerObject* self)
{
    if (!self->m_pIDDECommandHandler)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIDDECommandHandler->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IDDECommandHandler to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIDDECommandHandler_GetPointer(PyIDDECommandHandlerObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIDDECommandHandler);
}

static PyObject*
PyIDDECommandHandler_GetIID(PyIDDECommandHandlerObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "b8352370-23e6-42fc-9b43-5e7536c13af9");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIDDECommandHandler_GetHR(PyIDDECommandHandlerObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIDDECommandHandler_GetIgnoreFailures(PyIDDECommandHandlerObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIDDECommandHandler_SetIgnoreFailures(PyIDDECommandHandlerObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIDDECommandHandler_SupportsInterface(PyIDDECommandHandlerObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIDDECommandHandler->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IDDECommandHandlerMethod_CanExecute(PyIDDECommandHandlerObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsCommand = 0;
    PyObject* pyvar_Command;
    PyObject* unicodeCommand = NULL;
    VARIANT_BOOL b_CanExecute = VARIANT_FALSE;
    PyObject* pyvar_CanExecute = Py_False;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_Command))
      goto iddecommandhandler_canexecute_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_Command))
        unicodeCommand = PyUnicode_FromObject(pyvar_Command);
    else if (PyUnicode_Check(pyvar_Command))
    {
        unicodeCommand = pyvar_Command;
        Py_INCREF(unicodeCommand);
    }
    else if (pyvar_Command != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Command at index 0");
    if (unicodeCommand)
        bsCommand = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeCommand), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeCommand));
    
    if (PyErr_Occurred())
      goto iddecommandhandler_canexecute_method_cleanup;
    
    // No setup for CanExecute

    // Call method on actual COM interface
    hr = self->m_pIDDECommandHandler->CanExecute(bsCommand, &b_CanExecute);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDDECommandHandler->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDDECommandHandler) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDDECommandHandler.CanExecute() returned %ld", (long)hr);
        goto iddecommandhandler_canexecute_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Command
    pyvar_CanExecute = ((b_CanExecute == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto iddecommandhandler_canexecute_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_CanExecute);
    goto iddecommandhandler_canexecute_method_cleanup;

    iddecommandhandler_canexecute_method_cleanup:
    self->m_HR = hr;
    if (bsCommand)
        ::SysFreeString(bsCommand);
    
    // No cleanup for CanExecute
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDDECommandHandler.CanExecute");
    return return_tuple;
}

static PyObject*
IDDECommandHandlerMethod_Execute(PyIDDECommandHandlerObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsCommand = 0;
    PyObject* pyvar_Command;
    PyObject* unicodeCommand = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_Command))
      goto iddecommandhandler_execute_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_Command))
        unicodeCommand = PyUnicode_FromObject(pyvar_Command);
    else if (PyUnicode_Check(pyvar_Command))
    {
        unicodeCommand = pyvar_Command;
        Py_INCREF(unicodeCommand);
    }
    else if (pyvar_Command != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Command at index 0");
    if (unicodeCommand)
        bsCommand = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeCommand), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeCommand));
    
    if (PyErr_Occurred())
      goto iddecommandhandler_execute_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIDDECommandHandler->Execute(bsCommand);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDDECommandHandler->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDDECommandHandler) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDDECommandHandler.Execute() returned %ld", (long)hr);
        goto iddecommandhandler_execute_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Command

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iddecommandhandler_execute_method_cleanup;

    iddecommandhandler_execute_method_cleanup:
    self->m_HR = hr;
    if (bsCommand)
        ::SysFreeString(bsCommand);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDDECommandHandler.Execute");
    return return_tuple;
}


PyMethodDef PyIDDECommandHandlerMethods[] = {
    {"supports", (PyCFunction)PyIDDECommandHandler_SupportsInterface, METH_O, ""},
    {"CanExecute", (PyCFunction)IDDECommandHandlerMethod_CanExecute, METH_VARARGS, ""},
    {"Execute", (PyCFunction)IDDECommandHandlerMethod_Execute, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIDDECommandHandlerGetSet[] = {
  {"_pUnk", (getter)PyIDDECommandHandler_GetpUnk, NULL, "Get opaque pointer to an Unknown from IDDECommandHandler", NULL},
  {"_pointer", (getter)PyIDDECommandHandler_GetPointer, NULL, "Get memory address for IDDECommandHandler", NULL},
  {"_IID", (getter)PyIDDECommandHandler_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIDDECommandHandler_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIDDECommandHandler_GetIgnoreFailures, (setter)PyIDDECommandHandler_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIDDECommandHandlerObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriFramework.IDDECommandHandlerObject",                          
                                              /* tp_name */
  sizeof(PyIDDECommandHandlerObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIDDECommandHandlerObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIDDECommandHandlerMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIDDECommandHandlerGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIDDECommandHandlerObject_new,                      
                                              /* tp_new */
};

// Interface IPropertyPageContext

typedef struct PyIPropertyPageContextObject {
    PyObject_HEAD
    IPropertyPageContext* m_pIPropertyPageContext;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIPropertyPageContextObject;

static PyObject*
PyIPropertyPageContextObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIPropertyPageContextObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IPropertyPageContext* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IPropertyPageContext, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IPropertyPageContext with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIPropertyPageContextObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IPropertyPageContext");
            return NULL;
        }
        self->m_pIPropertyPageContext = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IPropertyPageContext");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IPropertyPageContext");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IPropertyPageContext* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IPropertyPageContext, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IPropertyPageContext");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIPropertyPageContextObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IPropertyPageContext");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIPropertyPageContext = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIPropertyPageContextObject_dealloc(PyIPropertyPageContextObject* self)
{
    if (self->m_pIPropertyPageContext)
        self->m_pIPropertyPageContext->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIPropertyPageContext_GetpUnk(PyIPropertyPageContextObject* self)
{
    if (!self->m_pIPropertyPageContext)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIPropertyPageContext->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IPropertyPageContext to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIPropertyPageContext_GetPointer(PyIPropertyPageContextObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIPropertyPageContext);
}

static PyObject*
PyIPropertyPageContext_GetIID(PyIPropertyPageContextObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "f87fa8a3-e51a-11d1-877c-0000f8751720");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIPropertyPageContext_GetHR(PyIPropertyPageContextObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIPropertyPageContext_GetIgnoreFailures(PyIPropertyPageContextObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIPropertyPageContext_SetIgnoreFailures(PyIPropertyPageContextObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIPropertyPageContext_SupportsInterface(PyIPropertyPageContextObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIPropertyPageContext->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IPropertyPageContextMethod_get_Priority(PyIPropertyPageContextObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lPriority = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Priority

    // Call method on actual COM interface
    hr = self->m_pIPropertyPageContext->get_Priority(&lPriority);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPropertyPageContext->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPropertyPageContext) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPropertyPageContext.get_Priority() returned %ld", (long)hr);
        goto ipropertypagecontext_get_priority_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Priority

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lPriority);
    goto ipropertypagecontext_get_priority_method_cleanup;

    ipropertypagecontext_get_priority_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Priority
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPropertyPageContext.get_Priority");
    return return_tuple;
}

static PyObject*
IPropertyPageContextMethod_Applies(PyIPropertyPageContextObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT vunkArray;
    ::VariantInit(&vunkArray);
    PyObject* pyvar_unkArray = NULL;
    VARIANT_BOOL b_Applies = VARIANT_FALSE;
    PyObject* pyvar_Applies = Py_False;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_unkArray))
      goto ipropertypagecontext_applies_method_cleanup;

    // Set up initial variable values as needed
    PyObject_AsVariant(pyvar_unkArray, &vunkArray);
    
    if (PyErr_Occurred())
      goto ipropertypagecontext_applies_method_cleanup;
    
    // No setup for Applies

    // Call method on actual COM interface
    hr = self->m_pIPropertyPageContext->Applies(vunkArray, &b_Applies);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPropertyPageContext->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPropertyPageContext) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPropertyPageContext.Applies() returned %ld", (long)hr);
        goto ipropertypagecontext_applies_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for unkArray
    pyvar_Applies = ((b_Applies == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto ipropertypagecontext_applies_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Applies);
    goto ipropertypagecontext_applies_method_cleanup;

    ipropertypagecontext_applies_method_cleanup:
    self->m_HR = hr;
    ::VariantClear(&vunkArray);
    // No cleanup for Applies
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPropertyPageContext.Applies");
    return return_tuple;
}

static PyObject*
IPropertyPageContextMethod_CreateCompatibleObject(PyIPropertyPageContextObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT vkind;
    ::VariantInit(&vkind);
    PyObject* pyvar_kind = NULL;
    VARIANT vpNewObject;
    ::VariantInit(&vpNewObject);
    PyObject* pyvar_pNewObject = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_kind))
      goto ipropertypagecontext_createcompatibleobject_method_cleanup;

    // Set up initial variable values as needed
    PyObject_AsVariant(pyvar_kind, &vkind);
    
    if (PyErr_Occurred())
      goto ipropertypagecontext_createcompatibleobject_method_cleanup;
    
    // No setup for pNewObject

    // Call method on actual COM interface
    hr = self->m_pIPropertyPageContext->CreateCompatibleObject(vkind, &vpNewObject);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPropertyPageContext->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPropertyPageContext) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPropertyPageContext.CreateCompatibleObject() returned %ld", (long)hr);
        goto ipropertypagecontext_createcompatibleobject_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for kind
    pyvar_pNewObject = Variant_AsPyObject(&vpNewObject);
    if (PyErr_Occurred())
      goto ipropertypagecontext_createcompatibleobject_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pNewObject);
    goto ipropertypagecontext_createcompatibleobject_method_cleanup;

    ipropertypagecontext_createcompatibleobject_method_cleanup:
    self->m_HR = hr;
    ::VariantClear(&vkind);
    ::VariantClear(&vpNewObject);
    Py_XDECREF(pyvar_pNewObject);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPropertyPageContext.CreateCompatibleObject");
    return return_tuple;
}

static PyObject*
IPropertyPageContextMethod_QueryObject(PyIPropertyPageContextObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT vtheObject;
    ::VariantInit(&vtheObject);
    PyObject* pyvar_theObject = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_theObject))
      goto ipropertypagecontext_queryobject_method_cleanup;

    // Set up initial variable values as needed
    PyObject_AsVariant(pyvar_theObject, &vtheObject);
    
    if (PyErr_Occurred())
      goto ipropertypagecontext_queryobject_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIPropertyPageContext->QueryObject(vtheObject);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPropertyPageContext->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPropertyPageContext) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPropertyPageContext.QueryObject() returned %ld", (long)hr);
        goto ipropertypagecontext_queryobject_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for theObject

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ipropertypagecontext_queryobject_method_cleanup;

    ipropertypagecontext_queryobject_method_cleanup:
    self->m_HR = hr;
    ::VariantClear(&vtheObject);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPropertyPageContext.QueryObject");
    return return_tuple;
}

static PyObject*
IPropertyPageContextMethod_GetHelpFile(PyIPropertyPageContextObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lcontrolID = 0;
    BSTR bsHelpFile;
    PyObject* pyvar_HelpFile = Py_None;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lcontrolID))
      goto ipropertypagecontext_gethelpfile_method_cleanup;

    // Set up initial variable values as needed
    // No setup for controlID
    // No setup for HelpFile

    // Call method on actual COM interface
    hr = self->m_pIPropertyPageContext->GetHelpFile(lcontrolID, &bsHelpFile);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPropertyPageContext->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPropertyPageContext) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPropertyPageContext.GetHelpFile() returned %ld", (long)hr);
        goto ipropertypagecontext_gethelpfile_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for controlID
    pyvar_HelpFile = PyUnicode_FromWideChar(bsHelpFile,::SysStringLen(bsHelpFile));
    ::SysFreeString(bsHelpFile);
    
    if (PyErr_Occurred())
      goto ipropertypagecontext_gethelpfile_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_HelpFile);
    goto ipropertypagecontext_gethelpfile_method_cleanup;

    ipropertypagecontext_gethelpfile_method_cleanup:
    self->m_HR = hr;
    // No cleanup for controlID
    if (pyvar_HelpFile != Py_None)
        Py_XDECREF(pyvar_HelpFile);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPropertyPageContext.GetHelpFile");
    return return_tuple;
}

static PyObject*
IPropertyPageContextMethod_GetHelpId(PyIPropertyPageContextObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lcontrolID = 0;
    long lhelpID = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lcontrolID))
      goto ipropertypagecontext_gethelpid_method_cleanup;

    // Set up initial variable values as needed
    // No setup for controlID
    // No setup for helpID

    // Call method on actual COM interface
    hr = self->m_pIPropertyPageContext->GetHelpId(lcontrolID, &lhelpID);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPropertyPageContext->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPropertyPageContext) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPropertyPageContext.GetHelpId() returned %ld", (long)hr);
        goto ipropertypagecontext_gethelpid_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for controlID
    // No teardown for helpID

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lhelpID);
    goto ipropertypagecontext_gethelpid_method_cleanup;

    ipropertypagecontext_gethelpid_method_cleanup:
    self->m_HR = hr;
    // No cleanup for controlID
    // No cleanup for helpID
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPropertyPageContext.GetHelpId");
    return return_tuple;
}

static PyObject*
IPropertyPageContextMethod_Cancel(PyIPropertyPageContextObject* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pIPropertyPageContext->Cancel();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPropertyPageContext->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPropertyPageContext) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPropertyPageContext.Cancel() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}


PyMethodDef PyIPropertyPageContextMethods[] = {
    {"supports", (PyCFunction)PyIPropertyPageContext_SupportsInterface, METH_O, ""},
    {"get_Priority", (PyCFunction)IPropertyPageContextMethod_get_Priority, METH_VARARGS, ""},
    {"Applies", (PyCFunction)IPropertyPageContextMethod_Applies, METH_VARARGS, ""},
    {"CreateCompatibleObject", (PyCFunction)IPropertyPageContextMethod_CreateCompatibleObject, METH_VARARGS, ""},
    {"QueryObject", (PyCFunction)IPropertyPageContextMethod_QueryObject, METH_VARARGS, ""},
    {"GetHelpFile", (PyCFunction)IPropertyPageContextMethod_GetHelpFile, METH_VARARGS, ""},
    {"GetHelpId", (PyCFunction)IPropertyPageContextMethod_GetHelpId, METH_VARARGS, ""},
    {"Cancel", (PyCFunction)IPropertyPageContextMethod_Cancel, METH_NOARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIPropertyPageContextGetSet[] = {
  {"_pUnk", (getter)PyIPropertyPageContext_GetpUnk, NULL, "Get opaque pointer to an Unknown from IPropertyPageContext", NULL},
  {"_pointer", (getter)PyIPropertyPageContext_GetPointer, NULL, "Get memory address for IPropertyPageContext", NULL},
  {"_IID", (getter)PyIPropertyPageContext_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIPropertyPageContext_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIPropertyPageContext_GetIgnoreFailures, (setter)PyIPropertyPageContext_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIPropertyPageContextObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriFramework.IPropertyPageContextObject",                          
                                              /* tp_name */
  sizeof(PyIPropertyPageContextObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIPropertyPageContextObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIPropertyPageContextMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIPropertyPageContextGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIPropertyPageContextObject_new,                      
                                              /* tp_new */
};

// Interface IColorPalette

typedef struct PyIColorPaletteObject {
    PyObject_HEAD
    IColorPalette* m_pIColorPalette;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIColorPaletteObject;

static PyObject*
PyIColorPaletteObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIColorPaletteObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IColorPalette* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IColorPalette, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IColorPalette with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIColorPaletteObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IColorPalette");
            return NULL;
        }
        self->m_pIColorPalette = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IColorPalette");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IColorPalette");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IColorPalette* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IColorPalette, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IColorPalette");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIColorPaletteObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IColorPalette");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIColorPalette = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIColorPaletteObject_dealloc(PyIColorPaletteObject* self)
{
    if (self->m_pIColorPalette)
        self->m_pIColorPalette->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIColorPalette_GetpUnk(PyIColorPaletteObject* self)
{
    if (!self->m_pIColorPalette)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIColorPalette->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IColorPalette to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIColorPalette_GetPointer(PyIColorPaletteObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIColorPalette);
}

static PyObject*
PyIColorPalette_GetIID(PyIColorPaletteObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "14746473-1534-11d3-9f49-00c04f6bc709");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIColorPalette_GetHR(PyIColorPaletteObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIColorPalette_GetIgnoreFailures(PyIColorPaletteObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIColorPalette_SetIgnoreFailures(PyIColorPaletteObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIColorPalette_SupportsInterface(PyIColorPaletteObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIColorPalette->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IColorPaletteMethod_TrackPopupMenu(PyIColorPaletteObject* self, PyObject* args)
{
    /* Param types that are unhandleable: 
       INPUT [u'tagRECT', u'*']
    */
    PyErr_SetString(PyExc_NotImplementedError, "Wrapper for IColorPalette.TrackPopupMenu not implemented.");
    return NULL;
}

static PyObject*
IColorPaletteMethod_get_Color(PyIColorPaletteObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IColor* ipnewColor = NULL;
    PyObject* py_newColor = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for newColor

    // Call method on actual COM interface
    hr = self->m_pIColorPalette->get_Color(&ipnewColor);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIColorPalette->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IColorPalette) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IColorPalette.get_Color() returned %ld", (long)hr);
        goto icolorpalette_get_color_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_newColor);
    if (ipnewColor)
    {
        IUnknown* pUnk = NULL;
        ipnewColor->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_newColor = IUnknownToPythonIIDObject(pUnk, &IID_IColor);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_newColor)
    {
        if (py_newColor)
           Py_DECREF(py_newColor);
        py_newColor = Py_None;
        Py_INCREF(py_newColor);
    }
    if (PyErr_Occurred())
      goto icolorpalette_get_color_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_newColor);
    goto icolorpalette_get_color_method_cleanup;

    icolorpalette_get_color_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_newColor);
    if (ipnewColor)
      ipnewColor->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IColorPalette.get_Color");
    return return_tuple;
}


PyMethodDef PyIColorPaletteMethods[] = {
    {"supports", (PyCFunction)PyIColorPalette_SupportsInterface, METH_O, ""},
    {"TrackPopupMenu", (PyCFunction)IColorPaletteMethod_TrackPopupMenu, METH_VARARGS, ""},
    {"get_Color", (PyCFunction)IColorPaletteMethod_get_Color, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIColorPaletteGetSet[] = {
  {"_pUnk", (getter)PyIColorPalette_GetpUnk, NULL, "Get opaque pointer to an Unknown from IColorPalette", NULL},
  {"_pointer", (getter)PyIColorPalette_GetPointer, NULL, "Get memory address for IColorPalette", NULL},
  {"_IID", (getter)PyIColorPalette_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIColorPalette_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIColorPalette_GetIgnoreFailures, (setter)PyIColorPalette_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIColorPaletteObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriFramework.IColorPaletteObject",                          
                                              /* tp_name */
  sizeof(PyIColorPaletteObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIColorPaletteObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIColorPaletteMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIColorPaletteGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIColorPaletteObject_new,                      
                                              /* tp_new */
};

// Interface IArcToolboxTool

typedef struct PyIArcToolboxToolObject {
    PyObject_HEAD
    IArcToolboxTool* m_pIArcToolboxTool;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIArcToolboxToolObject;

static PyObject*
PyIArcToolboxToolObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIArcToolboxToolObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IArcToolboxTool* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IArcToolboxTool, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IArcToolboxTool with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIArcToolboxToolObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IArcToolboxTool");
            return NULL;
        }
        self->m_pIArcToolboxTool = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IArcToolboxTool");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IArcToolboxTool");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IArcToolboxTool* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IArcToolboxTool, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IArcToolboxTool");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIArcToolboxToolObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IArcToolboxTool");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIArcToolboxTool = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIArcToolboxToolObject_dealloc(PyIArcToolboxToolObject* self)
{
    if (self->m_pIArcToolboxTool)
        self->m_pIArcToolboxTool->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIArcToolboxTool_GetpUnk(PyIArcToolboxToolObject* self)
{
    if (!self->m_pIArcToolboxTool)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIArcToolboxTool->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IArcToolboxTool to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIArcToolboxTool_GetPointer(PyIArcToolboxToolObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIArcToolboxTool);
}

static PyObject*
PyIArcToolboxTool_GetIID(PyIArcToolboxToolObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "0acdfe44-f5e2-11d3-a623-0008c711c8c1");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIArcToolboxTool_GetHR(PyIArcToolboxToolObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIArcToolboxTool_GetIgnoreFailures(PyIArcToolboxToolObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIArcToolboxTool_SetIgnoreFailures(PyIArcToolboxToolObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIArcToolboxTool_SupportsInterface(PyIArcToolboxToolObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIArcToolboxTool->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IArcToolboxToolMethod_put_Modality(PyIArcToolboxToolObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriATModality edialogModality;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&edialogModality))
      goto iarctoolboxtool_put_modality_method_cleanup;

    // Set up initial variable values as needed
    // No setup for dialogModality

    // Call method on actual COM interface
    hr = self->m_pIArcToolboxTool->put_Modality(edialogModality);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIArcToolboxTool->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IArcToolboxTool) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IArcToolboxTool.put_Modality() returned %ld", (long)hr);
        goto iarctoolboxtool_put_modality_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for dialogModality

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iarctoolboxtool_put_modality_method_cleanup;

    iarctoolboxtool_put_modality_method_cleanup:
    self->m_HR = hr;
    // No cleanup for dialogModality
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IArcToolboxTool.put_Modality");
    return return_tuple;
}

static PyObject*
IArcToolboxToolMethod_get_Modality(PyIArcToolboxToolObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriATModality edialogModality;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for dialogModality

    // Call method on actual COM interface
    hr = self->m_pIArcToolboxTool->get_Modality(&edialogModality);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIArcToolboxTool->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IArcToolboxTool) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IArcToolboxTool.get_Modality() returned %ld", (long)hr);
        goto iarctoolboxtool_get_modality_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for dialogModality

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)edialogModality);
    goto iarctoolboxtool_get_modality_method_cleanup;

    iarctoolboxtool_get_modality_method_cleanup:
    self->m_HR = hr;
    // No cleanup for dialogModality
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IArcToolboxTool.get_Modality");
    return return_tuple;
}

static PyObject*
IArcToolboxToolMethod_get_Name(PyIArcToolboxToolObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName;
    PyObject* pyvar_Name = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Name

    // Call method on actual COM interface
    hr = self->m_pIArcToolboxTool->get_Name(&bsName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIArcToolboxTool->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IArcToolboxTool) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IArcToolboxTool.get_Name() returned %ld", (long)hr);
        goto iarctoolboxtool_get_name_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Name = PyUnicode_FromWideChar(bsName,::SysStringLen(bsName));
    ::SysFreeString(bsName);
    
    if (PyErr_Occurred())
      goto iarctoolboxtool_get_name_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Name);
    goto iarctoolboxtool_get_name_method_cleanup;

    iarctoolboxtool_get_name_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Name != Py_None)
        Py_XDECREF(pyvar_Name);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IArcToolboxTool.get_Name");
    return return_tuple;
}

static PyObject*
IArcToolboxToolMethod_get_Message(PyIArcToolboxToolObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsMessage;
    PyObject* pyvar_Message = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Message

    // Call method on actual COM interface
    hr = self->m_pIArcToolboxTool->get_Message(&bsMessage);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIArcToolboxTool->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IArcToolboxTool) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IArcToolboxTool.get_Message() returned %ld", (long)hr);
        goto iarctoolboxtool_get_message_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Message = PyUnicode_FromWideChar(bsMessage,::SysStringLen(bsMessage));
    ::SysFreeString(bsMessage);
    
    if (PyErr_Occurred())
      goto iarctoolboxtool_get_message_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Message);
    goto iarctoolboxtool_get_message_method_cleanup;

    iarctoolboxtool_get_message_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Message != Py_None)
        Py_XDECREF(pyvar_Message);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IArcToolboxTool.get_Message");
    return return_tuple;
}

static PyObject*
IArcToolboxToolMethod_get_HelpFile(PyIArcToolboxToolObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsHelpFile;
    PyObject* pyvar_HelpFile = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for HelpFile

    // Call method on actual COM interface
    hr = self->m_pIArcToolboxTool->get_HelpFile(&bsHelpFile);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIArcToolboxTool->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IArcToolboxTool) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IArcToolboxTool.get_HelpFile() returned %ld", (long)hr);
        goto iarctoolboxtool_get_helpfile_method_cleanup;
    }

    // Set up return values as needed
    pyvar_HelpFile = PyUnicode_FromWideChar(bsHelpFile,::SysStringLen(bsHelpFile));
    ::SysFreeString(bsHelpFile);
    
    if (PyErr_Occurred())
      goto iarctoolboxtool_get_helpfile_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_HelpFile);
    goto iarctoolboxtool_get_helpfile_method_cleanup;

    iarctoolboxtool_get_helpfile_method_cleanup:
    self->m_HR = hr;
    if (pyvar_HelpFile != Py_None)
        Py_XDECREF(pyvar_HelpFile);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IArcToolboxTool.get_HelpFile");
    return return_tuple;
}

static PyObject*
IArcToolboxToolMethod_get_HelpContextID(PyIArcToolboxToolObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lhelpID = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for helpID

    // Call method on actual COM interface
    hr = self->m_pIArcToolboxTool->get_HelpContextID(&lhelpID);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIArcToolboxTool->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IArcToolboxTool) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IArcToolboxTool.get_HelpContextID() returned %ld", (long)hr);
        goto iarctoolboxtool_get_helpcontextid_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for helpID

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lhelpID);
    goto iarctoolboxtool_get_helpcontextid_method_cleanup;

    iarctoolboxtool_get_helpcontextid_method_cleanup:
    self->m_HR = hr;
    // No cleanup for helpID
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IArcToolboxTool.get_HelpContextID");
    return return_tuple;
}

static PyObject*
IArcToolboxToolMethod_get_Bitmap(PyIArcToolboxToolObject* self, PyObject* args)
{
    /* Param types that are unhandleable: 
       OUTPUT [u'IPictureDisp', u'*', u'*']
    */
    PyErr_SetString(PyExc_NotImplementedError, "Wrapper for IArcToolboxTool.get_Bitmap not implemented.");
    return NULL;
}

static PyObject*
IArcToolboxToolMethod_get_TreeviewLocation(PyIArcToolboxToolObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsTreeviewLocation;
    PyObject* pyvar_TreeviewLocation = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for TreeviewLocation

    // Call method on actual COM interface
    hr = self->m_pIArcToolboxTool->get_TreeviewLocation(&bsTreeviewLocation);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIArcToolboxTool->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IArcToolboxTool) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IArcToolboxTool.get_TreeviewLocation() returned %ld", (long)hr);
        goto iarctoolboxtool_get_treeviewlocation_method_cleanup;
    }

    // Set up return values as needed
    pyvar_TreeviewLocation = PyUnicode_FromWideChar(bsTreeviewLocation,::SysStringLen(bsTreeviewLocation));
    ::SysFreeString(bsTreeviewLocation);
    
    if (PyErr_Occurred())
      goto iarctoolboxtool_get_treeviewlocation_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_TreeviewLocation);
    goto iarctoolboxtool_get_treeviewlocation_method_cleanup;

    iarctoolboxtool_get_treeviewlocation_method_cleanup:
    self->m_HR = hr;
    if (pyvar_TreeviewLocation != Py_None)
        Py_XDECREF(pyvar_TreeviewLocation);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IArcToolboxTool.get_TreeviewLocation");
    return return_tuple;
}

static PyObject*
IArcToolboxToolMethod_OnCreate(PyIArcToolboxToolObject* self, PyObject* args)
{
    /* Param types that are unhandleable: 
       INPUT [u'IDispatch', u'*']
    */
    PyErr_SetString(PyExc_NotImplementedError, "Wrapper for IArcToolboxTool.OnCreate not implemented.");
    return NULL;
}

static PyObject*
IArcToolboxToolMethod_Execute(PyIArcToolboxToolObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT vInputData;
    ::VariantInit(&vInputData);
    PyObject* pyvar_InputData = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_InputData))
      goto iarctoolboxtool_execute_method_cleanup;

    // Set up initial variable values as needed
    PyObject_AsVariant(pyvar_InputData, &vInputData);
    
    if (PyErr_Occurred())
      goto iarctoolboxtool_execute_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIArcToolboxTool->Execute(&vInputData);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIArcToolboxTool->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IArcToolboxTool) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IArcToolboxTool.Execute() returned %ld", (long)hr);
        goto iarctoolboxtool_execute_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for InputData

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iarctoolboxtool_execute_method_cleanup;

    iarctoolboxtool_execute_method_cleanup:
    self->m_HR = hr;
    ::VariantClear(&vInputData);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IArcToolboxTool.Execute");
    return return_tuple;
}


PyMethodDef PyIArcToolboxToolMethods[] = {
    {"supports", (PyCFunction)PyIArcToolboxTool_SupportsInterface, METH_O, ""},
    {"put_Modality", (PyCFunction)IArcToolboxToolMethod_put_Modality, METH_VARARGS, ""},
    {"get_Modality", (PyCFunction)IArcToolboxToolMethod_get_Modality, METH_VARARGS, ""},
    {"get_Name", (PyCFunction)IArcToolboxToolMethod_get_Name, METH_VARARGS, ""},
    {"get_Message", (PyCFunction)IArcToolboxToolMethod_get_Message, METH_VARARGS, ""},
    {"get_HelpFile", (PyCFunction)IArcToolboxToolMethod_get_HelpFile, METH_VARARGS, ""},
    {"get_HelpContextID", (PyCFunction)IArcToolboxToolMethod_get_HelpContextID, METH_VARARGS, ""},
    {"get_Bitmap", (PyCFunction)IArcToolboxToolMethod_get_Bitmap, METH_VARARGS, ""},
    {"get_TreeviewLocation", (PyCFunction)IArcToolboxToolMethod_get_TreeviewLocation, METH_VARARGS, ""},
    {"OnCreate", (PyCFunction)IArcToolboxToolMethod_OnCreate, METH_VARARGS, ""},
    {"Execute", (PyCFunction)IArcToolboxToolMethod_Execute, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIArcToolboxToolGetSet[] = {
  {"_pUnk", (getter)PyIArcToolboxTool_GetpUnk, NULL, "Get opaque pointer to an Unknown from IArcToolboxTool", NULL},
  {"_pointer", (getter)PyIArcToolboxTool_GetPointer, NULL, "Get memory address for IArcToolboxTool", NULL},
  {"_IID", (getter)PyIArcToolboxTool_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIArcToolboxTool_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIArcToolboxTool_GetIgnoreFailures, (setter)PyIArcToolboxTool_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIArcToolboxToolObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriFramework.IArcToolboxToolObject",                          
                                              /* tp_name */
  sizeof(PyIArcToolboxToolObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIArcToolboxToolObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIArcToolboxToolMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIArcToolboxToolGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIArcToolboxToolObject_new,                      
                                              /* tp_new */
};

// Interface IFileOpenHandler

typedef struct PyIFileOpenHandlerObject {
    PyObject_HEAD
    IFileOpenHandler* m_pIFileOpenHandler;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIFileOpenHandlerObject;

static PyObject*
PyIFileOpenHandlerObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIFileOpenHandlerObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IFileOpenHandler* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IFileOpenHandler, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IFileOpenHandler with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIFileOpenHandlerObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IFileOpenHandler");
            return NULL;
        }
        self->m_pIFileOpenHandler = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IFileOpenHandler");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IFileOpenHandler");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IFileOpenHandler* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IFileOpenHandler, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IFileOpenHandler");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIFileOpenHandlerObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IFileOpenHandler");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIFileOpenHandler = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIFileOpenHandlerObject_dealloc(PyIFileOpenHandlerObject* self)
{
    if (self->m_pIFileOpenHandler)
        self->m_pIFileOpenHandler->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIFileOpenHandler_GetpUnk(PyIFileOpenHandlerObject* self)
{
    if (!self->m_pIFileOpenHandler)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIFileOpenHandler->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IFileOpenHandler to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIFileOpenHandler_GetPointer(PyIFileOpenHandlerObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIFileOpenHandler);
}

static PyObject*
PyIFileOpenHandler_GetIID(PyIFileOpenHandlerObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "316f1e91-30b6-43fe-9fd8-9c08c5394eb8");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIFileOpenHandler_GetHR(PyIFileOpenHandlerObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIFileOpenHandler_GetIgnoreFailures(PyIFileOpenHandlerObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIFileOpenHandler_SetIgnoreFailures(PyIFileOpenHandlerObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIFileOpenHandler_SupportsInterface(PyIFileOpenHandlerObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIFileOpenHandler->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IFileOpenHandlerMethod_CanOpen(PyIFileOpenHandlerObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsfilename = 0;
    PyObject* pyvar_filename;
    PyObject* unicodefilename = NULL;
    VARIANT_BOOL b_CanOpen = VARIANT_FALSE;
    PyObject* pyvar_CanOpen = Py_False;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_filename))
      goto ifileopenhandler_canopen_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_filename))
        unicodefilename = PyUnicode_FromObject(pyvar_filename);
    else if (PyUnicode_Check(pyvar_filename))
    {
        unicodefilename = pyvar_filename;
        Py_INCREF(unicodefilename);
    }
    else if (pyvar_filename != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter filename at index 0");
    if (unicodefilename)
        bsfilename = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodefilename), 
                                            (UINT)PyUnicode_GET_SIZE(unicodefilename));
    
    if (PyErr_Occurred())
      goto ifileopenhandler_canopen_method_cleanup;
    
    // No setup for CanOpen

    // Call method on actual COM interface
    hr = self->m_pIFileOpenHandler->CanOpen(bsfilename, &b_CanOpen);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIFileOpenHandler->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IFileOpenHandler) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IFileOpenHandler.CanOpen() returned %ld", (long)hr);
        goto ifileopenhandler_canopen_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for filename
    pyvar_CanOpen = ((b_CanOpen == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto ifileopenhandler_canopen_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_CanOpen);
    goto ifileopenhandler_canopen_method_cleanup;

    ifileopenhandler_canopen_method_cleanup:
    self->m_HR = hr;
    if (bsfilename)
        ::SysFreeString(bsfilename);
    
    // No cleanup for CanOpen
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IFileOpenHandler.CanOpen");
    return return_tuple;
}

static PyObject*
IFileOpenHandlerMethod_Open(PyIFileOpenHandlerObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsfilename = 0;
    PyObject* pyvar_filename;
    PyObject* unicodefilename = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_filename))
      goto ifileopenhandler_open_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_filename))
        unicodefilename = PyUnicode_FromObject(pyvar_filename);
    else if (PyUnicode_Check(pyvar_filename))
    {
        unicodefilename = pyvar_filename;
        Py_INCREF(unicodefilename);
    }
    else if (pyvar_filename != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter filename at index 0");
    if (unicodefilename)
        bsfilename = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodefilename), 
                                            (UINT)PyUnicode_GET_SIZE(unicodefilename));
    
    if (PyErr_Occurred())
      goto ifileopenhandler_open_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIFileOpenHandler->Open(bsfilename);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIFileOpenHandler->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IFileOpenHandler) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IFileOpenHandler.Open() returned %ld", (long)hr);
        goto ifileopenhandler_open_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for filename

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ifileopenhandler_open_method_cleanup;

    ifileopenhandler_open_method_cleanup:
    self->m_HR = hr;
    if (bsfilename)
        ::SysFreeString(bsfilename);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IFileOpenHandler.Open");
    return return_tuple;
}


PyMethodDef PyIFileOpenHandlerMethods[] = {
    {"supports", (PyCFunction)PyIFileOpenHandler_SupportsInterface, METH_O, ""},
    {"CanOpen", (PyCFunction)IFileOpenHandlerMethod_CanOpen, METH_VARARGS, ""},
    {"Open", (PyCFunction)IFileOpenHandlerMethod_Open, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIFileOpenHandlerGetSet[] = {
  {"_pUnk", (getter)PyIFileOpenHandler_GetpUnk, NULL, "Get opaque pointer to an Unknown from IFileOpenHandler", NULL},
  {"_pointer", (getter)PyIFileOpenHandler_GetPointer, NULL, "Get memory address for IFileOpenHandler", NULL},
  {"_IID", (getter)PyIFileOpenHandler_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIFileOpenHandler_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIFileOpenHandler_GetIgnoreFailures, (setter)PyIFileOpenHandler_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIFileOpenHandlerObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriFramework.IFileOpenHandlerObject",                          
                                              /* tp_name */
  sizeof(PyIFileOpenHandlerObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIFileOpenHandlerObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIFileOpenHandlerMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIFileOpenHandlerGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIFileOpenHandlerObject_new,                      
                                              /* tp_new */
};

// Interface IAtbApplication

typedef struct PyIAtbApplicationObject {
    PyObject_HEAD
    IAtbApplication* m_pIAtbApplication;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIAtbApplicationObject;

static PyObject*
PyIAtbApplicationObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIAtbApplicationObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IAtbApplication* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IAtbApplication, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IAtbApplication with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIAtbApplicationObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IAtbApplication");
            return NULL;
        }
        self->m_pIAtbApplication = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IAtbApplication");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IAtbApplication");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IAtbApplication* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IAtbApplication, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IAtbApplication");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIAtbApplicationObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IAtbApplication");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIAtbApplication = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIAtbApplicationObject_dealloc(PyIAtbApplicationObject* self)
{
    if (self->m_pIAtbApplication)
        self->m_pIAtbApplication->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIAtbApplication_GetpUnk(PyIAtbApplicationObject* self)
{
    if (!self->m_pIAtbApplication)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIAtbApplication->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IAtbApplication to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIAtbApplication_GetPointer(PyIAtbApplicationObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIAtbApplication);
}

static PyObject*
PyIAtbApplication_GetIID(PyIAtbApplicationObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "ea936dfe-2aa1-11d4-a632-0008c711c8c1");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIAtbApplication_GetHR(PyIAtbApplicationObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIAtbApplication_GetIgnoreFailures(PyIAtbApplicationObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIAtbApplication_SetIgnoreFailures(PyIAtbApplicationObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIAtbApplication_SupportsInterface(PyIAtbApplicationObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIAtbApplication->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IAtbApplicationMethod_get_hWnd(PyIAtbApplicationObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    OLE_HANDLE HhWnd = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for hWnd

    // Call method on actual COM interface
    hr = self->m_pIAtbApplication->get_hWnd(&HhWnd);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAtbApplication->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAtbApplication) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAtbApplication.get_hWnd() returned %ld", (long)hr);
        goto iatbapplication_get_hwnd_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for hWnd

    // Initialize output tuple
    return_tuple = Py_BuildValue("I",
                                            HhWnd);
    goto iatbapplication_get_hwnd_method_cleanup;

    iatbapplication_get_hwnd_method_cleanup:
    self->m_HR = hr;
    // No cleanup for hWnd
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAtbApplication.get_hWnd");
    return return_tuple;
}


PyMethodDef PyIAtbApplicationMethods[] = {
    {"supports", (PyCFunction)PyIAtbApplication_SupportsInterface, METH_O, ""},
    {"get_hWnd", (PyCFunction)IAtbApplicationMethod_get_hWnd, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIAtbApplicationGetSet[] = {
  {"_pUnk", (getter)PyIAtbApplication_GetpUnk, NULL, "Get opaque pointer to an Unknown from IAtbApplication", NULL},
  {"_pointer", (getter)PyIAtbApplication_GetPointer, NULL, "Get memory address for IAtbApplication", NULL},
  {"_IID", (getter)PyIAtbApplication_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIAtbApplication_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIAtbApplication_GetIgnoreFailures, (setter)PyIAtbApplication_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIAtbApplicationObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriFramework.IAtbApplicationObject",                          
                                              /* tp_name */
  sizeof(PyIAtbApplicationObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIAtbApplicationObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIAtbApplicationMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIAtbApplicationGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIAtbApplicationObject_new,                      
                                              /* tp_new */
};

// Interface IArcToolboxFind

typedef struct PyIArcToolboxFindObject {
    PyObject_HEAD
    IArcToolboxFind* m_pIArcToolboxFind;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIArcToolboxFindObject;

static PyObject*
PyIArcToolboxFindObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIArcToolboxFindObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IArcToolboxFind* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IArcToolboxFind, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IArcToolboxFind with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIArcToolboxFindObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IArcToolboxFind");
            return NULL;
        }
        self->m_pIArcToolboxFind = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IArcToolboxFind");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IArcToolboxFind");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IArcToolboxFind* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IArcToolboxFind, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IArcToolboxFind");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIArcToolboxFindObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IArcToolboxFind");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIArcToolboxFind = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIArcToolboxFindObject_dealloc(PyIArcToolboxFindObject* self)
{
    if (self->m_pIArcToolboxFind)
        self->m_pIArcToolboxFind->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIArcToolboxFind_GetpUnk(PyIArcToolboxFindObject* self)
{
    if (!self->m_pIArcToolboxFind)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIArcToolboxFind->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IArcToolboxFind to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIArcToolboxFind_GetPointer(PyIArcToolboxFindObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIArcToolboxFind);
}

static PyObject*
PyIArcToolboxFind_GetIID(PyIArcToolboxFindObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "ca787e4d-17a0-11d4-a629-0008c711c8c1");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIArcToolboxFind_GetHR(PyIArcToolboxFindObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIArcToolboxFind_GetIgnoreFailures(PyIArcToolboxFindObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIArcToolboxFind_SetIgnoreFailures(PyIArcToolboxFindObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIArcToolboxFind_SupportsInterface(PyIArcToolboxFindObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIArcToolboxFind->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IArcToolboxFindMethod_get_ArcCommands(PyIArcToolboxFindObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bscommands;
    PyObject* pyvar_commands = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for commands

    // Call method on actual COM interface
    hr = self->m_pIArcToolboxFind->get_ArcCommands(&bscommands);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIArcToolboxFind->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IArcToolboxFind) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IArcToolboxFind.get_ArcCommands() returned %ld", (long)hr);
        goto iarctoolboxfind_get_arccommands_method_cleanup;
    }

    // Set up return values as needed
    pyvar_commands = PyUnicode_FromWideChar(bscommands,::SysStringLen(bscommands));
    ::SysFreeString(bscommands);
    
    if (PyErr_Occurred())
      goto iarctoolboxfind_get_arccommands_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_commands);
    goto iarctoolboxfind_get_arccommands_method_cleanup;

    iarctoolboxfind_get_arccommands_method_cleanup:
    self->m_HR = hr;
    if (pyvar_commands != Py_None)
        Py_XDECREF(pyvar_commands);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IArcToolboxFind.get_ArcCommands");
    return return_tuple;
}

static PyObject*
IArcToolboxFindMethod_get_Keywords(PyIArcToolboxFindObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsKeywords;
    PyObject* pyvar_Keywords = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Keywords

    // Call method on actual COM interface
    hr = self->m_pIArcToolboxFind->get_Keywords(&bsKeywords);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIArcToolboxFind->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IArcToolboxFind) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IArcToolboxFind.get_Keywords() returned %ld", (long)hr);
        goto iarctoolboxfind_get_keywords_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Keywords = PyUnicode_FromWideChar(bsKeywords,::SysStringLen(bsKeywords));
    ::SysFreeString(bsKeywords);
    
    if (PyErr_Occurred())
      goto iarctoolboxfind_get_keywords_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Keywords);
    goto iarctoolboxfind_get_keywords_method_cleanup;

    iarctoolboxfind_get_keywords_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Keywords != Py_None)
        Py_XDECREF(pyvar_Keywords);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IArcToolboxFind.get_Keywords");
    return return_tuple;
}


PyMethodDef PyIArcToolboxFindMethods[] = {
    {"supports", (PyCFunction)PyIArcToolboxFind_SupportsInterface, METH_O, ""},
    {"get_ArcCommands", (PyCFunction)IArcToolboxFindMethod_get_ArcCommands, METH_VARARGS, ""},
    {"get_Keywords", (PyCFunction)IArcToolboxFindMethod_get_Keywords, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIArcToolboxFindGetSet[] = {
  {"_pUnk", (getter)PyIArcToolboxFind_GetpUnk, NULL, "Get opaque pointer to an Unknown from IArcToolboxFind", NULL},
  {"_pointer", (getter)PyIArcToolboxFind_GetPointer, NULL, "Get memory address for IArcToolboxFind", NULL},
  {"_IID", (getter)PyIArcToolboxFind_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIArcToolboxFind_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIArcToolboxFind_GetIgnoreFailures, (setter)PyIArcToolboxFind_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIArcToolboxFindObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriFramework.IArcToolboxFindObject",                          
                                              /* tp_name */
  sizeof(PyIArcToolboxFindObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIArcToolboxFindObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIArcToolboxFindMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIArcToolboxFindGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIArcToolboxFindObject_new,                      
                                              /* tp_new */
};

// Interface IApplicationStatusEvents

typedef struct PyIApplicationStatusEventsObject {
    PyObject_HEAD
    IApplicationStatusEvents* m_pIApplicationStatusEvents;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIApplicationStatusEventsObject;

static PyObject*
PyIApplicationStatusEventsObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIApplicationStatusEventsObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IApplicationStatusEvents* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IApplicationStatusEvents, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IApplicationStatusEvents with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIApplicationStatusEventsObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IApplicationStatusEvents");
            return NULL;
        }
        self->m_pIApplicationStatusEvents = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IApplicationStatusEvents");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IApplicationStatusEvents");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IApplicationStatusEvents* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IApplicationStatusEvents, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IApplicationStatusEvents");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIApplicationStatusEventsObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IApplicationStatusEvents");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIApplicationStatusEvents = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIApplicationStatusEventsObject_dealloc(PyIApplicationStatusEventsObject* self)
{
    if (self->m_pIApplicationStatusEvents)
        self->m_pIApplicationStatusEvents->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIApplicationStatusEvents_GetpUnk(PyIApplicationStatusEventsObject* self)
{
    if (!self->m_pIApplicationStatusEvents)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIApplicationStatusEvents->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IApplicationStatusEvents to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIApplicationStatusEvents_GetPointer(PyIApplicationStatusEventsObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIApplicationStatusEvents);
}

static PyObject*
PyIApplicationStatusEvents_GetIID(PyIApplicationStatusEventsObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "b93e627d-8506-4915-887d-b306b0482ba4");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIApplicationStatusEvents_GetHR(PyIApplicationStatusEventsObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIApplicationStatusEvents_GetIgnoreFailures(PyIApplicationStatusEventsObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIApplicationStatusEvents_SetIgnoreFailures(PyIApplicationStatusEventsObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIApplicationStatusEvents_SupportsInterface(PyIApplicationStatusEventsObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIApplicationStatusEvents->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IApplicationStatusEventsMethod_Initialized(PyIApplicationStatusEventsObject* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pIApplicationStatusEvents->Initialized();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIApplicationStatusEvents->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IApplicationStatusEvents) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IApplicationStatusEvents.Initialized() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}


PyMethodDef PyIApplicationStatusEventsMethods[] = {
    {"supports", (PyCFunction)PyIApplicationStatusEvents_SupportsInterface, METH_O, ""},
    {"Initialized", (PyCFunction)IApplicationStatusEventsMethod_Initialized, METH_NOARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIApplicationStatusEventsGetSet[] = {
  {"_pUnk", (getter)PyIApplicationStatusEvents_GetpUnk, NULL, "Get opaque pointer to an Unknown from IApplicationStatusEvents", NULL},
  {"_pointer", (getter)PyIApplicationStatusEvents_GetPointer, NULL, "Get memory address for IApplicationStatusEvents", NULL},
  {"_IID", (getter)PyIApplicationStatusEvents_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIApplicationStatusEvents_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIApplicationStatusEvents_GetIgnoreFailures, (setter)PyIApplicationStatusEvents_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIApplicationStatusEventsObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriFramework.IApplicationStatusEventsObject",                          
                                              /* tp_name */
  sizeof(PyIApplicationStatusEventsObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIApplicationStatusEventsObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIApplicationStatusEventsMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIApplicationStatusEventsGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIApplicationStatusEventsObject_new,                      
                                              /* tp_new */
};

// Interface IApplicationRefreshBitmap

typedef struct PyIApplicationRefreshBitmapObject {
    PyObject_HEAD
    IApplicationRefreshBitmap* m_pIApplicationRefreshBitmap;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIApplicationRefreshBitmapObject;

static PyObject*
PyIApplicationRefreshBitmapObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIApplicationRefreshBitmapObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IApplicationRefreshBitmap* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IApplicationRefreshBitmap, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IApplicationRefreshBitmap with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIApplicationRefreshBitmapObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IApplicationRefreshBitmap");
            return NULL;
        }
        self->m_pIApplicationRefreshBitmap = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IApplicationRefreshBitmap");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IApplicationRefreshBitmap");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IApplicationRefreshBitmap* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IApplicationRefreshBitmap, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IApplicationRefreshBitmap");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIApplicationRefreshBitmapObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IApplicationRefreshBitmap");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIApplicationRefreshBitmap = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIApplicationRefreshBitmapObject_dealloc(PyIApplicationRefreshBitmapObject* self)
{
    if (self->m_pIApplicationRefreshBitmap)
        self->m_pIApplicationRefreshBitmap->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIApplicationRefreshBitmap_GetpUnk(PyIApplicationRefreshBitmapObject* self)
{
    if (!self->m_pIApplicationRefreshBitmap)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIApplicationRefreshBitmap->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IApplicationRefreshBitmap to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIApplicationRefreshBitmap_GetPointer(PyIApplicationRefreshBitmapObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIApplicationRefreshBitmap);
}

static PyObject*
PyIApplicationRefreshBitmap_GetIID(PyIApplicationRefreshBitmapObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "eac93dbf-9e0f-4ad0-8106-3e32141c15ab");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIApplicationRefreshBitmap_GetHR(PyIApplicationRefreshBitmapObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIApplicationRefreshBitmap_GetIgnoreFailures(PyIApplicationRefreshBitmapObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIApplicationRefreshBitmap_SetIgnoreFailures(PyIApplicationRefreshBitmapObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIApplicationRefreshBitmap_SupportsInterface(PyIApplicationRefreshBitmapObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIApplicationRefreshBitmap->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IApplicationRefreshBitmapMethod_RefreshBitmap(PyIApplicationRefreshBitmapObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IUID* ipID = NULL;
    PyObject* py_ID;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_ID))
      goto iapplicationrefreshbitmap_refreshbitmap_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_ID, &IID_IUID, (void**)&ipID))
        PyErr_SetString(PyExc_TypeError, "Argument ID (position 0) is not IUID");
    
    if (PyErr_Occurred())
      goto iapplicationrefreshbitmap_refreshbitmap_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIApplicationRefreshBitmap->RefreshBitmap(ipID);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIApplicationRefreshBitmap->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IApplicationRefreshBitmap) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IApplicationRefreshBitmap.RefreshBitmap() returned %ld", (long)hr);
        goto iapplicationrefreshbitmap_refreshbitmap_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for ID

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iapplicationrefreshbitmap_refreshbitmap_method_cleanup;

    iapplicationrefreshbitmap_refreshbitmap_method_cleanup:
    self->m_HR = hr;
    if (ipID)
      ipID->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IApplicationRefreshBitmap.RefreshBitmap");
    return return_tuple;
}


PyMethodDef PyIApplicationRefreshBitmapMethods[] = {
    {"supports", (PyCFunction)PyIApplicationRefreshBitmap_SupportsInterface, METH_O, ""},
    {"RefreshBitmap", (PyCFunction)IApplicationRefreshBitmapMethod_RefreshBitmap, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIApplicationRefreshBitmapGetSet[] = {
  {"_pUnk", (getter)PyIApplicationRefreshBitmap_GetpUnk, NULL, "Get opaque pointer to an Unknown from IApplicationRefreshBitmap", NULL},
  {"_pointer", (getter)PyIApplicationRefreshBitmap_GetPointer, NULL, "Get memory address for IApplicationRefreshBitmap", NULL},
  {"_IID", (getter)PyIApplicationRefreshBitmap_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIApplicationRefreshBitmap_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIApplicationRefreshBitmap_GetIgnoreFailures, (setter)PyIApplicationRefreshBitmap_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIApplicationRefreshBitmapObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriFramework.IApplicationRefreshBitmapObject",                          
                                              /* tp_name */
  sizeof(PyIApplicationRefreshBitmapObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIApplicationRefreshBitmapObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIApplicationRefreshBitmapMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIApplicationRefreshBitmapGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIApplicationRefreshBitmapObject_new,                      
                                              /* tp_new */
};

// Interface IComPropertySheet2

typedef struct PyIComPropertySheet2Object {
    PyObject_HEAD
    IComPropertySheet2* m_pIComPropertySheet2;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIComPropertySheet2Object;

static PyObject*
PyIComPropertySheet2Object_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIComPropertySheet2Object* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IComPropertySheet2* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IComPropertySheet2, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IComPropertySheet2 with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIComPropertySheet2Object *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IComPropertySheet2");
            return NULL;
        }
        self->m_pIComPropertySheet2 = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IComPropertySheet2");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IComPropertySheet2");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IComPropertySheet2* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IComPropertySheet2, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IComPropertySheet2");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIComPropertySheet2Object *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IComPropertySheet2");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIComPropertySheet2 = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIComPropertySheet2Object_dealloc(PyIComPropertySheet2Object* self)
{
    if (self->m_pIComPropertySheet2)
        self->m_pIComPropertySheet2->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIComPropertySheet2_GetpUnk(PyIComPropertySheet2Object* self)
{
    if (!self->m_pIComPropertySheet2)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIComPropertySheet2->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IComPropertySheet2 to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIComPropertySheet2_GetPointer(PyIComPropertySheet2Object* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIComPropertySheet2);
}

static PyObject*
PyIComPropertySheet2_GetIID(PyIComPropertySheet2Object* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "c7fb79b7-41a6-4f58-b58b-c39fb83aaa0a");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIComPropertySheet2_GetHR(PyIComPropertySheet2Object* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIComPropertySheet2_GetIgnoreFailures(PyIComPropertySheet2Object* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIComPropertySheet2_SetIgnoreFailures(PyIComPropertySheet2Object* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIComPropertySheet2_SupportsInterface(PyIComPropertySheet2Object* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIComPropertySheet2->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IComPropertySheet2Method_put_ActivePageUID(PyIComPropertySheet2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IUID* ip_arg1 = NULL;
    PyObject* py__arg1;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py__arg1))
      goto icompropertysheet2_put_activepageuid_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py__arg1, &IID_IUID, (void**)&ip_arg1))
        PyErr_SetString(PyExc_TypeError, "Argument _arg1 (position 0) is not IUID");
    
    if (PyErr_Occurred())
      goto icompropertysheet2_put_activepageuid_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIComPropertySheet2->put_ActivePageUID(ip_arg1);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIComPropertySheet2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IComPropertySheet2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IComPropertySheet2.put_ActivePageUID() returned %ld", (long)hr);
        goto icompropertysheet2_put_activepageuid_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for _arg1

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icompropertysheet2_put_activepageuid_method_cleanup;

    icompropertysheet2_put_activepageuid_method_cleanup:
    self->m_HR = hr;
    if (ip_arg1)
      ip_arg1->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IComPropertySheet2.put_ActivePageUID");
    return return_tuple;
}

static PyObject*
IComPropertySheet2Method_GetActivePage(PyIComPropertySheet2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ISet* ippObjects = NULL;
    PyObject* py_pObjects;
    GUID gpGUID;
    PyObject* py_pGUID = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_pObjects))
      goto icompropertysheet2_getactivepage_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pObjects, &IID_ISet, (void**)&ippObjects))
        PyErr_SetString(PyExc_TypeError, "Argument pObjects (position 0) is not ISet");
    
    if (PyErr_Occurred())
      goto icompropertysheet2_getactivepage_method_cleanup;
    
    // No setup for pGUID

    // Call method on actual COM interface
    hr = self->m_pIComPropertySheet2->GetActivePage(ippObjects, &gpGUID);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIComPropertySheet2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IComPropertySheet2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IComPropertySheet2.GetActivePage() returned %ld", (long)hr);
        goto icompropertysheet2_getactivepage_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pObjects
    py_pGUID = GUIDToPythonUUID((const GUID*)&gpGUID);
    
    if (PyErr_Occurred())
      goto icompropertysheet2_getactivepage_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_pGUID);
    goto icompropertysheet2_getactivepage_method_cleanup;

    icompropertysheet2_getactivepage_method_cleanup:
    self->m_HR = hr;
    if (ippObjects)
      ippObjects->Release();
    Py_XDECREF(py_pGUID);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IComPropertySheet2.GetActivePage");
    return return_tuple;
}


PyMethodDef PyIComPropertySheet2Methods[] = {
    {"supports", (PyCFunction)PyIComPropertySheet2_SupportsInterface, METH_O, ""},
    {"put_ActivePageUID", (PyCFunction)IComPropertySheet2Method_put_ActivePageUID, METH_VARARGS, ""},
    {"GetActivePage", (PyCFunction)IComPropertySheet2Method_GetActivePage, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIComPropertySheet2GetSet[] = {
  {"_pUnk", (getter)PyIComPropertySheet2_GetpUnk, NULL, "Get opaque pointer to an Unknown from IComPropertySheet2", NULL},
  {"_pointer", (getter)PyIComPropertySheet2_GetPointer, NULL, "Get memory address for IComPropertySheet2", NULL},
  {"_IID", (getter)PyIComPropertySheet2_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIComPropertySheet2_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIComPropertySheet2_GetIgnoreFailures, (setter)PyIComPropertySheet2_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIComPropertySheet2Object_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriFramework.IComPropertySheet2Object",                          
                                              /* tp_name */
  sizeof(PyIComPropertySheet2Object),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIComPropertySheet2Object_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIComPropertySheet2Methods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIComPropertySheet2GetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIComPropertySheet2Object_new,                      
                                              /* tp_new */
};

// Interface IApplicationIdentifyDialog

typedef struct PyIApplicationIdentifyDialogObject {
    PyObject_HEAD
    IApplicationIdentifyDialog* m_pIApplicationIdentifyDialog;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIApplicationIdentifyDialogObject;

static PyObject*
PyIApplicationIdentifyDialogObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIApplicationIdentifyDialogObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IApplicationIdentifyDialog* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IApplicationIdentifyDialog, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IApplicationIdentifyDialog with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIApplicationIdentifyDialogObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IApplicationIdentifyDialog");
            return NULL;
        }
        self->m_pIApplicationIdentifyDialog = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IApplicationIdentifyDialog");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IApplicationIdentifyDialog");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IApplicationIdentifyDialog* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IApplicationIdentifyDialog, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IApplicationIdentifyDialog");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIApplicationIdentifyDialogObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IApplicationIdentifyDialog");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIApplicationIdentifyDialog = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIApplicationIdentifyDialogObject_dealloc(PyIApplicationIdentifyDialogObject* self)
{
    if (self->m_pIApplicationIdentifyDialog)
        self->m_pIApplicationIdentifyDialog->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIApplicationIdentifyDialog_GetpUnk(PyIApplicationIdentifyDialogObject* self)
{
    if (!self->m_pIApplicationIdentifyDialog)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIApplicationIdentifyDialog->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IApplicationIdentifyDialog to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIApplicationIdentifyDialog_GetPointer(PyIApplicationIdentifyDialogObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIApplicationIdentifyDialog);
}

static PyObject*
PyIApplicationIdentifyDialog_GetIID(PyIApplicationIdentifyDialogObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "b6165ddf-808e-11d4-80f3-00c04fa0adf8");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIApplicationIdentifyDialog_GetHR(PyIApplicationIdentifyDialogObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIApplicationIdentifyDialog_GetIgnoreFailures(PyIApplicationIdentifyDialogObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIApplicationIdentifyDialog_SetIgnoreFailures(PyIApplicationIdentifyDialogObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIApplicationIdentifyDialog_SupportsInterface(PyIApplicationIdentifyDialogObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIApplicationIdentifyDialog->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IApplicationIdentifyDialogMethod_GetClassID(PyIApplicationIdentifyDialogObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    GUID gclassID;
    PyObject* py_classID = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for classID

    // Call method on actual COM interface
    hr = self->m_pIApplicationIdentifyDialog->GetClassID(&gclassID);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIApplicationIdentifyDialog->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IApplicationIdentifyDialog) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IApplicationIdentifyDialog.GetClassID() returned %ld", (long)hr);
        goto iapplicationidentifydialog_getclassid_method_cleanup;
    }

    // Set up return values as needed
    py_classID = GUIDToPythonUUID((const GUID*)&gclassID);
    
    if (PyErr_Occurred())
      goto iapplicationidentifydialog_getclassid_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_classID);
    goto iapplicationidentifydialog_getclassid_method_cleanup;

    iapplicationidentifydialog_getclassid_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_classID);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IApplicationIdentifyDialog.GetClassID");
    return return_tuple;
}


PyMethodDef PyIApplicationIdentifyDialogMethods[] = {
    {"supports", (PyCFunction)PyIApplicationIdentifyDialog_SupportsInterface, METH_O, ""},
    {"GetClassID", (PyCFunction)IApplicationIdentifyDialogMethod_GetClassID, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIApplicationIdentifyDialogGetSet[] = {
  {"_pUnk", (getter)PyIApplicationIdentifyDialog_GetpUnk, NULL, "Get opaque pointer to an Unknown from IApplicationIdentifyDialog", NULL},
  {"_pointer", (getter)PyIApplicationIdentifyDialog_GetPointer, NULL, "Get memory address for IApplicationIdentifyDialog", NULL},
  {"_IID", (getter)PyIApplicationIdentifyDialog_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIApplicationIdentifyDialog_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIApplicationIdentifyDialog_GetIgnoreFailures, (setter)PyIApplicationIdentifyDialog_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIApplicationIdentifyDialogObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriFramework.IApplicationIdentifyDialogObject",                          
                                              /* tp_name */
  sizeof(PyIApplicationIdentifyDialogObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIApplicationIdentifyDialogObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIApplicationIdentifyDialogMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIApplicationIdentifyDialogGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIApplicationIdentifyDialogObject_new,                      
                                              /* tp_new */
};

// Interface IColorBrowser

typedef struct PyIColorBrowserObject {
    PyObject_HEAD
    IColorBrowser* m_pIColorBrowser;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIColorBrowserObject;

static PyObject*
PyIColorBrowserObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIColorBrowserObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IColorBrowser* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IColorBrowser, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IColorBrowser with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIColorBrowserObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IColorBrowser");
            return NULL;
        }
        self->m_pIColorBrowser = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IColorBrowser");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IColorBrowser");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IColorBrowser* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IColorBrowser, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IColorBrowser");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIColorBrowserObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IColorBrowser");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIColorBrowser = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIColorBrowserObject_dealloc(PyIColorBrowserObject* self)
{
    if (self->m_pIColorBrowser)
        self->m_pIColorBrowser->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIColorBrowser_GetpUnk(PyIColorBrowserObject* self)
{
    if (!self->m_pIColorBrowser)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIColorBrowser->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IColorBrowser to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIColorBrowser_GetPointer(PyIColorBrowserObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIColorBrowser);
}

static PyObject*
PyIColorBrowser_GetIID(PyIColorBrowserObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "e82a1a9b-7b12-11d1-946c-080009eebecb");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIColorBrowser_GetHR(PyIColorBrowserObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIColorBrowser_GetIgnoreFailures(PyIColorBrowserObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIColorBrowser_SetIgnoreFailures(PyIColorBrowserObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIColorBrowser_SupportsInterface(PyIColorBrowserObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIColorBrowser->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IColorBrowserMethod_put_Color(PyIColorBrowserObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IColor* ipColor = NULL;
    PyObject* py_Color;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_Color))
      goto icolorbrowser_put_color_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_Color, &IID_IColor, (void**)&ipColor))
        PyErr_SetString(PyExc_TypeError, "Argument Color (position 0) is not IColor");
    
    if (PyErr_Occurred())
      goto icolorbrowser_put_color_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIColorBrowser->put_Color(ipColor);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIColorBrowser->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IColorBrowser) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IColorBrowser.put_Color() returned %ld", (long)hr);
        goto icolorbrowser_put_color_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Color

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icolorbrowser_put_color_method_cleanup;

    icolorbrowser_put_color_method_cleanup:
    self->m_HR = hr;
    if (ipColor)
      ipColor->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IColorBrowser.put_Color");
    return return_tuple;
}

static PyObject*
IColorBrowserMethod_get_Color(PyIColorBrowserObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IColor* ipColor = NULL;
    PyObject* py_Color = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Color

    // Call method on actual COM interface
    hr = self->m_pIColorBrowser->get_Color(&ipColor);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIColorBrowser->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IColorBrowser) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IColorBrowser.get_Color() returned %ld", (long)hr);
        goto icolorbrowser_get_color_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_Color);
    if (ipColor)
    {
        IUnknown* pUnk = NULL;
        ipColor->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_Color = IUnknownToPythonIIDObject(pUnk, &IID_IColor);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_Color)
    {
        if (py_Color)
           Py_DECREF(py_Color);
        py_Color = Py_None;
        Py_INCREF(py_Color);
    }
    if (PyErr_Occurred())
      goto icolorbrowser_get_color_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_Color);
    goto icolorbrowser_get_color_method_cleanup;

    icolorbrowser_get_color_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_Color);
    if (ipColor)
      ipColor->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IColorBrowser.get_Color");
    return return_tuple;
}

static PyObject*
IColorBrowserMethod_DoModal(PyIColorBrowserObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    OLE_HANDLE HhWnd = 0;
    VARIANT_BOOL b_ok = VARIANT_FALSE;
    PyObject* pyvar_ok = Py_False;

    // Unpack values
    if (!PyArg_ParseTuple(args, "I", &HhWnd))
      goto icolorbrowser_domodal_method_cleanup;

    // Set up initial variable values as needed
    // No setup for hWnd
    // No setup for ok

    // Call method on actual COM interface
    hr = self->m_pIColorBrowser->DoModal(HhWnd, &b_ok);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIColorBrowser->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IColorBrowser) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IColorBrowser.DoModal() returned %ld", (long)hr);
        goto icolorbrowser_domodal_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for hWnd
    pyvar_ok = ((b_ok == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto icolorbrowser_domodal_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_ok);
    goto icolorbrowser_domodal_method_cleanup;

    icolorbrowser_domodal_method_cleanup:
    self->m_HR = hr;
    // No cleanup for hWnd
    // No cleanup for ok
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IColorBrowser.DoModal");
    return return_tuple;
}


PyMethodDef PyIColorBrowserMethods[] = {
    {"supports", (PyCFunction)PyIColorBrowser_SupportsInterface, METH_O, ""},
    {"put_Color", (PyCFunction)IColorBrowserMethod_put_Color, METH_VARARGS, ""},
    {"get_Color", (PyCFunction)IColorBrowserMethod_get_Color, METH_VARARGS, ""},
    {"DoModal", (PyCFunction)IColorBrowserMethod_DoModal, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIColorBrowserGetSet[] = {
  {"_pUnk", (getter)PyIColorBrowser_GetpUnk, NULL, "Get opaque pointer to an Unknown from IColorBrowser", NULL},
  {"_pointer", (getter)PyIColorBrowser_GetPointer, NULL, "Get memory address for IColorBrowser", NULL},
  {"_IID", (getter)PyIColorBrowser_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIColorBrowser_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIColorBrowser_GetIgnoreFailures, (setter)PyIColorBrowser_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIColorBrowserObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriFramework.IColorBrowserObject",                          
                                              /* tp_name */
  sizeof(PyIColorBrowserObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIColorBrowserObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIColorBrowserMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIColorBrowserGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIColorBrowserObject_new,                      
                                              /* tp_new */
};

// Interface IColorSelector

typedef struct PyIColorSelectorObject {
    PyObject_HEAD
    IColorSelector* m_pIColorSelector;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIColorSelectorObject;

static PyObject*
PyIColorSelectorObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIColorSelectorObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IColorSelector* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IColorSelector, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IColorSelector with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIColorSelectorObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IColorSelector");
            return NULL;
        }
        self->m_pIColorSelector = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IColorSelector");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IColorSelector");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IColorSelector* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IColorSelector, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IColorSelector");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIColorSelectorObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IColorSelector");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIColorSelector = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIColorSelectorObject_dealloc(PyIColorSelectorObject* self)
{
    if (self->m_pIColorSelector)
        self->m_pIColorSelector->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIColorSelector_GetpUnk(PyIColorSelectorObject* self)
{
    if (!self->m_pIColorSelector)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIColorSelector->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IColorSelector to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIColorSelector_GetPointer(PyIColorSelectorObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIColorSelector);
}

static PyObject*
PyIColorSelector_GetIID(PyIColorSelectorObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "569c3921-01ba-11d3-9f38-00c04f6bc709");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIColorSelector_GetHR(PyIColorSelectorObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIColorSelector_GetIgnoreFailures(PyIColorSelectorObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIColorSelector_SetIgnoreFailures(PyIColorSelectorObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIColorSelector_SupportsInterface(PyIColorSelectorObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIColorSelector->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IColorSelectorMethod_InitPopupPosition(PyIColorSelectorObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lparentLeft = 0;
    long lparentTop = 0;
    long lparentRight = 0;
    long lparentBottom = 0;
    VARIANT_BOOL b_aboveParent = VARIANT_FALSE;
    PyObject* pyvar_aboveParent = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "llllO", &lparentLeft, &lparentTop, &lparentRight, &lparentBottom, &pyvar_aboveParent))
      goto icolorselector_initpopupposition_method_cleanup;

    // Set up initial variable values as needed
    // No setup for parentLeft
    // No setup for parentTop
    // No setup for parentRight
    // No setup for parentBottom
    b_aboveParent = ((PyObject_IsTrue(pyvar_aboveParent) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto icolorselector_initpopupposition_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIColorSelector->InitPopupPosition(lparentLeft, lparentTop, lparentRight, lparentBottom, b_aboveParent);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIColorSelector->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IColorSelector) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IColorSelector.InitPopupPosition() returned %ld", (long)hr);
        goto icolorselector_initpopupposition_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for parentLeft
    // No teardown for parentTop
    // No teardown for parentRight
    // No teardown for parentBottom
    // No teardown for aboveParent

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icolorselector_initpopupposition_method_cleanup;

    icolorselector_initpopupposition_method_cleanup:
    self->m_HR = hr;
    // No cleanup for parentLeft
    // No cleanup for parentTop
    // No cleanup for parentRight
    // No cleanup for parentBottom
    // No cleanup for aboveParent
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IColorSelector.InitPopupPosition");
    return return_tuple;
}

static PyObject*
IColorSelectorMethod_put_Color(PyIColorSelectorObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IColor* ipColor = NULL;
    PyObject* py_Color;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_Color))
      goto icolorselector_put_color_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_Color, &IID_IColor, (void**)&ipColor))
        PyErr_SetString(PyExc_TypeError, "Argument Color (position 0) is not IColor");
    
    if (PyErr_Occurred())
      goto icolorselector_put_color_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIColorSelector->put_Color(ipColor);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIColorSelector->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IColorSelector) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IColorSelector.put_Color() returned %ld", (long)hr);
        goto icolorselector_put_color_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Color

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icolorselector_put_color_method_cleanup;

    icolorselector_put_color_method_cleanup:
    self->m_HR = hr;
    if (ipColor)
      ipColor->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IColorSelector.put_Color");
    return return_tuple;
}

static PyObject*
IColorSelectorMethod_get_Color(PyIColorSelectorObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IColor* ipColor = NULL;
    PyObject* py_Color = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Color

    // Call method on actual COM interface
    hr = self->m_pIColorSelector->get_Color(&ipColor);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIColorSelector->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IColorSelector) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IColorSelector.get_Color() returned %ld", (long)hr);
        goto icolorselector_get_color_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_Color);
    if (ipColor)
    {
        IUnknown* pUnk = NULL;
        ipColor->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_Color = IUnknownToPythonIIDObject(pUnk, &IID_IColor);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_Color)
    {
        if (py_Color)
           Py_DECREF(py_Color);
        py_Color = Py_None;
        Py_INCREF(py_Color);
    }
    if (PyErr_Occurred())
      goto icolorselector_get_color_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_Color);
    goto icolorselector_get_color_method_cleanup;

    icolorselector_get_color_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_Color);
    if (ipColor)
      ipColor->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IColorSelector.get_Color");
    return return_tuple;
}

static PyObject*
IColorSelectorMethod_DoModal(PyIColorSelectorObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    OLE_HANDLE HhWnd = 0;
    VARIANT_BOOL b_ok = VARIANT_FALSE;
    PyObject* pyvar_ok = Py_False;

    // Unpack values
    if (!PyArg_ParseTuple(args, "I", &HhWnd))
      goto icolorselector_domodal_method_cleanup;

    // Set up initial variable values as needed
    // No setup for hWnd
    // No setup for ok

    // Call method on actual COM interface
    hr = self->m_pIColorSelector->DoModal(HhWnd, &b_ok);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIColorSelector->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IColorSelector) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IColorSelector.DoModal() returned %ld", (long)hr);
        goto icolorselector_domodal_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for hWnd
    pyvar_ok = ((b_ok == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto icolorselector_domodal_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_ok);
    goto icolorselector_domodal_method_cleanup;

    icolorselector_domodal_method_cleanup:
    self->m_HR = hr;
    // No cleanup for hWnd
    // No cleanup for ok
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IColorSelector.DoModal");
    return return_tuple;
}


PyMethodDef PyIColorSelectorMethods[] = {
    {"supports", (PyCFunction)PyIColorSelector_SupportsInterface, METH_O, ""},
    {"InitPopupPosition", (PyCFunction)IColorSelectorMethod_InitPopupPosition, METH_VARARGS, ""},
    {"put_Color", (PyCFunction)IColorSelectorMethod_put_Color, METH_VARARGS, ""},
    {"get_Color", (PyCFunction)IColorSelectorMethod_get_Color, METH_VARARGS, ""},
    {"DoModal", (PyCFunction)IColorSelectorMethod_DoModal, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIColorSelectorGetSet[] = {
  {"_pUnk", (getter)PyIColorSelector_GetpUnk, NULL, "Get opaque pointer to an Unknown from IColorSelector", NULL},
  {"_pointer", (getter)PyIColorSelector_GetPointer, NULL, "Get memory address for IColorSelector", NULL},
  {"_IID", (getter)PyIColorSelector_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIColorSelector_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIColorSelector_GetIgnoreFailures, (setter)PyIColorSelector_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIColorSelectorObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriFramework.IColorSelectorObject",                          
                                              /* tp_name */
  sizeof(PyIColorSelectorObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIColorSelectorObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIColorSelectorMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIColorSelectorGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIColorSelectorObject_new,                      
                                              /* tp_new */
};

// Interface ICustomColorPalette

typedef struct PyICustomColorPaletteObject {
    PyObject_HEAD
    ICustomColorPalette* m_pICustomColorPalette;
    HRESULT m_HR;
    int m_ignore_failures;
} PyICustomColorPaletteObject;

static PyObject*
PyICustomColorPaletteObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyICustomColorPaletteObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ICustomColorPalette* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ICustomColorPalette, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ICustomColorPalette with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyICustomColorPaletteObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ICustomColorPalette");
            return NULL;
        }
        self->m_pICustomColorPalette = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ICustomColorPalette");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ICustomColorPalette");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ICustomColorPalette* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ICustomColorPalette, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ICustomColorPalette");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyICustomColorPaletteObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ICustomColorPalette");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pICustomColorPalette = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyICustomColorPaletteObject_dealloc(PyICustomColorPaletteObject* self)
{
    if (self->m_pICustomColorPalette)
        self->m_pICustomColorPalette->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyICustomColorPalette_GetpUnk(PyICustomColorPaletteObject* self)
{
    if (!self->m_pICustomColorPalette)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pICustomColorPalette->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ICustomColorPalette to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyICustomColorPalette_GetPointer(PyICustomColorPaletteObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pICustomColorPalette);
}

static PyObject*
PyICustomColorPalette_GetIID(PyICustomColorPaletteObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "7f579088-5407-42f1-bd80-548e7f3c1e6e");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyICustomColorPalette_GetHR(PyICustomColorPaletteObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyICustomColorPalette_GetIgnoreFailures(PyICustomColorPaletteObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyICustomColorPalette_SetIgnoreFailures(PyICustomColorPaletteObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyICustomColorPalette_SupportsInterface(PyICustomColorPaletteObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pICustomColorPalette->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ICustomColorPaletteMethod_putref_ColorSet(PyICustomColorPaletteObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ISet* ip_arg1 = NULL;
    PyObject* py__arg1;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py__arg1))
      goto icustomcolorpalette_putref_colorset_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py__arg1, &IID_ISet, (void**)&ip_arg1))
        PyErr_SetString(PyExc_TypeError, "Argument _arg1 (position 0) is not ISet");
    
    if (PyErr_Occurred())
      goto icustomcolorpalette_putref_colorset_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pICustomColorPalette->putref_ColorSet(ip_arg1);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICustomColorPalette->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICustomColorPalette) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICustomColorPalette.putref_ColorSet() returned %ld", (long)hr);
        goto icustomcolorpalette_putref_colorset_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for _arg1

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icustomcolorpalette_putref_colorset_method_cleanup;

    icustomcolorpalette_putref_colorset_method_cleanup:
    self->m_HR = hr;
    if (ip_arg1)
      ip_arg1->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICustomColorPalette.putref_ColorSet");
    return return_tuple;
}


PyMethodDef PyICustomColorPaletteMethods[] = {
    {"supports", (PyCFunction)PyICustomColorPalette_SupportsInterface, METH_O, ""},
    {"putref_ColorSet", (PyCFunction)ICustomColorPaletteMethod_putref_ColorSet, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyICustomColorPaletteGetSet[] = {
  {"_pUnk", (getter)PyICustomColorPalette_GetpUnk, NULL, "Get opaque pointer to an Unknown from ICustomColorPalette", NULL},
  {"_pointer", (getter)PyICustomColorPalette_GetPointer, NULL, "Get memory address for ICustomColorPalette", NULL},
  {"_IID", (getter)PyICustomColorPalette_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyICustomColorPalette_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyICustomColorPalette_GetIgnoreFailures, (setter)PyICustomColorPalette_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyICustomColorPaletteObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriFramework.ICustomColorPaletteObject",                          
                                              /* tp_name */
  sizeof(PyICustomColorPaletteObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyICustomColorPaletteObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyICustomColorPaletteMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyICustomColorPaletteGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyICustomColorPaletteObject_new,                      
                                              /* tp_new */
};

// Interface IComPropertyPageSite

typedef struct PyIComPropertyPageSiteObject {
    PyObject_HEAD
    IComPropertyPageSite* m_pIComPropertyPageSite;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIComPropertyPageSiteObject;

static PyObject*
PyIComPropertyPageSiteObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIComPropertyPageSiteObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IComPropertyPageSite* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IComPropertyPageSite, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IComPropertyPageSite with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIComPropertyPageSiteObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IComPropertyPageSite");
            return NULL;
        }
        self->m_pIComPropertyPageSite = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IComPropertyPageSite");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IComPropertyPageSite");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IComPropertyPageSite* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IComPropertyPageSite, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IComPropertyPageSite");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIComPropertyPageSiteObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IComPropertyPageSite");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIComPropertyPageSite = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIComPropertyPageSiteObject_dealloc(PyIComPropertyPageSiteObject* self)
{
    if (self->m_pIComPropertyPageSite)
        self->m_pIComPropertyPageSite->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIComPropertyPageSite_GetpUnk(PyIComPropertyPageSiteObject* self)
{
    if (!self->m_pIComPropertyPageSite)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIComPropertyPageSite->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IComPropertyPageSite to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIComPropertyPageSite_GetPointer(PyIComPropertyPageSiteObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIComPropertyPageSite);
}

static PyObject*
PyIComPropertyPageSite_GetIID(PyIComPropertyPageSiteObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "3b81f6f1-54a0-11d3-b8c3-00600802e603");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIComPropertyPageSite_GetHR(PyIComPropertyPageSiteObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIComPropertyPageSite_GetIgnoreFailures(PyIComPropertyPageSiteObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIComPropertyPageSite_SetIgnoreFailures(PyIComPropertyPageSiteObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIComPropertyPageSite_SupportsInterface(PyIComPropertyPageSiteObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIComPropertyPageSite->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IComPropertyPageSiteMethod_PageChanged(PyIComPropertyPageSiteObject* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pIComPropertyPageSite->PageChanged();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIComPropertyPageSite->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IComPropertyPageSite) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IComPropertyPageSite.PageChanged() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}


PyMethodDef PyIComPropertyPageSiteMethods[] = {
    {"supports", (PyCFunction)PyIComPropertyPageSite_SupportsInterface, METH_O, ""},
    {"PageChanged", (PyCFunction)IComPropertyPageSiteMethod_PageChanged, METH_NOARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIComPropertyPageSiteGetSet[] = {
  {"_pUnk", (getter)PyIComPropertyPageSite_GetpUnk, NULL, "Get opaque pointer to an Unknown from IComPropertyPageSite", NULL},
  {"_pointer", (getter)PyIComPropertyPageSite_GetPointer, NULL, "Get memory address for IComPropertyPageSite", NULL},
  {"_IID", (getter)PyIComPropertyPageSite_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIComPropertyPageSite_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIComPropertyPageSite_GetIgnoreFailures, (setter)PyIComPropertyPageSite_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIComPropertyPageSiteObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriFramework.IComPropertyPageSiteObject",                          
                                              /* tp_name */
  sizeof(PyIComPropertyPageSiteObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIComPropertyPageSiteObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIComPropertyPageSiteMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIComPropertyPageSiteGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIComPropertyPageSiteObject_new,                      
                                              /* tp_new */
};

// Interface IComPropertyPage

typedef struct PyIComPropertyPageObject {
    PyObject_HEAD
    IComPropertyPage* m_pIComPropertyPage;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIComPropertyPageObject;

static PyObject*
PyIComPropertyPageObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIComPropertyPageObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IComPropertyPage* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IComPropertyPage, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IComPropertyPage with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIComPropertyPageObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IComPropertyPage");
            return NULL;
        }
        self->m_pIComPropertyPage = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IComPropertyPage");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IComPropertyPage");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IComPropertyPage* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IComPropertyPage, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IComPropertyPage");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIComPropertyPageObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IComPropertyPage");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIComPropertyPage = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIComPropertyPageObject_dealloc(PyIComPropertyPageObject* self)
{
    if (self->m_pIComPropertyPage)
        self->m_pIComPropertyPage->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIComPropertyPage_GetpUnk(PyIComPropertyPageObject* self)
{
    if (!self->m_pIComPropertyPage)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIComPropertyPage->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IComPropertyPage to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIComPropertyPage_GetPointer(PyIComPropertyPageObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIComPropertyPage);
}

static PyObject*
PyIComPropertyPage_GetIID(PyIComPropertyPageObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "76951cc6-dbb1-11d2-b868-00600802e603");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIComPropertyPage_GetHR(PyIComPropertyPageObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIComPropertyPage_GetIgnoreFailures(PyIComPropertyPageObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIComPropertyPage_SetIgnoreFailures(PyIComPropertyPageObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIComPropertyPage_SupportsInterface(PyIComPropertyPageObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIComPropertyPage->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IComPropertyPageMethod_put_Title(PyIComPropertyPageObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsTitle = 0;
    PyObject* pyvar_Title;
    PyObject* unicodeTitle = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_Title))
      goto icompropertypage_put_title_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_Title))
        unicodeTitle = PyUnicode_FromObject(pyvar_Title);
    else if (PyUnicode_Check(pyvar_Title))
    {
        unicodeTitle = pyvar_Title;
        Py_INCREF(unicodeTitle);
    }
    else if (pyvar_Title != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Title at index 0");
    if (unicodeTitle)
        bsTitle = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeTitle), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeTitle));
    
    if (PyErr_Occurred())
      goto icompropertypage_put_title_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIComPropertyPage->put_Title(bsTitle);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIComPropertyPage->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IComPropertyPage) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IComPropertyPage.put_Title() returned %ld", (long)hr);
        goto icompropertypage_put_title_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Title

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icompropertypage_put_title_method_cleanup;

    icompropertypage_put_title_method_cleanup:
    self->m_HR = hr;
    if (bsTitle)
        ::SysFreeString(bsTitle);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IComPropertyPage.put_Title");
    return return_tuple;
}

static PyObject*
IComPropertyPageMethod_get_Title(PyIComPropertyPageObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsTitle;
    PyObject* pyvar_Title = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Title

    // Call method on actual COM interface
    hr = self->m_pIComPropertyPage->get_Title(&bsTitle);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIComPropertyPage->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IComPropertyPage) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IComPropertyPage.get_Title() returned %ld", (long)hr);
        goto icompropertypage_get_title_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Title = PyUnicode_FromWideChar(bsTitle,::SysStringLen(bsTitle));
    ::SysFreeString(bsTitle);
    
    if (PyErr_Occurred())
      goto icompropertypage_get_title_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Title);
    goto icompropertypage_get_title_method_cleanup;

    icompropertypage_get_title_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Title != Py_None)
        Py_XDECREF(pyvar_Title);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IComPropertyPage.get_Title");
    return return_tuple;
}

static PyObject*
IComPropertyPageMethod_put_Priority(PyIComPropertyPageObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lPriority = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lPriority))
      goto icompropertypage_put_priority_method_cleanup;

    // Set up initial variable values as needed
    // No setup for Priority

    // Call method on actual COM interface
    hr = self->m_pIComPropertyPage->put_Priority(lPriority);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIComPropertyPage->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IComPropertyPage) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IComPropertyPage.put_Priority() returned %ld", (long)hr);
        goto icompropertypage_put_priority_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Priority

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icompropertypage_put_priority_method_cleanup;

    icompropertypage_put_priority_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Priority
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IComPropertyPage.put_Priority");
    return return_tuple;
}

static PyObject*
IComPropertyPageMethod_get_Priority(PyIComPropertyPageObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lPriority = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Priority

    // Call method on actual COM interface
    hr = self->m_pIComPropertyPage->get_Priority(&lPriority);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIComPropertyPage->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IComPropertyPage) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IComPropertyPage.get_Priority() returned %ld", (long)hr);
        goto icompropertypage_get_priority_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Priority

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lPriority);
    goto icompropertypage_get_priority_method_cleanup;

    icompropertypage_get_priority_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Priority
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IComPropertyPage.get_Priority");
    return return_tuple;
}

static PyObject*
IComPropertyPageMethod_get_Width(PyIComPropertyPageObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lWidth = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Width

    // Call method on actual COM interface
    hr = self->m_pIComPropertyPage->get_Width(&lWidth);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIComPropertyPage->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IComPropertyPage) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IComPropertyPage.get_Width() returned %ld", (long)hr);
        goto icompropertypage_get_width_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Width

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lWidth);
    goto icompropertypage_get_width_method_cleanup;

    icompropertypage_get_width_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Width
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IComPropertyPage.get_Width");
    return return_tuple;
}

static PyObject*
IComPropertyPageMethod_get_Height(PyIComPropertyPageObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lHeight = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Height

    // Call method on actual COM interface
    hr = self->m_pIComPropertyPage->get_Height(&lHeight);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIComPropertyPage->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IComPropertyPage) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IComPropertyPage.get_Height() returned %ld", (long)hr);
        goto icompropertypage_get_height_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Height

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lHeight);
    goto icompropertypage_get_height_method_cleanup;

    icompropertypage_get_height_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Height
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IComPropertyPage.get_Height");
    return return_tuple;
}

static PyObject*
IComPropertyPageMethod_putref_PageSite(PyIComPropertyPageObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IComPropertyPageSite* ip_arg1 = NULL;
    PyObject* py__arg1;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py__arg1))
      goto icompropertypage_putref_pagesite_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py__arg1, &IID_IComPropertyPageSite, (void**)&ip_arg1))
        PyErr_SetString(PyExc_TypeError, "Argument _arg1 (position 0) is not IComPropertyPageSite");
    
    if (PyErr_Occurred())
      goto icompropertypage_putref_pagesite_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIComPropertyPage->putref_PageSite(ip_arg1);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIComPropertyPage->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IComPropertyPage) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IComPropertyPage.putref_PageSite() returned %ld", (long)hr);
        goto icompropertypage_putref_pagesite_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for _arg1

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icompropertypage_putref_pagesite_method_cleanup;

    icompropertypage_putref_pagesite_method_cleanup:
    self->m_HR = hr;
    if (ip_arg1)
      ip_arg1->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IComPropertyPage.putref_PageSite");
    return return_tuple;
}

static PyObject*
IComPropertyPageMethod_get_IsPageDirty(PyIComPropertyPageObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_isDirty = VARIANT_FALSE;
    PyObject* pyvar_isDirty = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for isDirty

    // Call method on actual COM interface
    hr = self->m_pIComPropertyPage->get_IsPageDirty(&b_isDirty);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIComPropertyPage->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IComPropertyPage) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IComPropertyPage.get_IsPageDirty() returned %ld", (long)hr);
        goto icompropertypage_get_ispagedirty_method_cleanup;
    }

    // Set up return values as needed
    pyvar_isDirty = ((b_isDirty == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto icompropertypage_get_ispagedirty_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_isDirty);
    goto icompropertypage_get_ispagedirty_method_cleanup;

    icompropertypage_get_ispagedirty_method_cleanup:
    self->m_HR = hr;
    // No cleanup for isDirty
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IComPropertyPage.get_IsPageDirty");
    return return_tuple;
}

static PyObject*
IComPropertyPageMethod_get_HelpFile(PyIComPropertyPageObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsHelpFile;
    PyObject* pyvar_HelpFile = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for HelpFile

    // Call method on actual COM interface
    hr = self->m_pIComPropertyPage->get_HelpFile(&bsHelpFile);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIComPropertyPage->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IComPropertyPage) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IComPropertyPage.get_HelpFile() returned %ld", (long)hr);
        goto icompropertypage_get_helpfile_method_cleanup;
    }

    // Set up return values as needed
    pyvar_HelpFile = PyUnicode_FromWideChar(bsHelpFile,::SysStringLen(bsHelpFile));
    ::SysFreeString(bsHelpFile);
    
    if (PyErr_Occurred())
      goto icompropertypage_get_helpfile_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_HelpFile);
    goto icompropertypage_get_helpfile_method_cleanup;

    icompropertypage_get_helpfile_method_cleanup:
    self->m_HR = hr;
    if (pyvar_HelpFile != Py_None)
        Py_XDECREF(pyvar_HelpFile);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IComPropertyPage.get_HelpFile");
    return return_tuple;
}

static PyObject*
IComPropertyPageMethod_get_HelpContextID(PyIComPropertyPageObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lcontrolID = 0;
    long lhelpID = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lcontrolID))
      goto icompropertypage_get_helpcontextid_method_cleanup;

    // Set up initial variable values as needed
    // No setup for controlID
    // No setup for helpID

    // Call method on actual COM interface
    hr = self->m_pIComPropertyPage->get_HelpContextID(lcontrolID, &lhelpID);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIComPropertyPage->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IComPropertyPage) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IComPropertyPage.get_HelpContextID() returned %ld", (long)hr);
        goto icompropertypage_get_helpcontextid_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for controlID
    // No teardown for helpID

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lhelpID);
    goto icompropertypage_get_helpcontextid_method_cleanup;

    icompropertypage_get_helpcontextid_method_cleanup:
    self->m_HR = hr;
    // No cleanup for controlID
    // No cleanup for helpID
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IComPropertyPage.get_HelpContextID");
    return return_tuple;
}

static PyObject*
IComPropertyPageMethod_Activate(PyIComPropertyPageObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    OLE_HANDLE HhWnd = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for hWnd

    // Call method on actual COM interface
    hr = self->m_pIComPropertyPage->Activate(&HhWnd);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIComPropertyPage->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IComPropertyPage) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IComPropertyPage.Activate() returned %ld", (long)hr);
        goto icompropertypage_activate_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for hWnd

    // Initialize output tuple
    return_tuple = Py_BuildValue("I",
                                            HhWnd);
    goto icompropertypage_activate_method_cleanup;

    icompropertypage_activate_method_cleanup:
    self->m_HR = hr;
    // No cleanup for hWnd
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IComPropertyPage.Activate");
    return return_tuple;
}

static PyObject*
IComPropertyPageMethod_Deactivate(PyIComPropertyPageObject* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pIComPropertyPage->Deactivate();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIComPropertyPage->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IComPropertyPage) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IComPropertyPage.Deactivate() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}

static PyObject*
IComPropertyPageMethod_Applies(PyIComPropertyPageObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ISet* ipobjects = NULL;
    PyObject* py_objects;
    VARIANT_BOOL b_pApplies = VARIANT_FALSE;
    PyObject* pyvar_pApplies = Py_False;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_objects))
      goto icompropertypage_applies_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_objects, &IID_ISet, (void**)&ipobjects))
        PyErr_SetString(PyExc_TypeError, "Argument objects (position 0) is not ISet");
    
    if (PyErr_Occurred())
      goto icompropertypage_applies_method_cleanup;
    
    // No setup for pApplies

    // Call method on actual COM interface
    hr = self->m_pIComPropertyPage->Applies(ipobjects, &b_pApplies);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIComPropertyPage->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IComPropertyPage) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IComPropertyPage.Applies() returned %ld", (long)hr);
        goto icompropertypage_applies_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for objects
    pyvar_pApplies = ((b_pApplies == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto icompropertypage_applies_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pApplies);
    goto icompropertypage_applies_method_cleanup;

    icompropertypage_applies_method_cleanup:
    self->m_HR = hr;
    if (ipobjects)
      ipobjects->Release();
    // No cleanup for pApplies
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IComPropertyPage.Applies");
    return return_tuple;
}

static PyObject*
IComPropertyPageMethod_SetObjects(PyIComPropertyPageObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ISet* ipobjects = NULL;
    PyObject* py_objects;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_objects))
      goto icompropertypage_setobjects_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_objects, &IID_ISet, (void**)&ipobjects))
        PyErr_SetString(PyExc_TypeError, "Argument objects (position 0) is not ISet");
    
    if (PyErr_Occurred())
      goto icompropertypage_setobjects_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIComPropertyPage->SetObjects(ipobjects);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIComPropertyPage->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IComPropertyPage) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IComPropertyPage.SetObjects() returned %ld", (long)hr);
        goto icompropertypage_setobjects_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for objects

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icompropertypage_setobjects_method_cleanup;

    icompropertypage_setobjects_method_cleanup:
    self->m_HR = hr;
    if (ipobjects)
      ipobjects->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IComPropertyPage.SetObjects");
    return return_tuple;
}

static PyObject*
IComPropertyPageMethod_Show(PyIComPropertyPageObject* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pIComPropertyPage->Show();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIComPropertyPage->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IComPropertyPage) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IComPropertyPage.Show() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}

static PyObject*
IComPropertyPageMethod_Hide(PyIComPropertyPageObject* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pIComPropertyPage->Hide();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIComPropertyPage->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IComPropertyPage) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IComPropertyPage.Hide() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}

static PyObject*
IComPropertyPageMethod_Apply(PyIComPropertyPageObject* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pIComPropertyPage->Apply();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIComPropertyPage->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IComPropertyPage) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IComPropertyPage.Apply() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}

static PyObject*
IComPropertyPageMethod_Cancel(PyIComPropertyPageObject* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pIComPropertyPage->Cancel();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIComPropertyPage->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IComPropertyPage) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IComPropertyPage.Cancel() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}


PyMethodDef PyIComPropertyPageMethods[] = {
    {"supports", (PyCFunction)PyIComPropertyPage_SupportsInterface, METH_O, ""},
    {"put_Title", (PyCFunction)IComPropertyPageMethod_put_Title, METH_VARARGS, ""},
    {"get_Title", (PyCFunction)IComPropertyPageMethod_get_Title, METH_VARARGS, ""},
    {"put_Priority", (PyCFunction)IComPropertyPageMethod_put_Priority, METH_VARARGS, ""},
    {"get_Priority", (PyCFunction)IComPropertyPageMethod_get_Priority, METH_VARARGS, ""},
    {"get_Width", (PyCFunction)IComPropertyPageMethod_get_Width, METH_VARARGS, ""},
    {"get_Height", (PyCFunction)IComPropertyPageMethod_get_Height, METH_VARARGS, ""},
    {"putref_PageSite", (PyCFunction)IComPropertyPageMethod_putref_PageSite, METH_VARARGS, ""},
    {"get_IsPageDirty", (PyCFunction)IComPropertyPageMethod_get_IsPageDirty, METH_VARARGS, ""},
    {"get_HelpFile", (PyCFunction)IComPropertyPageMethod_get_HelpFile, METH_VARARGS, ""},
    {"get_HelpContextID", (PyCFunction)IComPropertyPageMethod_get_HelpContextID, METH_VARARGS, ""},
    {"Activate", (PyCFunction)IComPropertyPageMethod_Activate, METH_VARARGS, ""},
    {"Deactivate", (PyCFunction)IComPropertyPageMethod_Deactivate, METH_NOARGS, ""},
    {"Applies", (PyCFunction)IComPropertyPageMethod_Applies, METH_VARARGS, ""},
    {"SetObjects", (PyCFunction)IComPropertyPageMethod_SetObjects, METH_VARARGS, ""},
    {"Show", (PyCFunction)IComPropertyPageMethod_Show, METH_NOARGS, ""},
    {"Hide", (PyCFunction)IComPropertyPageMethod_Hide, METH_NOARGS, ""},
    {"Apply", (PyCFunction)IComPropertyPageMethod_Apply, METH_NOARGS, ""},
    {"Cancel", (PyCFunction)IComPropertyPageMethod_Cancel, METH_NOARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIComPropertyPageGetSet[] = {
  {"_pUnk", (getter)PyIComPropertyPage_GetpUnk, NULL, "Get opaque pointer to an Unknown from IComPropertyPage", NULL},
  {"_pointer", (getter)PyIComPropertyPage_GetPointer, NULL, "Get memory address for IComPropertyPage", NULL},
  {"_IID", (getter)PyIComPropertyPage_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIComPropertyPage_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIComPropertyPage_GetIgnoreFailures, (setter)PyIComPropertyPage_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIComPropertyPageObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriFramework.IComPropertyPageObject",                          
                                              /* tp_name */
  sizeof(PyIComPropertyPageObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIComPropertyPageObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIComPropertyPageMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIComPropertyPageGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIComPropertyPageObject_new,                      
                                              /* tp_new */
};

// Interface IComPropertyPage2

typedef struct PyIComPropertyPage2Object {
    PyObject_HEAD
    IComPropertyPage2* m_pIComPropertyPage2;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIComPropertyPage2Object;

static PyObject*
PyIComPropertyPage2Object_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIComPropertyPage2Object* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IComPropertyPage2* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IComPropertyPage2, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IComPropertyPage2 with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIComPropertyPage2Object *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IComPropertyPage2");
            return NULL;
        }
        self->m_pIComPropertyPage2 = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IComPropertyPage2");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IComPropertyPage2");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IComPropertyPage2* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IComPropertyPage2, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IComPropertyPage2");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIComPropertyPage2Object *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IComPropertyPage2");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIComPropertyPage2 = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIComPropertyPage2Object_dealloc(PyIComPropertyPage2Object* self)
{
    if (self->m_pIComPropertyPage2)
        self->m_pIComPropertyPage2->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIComPropertyPage2_GetpUnk(PyIComPropertyPage2Object* self)
{
    if (!self->m_pIComPropertyPage2)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIComPropertyPage2->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IComPropertyPage2 to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIComPropertyPage2_GetPointer(PyIComPropertyPage2Object* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIComPropertyPage2);
}

static PyObject*
PyIComPropertyPage2_GetIID(PyIComPropertyPage2Object* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "97afb06f-5c30-4eb3-a4c9-0327a64246c0");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIComPropertyPage2_GetHR(PyIComPropertyPage2Object* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIComPropertyPage2_GetIgnoreFailures(PyIComPropertyPage2Object* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIComPropertyPage2_SetIgnoreFailures(PyIComPropertyPage2Object* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIComPropertyPage2_SupportsInterface(PyIComPropertyPage2Object* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIComPropertyPage2->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IComPropertyPage2Method_put_Title(PyIComPropertyPage2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsTitle = 0;
    PyObject* pyvar_Title;
    PyObject* unicodeTitle = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_Title))
      goto icompropertypage2_put_title_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_Title))
        unicodeTitle = PyUnicode_FromObject(pyvar_Title);
    else if (PyUnicode_Check(pyvar_Title))
    {
        unicodeTitle = pyvar_Title;
        Py_INCREF(unicodeTitle);
    }
    else if (pyvar_Title != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Title at index 0");
    if (unicodeTitle)
        bsTitle = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeTitle), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeTitle));
    
    if (PyErr_Occurred())
      goto icompropertypage2_put_title_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIComPropertyPage2->put_Title(bsTitle);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIComPropertyPage2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IComPropertyPage2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IComPropertyPage2.put_Title() returned %ld", (long)hr);
        goto icompropertypage2_put_title_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Title

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icompropertypage2_put_title_method_cleanup;

    icompropertypage2_put_title_method_cleanup:
    self->m_HR = hr;
    if (bsTitle)
        ::SysFreeString(bsTitle);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IComPropertyPage2.put_Title");
    return return_tuple;
}

static PyObject*
IComPropertyPage2Method_get_Title(PyIComPropertyPage2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsTitle;
    PyObject* pyvar_Title = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Title

    // Call method on actual COM interface
    hr = self->m_pIComPropertyPage2->get_Title(&bsTitle);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIComPropertyPage2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IComPropertyPage2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IComPropertyPage2.get_Title() returned %ld", (long)hr);
        goto icompropertypage2_get_title_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Title = PyUnicode_FromWideChar(bsTitle,::SysStringLen(bsTitle));
    ::SysFreeString(bsTitle);
    
    if (PyErr_Occurred())
      goto icompropertypage2_get_title_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Title);
    goto icompropertypage2_get_title_method_cleanup;

    icompropertypage2_get_title_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Title != Py_None)
        Py_XDECREF(pyvar_Title);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IComPropertyPage2.get_Title");
    return return_tuple;
}

static PyObject*
IComPropertyPage2Method_put_Priority(PyIComPropertyPage2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lPriority = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lPriority))
      goto icompropertypage2_put_priority_method_cleanup;

    // Set up initial variable values as needed
    // No setup for Priority

    // Call method on actual COM interface
    hr = self->m_pIComPropertyPage2->put_Priority(lPriority);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIComPropertyPage2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IComPropertyPage2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IComPropertyPage2.put_Priority() returned %ld", (long)hr);
        goto icompropertypage2_put_priority_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Priority

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icompropertypage2_put_priority_method_cleanup;

    icompropertypage2_put_priority_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Priority
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IComPropertyPage2.put_Priority");
    return return_tuple;
}

static PyObject*
IComPropertyPage2Method_get_Priority(PyIComPropertyPage2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lPriority = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Priority

    // Call method on actual COM interface
    hr = self->m_pIComPropertyPage2->get_Priority(&lPriority);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIComPropertyPage2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IComPropertyPage2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IComPropertyPage2.get_Priority() returned %ld", (long)hr);
        goto icompropertypage2_get_priority_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Priority

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lPriority);
    goto icompropertypage2_get_priority_method_cleanup;

    icompropertypage2_get_priority_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Priority
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IComPropertyPage2.get_Priority");
    return return_tuple;
}

static PyObject*
IComPropertyPage2Method_get_Width(PyIComPropertyPage2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lWidth = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Width

    // Call method on actual COM interface
    hr = self->m_pIComPropertyPage2->get_Width(&lWidth);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIComPropertyPage2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IComPropertyPage2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IComPropertyPage2.get_Width() returned %ld", (long)hr);
        goto icompropertypage2_get_width_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Width

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lWidth);
    goto icompropertypage2_get_width_method_cleanup;

    icompropertypage2_get_width_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Width
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IComPropertyPage2.get_Width");
    return return_tuple;
}

static PyObject*
IComPropertyPage2Method_get_Height(PyIComPropertyPage2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lHeight = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Height

    // Call method on actual COM interface
    hr = self->m_pIComPropertyPage2->get_Height(&lHeight);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIComPropertyPage2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IComPropertyPage2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IComPropertyPage2.get_Height() returned %ld", (long)hr);
        goto icompropertypage2_get_height_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Height

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lHeight);
    goto icompropertypage2_get_height_method_cleanup;

    icompropertypage2_get_height_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Height
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IComPropertyPage2.get_Height");
    return return_tuple;
}

static PyObject*
IComPropertyPage2Method_putref_PageSite(PyIComPropertyPage2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IComPropertyPageSite* ip_arg1 = NULL;
    PyObject* py__arg1;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py__arg1))
      goto icompropertypage2_putref_pagesite_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py__arg1, &IID_IComPropertyPageSite, (void**)&ip_arg1))
        PyErr_SetString(PyExc_TypeError, "Argument _arg1 (position 0) is not IComPropertyPageSite");
    
    if (PyErr_Occurred())
      goto icompropertypage2_putref_pagesite_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIComPropertyPage2->putref_PageSite(ip_arg1);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIComPropertyPage2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IComPropertyPage2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IComPropertyPage2.putref_PageSite() returned %ld", (long)hr);
        goto icompropertypage2_putref_pagesite_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for _arg1

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icompropertypage2_putref_pagesite_method_cleanup;

    icompropertypage2_putref_pagesite_method_cleanup:
    self->m_HR = hr;
    if (ip_arg1)
      ip_arg1->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IComPropertyPage2.putref_PageSite");
    return return_tuple;
}

static PyObject*
IComPropertyPage2Method_get_IsPageDirty(PyIComPropertyPage2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_isDirty = VARIANT_FALSE;
    PyObject* pyvar_isDirty = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for isDirty

    // Call method on actual COM interface
    hr = self->m_pIComPropertyPage2->get_IsPageDirty(&b_isDirty);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIComPropertyPage2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IComPropertyPage2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IComPropertyPage2.get_IsPageDirty() returned %ld", (long)hr);
        goto icompropertypage2_get_ispagedirty_method_cleanup;
    }

    // Set up return values as needed
    pyvar_isDirty = ((b_isDirty == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto icompropertypage2_get_ispagedirty_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_isDirty);
    goto icompropertypage2_get_ispagedirty_method_cleanup;

    icompropertypage2_get_ispagedirty_method_cleanup:
    self->m_HR = hr;
    // No cleanup for isDirty
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IComPropertyPage2.get_IsPageDirty");
    return return_tuple;
}

static PyObject*
IComPropertyPage2Method_get_HelpFile(PyIComPropertyPage2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsHelpFile;
    PyObject* pyvar_HelpFile = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for HelpFile

    // Call method on actual COM interface
    hr = self->m_pIComPropertyPage2->get_HelpFile(&bsHelpFile);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIComPropertyPage2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IComPropertyPage2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IComPropertyPage2.get_HelpFile() returned %ld", (long)hr);
        goto icompropertypage2_get_helpfile_method_cleanup;
    }

    // Set up return values as needed
    pyvar_HelpFile = PyUnicode_FromWideChar(bsHelpFile,::SysStringLen(bsHelpFile));
    ::SysFreeString(bsHelpFile);
    
    if (PyErr_Occurred())
      goto icompropertypage2_get_helpfile_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_HelpFile);
    goto icompropertypage2_get_helpfile_method_cleanup;

    icompropertypage2_get_helpfile_method_cleanup:
    self->m_HR = hr;
    if (pyvar_HelpFile != Py_None)
        Py_XDECREF(pyvar_HelpFile);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IComPropertyPage2.get_HelpFile");
    return return_tuple;
}

static PyObject*
IComPropertyPage2Method_get_HelpContextID(PyIComPropertyPage2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lcontrolID = 0;
    long lhelpID = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lcontrolID))
      goto icompropertypage2_get_helpcontextid_method_cleanup;

    // Set up initial variable values as needed
    // No setup for controlID
    // No setup for helpID

    // Call method on actual COM interface
    hr = self->m_pIComPropertyPage2->get_HelpContextID(lcontrolID, &lhelpID);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIComPropertyPage2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IComPropertyPage2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IComPropertyPage2.get_HelpContextID() returned %ld", (long)hr);
        goto icompropertypage2_get_helpcontextid_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for controlID
    // No teardown for helpID

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lhelpID);
    goto icompropertypage2_get_helpcontextid_method_cleanup;

    icompropertypage2_get_helpcontextid_method_cleanup:
    self->m_HR = hr;
    // No cleanup for controlID
    // No cleanup for helpID
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IComPropertyPage2.get_HelpContextID");
    return return_tuple;
}

static PyObject*
IComPropertyPage2Method_Activate(PyIComPropertyPage2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    OLE_HANDLE HhWnd = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for hWnd

    // Call method on actual COM interface
    hr = self->m_pIComPropertyPage2->Activate(&HhWnd);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIComPropertyPage2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IComPropertyPage2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IComPropertyPage2.Activate() returned %ld", (long)hr);
        goto icompropertypage2_activate_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for hWnd

    // Initialize output tuple
    return_tuple = Py_BuildValue("I",
                                            HhWnd);
    goto icompropertypage2_activate_method_cleanup;

    icompropertypage2_activate_method_cleanup:
    self->m_HR = hr;
    // No cleanup for hWnd
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IComPropertyPage2.Activate");
    return return_tuple;
}

static PyObject*
IComPropertyPage2Method_Deactivate(PyIComPropertyPage2Object* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pIComPropertyPage2->Deactivate();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIComPropertyPage2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IComPropertyPage2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IComPropertyPage2.Deactivate() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}

static PyObject*
IComPropertyPage2Method_Applies(PyIComPropertyPage2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ISet* ipobjects = NULL;
    PyObject* py_objects;
    VARIANT_BOOL b_pApplies = VARIANT_FALSE;
    PyObject* pyvar_pApplies = Py_False;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_objects))
      goto icompropertypage2_applies_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_objects, &IID_ISet, (void**)&ipobjects))
        PyErr_SetString(PyExc_TypeError, "Argument objects (position 0) is not ISet");
    
    if (PyErr_Occurred())
      goto icompropertypage2_applies_method_cleanup;
    
    // No setup for pApplies

    // Call method on actual COM interface
    hr = self->m_pIComPropertyPage2->Applies(ipobjects, &b_pApplies);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIComPropertyPage2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IComPropertyPage2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IComPropertyPage2.Applies() returned %ld", (long)hr);
        goto icompropertypage2_applies_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for objects
    pyvar_pApplies = ((b_pApplies == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto icompropertypage2_applies_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pApplies);
    goto icompropertypage2_applies_method_cleanup;

    icompropertypage2_applies_method_cleanup:
    self->m_HR = hr;
    if (ipobjects)
      ipobjects->Release();
    // No cleanup for pApplies
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IComPropertyPage2.Applies");
    return return_tuple;
}

static PyObject*
IComPropertyPage2Method_SetObjects(PyIComPropertyPage2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ISet* ipobjects = NULL;
    PyObject* py_objects;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_objects))
      goto icompropertypage2_setobjects_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_objects, &IID_ISet, (void**)&ipobjects))
        PyErr_SetString(PyExc_TypeError, "Argument objects (position 0) is not ISet");
    
    if (PyErr_Occurred())
      goto icompropertypage2_setobjects_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIComPropertyPage2->SetObjects(ipobjects);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIComPropertyPage2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IComPropertyPage2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IComPropertyPage2.SetObjects() returned %ld", (long)hr);
        goto icompropertypage2_setobjects_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for objects

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icompropertypage2_setobjects_method_cleanup;

    icompropertypage2_setobjects_method_cleanup:
    self->m_HR = hr;
    if (ipobjects)
      ipobjects->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IComPropertyPage2.SetObjects");
    return return_tuple;
}

static PyObject*
IComPropertyPage2Method_Show(PyIComPropertyPage2Object* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pIComPropertyPage2->Show();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIComPropertyPage2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IComPropertyPage2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IComPropertyPage2.Show() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}

static PyObject*
IComPropertyPage2Method_Hide(PyIComPropertyPage2Object* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pIComPropertyPage2->Hide();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIComPropertyPage2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IComPropertyPage2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IComPropertyPage2.Hide() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}

static PyObject*
IComPropertyPage2Method_Apply(PyIComPropertyPage2Object* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pIComPropertyPage2->Apply();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIComPropertyPage2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IComPropertyPage2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IComPropertyPage2.Apply() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}

static PyObject*
IComPropertyPage2Method_Cancel(PyIComPropertyPage2Object* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pIComPropertyPage2->Cancel();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIComPropertyPage2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IComPropertyPage2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IComPropertyPage2.Cancel() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}

static PyObject*
IComPropertyPage2Method_QueryCancel(PyIComPropertyPage2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_QueryCancel = VARIANT_FALSE;
    PyObject* pyvar_QueryCancel = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for QueryCancel

    // Call method on actual COM interface
    hr = self->m_pIComPropertyPage2->QueryCancel(&b_QueryCancel);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIComPropertyPage2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IComPropertyPage2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IComPropertyPage2.QueryCancel() returned %ld", (long)hr);
        goto icompropertypage2_querycancel_method_cleanup;
    }

    // Set up return values as needed
    pyvar_QueryCancel = ((b_QueryCancel == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto icompropertypage2_querycancel_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_QueryCancel);
    goto icompropertypage2_querycancel_method_cleanup;

    icompropertypage2_querycancel_method_cleanup:
    self->m_HR = hr;
    // No cleanup for QueryCancel
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IComPropertyPage2.QueryCancel");
    return return_tuple;
}


PyMethodDef PyIComPropertyPage2Methods[] = {
    {"supports", (PyCFunction)PyIComPropertyPage2_SupportsInterface, METH_O, ""},
    {"put_Title", (PyCFunction)IComPropertyPage2Method_put_Title, METH_VARARGS, ""},
    {"get_Title", (PyCFunction)IComPropertyPage2Method_get_Title, METH_VARARGS, ""},
    {"put_Priority", (PyCFunction)IComPropertyPage2Method_put_Priority, METH_VARARGS, ""},
    {"get_Priority", (PyCFunction)IComPropertyPage2Method_get_Priority, METH_VARARGS, ""},
    {"get_Width", (PyCFunction)IComPropertyPage2Method_get_Width, METH_VARARGS, ""},
    {"get_Height", (PyCFunction)IComPropertyPage2Method_get_Height, METH_VARARGS, ""},
    {"putref_PageSite", (PyCFunction)IComPropertyPage2Method_putref_PageSite, METH_VARARGS, ""},
    {"get_IsPageDirty", (PyCFunction)IComPropertyPage2Method_get_IsPageDirty, METH_VARARGS, ""},
    {"get_HelpFile", (PyCFunction)IComPropertyPage2Method_get_HelpFile, METH_VARARGS, ""},
    {"get_HelpContextID", (PyCFunction)IComPropertyPage2Method_get_HelpContextID, METH_VARARGS, ""},
    {"Activate", (PyCFunction)IComPropertyPage2Method_Activate, METH_VARARGS, ""},
    {"Deactivate", (PyCFunction)IComPropertyPage2Method_Deactivate, METH_NOARGS, ""},
    {"Applies", (PyCFunction)IComPropertyPage2Method_Applies, METH_VARARGS, ""},
    {"SetObjects", (PyCFunction)IComPropertyPage2Method_SetObjects, METH_VARARGS, ""},
    {"Show", (PyCFunction)IComPropertyPage2Method_Show, METH_NOARGS, ""},
    {"Hide", (PyCFunction)IComPropertyPage2Method_Hide, METH_NOARGS, ""},
    {"Apply", (PyCFunction)IComPropertyPage2Method_Apply, METH_NOARGS, ""},
    {"Cancel", (PyCFunction)IComPropertyPage2Method_Cancel, METH_NOARGS, ""},
    {"QueryCancel", (PyCFunction)IComPropertyPage2Method_QueryCancel, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIComPropertyPage2GetSet[] = {
  {"_pUnk", (getter)PyIComPropertyPage2_GetpUnk, NULL, "Get opaque pointer to an Unknown from IComPropertyPage2", NULL},
  {"_pointer", (getter)PyIComPropertyPage2_GetPointer, NULL, "Get memory address for IComPropertyPage2", NULL},
  {"_IID", (getter)PyIComPropertyPage2_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIComPropertyPage2_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIComPropertyPage2_GetIgnoreFailures, (setter)PyIComPropertyPage2_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIComPropertyPage2Object_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriFramework.IComPropertyPage2Object",                          
                                              /* tp_name */
  sizeof(PyIComPropertyPage2Object),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIComPropertyPage2Object_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIComPropertyPage2Methods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIComPropertyPage2GetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIComPropertyPage2Object_new,                      
                                              /* tp_new */
};

// Interface IModelessFrame

typedef struct PyIModelessFrameObject {
    PyObject_HEAD
    IModelessFrame* m_pIModelessFrame;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIModelessFrameObject;

static PyObject*
PyIModelessFrameObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIModelessFrameObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IModelessFrame* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IModelessFrame, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IModelessFrame with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIModelessFrameObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IModelessFrame");
            return NULL;
        }
        self->m_pIModelessFrame = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IModelessFrame");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IModelessFrame");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IModelessFrame* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IModelessFrame, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IModelessFrame");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIModelessFrameObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IModelessFrame");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIModelessFrame = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIModelessFrameObject_dealloc(PyIModelessFrameObject* self)
{
    if (self->m_pIModelessFrame)
        self->m_pIModelessFrame->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIModelessFrame_GetpUnk(PyIModelessFrameObject* self)
{
    if (!self->m_pIModelessFrame)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIModelessFrame->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IModelessFrame to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIModelessFrame_GetPointer(PyIModelessFrameObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIModelessFrame);
}

static PyObject*
PyIModelessFrame_GetIID(PyIModelessFrameObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "06861e43-9020-49eb-b949-824552ee2de0");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIModelessFrame_GetHR(PyIModelessFrameObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIModelessFrame_GetIgnoreFailures(PyIModelessFrameObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIModelessFrame_SetIgnoreFailures(PyIModelessFrameObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIModelessFrame_SupportsInterface(PyIModelessFrameObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIModelessFrame->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IModelessFrameMethod_Create(PyIModelessFrameObject* self, PyObject* args)
{
    /* Param types that are unhandleable: 
       INPUT [u'IDispatch', u'*']
    */
    PyErr_SetString(PyExc_NotImplementedError, "Wrapper for IModelessFrame.Create not implemented.");
    return NULL;
}

static PyObject*
IModelessFrameMethod_put_Visible(PyIModelessFrameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_bVisible = VARIANT_FALSE;
    PyObject* pyvar_bVisible = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_bVisible))
      goto imodelessframe_put_visible_method_cleanup;

    // Set up initial variable values as needed
    b_bVisible = ((PyObject_IsTrue(pyvar_bVisible) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto imodelessframe_put_visible_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIModelessFrame->put_Visible(b_bVisible);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIModelessFrame->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IModelessFrame) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IModelessFrame.put_Visible() returned %ld", (long)hr);
        goto imodelessframe_put_visible_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for bVisible

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto imodelessframe_put_visible_method_cleanup;

    imodelessframe_put_visible_method_cleanup:
    self->m_HR = hr;
    // No cleanup for bVisible
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IModelessFrame.put_Visible");
    return return_tuple;
}

static PyObject*
IModelessFrameMethod_get_Visible(PyIModelessFrameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_bVisible = VARIANT_FALSE;
    PyObject* pyvar_bVisible = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for bVisible

    // Call method on actual COM interface
    hr = self->m_pIModelessFrame->get_Visible(&b_bVisible);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIModelessFrame->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IModelessFrame) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IModelessFrame.get_Visible() returned %ld", (long)hr);
        goto imodelessframe_get_visible_method_cleanup;
    }

    // Set up return values as needed
    pyvar_bVisible = ((b_bVisible == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto imodelessframe_get_visible_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_bVisible);
    goto imodelessframe_get_visible_method_cleanup;

    imodelessframe_get_visible_method_cleanup:
    self->m_HR = hr;
    // No cleanup for bVisible
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IModelessFrame.get_Visible");
    return return_tuple;
}

static PyObject*
IModelessFrameMethod_put_Caption(PyIModelessFrameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspCaption = 0;
    PyObject* pyvar_pCaption;
    PyObject* unicodepCaption = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_pCaption))
      goto imodelessframe_put_caption_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_pCaption))
        unicodepCaption = PyUnicode_FromObject(pyvar_pCaption);
    else if (PyUnicode_Check(pyvar_pCaption))
    {
        unicodepCaption = pyvar_pCaption;
        Py_INCREF(unicodepCaption);
    }
    else if (pyvar_pCaption != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter pCaption at index 0");
    if (unicodepCaption)
        bspCaption = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodepCaption), 
                                            (UINT)PyUnicode_GET_SIZE(unicodepCaption));
    
    if (PyErr_Occurred())
      goto imodelessframe_put_caption_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIModelessFrame->put_Caption(bspCaption);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIModelessFrame->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IModelessFrame) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IModelessFrame.put_Caption() returned %ld", (long)hr);
        goto imodelessframe_put_caption_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pCaption

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto imodelessframe_put_caption_method_cleanup;

    imodelessframe_put_caption_method_cleanup:
    self->m_HR = hr;
    if (bspCaption)
        ::SysFreeString(bspCaption);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IModelessFrame.put_Caption");
    return return_tuple;
}

static PyObject*
IModelessFrameMethod_get_Caption(PyIModelessFrameObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspCaption;
    PyObject* pyvar_pCaption = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for pCaption

    // Call method on actual COM interface
    hr = self->m_pIModelessFrame->get_Caption(&bspCaption);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIModelessFrame->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IModelessFrame) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IModelessFrame.get_Caption() returned %ld", (long)hr);
        goto imodelessframe_get_caption_method_cleanup;
    }

    // Set up return values as needed
    pyvar_pCaption = PyUnicode_FromWideChar(bspCaption,::SysStringLen(bspCaption));
    ::SysFreeString(bspCaption);
    
    if (PyErr_Occurred())
      goto imodelessframe_get_caption_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pCaption);
    goto imodelessframe_get_caption_method_cleanup;

    imodelessframe_get_caption_method_cleanup:
    self->m_HR = hr;
    if (pyvar_pCaption != Py_None)
        Py_XDECREF(pyvar_pCaption);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IModelessFrame.get_Caption");
    return return_tuple;
}


PyMethodDef PyIModelessFrameMethods[] = {
    {"supports", (PyCFunction)PyIModelessFrame_SupportsInterface, METH_O, ""},
    {"Create", (PyCFunction)IModelessFrameMethod_Create, METH_VARARGS, ""},
    {"put_Visible", (PyCFunction)IModelessFrameMethod_put_Visible, METH_VARARGS, ""},
    {"get_Visible", (PyCFunction)IModelessFrameMethod_get_Visible, METH_VARARGS, ""},
    {"put_Caption", (PyCFunction)IModelessFrameMethod_put_Caption, METH_VARARGS, ""},
    {"get_Caption", (PyCFunction)IModelessFrameMethod_get_Caption, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIModelessFrameGetSet[] = {
  {"_pUnk", (getter)PyIModelessFrame_GetpUnk, NULL, "Get opaque pointer to an Unknown from IModelessFrame", NULL},
  {"_pointer", (getter)PyIModelessFrame_GetPointer, NULL, "Get memory address for IModelessFrame", NULL},
  {"_IID", (getter)PyIModelessFrame_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIModelessFrame_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIModelessFrame_GetIgnoreFailures, (setter)PyIModelessFrame_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIModelessFrameObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriFramework.IModelessFrameObject",                          
                                              /* tp_name */
  sizeof(PyIModelessFrameObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIModelessFrameObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIModelessFrameMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIModelessFrameGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIModelessFrameObject_new,                      
                                              /* tp_new */
};

// Interface IGetStringDialog

typedef struct PyIGetStringDialogObject {
    PyObject_HEAD
    IGetStringDialog* m_pIGetStringDialog;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIGetStringDialogObject;

static PyObject*
PyIGetStringDialogObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIGetStringDialogObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IGetStringDialog* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IGetStringDialog, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IGetStringDialog with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIGetStringDialogObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IGetStringDialog");
            return NULL;
        }
        self->m_pIGetStringDialog = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IGetStringDialog");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IGetStringDialog");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IGetStringDialog* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IGetStringDialog, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IGetStringDialog");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIGetStringDialogObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IGetStringDialog");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIGetStringDialog = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIGetStringDialogObject_dealloc(PyIGetStringDialogObject* self)
{
    if (self->m_pIGetStringDialog)
        self->m_pIGetStringDialog->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIGetStringDialog_GetpUnk(PyIGetStringDialogObject* self)
{
    if (!self->m_pIGetStringDialog)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIGetStringDialog->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IGetStringDialog to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIGetStringDialog_GetPointer(PyIGetStringDialogObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIGetStringDialog);
}

static PyObject*
PyIGetStringDialog_GetIID(PyIGetStringDialogObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "a7b8ec8f-ac12-11d2-ab27-00c04fa334b3");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIGetStringDialog_GetHR(PyIGetStringDialogObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIGetStringDialog_GetIgnoreFailures(PyIGetStringDialogObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIGetStringDialog_SetIgnoreFailures(PyIGetStringDialogObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIGetStringDialog_SupportsInterface(PyIGetStringDialogObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIGetStringDialog->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IGetStringDialogMethod_get_Value(PyIGetStringDialogObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsval;
    PyObject* pyvar_val = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for val

    // Call method on actual COM interface
    hr = self->m_pIGetStringDialog->get_Value(&bsval);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGetStringDialog->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGetStringDialog) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGetStringDialog.get_Value() returned %ld", (long)hr);
        goto igetstringdialog_get_value_method_cleanup;
    }

    // Set up return values as needed
    pyvar_val = PyUnicode_FromWideChar(bsval,::SysStringLen(bsval));
    ::SysFreeString(bsval);
    
    if (PyErr_Occurred())
      goto igetstringdialog_get_value_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_val);
    goto igetstringdialog_get_value_method_cleanup;

    igetstringdialog_get_value_method_cleanup:
    self->m_HR = hr;
    if (pyvar_val != Py_None)
        Py_XDECREF(pyvar_val);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGetStringDialog.get_Value");
    return return_tuple;
}

static PyObject*
IGetStringDialogMethod_DoModal(PyIGetStringDialogObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsdialogTitle = 0;
    PyObject* pyvar_dialogTitle;
    PyObject* unicodedialogTitle = NULL;
    BSTR bsgetStringLabel = 0;
    PyObject* pyvar_getStringLabel;
    PyObject* unicodegetStringLabel = NULL;
    BSTR bsinitialValue = 0;
    PyObject* pyvar_initialValue;
    PyObject* unicodeinitialValue = NULL;
    OLE_HANDLE HhWnd = 0;
    VARIANT_BOOL b_okPressed = VARIANT_FALSE;
    PyObject* pyvar_okPressed = Py_False;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOOI", &pyvar_dialogTitle, &pyvar_getStringLabel, &pyvar_initialValue, &HhWnd))
      goto igetstringdialog_domodal_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_dialogTitle))
        unicodedialogTitle = PyUnicode_FromObject(pyvar_dialogTitle);
    else if (PyUnicode_Check(pyvar_dialogTitle))
    {
        unicodedialogTitle = pyvar_dialogTitle;
        Py_INCREF(unicodedialogTitle);
    }
    else if (pyvar_dialogTitle != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter dialogTitle at index 0");
    if (unicodedialogTitle)
        bsdialogTitle = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodedialogTitle), 
                                            (UINT)PyUnicode_GET_SIZE(unicodedialogTitle));
    
    if (PyErr_Occurred())
      goto igetstringdialog_domodal_method_cleanup;
    
    if (PyString_Check(pyvar_getStringLabel))
        unicodegetStringLabel = PyUnicode_FromObject(pyvar_getStringLabel);
    else if (PyUnicode_Check(pyvar_getStringLabel))
    {
        unicodegetStringLabel = pyvar_getStringLabel;
        Py_INCREF(unicodegetStringLabel);
    }
    else if (pyvar_getStringLabel != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter getStringLabel at index 1");
    if (unicodegetStringLabel)
        bsgetStringLabel = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodegetStringLabel), 
                                            (UINT)PyUnicode_GET_SIZE(unicodegetStringLabel));
    
    if (PyErr_Occurred())
      goto igetstringdialog_domodal_method_cleanup;
    
    if (PyString_Check(pyvar_initialValue))
        unicodeinitialValue = PyUnicode_FromObject(pyvar_initialValue);
    else if (PyUnicode_Check(pyvar_initialValue))
    {
        unicodeinitialValue = pyvar_initialValue;
        Py_INCREF(unicodeinitialValue);
    }
    else if (pyvar_initialValue != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter initialValue at index 2");
    if (unicodeinitialValue)
        bsinitialValue = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeinitialValue), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeinitialValue));
    
    if (PyErr_Occurred())
      goto igetstringdialog_domodal_method_cleanup;
    
    // No setup for hWnd
    // No setup for okPressed

    // Call method on actual COM interface
    hr = self->m_pIGetStringDialog->DoModal(bsdialogTitle, bsgetStringLabel, bsinitialValue, HhWnd, &b_okPressed);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGetStringDialog->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGetStringDialog) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGetStringDialog.DoModal() returned %ld", (long)hr);
        goto igetstringdialog_domodal_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for dialogTitle
    // No teardown for getStringLabel
    // No teardown for initialValue
    // No teardown for hWnd
    pyvar_okPressed = ((b_okPressed == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto igetstringdialog_domodal_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_okPressed);
    goto igetstringdialog_domodal_method_cleanup;

    igetstringdialog_domodal_method_cleanup:
    self->m_HR = hr;
    if (bsdialogTitle)
        ::SysFreeString(bsdialogTitle);
    
    if (bsgetStringLabel)
        ::SysFreeString(bsgetStringLabel);
    
    if (bsinitialValue)
        ::SysFreeString(bsinitialValue);
    
    // No cleanup for hWnd
    // No cleanup for okPressed
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGetStringDialog.DoModal");
    return return_tuple;
}


PyMethodDef PyIGetStringDialogMethods[] = {
    {"supports", (PyCFunction)PyIGetStringDialog_SupportsInterface, METH_O, ""},
    {"get_Value", (PyCFunction)IGetStringDialogMethod_get_Value, METH_VARARGS, ""},
    {"DoModal", (PyCFunction)IGetStringDialogMethod_DoModal, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIGetStringDialogGetSet[] = {
  {"_pUnk", (getter)PyIGetStringDialog_GetpUnk, NULL, "Get opaque pointer to an Unknown from IGetStringDialog", NULL},
  {"_pointer", (getter)PyIGetStringDialog_GetPointer, NULL, "Get memory address for IGetStringDialog", NULL},
  {"_IID", (getter)PyIGetStringDialog_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIGetStringDialog_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIGetStringDialog_GetIgnoreFailures, (setter)PyIGetStringDialog_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIGetStringDialogObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriFramework.IGetStringDialogObject",                          
                                              /* tp_name */
  sizeof(PyIGetStringDialogObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIGetStringDialogObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIGetStringDialogMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIGetStringDialogGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIGetStringDialogObject_new,                      
                                              /* tp_new */
};

// Interface IGetUserAndPasswordDialog

typedef struct PyIGetUserAndPasswordDialogObject {
    PyObject_HEAD
    IGetUserAndPasswordDialog* m_pIGetUserAndPasswordDialog;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIGetUserAndPasswordDialogObject;

static PyObject*
PyIGetUserAndPasswordDialogObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIGetUserAndPasswordDialogObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IGetUserAndPasswordDialog* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IGetUserAndPasswordDialog, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IGetUserAndPasswordDialog with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIGetUserAndPasswordDialogObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IGetUserAndPasswordDialog");
            return NULL;
        }
        self->m_pIGetUserAndPasswordDialog = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IGetUserAndPasswordDialog");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IGetUserAndPasswordDialog");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IGetUserAndPasswordDialog* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IGetUserAndPasswordDialog, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IGetUserAndPasswordDialog");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIGetUserAndPasswordDialogObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IGetUserAndPasswordDialog");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIGetUserAndPasswordDialog = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIGetUserAndPasswordDialogObject_dealloc(PyIGetUserAndPasswordDialogObject* self)
{
    if (self->m_pIGetUserAndPasswordDialog)
        self->m_pIGetUserAndPasswordDialog->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIGetUserAndPasswordDialog_GetpUnk(PyIGetUserAndPasswordDialogObject* self)
{
    if (!self->m_pIGetUserAndPasswordDialog)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIGetUserAndPasswordDialog->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IGetUserAndPasswordDialog to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIGetUserAndPasswordDialog_GetPointer(PyIGetUserAndPasswordDialogObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIGetUserAndPasswordDialog);
}

static PyObject*
PyIGetUserAndPasswordDialog_GetIID(PyIGetUserAndPasswordDialogObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "b7f5ddff-1301-47a2-901a-d38f364544d2");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIGetUserAndPasswordDialog_GetHR(PyIGetUserAndPasswordDialogObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIGetUserAndPasswordDialog_GetIgnoreFailures(PyIGetUserAndPasswordDialogObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIGetUserAndPasswordDialog_SetIgnoreFailures(PyIGetUserAndPasswordDialogObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIGetUserAndPasswordDialog_SupportsInterface(PyIGetUserAndPasswordDialogObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIGetUserAndPasswordDialog->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IGetUserAndPasswordDialogMethod_get_UserName(PyIGetUserAndPasswordDialogObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsUserName;
    PyObject* pyvar_UserName = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for UserName

    // Call method on actual COM interface
    hr = self->m_pIGetUserAndPasswordDialog->get_UserName(&bsUserName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGetUserAndPasswordDialog->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGetUserAndPasswordDialog) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGetUserAndPasswordDialog.get_UserName() returned %ld", (long)hr);
        goto igetuserandpassworddialog_get_username_method_cleanup;
    }

    // Set up return values as needed
    pyvar_UserName = PyUnicode_FromWideChar(bsUserName,::SysStringLen(bsUserName));
    ::SysFreeString(bsUserName);
    
    if (PyErr_Occurred())
      goto igetuserandpassworddialog_get_username_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_UserName);
    goto igetuserandpassworddialog_get_username_method_cleanup;

    igetuserandpassworddialog_get_username_method_cleanup:
    self->m_HR = hr;
    if (pyvar_UserName != Py_None)
        Py_XDECREF(pyvar_UserName);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGetUserAndPasswordDialog.get_UserName");
    return return_tuple;
}

static PyObject*
IGetUserAndPasswordDialogMethod_get_Password(PyIGetUserAndPasswordDialogObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsPassword;
    PyObject* pyvar_Password = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Password

    // Call method on actual COM interface
    hr = self->m_pIGetUserAndPasswordDialog->get_Password(&bsPassword);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGetUserAndPasswordDialog->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGetUserAndPasswordDialog) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGetUserAndPasswordDialog.get_Password() returned %ld", (long)hr);
        goto igetuserandpassworddialog_get_password_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Password = PyUnicode_FromWideChar(bsPassword,::SysStringLen(bsPassword));
    ::SysFreeString(bsPassword);
    
    if (PyErr_Occurred())
      goto igetuserandpassworddialog_get_password_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Password);
    goto igetuserandpassworddialog_get_password_method_cleanup;

    igetuserandpassworddialog_get_password_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Password != Py_None)
        Py_XDECREF(pyvar_Password);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGetUserAndPasswordDialog.get_Password");
    return return_tuple;
}

static PyObject*
IGetUserAndPasswordDialogMethod_DoModal(PyIGetUserAndPasswordDialogObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsdialogTitle = 0;
    PyObject* pyvar_dialogTitle;
    PyObject* unicodedialogTitle = NULL;
    BSTR bsstringLabel = 0;
    PyObject* pyvar_stringLabel;
    PyObject* unicodestringLabel = NULL;
    OLE_HANDLE HhWnd = 0;
    VARIANT_BOOL b_okPressed = VARIANT_FALSE;
    PyObject* pyvar_okPressed = Py_False;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOI", &pyvar_dialogTitle, &pyvar_stringLabel, &HhWnd))
      goto igetuserandpassworddialog_domodal_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_dialogTitle))
        unicodedialogTitle = PyUnicode_FromObject(pyvar_dialogTitle);
    else if (PyUnicode_Check(pyvar_dialogTitle))
    {
        unicodedialogTitle = pyvar_dialogTitle;
        Py_INCREF(unicodedialogTitle);
    }
    else if (pyvar_dialogTitle != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter dialogTitle at index 0");
    if (unicodedialogTitle)
        bsdialogTitle = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodedialogTitle), 
                                            (UINT)PyUnicode_GET_SIZE(unicodedialogTitle));
    
    if (PyErr_Occurred())
      goto igetuserandpassworddialog_domodal_method_cleanup;
    
    if (PyString_Check(pyvar_stringLabel))
        unicodestringLabel = PyUnicode_FromObject(pyvar_stringLabel);
    else if (PyUnicode_Check(pyvar_stringLabel))
    {
        unicodestringLabel = pyvar_stringLabel;
        Py_INCREF(unicodestringLabel);
    }
    else if (pyvar_stringLabel != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter stringLabel at index 1");
    if (unicodestringLabel)
        bsstringLabel = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodestringLabel), 
                                            (UINT)PyUnicode_GET_SIZE(unicodestringLabel));
    
    if (PyErr_Occurred())
      goto igetuserandpassworddialog_domodal_method_cleanup;
    
    // No setup for hWnd
    // No setup for okPressed

    // Call method on actual COM interface
    hr = self->m_pIGetUserAndPasswordDialog->DoModal(bsdialogTitle, bsstringLabel, HhWnd, &b_okPressed);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIGetUserAndPasswordDialog->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IGetUserAndPasswordDialog) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IGetUserAndPasswordDialog.DoModal() returned %ld", (long)hr);
        goto igetuserandpassworddialog_domodal_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for dialogTitle
    // No teardown for stringLabel
    // No teardown for hWnd
    pyvar_okPressed = ((b_okPressed == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto igetuserandpassworddialog_domodal_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_okPressed);
    goto igetuserandpassworddialog_domodal_method_cleanup;

    igetuserandpassworddialog_domodal_method_cleanup:
    self->m_HR = hr;
    if (bsdialogTitle)
        ::SysFreeString(bsdialogTitle);
    
    if (bsstringLabel)
        ::SysFreeString(bsstringLabel);
    
    // No cleanup for hWnd
    // No cleanup for okPressed
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IGetUserAndPasswordDialog.DoModal");
    return return_tuple;
}


PyMethodDef PyIGetUserAndPasswordDialogMethods[] = {
    {"supports", (PyCFunction)PyIGetUserAndPasswordDialog_SupportsInterface, METH_O, ""},
    {"get_UserName", (PyCFunction)IGetUserAndPasswordDialogMethod_get_UserName, METH_VARARGS, ""},
    {"get_Password", (PyCFunction)IGetUserAndPasswordDialogMethod_get_Password, METH_VARARGS, ""},
    {"DoModal", (PyCFunction)IGetUserAndPasswordDialogMethod_DoModal, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIGetUserAndPasswordDialogGetSet[] = {
  {"_pUnk", (getter)PyIGetUserAndPasswordDialog_GetpUnk, NULL, "Get opaque pointer to an Unknown from IGetUserAndPasswordDialog", NULL},
  {"_pointer", (getter)PyIGetUserAndPasswordDialog_GetPointer, NULL, "Get memory address for IGetUserAndPasswordDialog", NULL},
  {"_IID", (getter)PyIGetUserAndPasswordDialog_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIGetUserAndPasswordDialog_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIGetUserAndPasswordDialog_GetIgnoreFailures, (setter)PyIGetUserAndPasswordDialog_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIGetUserAndPasswordDialogObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriFramework.IGetUserAndPasswordDialogObject",                          
                                              /* tp_name */
  sizeof(PyIGetUserAndPasswordDialogObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIGetUserAndPasswordDialogObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIGetUserAndPasswordDialogMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIGetUserAndPasswordDialogGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIGetUserAndPasswordDialogObject_new,                      
                                              /* tp_new */
};

// Interface INumberDialog

typedef struct PyINumberDialogObject {
    PyObject_HEAD
    INumberDialog* m_pINumberDialog;
    HRESULT m_HR;
    int m_ignore_failures;
} PyINumberDialogObject;

static PyObject*
PyINumberDialogObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyINumberDialogObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        INumberDialog* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_INumberDialog, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate INumberDialog with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyINumberDialogObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate INumberDialog");
            return NULL;
        }
        self->m_pINumberDialog = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for INumberDialog");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to INumberDialog");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    INumberDialog* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_INumberDialog, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to INumberDialog");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyINumberDialogObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate INumberDialog");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pINumberDialog = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyINumberDialogObject_dealloc(PyINumberDialogObject* self)
{
    if (self->m_pINumberDialog)
        self->m_pINumberDialog->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyINumberDialog_GetpUnk(PyINumberDialogObject* self)
{
    if (!self->m_pINumberDialog)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pINumberDialog->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI INumberDialog to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyINumberDialog_GetPointer(PyINumberDialogObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pINumberDialog);
}

static PyObject*
PyINumberDialog_GetIID(PyINumberDialogObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "759f7b98-e07d-11d1-aa87-00c04fa374bd");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyINumberDialog_GetHR(PyINumberDialogObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyINumberDialog_GetIgnoreFailures(PyINumberDialogObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyINumberDialog_SetIgnoreFailures(PyINumberDialogObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyINumberDialog_SupportsInterface(PyINumberDialogObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pINumberDialog->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
INumberDialogMethod_get_Value(PyINumberDialogObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dval = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for val

    // Call method on actual COM interface
    hr = self->m_pINumberDialog->get_Value(&dval);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pINumberDialog->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_INumberDialog) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: INumberDialog.get_Value() returned %ld", (long)hr);
        goto inumberdialog_get_value_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for val

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dval);
    goto inumberdialog_get_value_method_cleanup;

    inumberdialog_get_value_method_cleanup:
    self->m_HR = hr;
    // No cleanup for val
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in INumberDialog.get_Value");
    return return_tuple;
}

static PyObject*
INumberDialogMethod_DoModal(PyINumberDialogObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsTitle = 0;
    PyObject* pyvar_Title;
    PyObject* unicodeTitle = NULL;
    double dinitialValue = 0;
    long lnumDecs = 0;
    OLE_HANDLE HhWnd = 0;
    VARIANT_BOOL b_okPressed = VARIANT_FALSE;
    PyObject* pyvar_okPressed = Py_False;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OdlI", &pyvar_Title, &dinitialValue, &lnumDecs, &HhWnd))
      goto inumberdialog_domodal_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_Title))
        unicodeTitle = PyUnicode_FromObject(pyvar_Title);
    else if (PyUnicode_Check(pyvar_Title))
    {
        unicodeTitle = pyvar_Title;
        Py_INCREF(unicodeTitle);
    }
    else if (pyvar_Title != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Title at index 0");
    if (unicodeTitle)
        bsTitle = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeTitle), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeTitle));
    
    if (PyErr_Occurred())
      goto inumberdialog_domodal_method_cleanup;
    
    // No setup for initialValue
    // No setup for numDecs
    // No setup for hWnd
    // No setup for okPressed

    // Call method on actual COM interface
    hr = self->m_pINumberDialog->DoModal(bsTitle, dinitialValue, lnumDecs, HhWnd, &b_okPressed);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pINumberDialog->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_INumberDialog) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: INumberDialog.DoModal() returned %ld", (long)hr);
        goto inumberdialog_domodal_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Title
    // No teardown for initialValue
    // No teardown for numDecs
    // No teardown for hWnd
    pyvar_okPressed = ((b_okPressed == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto inumberdialog_domodal_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_okPressed);
    goto inumberdialog_domodal_method_cleanup;

    inumberdialog_domodal_method_cleanup:
    self->m_HR = hr;
    if (bsTitle)
        ::SysFreeString(bsTitle);
    
    // No cleanup for initialValue
    // No cleanup for numDecs
    // No cleanup for hWnd
    // No cleanup for okPressed
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in INumberDialog.DoModal");
    return return_tuple;
}


PyMethodDef PyINumberDialogMethods[] = {
    {"supports", (PyCFunction)PyINumberDialog_SupportsInterface, METH_O, ""},
    {"get_Value", (PyCFunction)INumberDialogMethod_get_Value, METH_VARARGS, ""},
    {"DoModal", (PyCFunction)INumberDialogMethod_DoModal, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyINumberDialogGetSet[] = {
  {"_pUnk", (getter)PyINumberDialog_GetpUnk, NULL, "Get opaque pointer to an Unknown from INumberDialog", NULL},
  {"_pointer", (getter)PyINumberDialog_GetPointer, NULL, "Get memory address for INumberDialog", NULL},
  {"_IID", (getter)PyINumberDialog_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyINumberDialog_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyINumberDialog_GetIgnoreFailures, (setter)PyINumberDialog_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyINumberDialogObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriFramework.INumberDialogObject",                          
                                              /* tp_name */
  sizeof(PyINumberDialogObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyINumberDialogObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyINumberDialogMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyINumberDialogGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyINumberDialogObject_new,                      
                                              /* tp_new */
};

// Interface IMessageDialog

typedef struct PyIMessageDialogObject {
    PyObject_HEAD
    IMessageDialog* m_pIMessageDialog;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIMessageDialogObject;

static PyObject*
PyIMessageDialogObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIMessageDialogObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IMessageDialog* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IMessageDialog, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IMessageDialog with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIMessageDialogObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IMessageDialog");
            return NULL;
        }
        self->m_pIMessageDialog = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IMessageDialog");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IMessageDialog");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IMessageDialog* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IMessageDialog, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IMessageDialog");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIMessageDialogObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IMessageDialog");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIMessageDialog = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIMessageDialogObject_dealloc(PyIMessageDialogObject* self)
{
    if (self->m_pIMessageDialog)
        self->m_pIMessageDialog->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIMessageDialog_GetpUnk(PyIMessageDialogObject* self)
{
    if (!self->m_pIMessageDialog)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIMessageDialog->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IMessageDialog to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIMessageDialog_GetPointer(PyIMessageDialogObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIMessageDialog);
}

static PyObject*
PyIMessageDialog_GetIID(PyIMessageDialogObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "48f2c005-25c4-11d3-9fba-00c04f6bc8dd");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIMessageDialog_GetHR(PyIMessageDialogObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIMessageDialog_GetIgnoreFailures(PyIMessageDialogObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIMessageDialog_SetIgnoreFailures(PyIMessageDialogObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIMessageDialog_SupportsInterface(PyIMessageDialogObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIMessageDialog->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IMessageDialogMethod_DoModal(PyIMessageDialogObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsTitle = 0;
    PyObject* pyvar_Title;
    PyObject* unicodeTitle = NULL;
    BSTR bsMessage = 0;
    PyObject* pyvar_Message;
    PyObject* unicodeMessage = NULL;
    BSTR bsOKButtonMessage = 0;
    PyObject* pyvar_OKButtonMessage;
    PyObject* unicodeOKButtonMessage = NULL;
    BSTR bsCANCELButtonMessage = 0;
    PyObject* pyvar_CANCELButtonMessage;
    PyObject* unicodeCANCELButtonMessage = NULL;
    OLE_HANDLE HhWnd = 0;
    VARIANT_BOOL b_okPressed = VARIANT_FALSE;
    PyObject* pyvar_okPressed = Py_False;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOOOI", &pyvar_Title, &pyvar_Message, &pyvar_OKButtonMessage, &pyvar_CANCELButtonMessage, &HhWnd))
      goto imessagedialog_domodal_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_Title))
        unicodeTitle = PyUnicode_FromObject(pyvar_Title);
    else if (PyUnicode_Check(pyvar_Title))
    {
        unicodeTitle = pyvar_Title;
        Py_INCREF(unicodeTitle);
    }
    else if (pyvar_Title != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Title at index 0");
    if (unicodeTitle)
        bsTitle = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeTitle), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeTitle));
    
    if (PyErr_Occurred())
      goto imessagedialog_domodal_method_cleanup;
    
    if (PyString_Check(pyvar_Message))
        unicodeMessage = PyUnicode_FromObject(pyvar_Message);
    else if (PyUnicode_Check(pyvar_Message))
    {
        unicodeMessage = pyvar_Message;
        Py_INCREF(unicodeMessage);
    }
    else if (pyvar_Message != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Message at index 1");
    if (unicodeMessage)
        bsMessage = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeMessage), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeMessage));
    
    if (PyErr_Occurred())
      goto imessagedialog_domodal_method_cleanup;
    
    if (PyString_Check(pyvar_OKButtonMessage))
        unicodeOKButtonMessage = PyUnicode_FromObject(pyvar_OKButtonMessage);
    else if (PyUnicode_Check(pyvar_OKButtonMessage))
    {
        unicodeOKButtonMessage = pyvar_OKButtonMessage;
        Py_INCREF(unicodeOKButtonMessage);
    }
    else if (pyvar_OKButtonMessage != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter OKButtonMessage at index 2");
    if (unicodeOKButtonMessage)
        bsOKButtonMessage = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeOKButtonMessage), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeOKButtonMessage));
    
    if (PyErr_Occurred())
      goto imessagedialog_domodal_method_cleanup;
    
    if (PyString_Check(pyvar_CANCELButtonMessage))
        unicodeCANCELButtonMessage = PyUnicode_FromObject(pyvar_CANCELButtonMessage);
    else if (PyUnicode_Check(pyvar_CANCELButtonMessage))
    {
        unicodeCANCELButtonMessage = pyvar_CANCELButtonMessage;
        Py_INCREF(unicodeCANCELButtonMessage);
    }
    else if (pyvar_CANCELButtonMessage != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter CANCELButtonMessage at index 3");
    if (unicodeCANCELButtonMessage)
        bsCANCELButtonMessage = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeCANCELButtonMessage), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeCANCELButtonMessage));
    
    if (PyErr_Occurred())
      goto imessagedialog_domodal_method_cleanup;
    
    // No setup for hWnd
    // No setup for okPressed

    // Call method on actual COM interface
    hr = self->m_pIMessageDialog->DoModal(bsTitle, bsMessage, bsOKButtonMessage, bsCANCELButtonMessage, HhWnd, &b_okPressed);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIMessageDialog->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IMessageDialog) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IMessageDialog.DoModal() returned %ld", (long)hr);
        goto imessagedialog_domodal_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Title
    // No teardown for Message
    // No teardown for OKButtonMessage
    // No teardown for CANCELButtonMessage
    // No teardown for hWnd
    pyvar_okPressed = ((b_okPressed == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto imessagedialog_domodal_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_okPressed);
    goto imessagedialog_domodal_method_cleanup;

    imessagedialog_domodal_method_cleanup:
    self->m_HR = hr;
    if (bsTitle)
        ::SysFreeString(bsTitle);
    
    if (bsMessage)
        ::SysFreeString(bsMessage);
    
    if (bsOKButtonMessage)
        ::SysFreeString(bsOKButtonMessage);
    
    if (bsCANCELButtonMessage)
        ::SysFreeString(bsCANCELButtonMessage);
    
    // No cleanup for hWnd
    // No cleanup for okPressed
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IMessageDialog.DoModal");
    return return_tuple;
}


PyMethodDef PyIMessageDialogMethods[] = {
    {"supports", (PyCFunction)PyIMessageDialog_SupportsInterface, METH_O, ""},
    {"DoModal", (PyCFunction)IMessageDialogMethod_DoModal, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIMessageDialogGetSet[] = {
  {"_pUnk", (getter)PyIMessageDialog_GetpUnk, NULL, "Get opaque pointer to an Unknown from IMessageDialog", NULL},
  {"_pointer", (getter)PyIMessageDialog_GetPointer, NULL, "Get memory address for IMessageDialog", NULL},
  {"_IID", (getter)PyIMessageDialog_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIMessageDialog_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIMessageDialog_GetIgnoreFailures, (setter)PyIMessageDialog_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIMessageDialogObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriFramework.IMessageDialogObject",                          
                                              /* tp_name */
  sizeof(PyIMessageDialogObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIMessageDialogObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIMessageDialogMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIMessageDialogGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIMessageDialogObject_new,                      
                                              /* tp_new */
};

// Interface ICoordinateDialog

typedef struct PyICoordinateDialogObject {
    PyObject_HEAD
    ICoordinateDialog* m_pICoordinateDialog;
    HRESULT m_HR;
    int m_ignore_failures;
} PyICoordinateDialogObject;

static PyObject*
PyICoordinateDialogObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyICoordinateDialogObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ICoordinateDialog* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ICoordinateDialog, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ICoordinateDialog with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyICoordinateDialogObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ICoordinateDialog");
            return NULL;
        }
        self->m_pICoordinateDialog = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ICoordinateDialog");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ICoordinateDialog");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ICoordinateDialog* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ICoordinateDialog, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ICoordinateDialog");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyICoordinateDialogObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ICoordinateDialog");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pICoordinateDialog = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyICoordinateDialogObject_dealloc(PyICoordinateDialogObject* self)
{
    if (self->m_pICoordinateDialog)
        self->m_pICoordinateDialog->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyICoordinateDialog_GetpUnk(PyICoordinateDialogObject* self)
{
    if (!self->m_pICoordinateDialog)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pICoordinateDialog->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ICoordinateDialog to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyICoordinateDialog_GetPointer(PyICoordinateDialogObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pICoordinateDialog);
}

static PyObject*
PyICoordinateDialog_GetIID(PyICoordinateDialogObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "759f7b9b-e07d-11d1-aa87-00c04fa374bd");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyICoordinateDialog_GetHR(PyICoordinateDialogObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyICoordinateDialog_GetIgnoreFailures(PyICoordinateDialogObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyICoordinateDialog_SetIgnoreFailures(PyICoordinateDialogObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyICoordinateDialog_SupportsInterface(PyICoordinateDialogObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pICoordinateDialog->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ICoordinateDialogMethod_get_X(PyICoordinateDialogObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dval = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for val

    // Call method on actual COM interface
    hr = self->m_pICoordinateDialog->get_X(&dval);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICoordinateDialog->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICoordinateDialog) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICoordinateDialog.get_X() returned %ld", (long)hr);
        goto icoordinatedialog_get_x_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for val

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dval);
    goto icoordinatedialog_get_x_method_cleanup;

    icoordinatedialog_get_x_method_cleanup:
    self->m_HR = hr;
    // No cleanup for val
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICoordinateDialog.get_X");
    return return_tuple;
}

static PyObject*
ICoordinateDialogMethod_get_Y(PyICoordinateDialogObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    double dval = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for val

    // Call method on actual COM interface
    hr = self->m_pICoordinateDialog->get_Y(&dval);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICoordinateDialog->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICoordinateDialog) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICoordinateDialog.get_Y() returned %ld", (long)hr);
        goto icoordinatedialog_get_y_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for val

    // Initialize output tuple
    return_tuple = Py_BuildValue("d",
                                            dval);
    goto icoordinatedialog_get_y_method_cleanup;

    icoordinatedialog_get_y_method_cleanup:
    self->m_HR = hr;
    // No cleanup for val
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICoordinateDialog.get_Y");
    return return_tuple;
}

static PyObject*
ICoordinateDialogMethod_DoModal(PyICoordinateDialogObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsTitle = 0;
    PyObject* pyvar_Title;
    PyObject* unicodeTitle = NULL;
    double dinitialX = 0;
    double dinitialY = 0;
    long lnumDecs = 0;
    OLE_HANDLE HhWnd = 0;
    VARIANT_BOOL b_okPressed = VARIANT_FALSE;
    PyObject* pyvar_okPressed = Py_False;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OddlI", &pyvar_Title, &dinitialX, &dinitialY, &lnumDecs, &HhWnd))
      goto icoordinatedialog_domodal_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_Title))
        unicodeTitle = PyUnicode_FromObject(pyvar_Title);
    else if (PyUnicode_Check(pyvar_Title))
    {
        unicodeTitle = pyvar_Title;
        Py_INCREF(unicodeTitle);
    }
    else if (pyvar_Title != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Title at index 0");
    if (unicodeTitle)
        bsTitle = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeTitle), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeTitle));
    
    if (PyErr_Occurred())
      goto icoordinatedialog_domodal_method_cleanup;
    
    // No setup for initialX
    // No setup for initialY
    // No setup for numDecs
    // No setup for hWnd
    // No setup for okPressed

    // Call method on actual COM interface
    hr = self->m_pICoordinateDialog->DoModal(bsTitle, dinitialX, dinitialY, lnumDecs, HhWnd, &b_okPressed);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICoordinateDialog->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICoordinateDialog) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICoordinateDialog.DoModal() returned %ld", (long)hr);
        goto icoordinatedialog_domodal_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Title
    // No teardown for initialX
    // No teardown for initialY
    // No teardown for numDecs
    // No teardown for hWnd
    pyvar_okPressed = ((b_okPressed == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto icoordinatedialog_domodal_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_okPressed);
    goto icoordinatedialog_domodal_method_cleanup;

    icoordinatedialog_domodal_method_cleanup:
    self->m_HR = hr;
    if (bsTitle)
        ::SysFreeString(bsTitle);
    
    // No cleanup for initialX
    // No cleanup for initialY
    // No cleanup for numDecs
    // No cleanup for hWnd
    // No cleanup for okPressed
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICoordinateDialog.DoModal");
    return return_tuple;
}


PyMethodDef PyICoordinateDialogMethods[] = {
    {"supports", (PyCFunction)PyICoordinateDialog_SupportsInterface, METH_O, ""},
    {"get_X", (PyCFunction)ICoordinateDialogMethod_get_X, METH_VARARGS, ""},
    {"get_Y", (PyCFunction)ICoordinateDialogMethod_get_Y, METH_VARARGS, ""},
    {"DoModal", (PyCFunction)ICoordinateDialogMethod_DoModal, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyICoordinateDialogGetSet[] = {
  {"_pUnk", (getter)PyICoordinateDialog_GetpUnk, NULL, "Get opaque pointer to an Unknown from ICoordinateDialog", NULL},
  {"_pointer", (getter)PyICoordinateDialog_GetPointer, NULL, "Get memory address for ICoordinateDialog", NULL},
  {"_IID", (getter)PyICoordinateDialog_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyICoordinateDialog_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyICoordinateDialog_GetIgnoreFailures, (setter)PyICoordinateDialog_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyICoordinateDialogObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriFramework.ICoordinateDialogObject",                          
                                              /* tp_name */
  sizeof(PyICoordinateDialogObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyICoordinateDialogObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyICoordinateDialogMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyICoordinateDialogGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyICoordinateDialogObject_new,                      
                                              /* tp_new */
};

// Interface IProgressDialog2

typedef struct PyIProgressDialog2Object {
    PyObject_HEAD
    IProgressDialog2* m_pIProgressDialog2;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIProgressDialog2Object;

static PyObject*
PyIProgressDialog2Object_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIProgressDialog2Object* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IProgressDialog2* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IProgressDialog2, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IProgressDialog2 with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIProgressDialog2Object *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IProgressDialog2");
            return NULL;
        }
        self->m_pIProgressDialog2 = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IProgressDialog2");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IProgressDialog2");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IProgressDialog2* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IProgressDialog2, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IProgressDialog2");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIProgressDialog2Object *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IProgressDialog2");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIProgressDialog2 = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIProgressDialog2Object_dealloc(PyIProgressDialog2Object* self)
{
    if (self->m_pIProgressDialog2)
        self->m_pIProgressDialog2->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIProgressDialog2_GetpUnk(PyIProgressDialog2Object* self)
{
    if (!self->m_pIProgressDialog2)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIProgressDialog2->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IProgressDialog2 to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIProgressDialog2_GetPointer(PyIProgressDialog2Object* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIProgressDialog2);
}

static PyObject*
PyIProgressDialog2_GetIID(PyIProgressDialog2Object* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "0e21fd01-1dc9-4230-95cd-64ee2c4266a1");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIProgressDialog2_GetHR(PyIProgressDialog2Object* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIProgressDialog2_GetIgnoreFailures(PyIProgressDialog2Object* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIProgressDialog2_SetIgnoreFailures(PyIProgressDialog2Object* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIProgressDialog2_SupportsInterface(PyIProgressDialog2Object* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIProgressDialog2->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IProgressDialog2Method_ShowDialog(PyIProgressDialog2Object* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pIProgressDialog2->ShowDialog();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIProgressDialog2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IProgressDialog2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IProgressDialog2.ShowDialog() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}

static PyObject*
IProgressDialog2Method_HideDialog(PyIProgressDialog2Object* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pIProgressDialog2->HideDialog();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIProgressDialog2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IProgressDialog2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IProgressDialog2.HideDialog() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}

static PyObject*
IProgressDialog2Method_get_CancelEnabled(PyIProgressDialog2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_bVal = VARIANT_FALSE;
    PyObject* pyvar_bVal = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for bVal

    // Call method on actual COM interface
    hr = self->m_pIProgressDialog2->get_CancelEnabled(&b_bVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIProgressDialog2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IProgressDialog2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IProgressDialog2.get_CancelEnabled() returned %ld", (long)hr);
        goto iprogressdialog2_get_cancelenabled_method_cleanup;
    }

    // Set up return values as needed
    pyvar_bVal = ((b_bVal == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto iprogressdialog2_get_cancelenabled_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_bVal);
    goto iprogressdialog2_get_cancelenabled_method_cleanup;

    iprogressdialog2_get_cancelenabled_method_cleanup:
    self->m_HR = hr;
    // No cleanup for bVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IProgressDialog2.get_CancelEnabled");
    return return_tuple;
}

static PyObject*
IProgressDialog2Method_put_CancelEnabled(PyIProgressDialog2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_bVal = VARIANT_FALSE;
    PyObject* pyvar_bVal = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_bVal))
      goto iprogressdialog2_put_cancelenabled_method_cleanup;

    // Set up initial variable values as needed
    b_bVal = ((PyObject_IsTrue(pyvar_bVal) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iprogressdialog2_put_cancelenabled_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIProgressDialog2->put_CancelEnabled(b_bVal);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIProgressDialog2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IProgressDialog2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IProgressDialog2.put_CancelEnabled() returned %ld", (long)hr);
        goto iprogressdialog2_put_cancelenabled_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for bVal

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iprogressdialog2_put_cancelenabled_method_cleanup;

    iprogressdialog2_put_cancelenabled_method_cleanup:
    self->m_HR = hr;
    // No cleanup for bVal
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IProgressDialog2.put_CancelEnabled");
    return return_tuple;
}

static PyObject*
IProgressDialog2Method_put_Description(PyIProgressDialog2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsstatus = 0;
    PyObject* pyvar_status;
    PyObject* unicodestatus = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_status))
      goto iprogressdialog2_put_description_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_status))
        unicodestatus = PyUnicode_FromObject(pyvar_status);
    else if (PyUnicode_Check(pyvar_status))
    {
        unicodestatus = pyvar_status;
        Py_INCREF(unicodestatus);
    }
    else if (pyvar_status != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter status at index 0");
    if (unicodestatus)
        bsstatus = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodestatus), 
                                            (UINT)PyUnicode_GET_SIZE(unicodestatus));
    
    if (PyErr_Occurred())
      goto iprogressdialog2_put_description_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIProgressDialog2->put_Description(bsstatus);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIProgressDialog2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IProgressDialog2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IProgressDialog2.put_Description() returned %ld", (long)hr);
        goto iprogressdialog2_put_description_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for status

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iprogressdialog2_put_description_method_cleanup;

    iprogressdialog2_put_description_method_cleanup:
    self->m_HR = hr;
    if (bsstatus)
        ::SysFreeString(bsstatus);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IProgressDialog2.put_Description");
    return return_tuple;
}

static PyObject*
IProgressDialog2Method_get_Description(PyIProgressDialog2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsstatus;
    PyObject* pyvar_status = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for status

    // Call method on actual COM interface
    hr = self->m_pIProgressDialog2->get_Description(&bsstatus);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIProgressDialog2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IProgressDialog2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IProgressDialog2.get_Description() returned %ld", (long)hr);
        goto iprogressdialog2_get_description_method_cleanup;
    }

    // Set up return values as needed
    pyvar_status = PyUnicode_FromWideChar(bsstatus,::SysStringLen(bsstatus));
    ::SysFreeString(bsstatus);
    
    if (PyErr_Occurred())
      goto iprogressdialog2_get_description_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_status);
    goto iprogressdialog2_get_description_method_cleanup;

    iprogressdialog2_get_description_method_cleanup:
    self->m_HR = hr;
    if (pyvar_status != Py_None)
        Py_XDECREF(pyvar_status);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IProgressDialog2.get_Description");
    return return_tuple;
}

static PyObject*
IProgressDialog2Method_put_Title(PyIProgressDialog2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsTitle = 0;
    PyObject* pyvar_Title;
    PyObject* unicodeTitle = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_Title))
      goto iprogressdialog2_put_title_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_Title))
        unicodeTitle = PyUnicode_FromObject(pyvar_Title);
    else if (PyUnicode_Check(pyvar_Title))
    {
        unicodeTitle = pyvar_Title;
        Py_INCREF(unicodeTitle);
    }
    else if (pyvar_Title != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Title at index 0");
    if (unicodeTitle)
        bsTitle = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeTitle), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeTitle));
    
    if (PyErr_Occurred())
      goto iprogressdialog2_put_title_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIProgressDialog2->put_Title(bsTitle);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIProgressDialog2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IProgressDialog2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IProgressDialog2.put_Title() returned %ld", (long)hr);
        goto iprogressdialog2_put_title_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Title

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iprogressdialog2_put_title_method_cleanup;

    iprogressdialog2_put_title_method_cleanup:
    self->m_HR = hr;
    if (bsTitle)
        ::SysFreeString(bsTitle);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IProgressDialog2.put_Title");
    return return_tuple;
}

static PyObject*
IProgressDialog2Method_get_Title(PyIProgressDialog2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsTitle;
    PyObject* pyvar_Title = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Title

    // Call method on actual COM interface
    hr = self->m_pIProgressDialog2->get_Title(&bsTitle);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIProgressDialog2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IProgressDialog2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IProgressDialog2.get_Title() returned %ld", (long)hr);
        goto iprogressdialog2_get_title_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Title = PyUnicode_FromWideChar(bsTitle,::SysStringLen(bsTitle));
    ::SysFreeString(bsTitle);
    
    if (PyErr_Occurred())
      goto iprogressdialog2_get_title_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Title);
    goto iprogressdialog2_get_title_method_cleanup;

    iprogressdialog2_get_title_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Title != Py_None)
        Py_XDECREF(pyvar_Title);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IProgressDialog2.get_Title");
    return return_tuple;
}

static PyObject*
IProgressDialog2Method_put_Animation(PyIProgressDialog2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriProgressAnimationTypes eType;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&eType))
      goto iprogressdialog2_put_animation_method_cleanup;

    // Set up initial variable values as needed
    // No setup for Type

    // Call method on actual COM interface
    hr = self->m_pIProgressDialog2->put_Animation(eType);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIProgressDialog2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IProgressDialog2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IProgressDialog2.put_Animation() returned %ld", (long)hr);
        goto iprogressdialog2_put_animation_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Type

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iprogressdialog2_put_animation_method_cleanup;

    iprogressdialog2_put_animation_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Type
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IProgressDialog2.put_Animation");
    return return_tuple;
}

static PyObject*
IProgressDialog2Method_get_Animation(PyIProgressDialog2Object* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriProgressAnimationTypes eType;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Type

    // Call method on actual COM interface
    hr = self->m_pIProgressDialog2->get_Animation(&eType);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIProgressDialog2->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IProgressDialog2) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IProgressDialog2.get_Animation() returned %ld", (long)hr);
        goto iprogressdialog2_get_animation_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Type

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)eType);
    goto iprogressdialog2_get_animation_method_cleanup;

    iprogressdialog2_get_animation_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Type
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IProgressDialog2.get_Animation");
    return return_tuple;
}


PyMethodDef PyIProgressDialog2Methods[] = {
    {"supports", (PyCFunction)PyIProgressDialog2_SupportsInterface, METH_O, ""},
    {"ShowDialog", (PyCFunction)IProgressDialog2Method_ShowDialog, METH_NOARGS, ""},
    {"HideDialog", (PyCFunction)IProgressDialog2Method_HideDialog, METH_NOARGS, ""},
    {"get_CancelEnabled", (PyCFunction)IProgressDialog2Method_get_CancelEnabled, METH_VARARGS, ""},
    {"put_CancelEnabled", (PyCFunction)IProgressDialog2Method_put_CancelEnabled, METH_VARARGS, ""},
    {"put_Description", (PyCFunction)IProgressDialog2Method_put_Description, METH_VARARGS, ""},
    {"get_Description", (PyCFunction)IProgressDialog2Method_get_Description, METH_VARARGS, ""},
    {"put_Title", (PyCFunction)IProgressDialog2Method_put_Title, METH_VARARGS, ""},
    {"get_Title", (PyCFunction)IProgressDialog2Method_get_Title, METH_VARARGS, ""},
    {"put_Animation", (PyCFunction)IProgressDialog2Method_put_Animation, METH_VARARGS, ""},
    {"get_Animation", (PyCFunction)IProgressDialog2Method_get_Animation, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIProgressDialog2GetSet[] = {
  {"_pUnk", (getter)PyIProgressDialog2_GetpUnk, NULL, "Get opaque pointer to an Unknown from IProgressDialog2", NULL},
  {"_pointer", (getter)PyIProgressDialog2_GetPointer, NULL, "Get memory address for IProgressDialog2", NULL},
  {"_IID", (getter)PyIProgressDialog2_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIProgressDialog2_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIProgressDialog2_GetIgnoreFailures, (setter)PyIProgressDialog2_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIProgressDialog2Object_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriFramework.IProgressDialog2Object",                          
                                              /* tp_name */
  sizeof(PyIProgressDialog2Object),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIProgressDialog2Object_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIProgressDialog2Methods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIProgressDialog2GetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIProgressDialog2Object_new,                      
                                              /* tp_new */
};

// Interface IProgressDialogFactory

typedef struct PyIProgressDialogFactoryObject {
    PyObject_HEAD
    IProgressDialogFactory* m_pIProgressDialogFactory;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIProgressDialogFactoryObject;

static PyObject*
PyIProgressDialogFactoryObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIProgressDialogFactoryObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IProgressDialogFactory* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IProgressDialogFactory, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IProgressDialogFactory with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIProgressDialogFactoryObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IProgressDialogFactory");
            return NULL;
        }
        self->m_pIProgressDialogFactory = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IProgressDialogFactory");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IProgressDialogFactory");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IProgressDialogFactory* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IProgressDialogFactory, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IProgressDialogFactory");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIProgressDialogFactoryObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IProgressDialogFactory");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIProgressDialogFactory = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIProgressDialogFactoryObject_dealloc(PyIProgressDialogFactoryObject* self)
{
    if (self->m_pIProgressDialogFactory)
        self->m_pIProgressDialogFactory->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIProgressDialogFactory_GetpUnk(PyIProgressDialogFactoryObject* self)
{
    if (!self->m_pIProgressDialogFactory)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIProgressDialogFactory->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IProgressDialogFactory to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIProgressDialogFactory_GetPointer(PyIProgressDialogFactoryObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIProgressDialogFactory);
}

static PyObject*
PyIProgressDialogFactory_GetIID(PyIProgressDialogFactoryObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "31a6aeb1-f644-11d1-a248-080009b6f22b");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIProgressDialogFactory_GetHR(PyIProgressDialogFactoryObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIProgressDialogFactory_GetIgnoreFailures(PyIProgressDialogFactoryObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIProgressDialogFactory_SetIgnoreFailures(PyIProgressDialogFactoryObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIProgressDialogFactory_SupportsInterface(PyIProgressDialogFactoryObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIProgressDialogFactory->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IProgressDialogFactoryMethod_Create(PyIProgressDialogFactoryObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ITrackCancel* iptrackCancel = NULL;
    PyObject* py_trackCancel;
    OLE_HANDLE HhWnd = 0;
    IStepProgressor* ipstepProgressor = NULL;
    PyObject* py_stepProgressor = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OI", &py_trackCancel, &HhWnd))
      goto iprogressdialogfactory_create_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_trackCancel, &IID_ITrackCancel, (void**)&iptrackCancel))
        PyErr_SetString(PyExc_TypeError, "Argument trackCancel (position 0) is not ITrackCancel");
    
    if (PyErr_Occurred())
      goto iprogressdialogfactory_create_method_cleanup;
    
    // No setup for hWnd
    // No setup for stepProgressor

    // Call method on actual COM interface
    hr = self->m_pIProgressDialogFactory->Create(iptrackCancel, HhWnd, &ipstepProgressor);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIProgressDialogFactory->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IProgressDialogFactory) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IProgressDialogFactory.Create() returned %ld", (long)hr);
        goto iprogressdialogfactory_create_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for trackCancel
    // No teardown for hWnd
    Py_XDECREF(py_stepProgressor);
    if (ipstepProgressor)
    {
        IUnknown* pUnk = NULL;
        ipstepProgressor->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_stepProgressor = IUnknownToPythonIIDObject(pUnk, &IID_IStepProgressor);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_stepProgressor)
    {
        if (py_stepProgressor)
           Py_DECREF(py_stepProgressor);
        py_stepProgressor = Py_None;
        Py_INCREF(py_stepProgressor);
    }
    if (PyErr_Occurred())
      goto iprogressdialogfactory_create_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_stepProgressor);
    goto iprogressdialogfactory_create_method_cleanup;

    iprogressdialogfactory_create_method_cleanup:
    self->m_HR = hr;
    if (iptrackCancel)
      iptrackCancel->Release();
    // No cleanup for hWnd
    Py_XDECREF(py_stepProgressor);
    if (ipstepProgressor)
      ipstepProgressor->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IProgressDialogFactory.Create");
    return return_tuple;
}


PyMethodDef PyIProgressDialogFactoryMethods[] = {
    {"supports", (PyCFunction)PyIProgressDialogFactory_SupportsInterface, METH_O, ""},
    {"Create", (PyCFunction)IProgressDialogFactoryMethod_Create, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIProgressDialogFactoryGetSet[] = {
  {"_pUnk", (getter)PyIProgressDialogFactory_GetpUnk, NULL, "Get opaque pointer to an Unknown from IProgressDialogFactory", NULL},
  {"_pointer", (getter)PyIProgressDialogFactory_GetPointer, NULL, "Get memory address for IProgressDialogFactory", NULL},
  {"_IID", (getter)PyIProgressDialogFactory_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIProgressDialogFactory_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIProgressDialogFactory_GetIgnoreFailures, (setter)PyIProgressDialogFactory_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIProgressDialogFactoryObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriFramework.IProgressDialogFactoryObject",                          
                                              /* tp_name */
  sizeof(PyIProgressDialogFactoryObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIProgressDialogFactoryObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIProgressDialogFactoryMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIProgressDialogFactoryGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIProgressDialogFactoryObject_new,                      
                                              /* tp_new */
};

// Interface IListDialog

typedef struct PyIListDialogObject {
    PyObject_HEAD
    IListDialog* m_pIListDialog;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIListDialogObject;

static PyObject*
PyIListDialogObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIListDialogObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IListDialog* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IListDialog, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IListDialog with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIListDialogObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IListDialog");
            return NULL;
        }
        self->m_pIListDialog = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IListDialog");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IListDialog");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IListDialog* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IListDialog, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IListDialog");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIListDialogObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IListDialog");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIListDialog = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIListDialogObject_dealloc(PyIListDialogObject* self)
{
    if (self->m_pIListDialog)
        self->m_pIListDialog->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIListDialog_GetpUnk(PyIListDialogObject* self)
{
    if (!self->m_pIListDialog)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIListDialog->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IListDialog to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIListDialog_GetPointer(PyIListDialogObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIListDialog);
}

static PyObject*
PyIListDialog_GetIID(PyIListDialogObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "5f399a16-0b7d-11d2-8c1e-0000f8774f55");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIListDialog_GetHR(PyIListDialogObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIListDialog_GetIgnoreFailures(PyIListDialogObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIListDialog_SetIgnoreFailures(PyIListDialogObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIListDialog_SupportsInterface(PyIListDialogObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIListDialog->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IListDialogMethod_AddString(PyIListDialogObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsChoice = 0;
    PyObject* pyvar_Choice;
    PyObject* unicodeChoice = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_Choice))
      goto ilistdialog_addstring_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_Choice))
        unicodeChoice = PyUnicode_FromObject(pyvar_Choice);
    else if (PyUnicode_Check(pyvar_Choice))
    {
        unicodeChoice = pyvar_Choice;
        Py_INCREF(unicodeChoice);
    }
    else if (pyvar_Choice != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Choice at index 0");
    if (unicodeChoice)
        bsChoice = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeChoice), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeChoice));
    
    if (PyErr_Occurred())
      goto ilistdialog_addstring_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIListDialog->AddString(bsChoice);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIListDialog->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IListDialog) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IListDialog.AddString() returned %ld", (long)hr);
        goto ilistdialog_addstring_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Choice

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ilistdialog_addstring_method_cleanup;

    ilistdialog_addstring_method_cleanup:
    self->m_HR = hr;
    if (bsChoice)
        ::SysFreeString(bsChoice);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IListDialog.AddString");
    return return_tuple;
}

static PyObject*
IListDialogMethod_get_Choice(PyIListDialogObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lIndex = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Index

    // Call method on actual COM interface
    hr = self->m_pIListDialog->get_Choice(&lIndex);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIListDialog->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IListDialog) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IListDialog.get_Choice() returned %ld", (long)hr);
        goto ilistdialog_get_choice_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Index

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lIndex);
    goto ilistdialog_get_choice_method_cleanup;

    ilistdialog_get_choice_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Index
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IListDialog.get_Choice");
    return return_tuple;
}

static PyObject*
IListDialogMethod_DoModal(PyIListDialogObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsTitle = 0;
    PyObject* pyvar_Title;
    PyObject* unicodeTitle = NULL;
    long linitialChoice = 0;
    OLE_HANDLE HhWnd = 0;
    VARIANT_BOOL b_pOK = VARIANT_FALSE;
    PyObject* pyvar_pOK = Py_False;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OlI", &pyvar_Title, &linitialChoice, &HhWnd))
      goto ilistdialog_domodal_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_Title))
        unicodeTitle = PyUnicode_FromObject(pyvar_Title);
    else if (PyUnicode_Check(pyvar_Title))
    {
        unicodeTitle = pyvar_Title;
        Py_INCREF(unicodeTitle);
    }
    else if (pyvar_Title != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Title at index 0");
    if (unicodeTitle)
        bsTitle = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeTitle), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeTitle));
    
    if (PyErr_Occurred())
      goto ilistdialog_domodal_method_cleanup;
    
    // No setup for initialChoice
    // No setup for hWnd
    // No setup for pOK

    // Call method on actual COM interface
    hr = self->m_pIListDialog->DoModal(bsTitle, linitialChoice, HhWnd, &b_pOK);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIListDialog->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IListDialog) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IListDialog.DoModal() returned %ld", (long)hr);
        goto ilistdialog_domodal_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Title
    // No teardown for initialChoice
    // No teardown for hWnd
    pyvar_pOK = ((b_pOK == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto ilistdialog_domodal_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pOK);
    goto ilistdialog_domodal_method_cleanup;

    ilistdialog_domodal_method_cleanup:
    self->m_HR = hr;
    if (bsTitle)
        ::SysFreeString(bsTitle);
    
    // No cleanup for initialChoice
    // No cleanup for hWnd
    // No cleanup for pOK
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IListDialog.DoModal");
    return return_tuple;
}


PyMethodDef PyIListDialogMethods[] = {
    {"supports", (PyCFunction)PyIListDialog_SupportsInterface, METH_O, ""},
    {"AddString", (PyCFunction)IListDialogMethod_AddString, METH_VARARGS, ""},
    {"get_Choice", (PyCFunction)IListDialogMethod_get_Choice, METH_VARARGS, ""},
    {"DoModal", (PyCFunction)IListDialogMethod_DoModal, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIListDialogGetSet[] = {
  {"_pUnk", (getter)PyIListDialog_GetpUnk, NULL, "Get opaque pointer to an Unknown from IListDialog", NULL},
  {"_pointer", (getter)PyIListDialog_GetPointer, NULL, "Get memory address for IListDialog", NULL},
  {"_IID", (getter)PyIListDialog_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIListDialog_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIListDialog_GetIgnoreFailures, (setter)PyIListDialog_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIListDialogObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriFramework.IListDialogObject",                          
                                              /* tp_name */
  sizeof(PyIListDialogObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIListDialogObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIListDialogMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIListDialogGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIListDialogObject_new,                      
                                              /* tp_new */
};

// Interface IStyleSelector

typedef struct PyIStyleSelectorObject {
    PyObject_HEAD
    IStyleSelector* m_pIStyleSelector;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIStyleSelectorObject;

static PyObject*
PyIStyleSelectorObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIStyleSelectorObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IStyleSelector* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IStyleSelector, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IStyleSelector with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIStyleSelectorObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IStyleSelector");
            return NULL;
        }
        self->m_pIStyleSelector = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IStyleSelector");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IStyleSelector");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IStyleSelector* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IStyleSelector, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IStyleSelector");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIStyleSelectorObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IStyleSelector");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIStyleSelector = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIStyleSelectorObject_dealloc(PyIStyleSelectorObject* self)
{
    if (self->m_pIStyleSelector)
        self->m_pIStyleSelector->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIStyleSelector_GetpUnk(PyIStyleSelectorObject* self)
{
    if (!self->m_pIStyleSelector)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIStyleSelector->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IStyleSelector to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIStyleSelector_GetPointer(PyIStyleSelectorObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIStyleSelector);
}

static PyObject*
PyIStyleSelector_GetIID(PyIStyleSelectorObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "c98e418d-78e7-11d2-87d4-0000f8751720");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIStyleSelector_GetHR(PyIStyleSelectorObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIStyleSelector_GetIgnoreFailures(PyIStyleSelectorObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIStyleSelector_SetIgnoreFailures(PyIStyleSelectorObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIStyleSelector_SupportsInterface(PyIStyleSelectorObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIStyleSelector->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IStyleSelectorMethod_AddStyle(PyIStyleSelectorObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IUnknown* ipStyle = NULL;
    PyObject* py_Style;
    VARIANT_BOOL b_result = VARIANT_FALSE;
    PyObject* pyvar_result = Py_False;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_Style))
      goto istyleselector_addstyle_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_Style, &IID_IUnknown, (void**)&ipStyle))
        PyErr_SetString(PyExc_TypeError, "Argument Style (position 0) is not IUnknown");
    
    if (PyErr_Occurred())
      goto istyleselector_addstyle_method_cleanup;
    
    // No setup for result

    // Call method on actual COM interface
    hr = self->m_pIStyleSelector->AddStyle(ipStyle, &b_result);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIStyleSelector->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IStyleSelector) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IStyleSelector.AddStyle() returned %ld", (long)hr);
        goto istyleselector_addstyle_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Style
    pyvar_result = ((b_result == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto istyleselector_addstyle_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_result);
    goto istyleselector_addstyle_method_cleanup;

    istyleselector_addstyle_method_cleanup:
    self->m_HR = hr;
    if (ipStyle)
      ipStyle->Release();
    // No cleanup for result
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IStyleSelector.AddStyle");
    return return_tuple;
}

static PyObject*
IStyleSelectorMethod_GetStyle(PyIStyleSelectorObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lIndex = 0;
    IUnknown* ipStyle = NULL;
    PyObject* py_Style = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lIndex))
      goto istyleselector_getstyle_method_cleanup;

    // Set up initial variable values as needed
    // No setup for Index
    // No setup for Style

    // Call method on actual COM interface
    hr = self->m_pIStyleSelector->GetStyle(lIndex, &ipStyle);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIStyleSelector->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IStyleSelector) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IStyleSelector.GetStyle() returned %ld", (long)hr);
        goto istyleselector_getstyle_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Index
    Py_XDECREF(py_Style);
    if (ipStyle)
    {
        IUnknown* pUnk = NULL;
        ipStyle->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_Style = IUnknownToPythonIIDObject(pUnk, &IID_IUnknown);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_Style)
    {
        if (py_Style)
           Py_DECREF(py_Style);
        py_Style = Py_None;
        Py_INCREF(py_Style);
    }
    if (PyErr_Occurred())
      goto istyleselector_getstyle_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_Style);
    goto istyleselector_getstyle_method_cleanup;

    istyleselector_getstyle_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Index
    Py_XDECREF(py_Style);
    if (ipStyle)
      ipStyle->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IStyleSelector.GetStyle");
    return return_tuple;
}

static PyObject*
IStyleSelectorMethod_DoModal(PyIStyleSelectorObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    OLE_HANDLE HparentHWnd = 0;
    VARIANT_BOOL b_ok = VARIANT_FALSE;
    PyObject* pyvar_ok = Py_False;

    // Unpack values
    if (!PyArg_ParseTuple(args, "I", &HparentHWnd))
      goto istyleselector_domodal_method_cleanup;

    // Set up initial variable values as needed
    // No setup for parentHWnd
    // No setup for ok

    // Call method on actual COM interface
    hr = self->m_pIStyleSelector->DoModal(HparentHWnd, &b_ok);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIStyleSelector->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IStyleSelector) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IStyleSelector.DoModal() returned %ld", (long)hr);
        goto istyleselector_domodal_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for parentHWnd
    pyvar_ok = ((b_ok == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto istyleselector_domodal_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_ok);
    goto istyleselector_domodal_method_cleanup;

    istyleselector_domodal_method_cleanup:
    self->m_HR = hr;
    // No cleanup for parentHWnd
    // No cleanup for ok
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IStyleSelector.DoModal");
    return return_tuple;
}


PyMethodDef PyIStyleSelectorMethods[] = {
    {"supports", (PyCFunction)PyIStyleSelector_SupportsInterface, METH_O, ""},
    {"AddStyle", (PyCFunction)IStyleSelectorMethod_AddStyle, METH_VARARGS, ""},
    {"GetStyle", (PyCFunction)IStyleSelectorMethod_GetStyle, METH_VARARGS, ""},
    {"DoModal", (PyCFunction)IStyleSelectorMethod_DoModal, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIStyleSelectorGetSet[] = {
  {"_pUnk", (getter)PyIStyleSelector_GetpUnk, NULL, "Get opaque pointer to an Unknown from IStyleSelector", NULL},
  {"_pointer", (getter)PyIStyleSelector_GetPointer, NULL, "Get memory address for IStyleSelector", NULL},
  {"_IID", (getter)PyIStyleSelector_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIStyleSelector_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIStyleSelector_GetIgnoreFailures, (setter)PyIStyleSelector_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIStyleSelectorObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriFramework.IStyleSelectorObject",                          
                                              /* tp_name */
  sizeof(PyIStyleSelectorObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIStyleSelectorObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIStyleSelectorMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIStyleSelectorGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIStyleSelectorObject_new,                      
                                              /* tp_new */
};

// Interface IComEmbeddedPropertyPage

typedef struct PyIComEmbeddedPropertyPageObject {
    PyObject_HEAD
    IComEmbeddedPropertyPage* m_pIComEmbeddedPropertyPage;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIComEmbeddedPropertyPageObject;

static PyObject*
PyIComEmbeddedPropertyPageObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIComEmbeddedPropertyPageObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IComEmbeddedPropertyPage* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IComEmbeddedPropertyPage, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IComEmbeddedPropertyPage with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIComEmbeddedPropertyPageObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IComEmbeddedPropertyPage");
            return NULL;
        }
        self->m_pIComEmbeddedPropertyPage = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IComEmbeddedPropertyPage");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IComEmbeddedPropertyPage");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IComEmbeddedPropertyPage* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IComEmbeddedPropertyPage, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IComEmbeddedPropertyPage");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIComEmbeddedPropertyPageObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IComEmbeddedPropertyPage");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIComEmbeddedPropertyPage = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIComEmbeddedPropertyPageObject_dealloc(PyIComEmbeddedPropertyPageObject* self)
{
    if (self->m_pIComEmbeddedPropertyPage)
        self->m_pIComEmbeddedPropertyPage->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIComEmbeddedPropertyPage_GetpUnk(PyIComEmbeddedPropertyPageObject* self)
{
    if (!self->m_pIComEmbeddedPropertyPage)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIComEmbeddedPropertyPage->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IComEmbeddedPropertyPage to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIComEmbeddedPropertyPage_GetPointer(PyIComEmbeddedPropertyPageObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIComEmbeddedPropertyPage);
}

static PyObject*
PyIComEmbeddedPropertyPage_GetIID(PyIComEmbeddedPropertyPageObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "063304c3-7b90-48e9-b2d3-e795a8ba926b");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIComEmbeddedPropertyPage_GetHR(PyIComEmbeddedPropertyPageObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIComEmbeddedPropertyPage_GetIgnoreFailures(PyIComEmbeddedPropertyPageObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIComEmbeddedPropertyPage_SetIgnoreFailures(PyIComEmbeddedPropertyPageObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIComEmbeddedPropertyPage_SupportsInterface(PyIComEmbeddedPropertyPageObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIComEmbeddedPropertyPage->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IComEmbeddedPropertyPageMethod_CreateCompatibleObject(PyIComEmbeddedPropertyPageObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT vkind;
    ::VariantInit(&vkind);
    PyObject* pyvar_kind = NULL;
    VARIANT vpNewObject;
    ::VariantInit(&vpNewObject);
    PyObject* pyvar_pNewObject = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_kind))
      goto icomembeddedpropertypage_createcompatibleobject_method_cleanup;

    // Set up initial variable values as needed
    PyObject_AsVariant(pyvar_kind, &vkind);
    
    if (PyErr_Occurred())
      goto icomembeddedpropertypage_createcompatibleobject_method_cleanup;
    
    // No setup for pNewObject

    // Call method on actual COM interface
    hr = self->m_pIComEmbeddedPropertyPage->CreateCompatibleObject(vkind, &vpNewObject);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIComEmbeddedPropertyPage->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IComEmbeddedPropertyPage) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IComEmbeddedPropertyPage.CreateCompatibleObject() returned %ld", (long)hr);
        goto icomembeddedpropertypage_createcompatibleobject_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for kind
    pyvar_pNewObject = Variant_AsPyObject(&vpNewObject);
    if (PyErr_Occurred())
      goto icomembeddedpropertypage_createcompatibleobject_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pNewObject);
    goto icomembeddedpropertypage_createcompatibleobject_method_cleanup;

    icomembeddedpropertypage_createcompatibleobject_method_cleanup:
    self->m_HR = hr;
    ::VariantClear(&vkind);
    ::VariantClear(&vpNewObject);
    Py_XDECREF(pyvar_pNewObject);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IComEmbeddedPropertyPage.CreateCompatibleObject");
    return return_tuple;
}

static PyObject*
IComEmbeddedPropertyPageMethod_QueryObject(PyIComEmbeddedPropertyPageObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT vtheObject;
    ::VariantInit(&vtheObject);
    PyObject* pyvar_theObject = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_theObject))
      goto icomembeddedpropertypage_queryobject_method_cleanup;

    // Set up initial variable values as needed
    PyObject_AsVariant(pyvar_theObject, &vtheObject);
    
    if (PyErr_Occurred())
      goto icomembeddedpropertypage_queryobject_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIComEmbeddedPropertyPage->QueryObject(vtheObject);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIComEmbeddedPropertyPage->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IComEmbeddedPropertyPage) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IComEmbeddedPropertyPage.QueryObject() returned %ld", (long)hr);
        goto icomembeddedpropertypage_queryobject_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for theObject

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icomembeddedpropertypage_queryobject_method_cleanup;

    icomembeddedpropertypage_queryobject_method_cleanup:
    self->m_HR = hr;
    ::VariantClear(&vtheObject);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IComEmbeddedPropertyPage.QueryObject");
    return return_tuple;
}


PyMethodDef PyIComEmbeddedPropertyPageMethods[] = {
    {"supports", (PyCFunction)PyIComEmbeddedPropertyPage_SupportsInterface, METH_O, ""},
    {"CreateCompatibleObject", (PyCFunction)IComEmbeddedPropertyPageMethod_CreateCompatibleObject, METH_VARARGS, ""},
    {"QueryObject", (PyCFunction)IComEmbeddedPropertyPageMethod_QueryObject, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIComEmbeddedPropertyPageGetSet[] = {
  {"_pUnk", (getter)PyIComEmbeddedPropertyPage_GetpUnk, NULL, "Get opaque pointer to an Unknown from IComEmbeddedPropertyPage", NULL},
  {"_pointer", (getter)PyIComEmbeddedPropertyPage_GetPointer, NULL, "Get memory address for IComEmbeddedPropertyPage", NULL},
  {"_IID", (getter)PyIComEmbeddedPropertyPage_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIComEmbeddedPropertyPage_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIComEmbeddedPropertyPage_GetIgnoreFailures, (setter)PyIComEmbeddedPropertyPage_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIComEmbeddedPropertyPageObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriFramework.IComEmbeddedPropertyPageObject",                          
                                              /* tp_name */
  sizeof(PyIComEmbeddedPropertyPageObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIComEmbeddedPropertyPageObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIComEmbeddedPropertyPageMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIComEmbeddedPropertyPageGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIComEmbeddedPropertyPageObject_new,                      
                                              /* tp_new */
};

// Interface IComPropertyPageObjectFactory

typedef struct PyIComPropertyPageObjectFactoryObject {
    PyObject_HEAD
    IComPropertyPageObjectFactory* m_pIComPropertyPageObjectFactory;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIComPropertyPageObjectFactoryObject;

static PyObject*
PyIComPropertyPageObjectFactoryObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIComPropertyPageObjectFactoryObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IComPropertyPageObjectFactory* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IComPropertyPageObjectFactory, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IComPropertyPageObjectFactory with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIComPropertyPageObjectFactoryObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IComPropertyPageObjectFactory");
            return NULL;
        }
        self->m_pIComPropertyPageObjectFactory = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IComPropertyPageObjectFactory");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IComPropertyPageObjectFactory");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IComPropertyPageObjectFactory* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IComPropertyPageObjectFactory, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IComPropertyPageObjectFactory");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIComPropertyPageObjectFactoryObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IComPropertyPageObjectFactory");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIComPropertyPageObjectFactory = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIComPropertyPageObjectFactoryObject_dealloc(PyIComPropertyPageObjectFactoryObject* self)
{
    if (self->m_pIComPropertyPageObjectFactory)
        self->m_pIComPropertyPageObjectFactory->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIComPropertyPageObjectFactory_GetpUnk(PyIComPropertyPageObjectFactoryObject* self)
{
    if (!self->m_pIComPropertyPageObjectFactory)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIComPropertyPageObjectFactory->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IComPropertyPageObjectFactory to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIComPropertyPageObjectFactory_GetPointer(PyIComPropertyPageObjectFactoryObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIComPropertyPageObjectFactory);
}

static PyObject*
PyIComPropertyPageObjectFactory_GetIID(PyIComPropertyPageObjectFactoryObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "76951cc8-dbb1-11d2-b868-00600802e603");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIComPropertyPageObjectFactory_GetHR(PyIComPropertyPageObjectFactoryObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIComPropertyPageObjectFactory_GetIgnoreFailures(PyIComPropertyPageObjectFactoryObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIComPropertyPageObjectFactory_SetIgnoreFailures(PyIComPropertyPageObjectFactoryObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIComPropertyPageObjectFactory_SupportsInterface(PyIComPropertyPageObjectFactoryObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIComPropertyPageObjectFactory->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IComPropertyPageObjectFactoryMethod_CreateCompatibleObject(PyIComPropertyPageObjectFactoryObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IUnknown* ipobjTemplate = NULL;
    PyObject* py_objTemplate;
    IUnknown* ipppObject = NULL;
    PyObject* py_ppObject = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_objTemplate))
      goto icompropertypageobjectfactory_createcompatibleobject_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_objTemplate, &IID_IUnknown, (void**)&ipobjTemplate))
        PyErr_SetString(PyExc_TypeError, "Argument objTemplate (position 0) is not IUnknown");
    
    if (PyErr_Occurred())
      goto icompropertypageobjectfactory_createcompatibleobject_method_cleanup;
    
    // No setup for ppObject

    // Call method on actual COM interface
    hr = self->m_pIComPropertyPageObjectFactory->CreateCompatibleObject(ipobjTemplate, &ipppObject);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIComPropertyPageObjectFactory->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IComPropertyPageObjectFactory) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IComPropertyPageObjectFactory.CreateCompatibleObject() returned %ld", (long)hr);
        goto icompropertypageobjectfactory_createcompatibleobject_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for objTemplate
    Py_XDECREF(py_ppObject);
    if (ipppObject)
    {
        IUnknown* pUnk = NULL;
        ipppObject->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppObject = IUnknownToPythonIIDObject(pUnk, &IID_IUnknown);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppObject)
    {
        if (py_ppObject)
           Py_DECREF(py_ppObject);
        py_ppObject = Py_None;
        Py_INCREF(py_ppObject);
    }
    if (PyErr_Occurred())
      goto icompropertypageobjectfactory_createcompatibleobject_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppObject);
    goto icompropertypageobjectfactory_createcompatibleobject_method_cleanup;

    icompropertypageobjectfactory_createcompatibleobject_method_cleanup:
    self->m_HR = hr;
    if (ipobjTemplate)
      ipobjTemplate->Release();
    Py_XDECREF(py_ppObject);
    if (ipppObject)
      ipppObject->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IComPropertyPageObjectFactory.CreateCompatibleObject");
    return return_tuple;
}

static PyObject*
IComPropertyPageObjectFactoryMethod_QueryObject(PyIComPropertyPageObjectFactoryObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IUnknown* ipppObject = NULL;
    PyObject* py_ppObject = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ppObject

    // Call method on actual COM interface
    hr = self->m_pIComPropertyPageObjectFactory->QueryObject(&ipppObject);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIComPropertyPageObjectFactory->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IComPropertyPageObjectFactory) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IComPropertyPageObjectFactory.QueryObject() returned %ld", (long)hr);
        goto icompropertypageobjectfactory_queryobject_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ppObject);
    if (ipppObject)
    {
        IUnknown* pUnk = NULL;
        ipppObject->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ppObject = IUnknownToPythonIIDObject(pUnk, &IID_IUnknown);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ppObject)
    {
        if (py_ppObject)
           Py_DECREF(py_ppObject);
        py_ppObject = Py_None;
        Py_INCREF(py_ppObject);
    }
    if (PyErr_Occurred())
      goto icompropertypageobjectfactory_queryobject_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ppObject);
    goto icompropertypageobjectfactory_queryobject_method_cleanup;

    icompropertypageobjectfactory_queryobject_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ppObject);
    if (ipppObject)
      ipppObject->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IComPropertyPageObjectFactory.QueryObject");
    return return_tuple;
}


PyMethodDef PyIComPropertyPageObjectFactoryMethods[] = {
    {"supports", (PyCFunction)PyIComPropertyPageObjectFactory_SupportsInterface, METH_O, ""},
    {"CreateCompatibleObject", (PyCFunction)IComPropertyPageObjectFactoryMethod_CreateCompatibleObject, METH_VARARGS, ""},
    {"QueryObject", (PyCFunction)IComPropertyPageObjectFactoryMethod_QueryObject, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIComPropertyPageObjectFactoryGetSet[] = {
  {"_pUnk", (getter)PyIComPropertyPageObjectFactory_GetpUnk, NULL, "Get opaque pointer to an Unknown from IComPropertyPageObjectFactory", NULL},
  {"_pointer", (getter)PyIComPropertyPageObjectFactory_GetPointer, NULL, "Get memory address for IComPropertyPageObjectFactory", NULL},
  {"_IID", (getter)PyIComPropertyPageObjectFactory_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIComPropertyPageObjectFactory_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIComPropertyPageObjectFactory_GetIgnoreFailures, (setter)PyIComPropertyPageObjectFactory_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIComPropertyPageObjectFactoryObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriFramework.IComPropertyPageObjectFactoryObject",                          
                                              /* tp_name */
  sizeof(PyIComPropertyPageObjectFactoryObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIComPropertyPageObjectFactoryObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIComPropertyPageObjectFactoryMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIComPropertyPageObjectFactoryGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIComPropertyPageObjectFactoryObject_new,                      
                                              /* tp_new */
};

// Interface IComPropertySheet

typedef struct PyIComPropertySheetObject {
    PyObject_HEAD
    IComPropertySheet* m_pIComPropertySheet;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIComPropertySheetObject;

static PyObject*
PyIComPropertySheetObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIComPropertySheetObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IComPropertySheet* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IComPropertySheet, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IComPropertySheet with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIComPropertySheetObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IComPropertySheet");
            return NULL;
        }
        self->m_pIComPropertySheet = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IComPropertySheet");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IComPropertySheet");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IComPropertySheet* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IComPropertySheet, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IComPropertySheet");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIComPropertySheetObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IComPropertySheet");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIComPropertySheet = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIComPropertySheetObject_dealloc(PyIComPropertySheetObject* self)
{
    if (self->m_pIComPropertySheet)
        self->m_pIComPropertySheet->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIComPropertySheet_GetpUnk(PyIComPropertySheetObject* self)
{
    if (!self->m_pIComPropertySheet)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIComPropertySheet->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IComPropertySheet to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIComPropertySheet_GetPointer(PyIComPropertySheetObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIComPropertySheet);
}

static PyObject*
PyIComPropertySheet_GetIID(PyIComPropertySheetObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "76951cc7-dbb1-11d2-b868-00600802e603");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIComPropertySheet_GetHR(PyIComPropertySheetObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIComPropertySheet_GetIgnoreFailures(PyIComPropertySheetObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIComPropertySheet_SetIgnoreFailures(PyIComPropertySheetObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIComPropertySheet_SupportsInterface(PyIComPropertySheetObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIComPropertySheet->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IComPropertySheetMethod_put_Title(PyIComPropertySheetObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsTitle = 0;
    PyObject* pyvar_Title;
    PyObject* unicodeTitle = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_Title))
      goto icompropertysheet_put_title_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_Title))
        unicodeTitle = PyUnicode_FromObject(pyvar_Title);
    else if (PyUnicode_Check(pyvar_Title))
    {
        unicodeTitle = pyvar_Title;
        Py_INCREF(unicodeTitle);
    }
    else if (pyvar_Title != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Title at index 0");
    if (unicodeTitle)
        bsTitle = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeTitle), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeTitle));
    
    if (PyErr_Occurred())
      goto icompropertysheet_put_title_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIComPropertySheet->put_Title(bsTitle);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIComPropertySheet->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IComPropertySheet) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IComPropertySheet.put_Title() returned %ld", (long)hr);
        goto icompropertysheet_put_title_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Title

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icompropertysheet_put_title_method_cleanup;

    icompropertysheet_put_title_method_cleanup:
    self->m_HR = hr;
    if (bsTitle)
        ::SysFreeString(bsTitle);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IComPropertySheet.put_Title");
    return return_tuple;
}

static PyObject*
IComPropertySheetMethod_get_Title(PyIComPropertySheetObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsTitle;
    PyObject* pyvar_Title = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Title

    // Call method on actual COM interface
    hr = self->m_pIComPropertySheet->get_Title(&bsTitle);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIComPropertySheet->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IComPropertySheet) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IComPropertySheet.get_Title() returned %ld", (long)hr);
        goto icompropertysheet_get_title_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Title = PyUnicode_FromWideChar(bsTitle,::SysStringLen(bsTitle));
    ::SysFreeString(bsTitle);
    
    if (PyErr_Occurred())
      goto icompropertysheet_get_title_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Title);
    goto icompropertysheet_get_title_method_cleanup;

    icompropertysheet_get_title_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Title != Py_None)
        Py_XDECREF(pyvar_Title);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IComPropertySheet.get_Title");
    return return_tuple;
}

static PyObject*
IComPropertySheetMethod_put_ActivePage(PyIComPropertySheetObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    short sIndex = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "h", &sIndex))
      goto icompropertysheet_put_activepage_method_cleanup;

    // Set up initial variable values as needed
    // No setup for Index

    // Call method on actual COM interface
    hr = self->m_pIComPropertySheet->put_ActivePage(sIndex);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIComPropertySheet->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IComPropertySheet) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IComPropertySheet.put_ActivePage() returned %ld", (long)hr);
        goto icompropertysheet_put_activepage_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Index

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icompropertysheet_put_activepage_method_cleanup;

    icompropertysheet_put_activepage_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Index
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IComPropertySheet.put_ActivePage");
    return return_tuple;
}

static PyObject*
IComPropertySheetMethod_get_ActivePage(PyIComPropertySheetObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    short sIndex = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Index

    // Call method on actual COM interface
    hr = self->m_pIComPropertySheet->get_ActivePage(&sIndex);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIComPropertySheet->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IComPropertySheet) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IComPropertySheet.get_ActivePage() returned %ld", (long)hr);
        goto icompropertysheet_get_activepage_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Index

    // Initialize output tuple
    return_tuple = Py_BuildValue("h",
                                            sIndex);
    goto icompropertysheet_get_activepage_method_cleanup;

    icompropertysheet_get_activepage_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Index
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IComPropertySheet.get_ActivePage");
    return return_tuple;
}

static PyObject*
IComPropertySheetMethod_put_DisableCancelButton(PyIComPropertySheetObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_disableButton = VARIANT_FALSE;
    PyObject* pyvar_disableButton = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_disableButton))
      goto icompropertysheet_put_disablecancelbutton_method_cleanup;

    // Set up initial variable values as needed
    b_disableButton = ((PyObject_IsTrue(pyvar_disableButton) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto icompropertysheet_put_disablecancelbutton_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIComPropertySheet->put_DisableCancelButton(b_disableButton);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIComPropertySheet->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IComPropertySheet) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IComPropertySheet.put_DisableCancelButton() returned %ld", (long)hr);
        goto icompropertysheet_put_disablecancelbutton_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for disableButton

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icompropertysheet_put_disablecancelbutton_method_cleanup;

    icompropertysheet_put_disablecancelbutton_method_cleanup:
    self->m_HR = hr;
    // No cleanup for disableButton
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IComPropertySheet.put_DisableCancelButton");
    return return_tuple;
}

static PyObject*
IComPropertySheetMethod_get_DisableCancelButton(PyIComPropertySheetObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_disableButton = VARIANT_FALSE;
    PyObject* pyvar_disableButton = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for disableButton

    // Call method on actual COM interface
    hr = self->m_pIComPropertySheet->get_DisableCancelButton(&b_disableButton);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIComPropertySheet->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IComPropertySheet) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IComPropertySheet.get_DisableCancelButton() returned %ld", (long)hr);
        goto icompropertysheet_get_disablecancelbutton_method_cleanup;
    }

    // Set up return values as needed
    pyvar_disableButton = ((b_disableButton == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto icompropertysheet_get_disablecancelbutton_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_disableButton);
    goto icompropertysheet_get_disablecancelbutton_method_cleanup;

    icompropertysheet_get_disablecancelbutton_method_cleanup:
    self->m_HR = hr;
    // No cleanup for disableButton
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IComPropertySheet.get_DisableCancelButton");
    return return_tuple;
}

static PyObject*
IComPropertySheetMethod_put_HideApplyButton(PyIComPropertySheetObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_HideApplyButton = VARIANT_FALSE;
    PyObject* pyvar_HideApplyButton = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_HideApplyButton))
      goto icompropertysheet_put_hideapplybutton_method_cleanup;

    // Set up initial variable values as needed
    b_HideApplyButton = ((PyObject_IsTrue(pyvar_HideApplyButton) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto icompropertysheet_put_hideapplybutton_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIComPropertySheet->put_HideApplyButton(b_HideApplyButton);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIComPropertySheet->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IComPropertySheet) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IComPropertySheet.put_HideApplyButton() returned %ld", (long)hr);
        goto icompropertysheet_put_hideapplybutton_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for HideApplyButton

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icompropertysheet_put_hideapplybutton_method_cleanup;

    icompropertysheet_put_hideapplybutton_method_cleanup:
    self->m_HR = hr;
    // No cleanup for HideApplyButton
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IComPropertySheet.put_HideApplyButton");
    return return_tuple;
}

static PyObject*
IComPropertySheetMethod_get_HideApplyButton(PyIComPropertySheetObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_HideApplyButton = VARIANT_FALSE;
    PyObject* pyvar_HideApplyButton = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for HideApplyButton

    // Call method on actual COM interface
    hr = self->m_pIComPropertySheet->get_HideApplyButton(&b_HideApplyButton);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIComPropertySheet->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IComPropertySheet) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IComPropertySheet.get_HideApplyButton() returned %ld", (long)hr);
        goto icompropertysheet_get_hideapplybutton_method_cleanup;
    }

    // Set up return values as needed
    pyvar_HideApplyButton = ((b_HideApplyButton == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto icompropertysheet_get_hideapplybutton_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_HideApplyButton);
    goto icompropertysheet_get_hideapplybutton_method_cleanup;

    icompropertysheet_get_hideapplybutton_method_cleanup:
    self->m_HR = hr;
    // No cleanup for HideApplyButton
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IComPropertySheet.get_HideApplyButton");
    return return_tuple;
}

static PyObject*
IComPropertySheetMethod_put_HideHelpButton(PyIComPropertySheetObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_HideHelpButton = VARIANT_FALSE;
    PyObject* pyvar_HideHelpButton = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_HideHelpButton))
      goto icompropertysheet_put_hidehelpbutton_method_cleanup;

    // Set up initial variable values as needed
    b_HideHelpButton = ((PyObject_IsTrue(pyvar_HideHelpButton) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto icompropertysheet_put_hidehelpbutton_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIComPropertySheet->put_HideHelpButton(b_HideHelpButton);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIComPropertySheet->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IComPropertySheet) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IComPropertySheet.put_HideHelpButton() returned %ld", (long)hr);
        goto icompropertysheet_put_hidehelpbutton_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for HideHelpButton

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icompropertysheet_put_hidehelpbutton_method_cleanup;

    icompropertysheet_put_hidehelpbutton_method_cleanup:
    self->m_HR = hr;
    // No cleanup for HideHelpButton
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IComPropertySheet.put_HideHelpButton");
    return return_tuple;
}

static PyObject*
IComPropertySheetMethod_get_HideHelpButton(PyIComPropertySheetObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_HideHelpButton = VARIANT_FALSE;
    PyObject* pyvar_HideHelpButton = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for HideHelpButton

    // Call method on actual COM interface
    hr = self->m_pIComPropertySheet->get_HideHelpButton(&b_HideHelpButton);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIComPropertySheet->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IComPropertySheet) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IComPropertySheet.get_HideHelpButton() returned %ld", (long)hr);
        goto icompropertysheet_get_hidehelpbutton_method_cleanup;
    }

    // Set up return values as needed
    pyvar_HideHelpButton = ((b_HideHelpButton == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto icompropertysheet_get_hidehelpbutton_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_HideHelpButton);
    goto icompropertysheet_get_hidehelpbutton_method_cleanup;

    icompropertysheet_get_hidehelpbutton_method_cleanup:
    self->m_HR = hr;
    // No cleanup for HideHelpButton
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IComPropertySheet.get_HideHelpButton");
    return return_tuple;
}

static PyObject*
IComPropertySheetMethod_AddCategoryID(PyIComPropertySheetObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IUID* ipCategory = NULL;
    PyObject* py_Category;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_Category))
      goto icompropertysheet_addcategoryid_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_Category, &IID_IUID, (void**)&ipCategory))
        PyErr_SetString(PyExc_TypeError, "Argument Category (position 0) is not IUID");
    
    if (PyErr_Occurred())
      goto icompropertysheet_addcategoryid_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIComPropertySheet->AddCategoryID(ipCategory);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIComPropertySheet->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IComPropertySheet) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IComPropertySheet.AddCategoryID() returned %ld", (long)hr);
        goto icompropertysheet_addcategoryid_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Category

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icompropertysheet_addcategoryid_method_cleanup;

    icompropertysheet_addcategoryid_method_cleanup:
    self->m_HR = hr;
    if (ipCategory)
      ipCategory->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IComPropertySheet.AddCategoryID");
    return return_tuple;
}

static PyObject*
IComPropertySheetMethod_ClearCategoryIDs(PyIComPropertySheetObject* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pIComPropertySheet->ClearCategoryIDs();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIComPropertySheet->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IComPropertySheet) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IComPropertySheet.ClearCategoryIDs() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}

static PyObject*
IComPropertySheetMethod_AddPage(PyIComPropertySheetObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT vPage;
    ::VariantInit(&vPage);
    PyObject* pyvar_Page = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_Page))
      goto icompropertysheet_addpage_method_cleanup;

    // Set up initial variable values as needed
    PyObject_AsVariant(pyvar_Page, &vPage);
    
    if (PyErr_Occurred())
      goto icompropertysheet_addpage_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIComPropertySheet->AddPage(vPage);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIComPropertySheet->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IComPropertySheet) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IComPropertySheet.AddPage() returned %ld", (long)hr);
        goto icompropertysheet_addpage_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Page

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icompropertysheet_addpage_method_cleanup;

    icompropertysheet_addpage_method_cleanup:
    self->m_HR = hr;
    ::VariantClear(&vPage);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IComPropertySheet.AddPage");
    return return_tuple;
}

static PyObject*
IComPropertySheetMethod_CanEdit(PyIComPropertySheetObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ISet* ipobjects = NULL;
    PyObject* py_objects;
    VARIANT_BOOL b_result = VARIANT_FALSE;
    PyObject* pyvar_result = Py_False;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_objects))
      goto icompropertysheet_canedit_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_objects, &IID_ISet, (void**)&ipobjects))
        PyErr_SetString(PyExc_TypeError, "Argument objects (position 0) is not ISet");
    
    if (PyErr_Occurred())
      goto icompropertysheet_canedit_method_cleanup;
    
    // No setup for result

    // Call method on actual COM interface
    hr = self->m_pIComPropertySheet->CanEdit(ipobjects, &b_result);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIComPropertySheet->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IComPropertySheet) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IComPropertySheet.CanEdit() returned %ld", (long)hr);
        goto icompropertysheet_canedit_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for objects
    pyvar_result = ((b_result == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto icompropertysheet_canedit_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_result);
    goto icompropertysheet_canedit_method_cleanup;

    icompropertysheet_canedit_method_cleanup:
    self->m_HR = hr;
    if (ipobjects)
      ipobjects->Release();
    // No cleanup for result
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IComPropertySheet.CanEdit");
    return return_tuple;
}

static PyObject*
IComPropertySheetMethod_EditProperties(PyIComPropertySheetObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ISet* ipobjects = NULL;
    PyObject* py_objects;
    OLE_HANDLE HhWnd = 0;
    VARIANT_BOOL b_ok = VARIANT_FALSE;
    PyObject* pyvar_ok = Py_False;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OI", &py_objects, &HhWnd))
      goto icompropertysheet_editproperties_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_objects, &IID_ISet, (void**)&ipobjects))
        PyErr_SetString(PyExc_TypeError, "Argument objects (position 0) is not ISet");
    
    if (PyErr_Occurred())
      goto icompropertysheet_editproperties_method_cleanup;
    
    // No setup for hWnd
    // No setup for ok

    // Call method on actual COM interface
    hr = self->m_pIComPropertySheet->EditProperties(ipobjects, HhWnd, &b_ok);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIComPropertySheet->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IComPropertySheet) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IComPropertySheet.EditProperties() returned %ld", (long)hr);
        goto icompropertysheet_editproperties_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for objects
    // No teardown for hWnd
    pyvar_ok = ((b_ok == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto icompropertysheet_editproperties_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_ok);
    goto icompropertysheet_editproperties_method_cleanup;

    icompropertysheet_editproperties_method_cleanup:
    self->m_HR = hr;
    if (ipobjects)
      ipobjects->Release();
    // No cleanup for hWnd
    // No cleanup for ok
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IComPropertySheet.EditProperties");
    return return_tuple;
}


PyMethodDef PyIComPropertySheetMethods[] = {
    {"supports", (PyCFunction)PyIComPropertySheet_SupportsInterface, METH_O, ""},
    {"put_Title", (PyCFunction)IComPropertySheetMethod_put_Title, METH_VARARGS, ""},
    {"get_Title", (PyCFunction)IComPropertySheetMethod_get_Title, METH_VARARGS, ""},
    {"put_ActivePage", (PyCFunction)IComPropertySheetMethod_put_ActivePage, METH_VARARGS, ""},
    {"get_ActivePage", (PyCFunction)IComPropertySheetMethod_get_ActivePage, METH_VARARGS, ""},
    {"put_DisableCancelButton", (PyCFunction)IComPropertySheetMethod_put_DisableCancelButton, METH_VARARGS, ""},
    {"get_DisableCancelButton", (PyCFunction)IComPropertySheetMethod_get_DisableCancelButton, METH_VARARGS, ""},
    {"put_HideApplyButton", (PyCFunction)IComPropertySheetMethod_put_HideApplyButton, METH_VARARGS, ""},
    {"get_HideApplyButton", (PyCFunction)IComPropertySheetMethod_get_HideApplyButton, METH_VARARGS, ""},
    {"put_HideHelpButton", (PyCFunction)IComPropertySheetMethod_put_HideHelpButton, METH_VARARGS, ""},
    {"get_HideHelpButton", (PyCFunction)IComPropertySheetMethod_get_HideHelpButton, METH_VARARGS, ""},
    {"AddCategoryID", (PyCFunction)IComPropertySheetMethod_AddCategoryID, METH_VARARGS, ""},
    {"ClearCategoryIDs", (PyCFunction)IComPropertySheetMethod_ClearCategoryIDs, METH_NOARGS, ""},
    {"AddPage", (PyCFunction)IComPropertySheetMethod_AddPage, METH_VARARGS, ""},
    {"CanEdit", (PyCFunction)IComPropertySheetMethod_CanEdit, METH_VARARGS, ""},
    {"EditProperties", (PyCFunction)IComPropertySheetMethod_EditProperties, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIComPropertySheetGetSet[] = {
  {"_pUnk", (getter)PyIComPropertySheet_GetpUnk, NULL, "Get opaque pointer to an Unknown from IComPropertySheet", NULL},
  {"_pointer", (getter)PyIComPropertySheet_GetPointer, NULL, "Get memory address for IComPropertySheet", NULL},
  {"_IID", (getter)PyIComPropertySheet_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIComPropertySheet_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIComPropertySheet_GetIgnoreFailures, (setter)PyIComPropertySheet_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIComPropertySheetObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriFramework.IComPropertySheetObject",                          
                                              /* tp_name */
  sizeof(PyIComPropertySheetObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIComPropertySheetObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIComPropertySheetMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIComPropertySheetGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIComPropertySheetObject_new,                      
                                              /* tp_new */
};

// Interface IComPropertySheetID

typedef struct PyIComPropertySheetIDObject {
    PyObject_HEAD
    IComPropertySheetID* m_pIComPropertySheetID;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIComPropertySheetIDObject;

static PyObject*
PyIComPropertySheetIDObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIComPropertySheetIDObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IComPropertySheetID* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IComPropertySheetID, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IComPropertySheetID with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIComPropertySheetIDObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IComPropertySheetID");
            return NULL;
        }
        self->m_pIComPropertySheetID = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IComPropertySheetID");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IComPropertySheetID");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IComPropertySheetID* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IComPropertySheetID, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IComPropertySheetID");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIComPropertySheetIDObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IComPropertySheetID");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIComPropertySheetID = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIComPropertySheetIDObject_dealloc(PyIComPropertySheetIDObject* self)
{
    if (self->m_pIComPropertySheetID)
        self->m_pIComPropertySheetID->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIComPropertySheetID_GetpUnk(PyIComPropertySheetIDObject* self)
{
    if (!self->m_pIComPropertySheetID)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIComPropertySheetID->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IComPropertySheetID to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIComPropertySheetID_GetPointer(PyIComPropertySheetIDObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIComPropertySheetID);
}

static PyObject*
PyIComPropertySheetID_GetIID(PyIComPropertySheetIDObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "c7fb79b8-41a6-4f58-b58b-c39fb83aaa0a");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIComPropertySheetID_GetHR(PyIComPropertySheetIDObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIComPropertySheetID_GetIgnoreFailures(PyIComPropertySheetIDObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIComPropertySheetID_SetIgnoreFailures(PyIComPropertySheetIDObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIComPropertySheetID_SupportsInterface(PyIComPropertySheetIDObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIComPropertySheetID->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IComPropertySheetIDMethod_put_RegistryKey(PyIComPropertySheetIDObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsidStr = 0;
    PyObject* pyvar_idStr;
    PyObject* unicodeidStr = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_idStr))
      goto icompropertysheetid_put_registrykey_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_idStr))
        unicodeidStr = PyUnicode_FromObject(pyvar_idStr);
    else if (PyUnicode_Check(pyvar_idStr))
    {
        unicodeidStr = pyvar_idStr;
        Py_INCREF(unicodeidStr);
    }
    else if (pyvar_idStr != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter idStr at index 0");
    if (unicodeidStr)
        bsidStr = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeidStr), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeidStr));
    
    if (PyErr_Occurred())
      goto icompropertysheetid_put_registrykey_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIComPropertySheetID->put_RegistryKey(bsidStr);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIComPropertySheetID->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IComPropertySheetID) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IComPropertySheetID.put_RegistryKey() returned %ld", (long)hr);
        goto icompropertysheetid_put_registrykey_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for idStr

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icompropertysheetid_put_registrykey_method_cleanup;

    icompropertysheetid_put_registrykey_method_cleanup:
    self->m_HR = hr;
    if (bsidStr)
        ::SysFreeString(bsidStr);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IComPropertySheetID.put_RegistryKey");
    return return_tuple;
}

static PyObject*
IComPropertySheetIDMethod_get_RegistryKey(PyIComPropertySheetIDObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsidStr;
    PyObject* pyvar_idStr = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for idStr

    // Call method on actual COM interface
    hr = self->m_pIComPropertySheetID->get_RegistryKey(&bsidStr);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIComPropertySheetID->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IComPropertySheetID) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IComPropertySheetID.get_RegistryKey() returned %ld", (long)hr);
        goto icompropertysheetid_get_registrykey_method_cleanup;
    }

    // Set up return values as needed
    pyvar_idStr = PyUnicode_FromWideChar(bsidStr,::SysStringLen(bsidStr));
    ::SysFreeString(bsidStr);
    
    if (PyErr_Occurred())
      goto icompropertysheetid_get_registrykey_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_idStr);
    goto icompropertysheetid_get_registrykey_method_cleanup;

    icompropertysheetid_get_registrykey_method_cleanup:
    self->m_HR = hr;
    if (pyvar_idStr != Py_None)
        Py_XDECREF(pyvar_idStr);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IComPropertySheetID.get_RegistryKey");
    return return_tuple;
}


PyMethodDef PyIComPropertySheetIDMethods[] = {
    {"supports", (PyCFunction)PyIComPropertySheetID_SupportsInterface, METH_O, ""},
    {"put_RegistryKey", (PyCFunction)IComPropertySheetIDMethod_put_RegistryKey, METH_VARARGS, ""},
    {"get_RegistryKey", (PyCFunction)IComPropertySheetIDMethod_get_RegistryKey, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIComPropertySheetIDGetSet[] = {
  {"_pUnk", (getter)PyIComPropertySheetID_GetpUnk, NULL, "Get opaque pointer to an Unknown from IComPropertySheetID", NULL},
  {"_pointer", (getter)PyIComPropertySheetID_GetPointer, NULL, "Get memory address for IComPropertySheetID", NULL},
  {"_IID", (getter)PyIComPropertySheetID_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIComPropertySheetID_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIComPropertySheetID_GetIgnoreFailures, (setter)PyIComPropertySheetID_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIComPropertySheetIDObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriFramework.IComPropertySheetIDObject",                          
                                              /* tp_name */
  sizeof(PyIComPropertySheetIDObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIComPropertySheetIDObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIComPropertySheetIDMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIComPropertySheetIDGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIComPropertySheetIDObject_new,                      
                                              /* tp_new */
};

// Interface IPropertyPageSiteConfig

typedef struct PyIPropertyPageSiteConfigObject {
    PyObject_HEAD
    IPropertyPageSiteConfig* m_pIPropertyPageSiteConfig;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIPropertyPageSiteConfigObject;

static PyObject*
PyIPropertyPageSiteConfigObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIPropertyPageSiteConfigObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IPropertyPageSiteConfig* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IPropertyPageSiteConfig, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IPropertyPageSiteConfig with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIPropertyPageSiteConfigObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IPropertyPageSiteConfig");
            return NULL;
        }
        self->m_pIPropertyPageSiteConfig = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IPropertyPageSiteConfig");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IPropertyPageSiteConfig");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IPropertyPageSiteConfig* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IPropertyPageSiteConfig, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IPropertyPageSiteConfig");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIPropertyPageSiteConfigObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IPropertyPageSiteConfig");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIPropertyPageSiteConfig = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIPropertyPageSiteConfigObject_dealloc(PyIPropertyPageSiteConfigObject* self)
{
    if (self->m_pIPropertyPageSiteConfig)
        self->m_pIPropertyPageSiteConfig->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIPropertyPageSiteConfig_GetpUnk(PyIPropertyPageSiteConfigObject* self)
{
    if (!self->m_pIPropertyPageSiteConfig)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIPropertyPageSiteConfig->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IPropertyPageSiteConfig to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIPropertyPageSiteConfig_GetPointer(PyIPropertyPageSiteConfigObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIPropertyPageSiteConfig);
}

static PyObject*
PyIPropertyPageSiteConfig_GetIID(PyIPropertyPageSiteConfigObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "2645f960-b557-4b7b-b017-10f10159b78b");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIPropertyPageSiteConfig_GetHR(PyIPropertyPageSiteConfigObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIPropertyPageSiteConfig_GetIgnoreFailures(PyIPropertyPageSiteConfigObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIPropertyPageSiteConfig_SetIgnoreFailures(PyIPropertyPageSiteConfigObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIPropertyPageSiteConfig_SupportsInterface(PyIPropertyPageSiteConfigObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIPropertyPageSiteConfig->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IPropertyPageSiteConfigMethod_put_hWnd(PyIPropertyPageSiteConfigObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lhWnd = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lhWnd))
      goto ipropertypagesiteconfig_put_hwnd_method_cleanup;

    // Set up initial variable values as needed
    // No setup for hWnd

    // Call method on actual COM interface
    hr = self->m_pIPropertyPageSiteConfig->put_hWnd(lhWnd);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPropertyPageSiteConfig->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPropertyPageSiteConfig) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPropertyPageSiteConfig.put_hWnd() returned %ld", (long)hr);
        goto ipropertypagesiteconfig_put_hwnd_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for hWnd

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto ipropertypagesiteconfig_put_hwnd_method_cleanup;

    ipropertypagesiteconfig_put_hwnd_method_cleanup:
    self->m_HR = hr;
    // No cleanup for hWnd
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPropertyPageSiteConfig.put_hWnd");
    return return_tuple;
}

static PyObject*
IPropertyPageSiteConfigMethod_get_hWnd(PyIPropertyPageSiteConfigObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lhWnd = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for hWnd

    // Call method on actual COM interface
    hr = self->m_pIPropertyPageSiteConfig->get_hWnd(&lhWnd);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIPropertyPageSiteConfig->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IPropertyPageSiteConfig) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IPropertyPageSiteConfig.get_hWnd() returned %ld", (long)hr);
        goto ipropertypagesiteconfig_get_hwnd_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for hWnd

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lhWnd);
    goto ipropertypagesiteconfig_get_hwnd_method_cleanup;

    ipropertypagesiteconfig_get_hwnd_method_cleanup:
    self->m_HR = hr;
    // No cleanup for hWnd
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IPropertyPageSiteConfig.get_hWnd");
    return return_tuple;
}

static PyObject*
IPropertyPageSiteConfigMethod_putref_Page(PyIPropertyPageSiteConfigObject* self, PyObject* args)
{
    /* Param types that are unhandleable: 
       INPUT [u'IPropertyPage', u'*']
    */
    PyErr_SetString(PyExc_NotImplementedError, "Wrapper for IPropertyPageSiteConfig.putref_Page not implemented.");
    return NULL;
}

static PyObject*
IPropertyPageSiteConfigMethod_get_Page(PyIPropertyPageSiteConfigObject* self, PyObject* args)
{
    /* Param types that are unhandleable: 
       OUTPUT [u'IPropertyPage', u'*', u'*']
    */
    PyErr_SetString(PyExc_NotImplementedError, "Wrapper for IPropertyPageSiteConfig.get_Page not implemented.");
    return NULL;
}


PyMethodDef PyIPropertyPageSiteConfigMethods[] = {
    {"supports", (PyCFunction)PyIPropertyPageSiteConfig_SupportsInterface, METH_O, ""},
    {"put_hWnd", (PyCFunction)IPropertyPageSiteConfigMethod_put_hWnd, METH_VARARGS, ""},
    {"get_hWnd", (PyCFunction)IPropertyPageSiteConfigMethod_get_hWnd, METH_VARARGS, ""},
    {"putref_Page", (PyCFunction)IPropertyPageSiteConfigMethod_putref_Page, METH_VARARGS, ""},
    {"get_Page", (PyCFunction)IPropertyPageSiteConfigMethod_get_Page, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIPropertyPageSiteConfigGetSet[] = {
  {"_pUnk", (getter)PyIPropertyPageSiteConfig_GetpUnk, NULL, "Get opaque pointer to an Unknown from IPropertyPageSiteConfig", NULL},
  {"_pointer", (getter)PyIPropertyPageSiteConfig_GetPointer, NULL, "Get memory address for IPropertyPageSiteConfig", NULL},
  {"_IID", (getter)PyIPropertyPageSiteConfig_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIPropertyPageSiteConfig_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIPropertyPageSiteConfig_GetIgnoreFailures, (setter)PyIPropertyPageSiteConfig_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIPropertyPageSiteConfigObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriFramework.IPropertyPageSiteConfigObject",                          
                                              /* tp_name */
  sizeof(PyIPropertyPageSiteConfigObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIPropertyPageSiteConfigObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIPropertyPageSiteConfigMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIPropertyPageSiteConfigGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIPropertyPageSiteConfigObject_new,                      
                                              /* tp_new */
};

// Interface INumberFormatDialog

typedef struct PyINumberFormatDialogObject {
    PyObject_HEAD
    INumberFormatDialog* m_pINumberFormatDialog;
    HRESULT m_HR;
    int m_ignore_failures;
} PyINumberFormatDialogObject;

static PyObject*
PyINumberFormatDialogObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyINumberFormatDialogObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        INumberFormatDialog* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_INumberFormatDialog, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate INumberFormatDialog with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyINumberFormatDialogObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate INumberFormatDialog");
            return NULL;
        }
        self->m_pINumberFormatDialog = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for INumberFormatDialog");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to INumberFormatDialog");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    INumberFormatDialog* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_INumberFormatDialog, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to INumberFormatDialog");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyINumberFormatDialogObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate INumberFormatDialog");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pINumberFormatDialog = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyINumberFormatDialogObject_dealloc(PyINumberFormatDialogObject* self)
{
    if (self->m_pINumberFormatDialog)
        self->m_pINumberFormatDialog->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyINumberFormatDialog_GetpUnk(PyINumberFormatDialogObject* self)
{
    if (!self->m_pINumberFormatDialog)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pINumberFormatDialog->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI INumberFormatDialog to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyINumberFormatDialog_GetPointer(PyINumberFormatDialogObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pINumberFormatDialog);
}

static PyObject*
PyINumberFormatDialog_GetIID(PyINumberFormatDialogObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "88002c09-939a-11d2-ae73-080009ec732a");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyINumberFormatDialog_GetHR(PyINumberFormatDialogObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyINumberFormatDialog_GetIgnoreFailures(PyINumberFormatDialogObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyINumberFormatDialog_SetIgnoreFailures(PyINumberFormatDialogObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyINumberFormatDialog_SupportsInterface(PyINumberFormatDialogObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pINumberFormatDialog->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
INumberFormatDialogMethod_get_NumberFormat(PyINumberFormatDialogObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    INumberFormat* ipformat = NULL;
    PyObject* py_format = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for format

    // Call method on actual COM interface
    hr = self->m_pINumberFormatDialog->get_NumberFormat(&ipformat);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pINumberFormatDialog->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_INumberFormatDialog) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: INumberFormatDialog.get_NumberFormat() returned %ld", (long)hr);
        goto inumberformatdialog_get_numberformat_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_format);
    if (ipformat)
    {
        IUnknown* pUnk = NULL;
        ipformat->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_format = IUnknownToPythonIIDObject(pUnk, &IID_INumberFormat);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_format)
    {
        if (py_format)
           Py_DECREF(py_format);
        py_format = Py_None;
        Py_INCREF(py_format);
    }
    if (PyErr_Occurred())
      goto inumberformatdialog_get_numberformat_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_format);
    goto inumberformatdialog_get_numberformat_method_cleanup;

    inumberformatdialog_get_numberformat_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_format);
    if (ipformat)
      ipformat->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in INumberFormatDialog.get_NumberFormat");
    return return_tuple;
}

static PyObject*
INumberFormatDialogMethod_put_NumberFormat(PyINumberFormatDialogObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    INumberFormat* ipformat = NULL;
    PyObject* py_format;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_format))
      goto inumberformatdialog_put_numberformat_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_format, &IID_INumberFormat, (void**)&ipformat))
        PyErr_SetString(PyExc_TypeError, "Argument format (position 0) is not INumberFormat");
    
    if (PyErr_Occurred())
      goto inumberformatdialog_put_numberformat_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pINumberFormatDialog->put_NumberFormat(ipformat);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pINumberFormatDialog->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_INumberFormatDialog) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: INumberFormatDialog.put_NumberFormat() returned %ld", (long)hr);
        goto inumberformatdialog_put_numberformat_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for format

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto inumberformatdialog_put_numberformat_method_cleanup;

    inumberformatdialog_put_numberformat_method_cleanup:
    self->m_HR = hr;
    if (ipformat)
      ipformat->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in INumberFormatDialog.put_NumberFormat");
    return return_tuple;
}

static PyObject*
INumberFormatDialogMethod_DoModal(PyINumberFormatDialogObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    OLE_HANDLE HhWnd = 0;
    VARIANT_BOOL b_okPressed = VARIANT_FALSE;
    PyObject* pyvar_okPressed = Py_False;

    // Unpack values
    if (!PyArg_ParseTuple(args, "I", &HhWnd))
      goto inumberformatdialog_domodal_method_cleanup;

    // Set up initial variable values as needed
    // No setup for hWnd
    // No setup for okPressed

    // Call method on actual COM interface
    hr = self->m_pINumberFormatDialog->DoModal(HhWnd, &b_okPressed);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pINumberFormatDialog->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_INumberFormatDialog) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: INumberFormatDialog.DoModal() returned %ld", (long)hr);
        goto inumberformatdialog_domodal_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for hWnd
    pyvar_okPressed = ((b_okPressed == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto inumberformatdialog_domodal_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_okPressed);
    goto inumberformatdialog_domodal_method_cleanup;

    inumberformatdialog_domodal_method_cleanup:
    self->m_HR = hr;
    // No cleanup for hWnd
    // No cleanup for okPressed
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in INumberFormatDialog.DoModal");
    return return_tuple;
}


PyMethodDef PyINumberFormatDialogMethods[] = {
    {"supports", (PyCFunction)PyINumberFormatDialog_SupportsInterface, METH_O, ""},
    {"get_NumberFormat", (PyCFunction)INumberFormatDialogMethod_get_NumberFormat, METH_VARARGS, ""},
    {"put_NumberFormat", (PyCFunction)INumberFormatDialogMethod_put_NumberFormat, METH_VARARGS, ""},
    {"DoModal", (PyCFunction)INumberFormatDialogMethod_DoModal, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyINumberFormatDialogGetSet[] = {
  {"_pUnk", (getter)PyINumberFormatDialog_GetpUnk, NULL, "Get opaque pointer to an Unknown from INumberFormatDialog", NULL},
  {"_pointer", (getter)PyINumberFormatDialog_GetPointer, NULL, "Get memory address for INumberFormatDialog", NULL},
  {"_IID", (getter)PyINumberFormatDialog_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyINumberFormatDialog_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyINumberFormatDialog_GetIgnoreFailures, (setter)PyINumberFormatDialog_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyINumberFormatDialogObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriFramework.INumberFormatDialogObject",                          
                                              /* tp_name */
  sizeof(PyINumberFormatDialogObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyINumberFormatDialogObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyINumberFormatDialogMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyINumberFormatDialogGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyINumberFormatDialogObject_new,                      
                                              /* tp_new */
};

// Interface ISymbolPickerDialog

typedef struct PyISymbolPickerDialogObject {
    PyObject_HEAD
    ISymbolPickerDialog* m_pISymbolPickerDialog;
    HRESULT m_HR;
    int m_ignore_failures;
} PyISymbolPickerDialogObject;

static PyObject*
PyISymbolPickerDialogObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyISymbolPickerDialogObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ISymbolPickerDialog* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ISymbolPickerDialog, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ISymbolPickerDialog with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyISymbolPickerDialogObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ISymbolPickerDialog");
            return NULL;
        }
        self->m_pISymbolPickerDialog = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ISymbolPickerDialog");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ISymbolPickerDialog");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ISymbolPickerDialog* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ISymbolPickerDialog, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ISymbolPickerDialog");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyISymbolPickerDialogObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ISymbolPickerDialog");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pISymbolPickerDialog = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyISymbolPickerDialogObject_dealloc(PyISymbolPickerDialogObject* self)
{
    if (self->m_pISymbolPickerDialog)
        self->m_pISymbolPickerDialog->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyISymbolPickerDialog_GetpUnk(PyISymbolPickerDialogObject* self)
{
    if (!self->m_pISymbolPickerDialog)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pISymbolPickerDialog->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ISymbolPickerDialog to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyISymbolPickerDialog_GetPointer(PyISymbolPickerDialogObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pISymbolPickerDialog);
}

static PyObject*
PyISymbolPickerDialog_GetIID(PyISymbolPickerDialogObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "5c8df895-d553-41f2-b5d3-2703efe0b07a");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyISymbolPickerDialog_GetHR(PyISymbolPickerDialogObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyISymbolPickerDialog_GetIgnoreFailures(PyISymbolPickerDialogObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyISymbolPickerDialog_SetIgnoreFailures(PyISymbolPickerDialogObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyISymbolPickerDialog_SupportsInterface(PyISymbolPickerDialogObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pISymbolPickerDialog->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ISymbolPickerDialogMethod_get_SelectedFontName(PyISymbolPickerDialogObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsFontFaceName;
    PyObject* pyvar_FontFaceName = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for FontFaceName

    // Call method on actual COM interface
    hr = self->m_pISymbolPickerDialog->get_SelectedFontName(&bsFontFaceName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISymbolPickerDialog->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISymbolPickerDialog) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISymbolPickerDialog.get_SelectedFontName() returned %ld", (long)hr);
        goto isymbolpickerdialog_get_selectedfontname_method_cleanup;
    }

    // Set up return values as needed
    pyvar_FontFaceName = PyUnicode_FromWideChar(bsFontFaceName,::SysStringLen(bsFontFaceName));
    ::SysFreeString(bsFontFaceName);
    
    if (PyErr_Occurred())
      goto isymbolpickerdialog_get_selectedfontname_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_FontFaceName);
    goto isymbolpickerdialog_get_selectedfontname_method_cleanup;

    isymbolpickerdialog_get_selectedfontname_method_cleanup:
    self->m_HR = hr;
    if (pyvar_FontFaceName != Py_None)
        Py_XDECREF(pyvar_FontFaceName);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISymbolPickerDialog.get_SelectedFontName");
    return return_tuple;
}

static PyObject*
ISymbolPickerDialogMethod_put_SelectedFontName(PyISymbolPickerDialogObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsFontFaceName = 0;
    PyObject* pyvar_FontFaceName;
    PyObject* unicodeFontFaceName = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_FontFaceName))
      goto isymbolpickerdialog_put_selectedfontname_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_FontFaceName))
        unicodeFontFaceName = PyUnicode_FromObject(pyvar_FontFaceName);
    else if (PyUnicode_Check(pyvar_FontFaceName))
    {
        unicodeFontFaceName = pyvar_FontFaceName;
        Py_INCREF(unicodeFontFaceName);
    }
    else if (pyvar_FontFaceName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter FontFaceName at index 0");
    if (unicodeFontFaceName)
        bsFontFaceName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeFontFaceName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeFontFaceName));
    
    if (PyErr_Occurred())
      goto isymbolpickerdialog_put_selectedfontname_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pISymbolPickerDialog->put_SelectedFontName(bsFontFaceName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISymbolPickerDialog->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISymbolPickerDialog) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISymbolPickerDialog.put_SelectedFontName() returned %ld", (long)hr);
        goto isymbolpickerdialog_put_selectedfontname_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for FontFaceName

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto isymbolpickerdialog_put_selectedfontname_method_cleanup;

    isymbolpickerdialog_put_selectedfontname_method_cleanup:
    self->m_HR = hr;
    if (bsFontFaceName)
        ::SysFreeString(bsFontFaceName);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISymbolPickerDialog.put_SelectedFontName");
    return return_tuple;
}

static PyObject*
ISymbolPickerDialogMethod_get_SelectedChar(PyISymbolPickerDialogObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long liCharUnicode = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for iCharUnicode

    // Call method on actual COM interface
    hr = self->m_pISymbolPickerDialog->get_SelectedChar(&liCharUnicode);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISymbolPickerDialog->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISymbolPickerDialog) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISymbolPickerDialog.get_SelectedChar() returned %ld", (long)hr);
        goto isymbolpickerdialog_get_selectedchar_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for iCharUnicode

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            liCharUnicode);
    goto isymbolpickerdialog_get_selectedchar_method_cleanup;

    isymbolpickerdialog_get_selectedchar_method_cleanup:
    self->m_HR = hr;
    // No cleanup for iCharUnicode
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISymbolPickerDialog.get_SelectedChar");
    return return_tuple;
}

static PyObject*
ISymbolPickerDialogMethod_put_SelectedChar(PyISymbolPickerDialogObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long liCharUnicode = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &liCharUnicode))
      goto isymbolpickerdialog_put_selectedchar_method_cleanup;

    // Set up initial variable values as needed
    // No setup for iCharUnicode

    // Call method on actual COM interface
    hr = self->m_pISymbolPickerDialog->put_SelectedChar(liCharUnicode);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISymbolPickerDialog->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISymbolPickerDialog) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISymbolPickerDialog.put_SelectedChar() returned %ld", (long)hr);
        goto isymbolpickerdialog_put_selectedchar_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for iCharUnicode

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto isymbolpickerdialog_put_selectedchar_method_cleanup;

    isymbolpickerdialog_put_selectedchar_method_cleanup:
    self->m_HR = hr;
    // No cleanup for iCharUnicode
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISymbolPickerDialog.put_SelectedChar");
    return return_tuple;
}

static PyObject*
ISymbolPickerDialogMethod_DoModal(PyISymbolPickerDialogObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    OLE_HANDLE HhWndParent = 0;
    VARIANT_BOOL b_pOK = VARIANT_FALSE;
    PyObject* pyvar_pOK = Py_False;

    // Unpack values
    if (!PyArg_ParseTuple(args, "I", &HhWndParent))
      goto isymbolpickerdialog_domodal_method_cleanup;

    // Set up initial variable values as needed
    // No setup for hWndParent
    // No setup for pOK

    // Call method on actual COM interface
    hr = self->m_pISymbolPickerDialog->DoModal(HhWndParent, &b_pOK);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pISymbolPickerDialog->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ISymbolPickerDialog) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ISymbolPickerDialog.DoModal() returned %ld", (long)hr);
        goto isymbolpickerdialog_domodal_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for hWndParent
    pyvar_pOK = ((b_pOK == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto isymbolpickerdialog_domodal_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_pOK);
    goto isymbolpickerdialog_domodal_method_cleanup;

    isymbolpickerdialog_domodal_method_cleanup:
    self->m_HR = hr;
    // No cleanup for hWndParent
    // No cleanup for pOK
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ISymbolPickerDialog.DoModal");
    return return_tuple;
}


PyMethodDef PyISymbolPickerDialogMethods[] = {
    {"supports", (PyCFunction)PyISymbolPickerDialog_SupportsInterface, METH_O, ""},
    {"get_SelectedFontName", (PyCFunction)ISymbolPickerDialogMethod_get_SelectedFontName, METH_VARARGS, ""},
    {"put_SelectedFontName", (PyCFunction)ISymbolPickerDialogMethod_put_SelectedFontName, METH_VARARGS, ""},
    {"get_SelectedChar", (PyCFunction)ISymbolPickerDialogMethod_get_SelectedChar, METH_VARARGS, ""},
    {"put_SelectedChar", (PyCFunction)ISymbolPickerDialogMethod_put_SelectedChar, METH_VARARGS, ""},
    {"DoModal", (PyCFunction)ISymbolPickerDialogMethod_DoModal, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyISymbolPickerDialogGetSet[] = {
  {"_pUnk", (getter)PyISymbolPickerDialog_GetpUnk, NULL, "Get opaque pointer to an Unknown from ISymbolPickerDialog", NULL},
  {"_pointer", (getter)PyISymbolPickerDialog_GetPointer, NULL, "Get memory address for ISymbolPickerDialog", NULL},
  {"_IID", (getter)PyISymbolPickerDialog_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyISymbolPickerDialog_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyISymbolPickerDialog_GetIgnoreFailures, (setter)PyISymbolPickerDialog_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyISymbolPickerDialogObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriFramework.ISymbolPickerDialogObject",                          
                                              /* tp_name */
  sizeof(PyISymbolPickerDialogObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyISymbolPickerDialogObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyISymbolPickerDialogMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyISymbolPickerDialogGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyISymbolPickerDialogObject_new,                      
                                              /* tp_new */
};

// Interface IApplication

typedef struct PyIApplicationObject {
    PyObject_HEAD
    IApplication* m_pIApplication;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIApplicationObject;

static PyObject*
PyIApplicationObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIApplicationObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IApplication* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IApplication, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IApplication with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIApplicationObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IApplication");
            return NULL;
        }
        self->m_pIApplication = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IApplication");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IApplication");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IApplication* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IApplication, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IApplication");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIApplicationObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IApplication");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIApplication = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIApplicationObject_dealloc(PyIApplicationObject* self)
{
    if (self->m_pIApplication)
        self->m_pIApplication->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIApplication_GetpUnk(PyIApplicationObject* self)
{
    if (!self->m_pIApplication)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIApplication->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IApplication to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIApplication_GetPointer(PyIApplicationObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIApplication);
}

static PyObject*
PyIApplication_GetIID(PyIApplicationObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "8e52b9a5-307b-11d2-94c9-080009eebecb");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIApplication_GetHR(PyIApplicationObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIApplication_GetIgnoreFailures(PyIApplicationObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIApplication_SetIgnoreFailures(PyIApplicationObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIApplication_SupportsInterface(PyIApplicationObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIApplication->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IApplicationMethod_get_Name(PyIApplicationObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName;
    PyObject* pyvar_Name = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Name

    // Call method on actual COM interface
    hr = self->m_pIApplication->get_Name(&bsName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIApplication->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IApplication) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IApplication.get_Name() returned %ld", (long)hr);
        goto iapplication_get_name_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Name = PyUnicode_FromWideChar(bsName,::SysStringLen(bsName));
    ::SysFreeString(bsName);
    
    if (PyErr_Occurred())
      goto iapplication_get_name_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Name);
    goto iapplication_get_name_method_cleanup;

    iapplication_get_name_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Name != Py_None)
        Py_XDECREF(pyvar_Name);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IApplication.get_Name");
    return return_tuple;
}

static PyObject*
IApplicationMethod_get_Document(PyIApplicationObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IDocument* ipdoc = NULL;
    PyObject* py_doc = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for doc

    // Call method on actual COM interface
    hr = self->m_pIApplication->get_Document(&ipdoc);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIApplication->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IApplication) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IApplication.get_Document() returned %ld", (long)hr);
        goto iapplication_get_document_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_doc);
    if (ipdoc)
    {
        IUnknown* pUnk = NULL;
        ipdoc->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_doc = IUnknownToPythonIIDObject(pUnk, &IID_IDocument);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_doc)
    {
        if (py_doc)
           Py_DECREF(py_doc);
        py_doc = Py_None;
        Py_INCREF(py_doc);
    }
    if (PyErr_Occurred())
      goto iapplication_get_document_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_doc);
    goto iapplication_get_document_method_cleanup;

    iapplication_get_document_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_doc);
    if (ipdoc)
      ipdoc->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IApplication.get_Document");
    return return_tuple;
}

static PyObject*
IApplicationMethod_get_StatusBar(PyIApplicationObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IStatusBar* ipStatusBar = NULL;
    PyObject* py_StatusBar = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for StatusBar

    // Call method on actual COM interface
    hr = self->m_pIApplication->get_StatusBar(&ipStatusBar);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIApplication->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IApplication) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IApplication.get_StatusBar() returned %ld", (long)hr);
        goto iapplication_get_statusbar_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_StatusBar);
    if (ipStatusBar)
    {
        IUnknown* pUnk = NULL;
        ipStatusBar->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_StatusBar = IUnknownToPythonIIDObject(pUnk, &IID_IStatusBar);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_StatusBar)
    {
        if (py_StatusBar)
           Py_DECREF(py_StatusBar);
        py_StatusBar = Py_None;
        Py_INCREF(py_StatusBar);
    }
    if (PyErr_Occurred())
      goto iapplication_get_statusbar_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_StatusBar);
    goto iapplication_get_statusbar_method_cleanup;

    iapplication_get_statusbar_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_StatusBar);
    if (ipStatusBar)
      ipStatusBar->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IApplication.get_StatusBar");
    return return_tuple;
}

static PyObject*
IApplicationMethod_ShowDialog(PyIApplicationObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long ldialogID = 0;
    VARIANT vbShow;
    ::VariantInit(&vbShow);
    PyObject* pyvar_bShow = NULL;
    VARIANT vresult;
    ::VariantInit(&vresult);
    PyObject* pyvar_result = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "lO", &ldialogID, &pyvar_bShow))
      goto iapplication_showdialog_method_cleanup;

    // Set up initial variable values as needed
    // No setup for dialogID
    PyObject_AsVariant(pyvar_bShow, &vbShow);
    
    if (PyErr_Occurred())
      goto iapplication_showdialog_method_cleanup;
    
    // No setup for result

    // Call method on actual COM interface
    hr = self->m_pIApplication->ShowDialog(ldialogID, &vbShow, &vresult);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIApplication->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IApplication) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IApplication.ShowDialog() returned %ld", (long)hr);
        goto iapplication_showdialog_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for dialogID
    // No teardown for bShow
    pyvar_result = Variant_AsPyObject(&vresult);
    if (PyErr_Occurred())
      goto iapplication_showdialog_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_result);
    goto iapplication_showdialog_method_cleanup;

    iapplication_showdialog_method_cleanup:
    self->m_HR = hr;
    // No cleanup for dialogID
    ::VariantClear(&vbShow);
    ::VariantClear(&vresult);
    Py_XDECREF(pyvar_result);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IApplication.ShowDialog");
    return return_tuple;
}

static PyObject*
IApplicationMethod_IsDialogVisible(PyIApplicationObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long ldialogID = 0;
    VARIANT_BOOL b_bVisible = VARIANT_FALSE;
    PyObject* pyvar_bVisible = Py_False;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &ldialogID))
      goto iapplication_isdialogvisible_method_cleanup;

    // Set up initial variable values as needed
    // No setup for dialogID
    // No setup for bVisible

    // Call method on actual COM interface
    hr = self->m_pIApplication->IsDialogVisible(ldialogID, &b_bVisible);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIApplication->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IApplication) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IApplication.IsDialogVisible() returned %ld", (long)hr);
        goto iapplication_isdialogvisible_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for dialogID
    pyvar_bVisible = ((b_bVisible == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto iapplication_isdialogvisible_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_bVisible);
    goto iapplication_isdialogvisible_method_cleanup;

    iapplication_isdialogvisible_method_cleanup:
    self->m_HR = hr;
    // No cleanup for dialogID
    // No cleanup for bVisible
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IApplication.IsDialogVisible");
    return return_tuple;
}

static PyObject*
IApplicationMethod_get_CurrentTool(PyIApplicationObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ICommandItem* ipTool = NULL;
    PyObject* py_Tool = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Tool

    // Call method on actual COM interface
    hr = self->m_pIApplication->get_CurrentTool(&ipTool);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIApplication->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IApplication) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IApplication.get_CurrentTool() returned %ld", (long)hr);
        goto iapplication_get_currenttool_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_Tool);
    if (ipTool)
    {
        IUnknown* pUnk = NULL;
        ipTool->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_Tool = IUnknownToPythonIIDObject(pUnk, &IID_ICommandItem);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_Tool)
    {
        if (py_Tool)
           Py_DECREF(py_Tool);
        py_Tool = Py_None;
        Py_INCREF(py_Tool);
    }
    if (PyErr_Occurred())
      goto iapplication_get_currenttool_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_Tool);
    goto iapplication_get_currenttool_method_cleanup;

    iapplication_get_currenttool_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_Tool);
    if (ipTool)
      ipTool->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IApplication.get_CurrentTool");
    return return_tuple;
}

static PyObject*
IApplicationMethod_putref_CurrentTool(PyIApplicationObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ICommandItem* ipTool = NULL;
    PyObject* py_Tool;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_Tool))
      goto iapplication_putref_currenttool_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_Tool, &IID_ICommandItem, (void**)&ipTool))
        PyErr_SetString(PyExc_TypeError, "Argument Tool (position 0) is not ICommandItem");
    
    if (PyErr_Occurred())
      goto iapplication_putref_currenttool_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIApplication->putref_CurrentTool(ipTool);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIApplication->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IApplication) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IApplication.putref_CurrentTool() returned %ld", (long)hr);
        goto iapplication_putref_currenttool_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Tool

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iapplication_putref_currenttool_method_cleanup;

    iapplication_putref_currenttool_method_cleanup:
    self->m_HR = hr;
    if (ipTool)
      ipTool->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IApplication.putref_CurrentTool");
    return return_tuple;
}

static PyObject*
IApplicationMethod_get_VBE(PyIApplicationObject* self, PyObject* args)
{
    /* Param types that are unhandleable: 
       OUTPUT [u'IDispatch', u'*', u'*']
    */
    PyErr_SetString(PyExc_NotImplementedError, "Wrapper for IApplication.get_VBE not implemented.");
    return NULL;
}

static PyObject*
IApplicationMethod_NewDocument(PyIApplicationObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_selectTemplate = VARIANT_FALSE;
    PyObject* pyvar_selectTemplate = NULL;
    BSTR bstemplatePath = 0;
    PyObject* pyvar_templatePath;
    PyObject* unicodetemplatePath = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OO", &pyvar_selectTemplate, &pyvar_templatePath))
      goto iapplication_newdocument_method_cleanup;

    // Set up initial variable values as needed
    b_selectTemplate = ((PyObject_IsTrue(pyvar_selectTemplate) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iapplication_newdocument_method_cleanup;
    
    if (PyString_Check(pyvar_templatePath))
        unicodetemplatePath = PyUnicode_FromObject(pyvar_templatePath);
    else if (PyUnicode_Check(pyvar_templatePath))
    {
        unicodetemplatePath = pyvar_templatePath;
        Py_INCREF(unicodetemplatePath);
    }
    else if (pyvar_templatePath != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter templatePath at index 1");
    if (unicodetemplatePath)
        bstemplatePath = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodetemplatePath), 
                                            (UINT)PyUnicode_GET_SIZE(unicodetemplatePath));
    
    if (PyErr_Occurred())
      goto iapplication_newdocument_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIApplication->NewDocument(b_selectTemplate, bstemplatePath);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIApplication->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IApplication) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IApplication.NewDocument() returned %ld", (long)hr);
        goto iapplication_newdocument_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for selectTemplate
    // No teardown for templatePath

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iapplication_newdocument_method_cleanup;

    iapplication_newdocument_method_cleanup:
    self->m_HR = hr;
    // No cleanup for selectTemplate
    if (bstemplatePath)
        ::SysFreeString(bstemplatePath);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IApplication.NewDocument");
    return return_tuple;
}

static PyObject*
IApplicationMethod_OpenDocument(PyIApplicationObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bspath = 0;
    PyObject* pyvar_path;
    PyObject* unicodepath = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_path))
      goto iapplication_opendocument_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_path))
        unicodepath = PyUnicode_FromObject(pyvar_path);
    else if (PyUnicode_Check(pyvar_path))
    {
        unicodepath = pyvar_path;
        Py_INCREF(unicodepath);
    }
    else if (pyvar_path != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter path at index 0");
    if (unicodepath)
        bspath = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodepath), 
                                            (UINT)PyUnicode_GET_SIZE(unicodepath));
    
    if (PyErr_Occurred())
      goto iapplication_opendocument_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIApplication->OpenDocument(bspath);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIApplication->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IApplication) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IApplication.OpenDocument() returned %ld", (long)hr);
        goto iapplication_opendocument_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for path

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iapplication_opendocument_method_cleanup;

    iapplication_opendocument_method_cleanup:
    self->m_HR = hr;
    if (bspath)
        ::SysFreeString(bspath);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IApplication.OpenDocument");
    return return_tuple;
}

static PyObject*
IApplicationMethod_SaveDocument(PyIApplicationObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bssaveAsPath = 0;
    PyObject* pyvar_saveAsPath;
    PyObject* unicodesaveAsPath = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_saveAsPath))
      goto iapplication_savedocument_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_saveAsPath))
        unicodesaveAsPath = PyUnicode_FromObject(pyvar_saveAsPath);
    else if (PyUnicode_Check(pyvar_saveAsPath))
    {
        unicodesaveAsPath = pyvar_saveAsPath;
        Py_INCREF(unicodesaveAsPath);
    }
    else if (pyvar_saveAsPath != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter saveAsPath at index 0");
    if (unicodesaveAsPath)
        bssaveAsPath = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodesaveAsPath), 
                                            (UINT)PyUnicode_GET_SIZE(unicodesaveAsPath));
    
    if (PyErr_Occurred())
      goto iapplication_savedocument_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIApplication->SaveDocument(bssaveAsPath);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIApplication->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IApplication) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IApplication.SaveDocument() returned %ld", (long)hr);
        goto iapplication_savedocument_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for saveAsPath

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iapplication_savedocument_method_cleanup;

    iapplication_savedocument_method_cleanup:
    self->m_HR = hr;
    if (bssaveAsPath)
        ::SysFreeString(bssaveAsPath);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IApplication.SaveDocument");
    return return_tuple;
}

static PyObject*
IApplicationMethod_SaveAsDocument(PyIApplicationObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bssaveAsPath = 0;
    PyObject* pyvar_saveAsPath;
    PyObject* unicodesaveAsPath = NULL;
    VARIANT_BOOL b_saveAsCopy = VARIANT_FALSE;
    PyObject* pyvar_saveAsCopy = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OO", &pyvar_saveAsPath, &pyvar_saveAsCopy))
      goto iapplication_saveasdocument_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_saveAsPath))
        unicodesaveAsPath = PyUnicode_FromObject(pyvar_saveAsPath);
    else if (PyUnicode_Check(pyvar_saveAsPath))
    {
        unicodesaveAsPath = pyvar_saveAsPath;
        Py_INCREF(unicodesaveAsPath);
    }
    else if (pyvar_saveAsPath != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter saveAsPath at index 0");
    if (unicodesaveAsPath)
        bssaveAsPath = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodesaveAsPath), 
                                            (UINT)PyUnicode_GET_SIZE(unicodesaveAsPath));
    
    if (PyErr_Occurred())
      goto iapplication_saveasdocument_method_cleanup;
    
    b_saveAsCopy = ((PyObject_IsTrue(pyvar_saveAsCopy) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iapplication_saveasdocument_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIApplication->SaveAsDocument(bssaveAsPath, b_saveAsCopy);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIApplication->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IApplication) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IApplication.SaveAsDocument() returned %ld", (long)hr);
        goto iapplication_saveasdocument_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for saveAsPath
    // No teardown for saveAsCopy

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iapplication_saveasdocument_method_cleanup;

    iapplication_saveasdocument_method_cleanup:
    self->m_HR = hr;
    if (bssaveAsPath)
        ::SysFreeString(bssaveAsPath);
    
    // No cleanup for saveAsCopy
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IApplication.SaveAsDocument");
    return return_tuple;
}

static PyObject*
IApplicationMethod_PrintPreview(PyIApplicationObject* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pIApplication->PrintPreview();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIApplication->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IApplication) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IApplication.PrintPreview() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}

static PyObject*
IApplicationMethod_PrintDocument(PyIApplicationObject* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pIApplication->PrintDocument();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIApplication->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IApplication) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IApplication.PrintDocument() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}

static PyObject*
IApplicationMethod_LockCustomization(PyIApplicationObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsPassword = 0;
    PyObject* pyvar_Password;
    PyObject* unicodePassword = NULL;
    ICustomizationFilter* ipcustFilter = NULL;
    PyObject* py_custFilter;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OO", &pyvar_Password, &py_custFilter))
      goto iapplication_lockcustomization_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_Password))
        unicodePassword = PyUnicode_FromObject(pyvar_Password);
    else if (PyUnicode_Check(pyvar_Password))
    {
        unicodePassword = pyvar_Password;
        Py_INCREF(unicodePassword);
    }
    else if (pyvar_Password != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Password at index 0");
    if (unicodePassword)
        bsPassword = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodePassword), 
                                            (UINT)PyUnicode_GET_SIZE(unicodePassword));
    
    if (PyErr_Occurred())
      goto iapplication_lockcustomization_method_cleanup;
    
    if (!IFaceFromPyObject(py_custFilter, &IID_ICustomizationFilter, (void**)&ipcustFilter))
        PyErr_SetString(PyExc_TypeError, "Argument custFilter (position 1) is not ICustomizationFilter");
    
    if (PyErr_Occurred())
      goto iapplication_lockcustomization_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIApplication->LockCustomization(bsPassword, ipcustFilter);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIApplication->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IApplication) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IApplication.LockCustomization() returned %ld", (long)hr);
        goto iapplication_lockcustomization_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Password
    // No teardown for custFilter

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iapplication_lockcustomization_method_cleanup;

    iapplication_lockcustomization_method_cleanup:
    self->m_HR = hr;
    if (bsPassword)
        ::SysFreeString(bsPassword);
    
    if (ipcustFilter)
      ipcustFilter->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IApplication.LockCustomization");
    return return_tuple;
}

static PyObject*
IApplicationMethod_UnlockCustomization(PyIApplicationObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsPassword = 0;
    PyObject* pyvar_Password;
    PyObject* unicodePassword = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_Password))
      goto iapplication_unlockcustomization_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_Password))
        unicodePassword = PyUnicode_FromObject(pyvar_Password);
    else if (PyUnicode_Check(pyvar_Password))
    {
        unicodePassword = pyvar_Password;
        Py_INCREF(unicodePassword);
    }
    else if (pyvar_Password != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Password at index 0");
    if (unicodePassword)
        bsPassword = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodePassword), 
                                            (UINT)PyUnicode_GET_SIZE(unicodePassword));
    
    if (PyErr_Occurred())
      goto iapplication_unlockcustomization_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIApplication->UnlockCustomization(bsPassword);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIApplication->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IApplication) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IApplication.UnlockCustomization() returned %ld", (long)hr);
        goto iapplication_unlockcustomization_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Password

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iapplication_unlockcustomization_method_cleanup;

    iapplication_unlockcustomization_method_cleanup:
    self->m_HR = hr;
    if (bsPassword)
        ::SysFreeString(bsPassword);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IApplication.UnlockCustomization");
    return return_tuple;
}

static PyObject*
IApplicationMethod_RefreshWindow(PyIApplicationObject* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pIApplication->RefreshWindow();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIApplication->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IApplication) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IApplication.RefreshWindow() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}

static PyObject*
IApplicationMethod_get_Templates(PyIApplicationObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ITemplates* ipTemplates = NULL;
    PyObject* py_Templates = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Templates

    // Call method on actual COM interface
    hr = self->m_pIApplication->get_Templates(&ipTemplates);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIApplication->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IApplication) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IApplication.get_Templates() returned %ld", (long)hr);
        goto iapplication_get_templates_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_Templates);
    if (ipTemplates)
    {
        IUnknown* pUnk = NULL;
        ipTemplates->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_Templates = IUnknownToPythonIIDObject(pUnk, &IID_ITemplates);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_Templates)
    {
        if (py_Templates)
           Py_DECREF(py_Templates);
        py_Templates = Py_None;
        Py_INCREF(py_Templates);
    }
    if (PyErr_Occurred())
      goto iapplication_get_templates_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_Templates);
    goto iapplication_get_templates_method_cleanup;

    iapplication_get_templates_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_Templates);
    if (ipTemplates)
      ipTemplates->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IApplication.get_Templates");
    return return_tuple;
}

static PyObject*
IApplicationMethod_get_hWnd(PyIApplicationObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    OLE_HANDLE HhWnd = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for hWnd

    // Call method on actual COM interface
    hr = self->m_pIApplication->get_hWnd(&HhWnd);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIApplication->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IApplication) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IApplication.get_hWnd() returned %ld", (long)hr);
        goto iapplication_get_hwnd_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for hWnd

    // Initialize output tuple
    return_tuple = Py_BuildValue("I",
                                            HhWnd);
    goto iapplication_get_hwnd_method_cleanup;

    iapplication_get_hwnd_method_cleanup:
    self->m_HR = hr;
    // No cleanup for hWnd
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IApplication.get_hWnd");
    return return_tuple;
}

static PyObject*
IApplicationMethod_FindExtensionByName(PyIApplicationObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsextensionName = 0;
    PyObject* pyvar_extensionName;
    PyObject* unicodeextensionName = NULL;
    IExtension* ipextension = NULL;
    PyObject* py_extension = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_extensionName))
      goto iapplication_findextensionbyname_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_extensionName))
        unicodeextensionName = PyUnicode_FromObject(pyvar_extensionName);
    else if (PyUnicode_Check(pyvar_extensionName))
    {
        unicodeextensionName = pyvar_extensionName;
        Py_INCREF(unicodeextensionName);
    }
    else if (pyvar_extensionName != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter extensionName at index 0");
    if (unicodeextensionName)
        bsextensionName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeextensionName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeextensionName));
    
    if (PyErr_Occurred())
      goto iapplication_findextensionbyname_method_cleanup;
    
    // No setup for extension

    // Call method on actual COM interface
    hr = self->m_pIApplication->FindExtensionByName(bsextensionName, &ipextension);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIApplication->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IApplication) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IApplication.FindExtensionByName() returned %ld", (long)hr);
        goto iapplication_findextensionbyname_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for extensionName
    Py_XDECREF(py_extension);
    if (ipextension)
    {
        IUnknown* pUnk = NULL;
        ipextension->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_extension = IUnknownToPythonIIDObject(pUnk, &IID_IExtension);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_extension)
    {
        if (py_extension)
           Py_DECREF(py_extension);
        py_extension = Py_None;
        Py_INCREF(py_extension);
    }
    if (PyErr_Occurred())
      goto iapplication_findextensionbyname_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_extension);
    goto iapplication_findextensionbyname_method_cleanup;

    iapplication_findextensionbyname_method_cleanup:
    self->m_HR = hr;
    if (bsextensionName)
        ::SysFreeString(bsextensionName);
    
    Py_XDECREF(py_extension);
    if (ipextension)
      ipextension->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IApplication.FindExtensionByName");
    return return_tuple;
}

static PyObject*
IApplicationMethod_FindExtensionByCLSID(PyIApplicationObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IUID* ipextensionCLSID = NULL;
    PyObject* py_extensionCLSID;
    IExtension* ipextension = NULL;
    PyObject* py_extension = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_extensionCLSID))
      goto iapplication_findextensionbyclsid_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_extensionCLSID, &IID_IUID, (void**)&ipextensionCLSID))
        PyErr_SetString(PyExc_TypeError, "Argument extensionCLSID (position 0) is not IUID");
    
    if (PyErr_Occurred())
      goto iapplication_findextensionbyclsid_method_cleanup;
    
    // No setup for extension

    // Call method on actual COM interface
    hr = self->m_pIApplication->FindExtensionByCLSID(ipextensionCLSID, &ipextension);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIApplication->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IApplication) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IApplication.FindExtensionByCLSID() returned %ld", (long)hr);
        goto iapplication_findextensionbyclsid_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for extensionCLSID
    Py_XDECREF(py_extension);
    if (ipextension)
    {
        IUnknown* pUnk = NULL;
        ipextension->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_extension = IUnknownToPythonIIDObject(pUnk, &IID_IExtension);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_extension)
    {
        if (py_extension)
           Py_DECREF(py_extension);
        py_extension = Py_None;
        Py_INCREF(py_extension);
    }
    if (PyErr_Occurred())
      goto iapplication_findextensionbyclsid_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_extension);
    goto iapplication_findextensionbyclsid_method_cleanup;

    iapplication_findextensionbyclsid_method_cleanup:
    self->m_HR = hr;
    if (ipextensionCLSID)
      ipextensionCLSID->Release();
    Py_XDECREF(py_extension);
    if (ipextension)
      ipextension->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IApplication.FindExtensionByCLSID");
    return return_tuple;
}

static PyObject*
IApplicationMethod_Shutdown(PyIApplicationObject* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pIApplication->Shutdown();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIApplication->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IApplication) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IApplication.Shutdown() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}

static PyObject*
IApplicationMethod_get_Visible(PyIApplicationObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_Visible = VARIANT_FALSE;
    PyObject* pyvar_Visible = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Visible

    // Call method on actual COM interface
    hr = self->m_pIApplication->get_Visible(&b_Visible);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIApplication->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IApplication) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IApplication.get_Visible() returned %ld", (long)hr);
        goto iapplication_get_visible_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Visible = ((b_Visible == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto iapplication_get_visible_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Visible);
    goto iapplication_get_visible_method_cleanup;

    iapplication_get_visible_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Visible
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IApplication.get_Visible");
    return return_tuple;
}

static PyObject*
IApplicationMethod_put_Visible(PyIApplicationObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_Visible = VARIANT_FALSE;
    PyObject* pyvar_Visible = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_Visible))
      goto iapplication_put_visible_method_cleanup;

    // Set up initial variable values as needed
    b_Visible = ((PyObject_IsTrue(pyvar_Visible) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto iapplication_put_visible_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIApplication->put_Visible(b_Visible);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIApplication->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IApplication) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IApplication.put_Visible() returned %ld", (long)hr);
        goto iapplication_put_visible_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Visible

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iapplication_put_visible_method_cleanup;

    iapplication_put_visible_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Visible
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IApplication.put_Visible");
    return return_tuple;
}

static PyObject*
IApplicationMethod_put_Caption(PyIApplicationObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsCaption = 0;
    PyObject* pyvar_Caption;
    PyObject* unicodeCaption = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_Caption))
      goto iapplication_put_caption_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_Caption))
        unicodeCaption = PyUnicode_FromObject(pyvar_Caption);
    else if (PyUnicode_Check(pyvar_Caption))
    {
        unicodeCaption = pyvar_Caption;
        Py_INCREF(unicodeCaption);
    }
    else if (pyvar_Caption != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Caption at index 0");
    if (unicodeCaption)
        bsCaption = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeCaption), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeCaption));
    
    if (PyErr_Occurred())
      goto iapplication_put_caption_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIApplication->put_Caption(bsCaption);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIApplication->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IApplication) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IApplication.put_Caption() returned %ld", (long)hr);
        goto iapplication_put_caption_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Caption

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iapplication_put_caption_method_cleanup;

    iapplication_put_caption_method_cleanup:
    self->m_HR = hr;
    if (bsCaption)
        ::SysFreeString(bsCaption);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IApplication.put_Caption");
    return return_tuple;
}

static PyObject*
IApplicationMethod_get_Caption(PyIApplicationObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsCaption;
    PyObject* pyvar_Caption = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Caption

    // Call method on actual COM interface
    hr = self->m_pIApplication->get_Caption(&bsCaption);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIApplication->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IApplication) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IApplication.get_Caption() returned %ld", (long)hr);
        goto iapplication_get_caption_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Caption = PyUnicode_FromWideChar(bsCaption,::SysStringLen(bsCaption));
    ::SysFreeString(bsCaption);
    
    if (PyErr_Occurred())
      goto iapplication_get_caption_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Caption);
    goto iapplication_get_caption_method_cleanup;

    iapplication_get_caption_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Caption != Py_None)
        Py_XDECREF(pyvar_Caption);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IApplication.get_Caption");
    return return_tuple;
}


PyMethodDef PyIApplicationMethods[] = {
    {"supports", (PyCFunction)PyIApplication_SupportsInterface, METH_O, ""},
    {"get_Name", (PyCFunction)IApplicationMethod_get_Name, METH_VARARGS, ""},
    {"get_Document", (PyCFunction)IApplicationMethod_get_Document, METH_VARARGS, ""},
    {"get_StatusBar", (PyCFunction)IApplicationMethod_get_StatusBar, METH_VARARGS, ""},
    {"ShowDialog", (PyCFunction)IApplicationMethod_ShowDialog, METH_VARARGS, ""},
    {"IsDialogVisible", (PyCFunction)IApplicationMethod_IsDialogVisible, METH_VARARGS, ""},
    {"get_CurrentTool", (PyCFunction)IApplicationMethod_get_CurrentTool, METH_VARARGS, ""},
    {"putref_CurrentTool", (PyCFunction)IApplicationMethod_putref_CurrentTool, METH_VARARGS, ""},
    {"get_VBE", (PyCFunction)IApplicationMethod_get_VBE, METH_VARARGS, ""},
    {"NewDocument", (PyCFunction)IApplicationMethod_NewDocument, METH_VARARGS, ""},
    {"OpenDocument", (PyCFunction)IApplicationMethod_OpenDocument, METH_VARARGS, ""},
    {"SaveDocument", (PyCFunction)IApplicationMethod_SaveDocument, METH_VARARGS, ""},
    {"SaveAsDocument", (PyCFunction)IApplicationMethod_SaveAsDocument, METH_VARARGS, ""},
    {"PrintPreview", (PyCFunction)IApplicationMethod_PrintPreview, METH_NOARGS, ""},
    {"PrintDocument", (PyCFunction)IApplicationMethod_PrintDocument, METH_NOARGS, ""},
    {"LockCustomization", (PyCFunction)IApplicationMethod_LockCustomization, METH_VARARGS, ""},
    {"UnlockCustomization", (PyCFunction)IApplicationMethod_UnlockCustomization, METH_VARARGS, ""},
    {"RefreshWindow", (PyCFunction)IApplicationMethod_RefreshWindow, METH_NOARGS, ""},
    {"get_Templates", (PyCFunction)IApplicationMethod_get_Templates, METH_VARARGS, ""},
    {"get_hWnd", (PyCFunction)IApplicationMethod_get_hWnd, METH_VARARGS, ""},
    {"FindExtensionByName", (PyCFunction)IApplicationMethod_FindExtensionByName, METH_VARARGS, ""},
    {"FindExtensionByCLSID", (PyCFunction)IApplicationMethod_FindExtensionByCLSID, METH_VARARGS, ""},
    {"Shutdown", (PyCFunction)IApplicationMethod_Shutdown, METH_NOARGS, ""},
    {"get_Visible", (PyCFunction)IApplicationMethod_get_Visible, METH_VARARGS, ""},
    {"put_Visible", (PyCFunction)IApplicationMethod_put_Visible, METH_VARARGS, ""},
    {"put_Caption", (PyCFunction)IApplicationMethod_put_Caption, METH_VARARGS, ""},
    {"get_Caption", (PyCFunction)IApplicationMethod_get_Caption, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIApplicationGetSet[] = {
  {"_pUnk", (getter)PyIApplication_GetpUnk, NULL, "Get opaque pointer to an Unknown from IApplication", NULL},
  {"_pointer", (getter)PyIApplication_GetPointer, NULL, "Get memory address for IApplication", NULL},
  {"_IID", (getter)PyIApplication_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIApplication_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIApplication_GetIgnoreFailures, (setter)PyIApplication_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIApplicationObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriFramework.IApplicationObject",                          
                                              /* tp_name */
  sizeof(PyIApplicationObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIApplicationObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIApplicationMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIApplicationGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIApplicationObject_new,                      
                                              /* tp_new */
};

// Interface IAppROT

typedef struct PyIAppROTObject {
    PyObject_HEAD
    IAppROT* m_pIAppROT;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIAppROTObject;

static PyObject*
PyIAppROTObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIAppROTObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IAppROT* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IAppROT, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IAppROT with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIAppROTObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IAppROT");
            return NULL;
        }
        self->m_pIAppROT = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IAppROT");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IAppROT");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IAppROT* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IAppROT, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IAppROT");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIAppROTObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IAppROT");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIAppROT = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIAppROTObject_dealloc(PyIAppROTObject* self)
{
    if (self->m_pIAppROT)
        self->m_pIAppROT->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIAppROT_GetpUnk(PyIAppROTObject* self)
{
    if (!self->m_pIAppROT)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIAppROT->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IAppROT to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIAppROT_GetPointer(PyIAppROTObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIAppROT);
}

static PyObject*
PyIAppROT_GetIID(PyIAppROTObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "fabc30f9-d273-11d2-9f36-00c04f6bc61a");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIAppROT_GetHR(PyIAppROTObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIAppROT_GetIgnoreFailures(PyIAppROTObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIAppROT_SetIgnoreFailures(PyIAppROTObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIAppROT_SupportsInterface(PyIAppROTObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIAppROT->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IAppROTMethod_Add(PyIAppROTObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IApplication* ippApp = NULL;
    PyObject* py_pApp;
    long lcookie = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_pApp))
      goto iapprot_add_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pApp, &IID_IApplication, (void**)&ippApp))
        PyErr_SetString(PyExc_TypeError, "Argument pApp (position 0) is not IApplication");
    
    if (PyErr_Occurred())
      goto iapprot_add_method_cleanup;
    
    // No setup for cookie

    // Call method on actual COM interface
    hr = self->m_pIAppROT->Add(ippApp, &lcookie);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAppROT->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAppROT) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAppROT.Add() returned %ld", (long)hr);
        goto iapprot_add_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pApp
    // No teardown for cookie

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lcookie);
    goto iapprot_add_method_cleanup;

    iapprot_add_method_cleanup:
    self->m_HR = hr;
    if (ippApp)
      ippApp->Release();
    // No cleanup for cookie
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAppROT.Add");
    return return_tuple;
}

static PyObject*
IAppROTMethod_Remove(PyIAppROTObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lcookie = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lcookie))
      goto iapprot_remove_method_cleanup;

    // Set up initial variable values as needed
    // No setup for cookie

    // Call method on actual COM interface
    hr = self->m_pIAppROT->Remove(lcookie);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAppROT->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAppROT) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAppROT.Remove() returned %ld", (long)hr);
        goto iapprot_remove_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for cookie

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iapprot_remove_method_cleanup;

    iapprot_remove_method_cleanup:
    self->m_HR = hr;
    // No cleanup for cookie
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAppROT.Remove");
    return return_tuple;
}

static PyObject*
IAppROTMethod_get_Count(PyIAppROTObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Count

    // Call method on actual COM interface
    hr = self->m_pIAppROT->get_Count(&lCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAppROT->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAppROT) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAppROT.get_Count() returned %ld", (long)hr);
        goto iapprot_get_count_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Count

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lCount);
    goto iapprot_get_count_method_cleanup;

    iapprot_get_count_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Count
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAppROT.get_Count");
    return return_tuple;
}

static PyObject*
IAppROTMethod_get_Item(PyIAppROTObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lIndex = 0;
    IApplication* ippApp = NULL;
    PyObject* py_pApp = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lIndex))
      goto iapprot_get_item_method_cleanup;

    // Set up initial variable values as needed
    // No setup for Index
    // No setup for pApp

    // Call method on actual COM interface
    hr = self->m_pIAppROT->get_Item(lIndex, &ippApp);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAppROT->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAppROT) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAppROT.get_Item() returned %ld", (long)hr);
        goto iapprot_get_item_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Index
    Py_XDECREF(py_pApp);
    if (ippApp)
    {
        IUnknown* pUnk = NULL;
        ippApp->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_pApp = IUnknownToPythonIIDObject(pUnk, &IID_IApplication);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_pApp)
    {
        if (py_pApp)
           Py_DECREF(py_pApp);
        py_pApp = Py_None;
        Py_INCREF(py_pApp);
    }
    if (PyErr_Occurred())
      goto iapprot_get_item_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_pApp);
    goto iapprot_get_item_method_cleanup;

    iapprot_get_item_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Index
    Py_XDECREF(py_pApp);
    if (ippApp)
      ippApp->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAppROT.get_Item");
    return return_tuple;
}


PyMethodDef PyIAppROTMethods[] = {
    {"supports", (PyCFunction)PyIAppROT_SupportsInterface, METH_O, ""},
    {"Add", (PyCFunction)IAppROTMethod_Add, METH_VARARGS, ""},
    {"Remove", (PyCFunction)IAppROTMethod_Remove, METH_VARARGS, ""},
    {"get_Count", (PyCFunction)IAppROTMethod_get_Count, METH_VARARGS, ""},
    {"get_Item", (PyCFunction)IAppROTMethod_get_Item, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIAppROTGetSet[] = {
  {"_pUnk", (getter)PyIAppROT_GetpUnk, NULL, "Get opaque pointer to an Unknown from IAppROT", NULL},
  {"_pointer", (getter)PyIAppROT_GetPointer, NULL, "Get memory address for IAppROT", NULL},
  {"_IID", (getter)PyIAppROT_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIAppROT_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIAppROT_GetIgnoreFailures, (setter)PyIAppROT_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIAppROTObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriFramework.IAppROTObject",                          
                                              /* tp_name */
  sizeof(PyIAppROTObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIAppROTObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIAppROTMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIAppROTGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIAppROTObject_new,                      
                                              /* tp_new */
};

// Interface IAppROTEvents

typedef struct PyIAppROTEventsObject {
    PyObject_HEAD
    IAppROTEvents* m_pIAppROTEvents;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIAppROTEventsObject;

static PyObject*
PyIAppROTEventsObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIAppROTEventsObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IAppROTEvents* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IAppROTEvents, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IAppROTEvents with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIAppROTEventsObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IAppROTEvents");
            return NULL;
        }
        self->m_pIAppROTEvents = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IAppROTEvents");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IAppROTEvents");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IAppROTEvents* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IAppROTEvents, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IAppROTEvents");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIAppROTEventsObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IAppROTEvents");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIAppROTEvents = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIAppROTEventsObject_dealloc(PyIAppROTEventsObject* self)
{
    if (self->m_pIAppROTEvents)
        self->m_pIAppROTEvents->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIAppROTEvents_GetpUnk(PyIAppROTEventsObject* self)
{
    if (!self->m_pIAppROTEvents)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIAppROTEvents->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IAppROTEvents to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIAppROTEvents_GetPointer(PyIAppROTEventsObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIAppROTEvents);
}

static PyObject*
PyIAppROTEvents_GetIID(PyIAppROTEventsObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "fabc30fa-d273-11d2-9f36-00c04f6bc61a");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIAppROTEvents_GetHR(PyIAppROTEventsObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIAppROTEvents_GetIgnoreFailures(PyIAppROTEventsObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIAppROTEvents_SetIgnoreFailures(PyIAppROTEventsObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIAppROTEvents_SupportsInterface(PyIAppROTEventsObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIAppROTEvents->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IAppROTEventsMethod_AppAdded(PyIAppROTEventsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IApplication* ippApp = NULL;
    PyObject* py_pApp;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_pApp))
      goto iapprotevents_appadded_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pApp, &IID_IApplication, (void**)&ippApp))
        PyErr_SetString(PyExc_TypeError, "Argument pApp (position 0) is not IApplication");
    
    if (PyErr_Occurred())
      goto iapprotevents_appadded_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIAppROTEvents->AppAdded(ippApp);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAppROTEvents->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAppROTEvents) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAppROTEvents.AppAdded() returned %ld", (long)hr);
        goto iapprotevents_appadded_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pApp

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iapprotevents_appadded_method_cleanup;

    iapprotevents_appadded_method_cleanup:
    self->m_HR = hr;
    if (ippApp)
      ippApp->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAppROTEvents.AppAdded");
    return return_tuple;
}

static PyObject*
IAppROTEventsMethod_AppRemoved(PyIAppROTEventsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IApplication* ippApp = NULL;
    PyObject* py_pApp;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_pApp))
      goto iapprotevents_appremoved_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pApp, &IID_IApplication, (void**)&ippApp))
        PyErr_SetString(PyExc_TypeError, "Argument pApp (position 0) is not IApplication");
    
    if (PyErr_Occurred())
      goto iapprotevents_appremoved_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIAppROTEvents->AppRemoved(ippApp);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIAppROTEvents->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IAppROTEvents) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IAppROTEvents.AppRemoved() returned %ld", (long)hr);
        goto iapprotevents_appremoved_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pApp

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto iapprotevents_appremoved_method_cleanup;

    iapprotevents_appremoved_method_cleanup:
    self->m_HR = hr;
    if (ippApp)
      ippApp->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IAppROTEvents.AppRemoved");
    return return_tuple;
}


PyMethodDef PyIAppROTEventsMethods[] = {
    {"supports", (PyCFunction)PyIAppROTEvents_SupportsInterface, METH_O, ""},
    {"AppAdded", (PyCFunction)IAppROTEventsMethod_AppAdded, METH_VARARGS, ""},
    {"AppRemoved", (PyCFunction)IAppROTEventsMethod_AppRemoved, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIAppROTEventsGetSet[] = {
  {"_pUnk", (getter)PyIAppROTEvents_GetpUnk, NULL, "Get opaque pointer to an Unknown from IAppROTEvents", NULL},
  {"_pointer", (getter)PyIAppROTEvents_GetPointer, NULL, "Get memory address for IAppROTEvents", NULL},
  {"_IID", (getter)PyIAppROTEvents_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIAppROTEvents_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIAppROTEvents_GetIgnoreFailures, (setter)PyIAppROTEvents_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIAppROTEventsObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriFramework.IAppROTEventsObject",                          
                                              /* tp_name */
  sizeof(PyIAppROTEventsObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIAppROTEventsObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIAppROTEventsMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIAppROTEventsGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIAppROTEventsObject_new,                      
                                              /* tp_new */
};

// Interface IDocument

typedef struct PyIDocumentObject {
    PyObject_HEAD
    IDocument* m_pIDocument;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIDocumentObject;

static PyObject*
PyIDocumentObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIDocumentObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IDocument* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IDocument, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IDocument with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIDocumentObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IDocument");
            return NULL;
        }
        self->m_pIDocument = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IDocument");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IDocument");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IDocument* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IDocument, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IDocument");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIDocumentObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IDocument");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIDocument = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIDocumentObject_dealloc(PyIDocumentObject* self)
{
    if (self->m_pIDocument)
        self->m_pIDocument->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIDocument_GetpUnk(PyIDocumentObject* self)
{
    if (!self->m_pIDocument)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIDocument->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IDocument to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIDocument_GetPointer(PyIDocumentObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIDocument);
}

static PyObject*
PyIDocument_GetIID(PyIDocumentObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "3e927177-307a-11d2-94c9-080009eebecb");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIDocument_GetHR(PyIDocumentObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIDocument_GetIgnoreFailures(PyIDocumentObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIDocument_SetIgnoreFailures(PyIDocumentObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIDocument_SupportsInterface(PyIDocumentObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIDocument->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IDocumentMethod_get_Parent(PyIDocumentObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IApplication* ipapp = NULL;
    PyObject* py_app = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for app

    // Call method on actual COM interface
    hr = self->m_pIDocument->get_Parent(&ipapp);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDocument->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDocument) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDocument.get_Parent() returned %ld", (long)hr);
        goto idocument_get_parent_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_app);
    if (ipapp)
    {
        IUnknown* pUnk = NULL;
        ipapp->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_app = IUnknownToPythonIIDObject(pUnk, &IID_IApplication);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_app)
    {
        if (py_app)
           Py_DECREF(py_app);
        py_app = Py_None;
        Py_INCREF(py_app);
    }
    if (PyErr_Occurred())
      goto idocument_get_parent_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_app);
    goto idocument_get_parent_method_cleanup;

    idocument_get_parent_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_app);
    if (ipapp)
      ipapp->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDocument.get_Parent");
    return return_tuple;
}

static PyObject*
IDocumentMethod_get_Title(PyIDocumentObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsTitle;
    PyObject* pyvar_Title = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Title

    // Call method on actual COM interface
    hr = self->m_pIDocument->get_Title(&bsTitle);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDocument->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDocument) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDocument.get_Title() returned %ld", (long)hr);
        goto idocument_get_title_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Title = PyUnicode_FromWideChar(bsTitle,::SysStringLen(bsTitle));
    ::SysFreeString(bsTitle);
    
    if (PyErr_Occurred())
      goto idocument_get_title_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Title);
    goto idocument_get_title_method_cleanup;

    idocument_get_title_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Title != Py_None)
        Py_XDECREF(pyvar_Title);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDocument.get_Title");
    return return_tuple;
}

static PyObject*
IDocumentMethod_get_CommandBars(PyIDocumentObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ICommandBars* ipcmdBars = NULL;
    PyObject* py_cmdBars = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for cmdBars

    // Call method on actual COM interface
    hr = self->m_pIDocument->get_CommandBars(&ipcmdBars);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDocument->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDocument) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDocument.get_CommandBars() returned %ld", (long)hr);
        goto idocument_get_commandbars_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_cmdBars);
    if (ipcmdBars)
    {
        IUnknown* pUnk = NULL;
        ipcmdBars->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_cmdBars = IUnknownToPythonIIDObject(pUnk, &IID_ICommandBars);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_cmdBars)
    {
        if (py_cmdBars)
           Py_DECREF(py_cmdBars);
        py_cmdBars = Py_None;
        Py_INCREF(py_cmdBars);
    }
    if (PyErr_Occurred())
      goto idocument_get_commandbars_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_cmdBars);
    goto idocument_get_commandbars_method_cleanup;

    idocument_get_commandbars_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_cmdBars);
    if (ipcmdBars)
      ipcmdBars->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDocument.get_CommandBars");
    return return_tuple;
}

static PyObject*
IDocumentMethod_get_Accelerators(PyIDocumentObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IAcceleratorTable* ipaccelTable = NULL;
    PyObject* py_accelTable = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for accelTable

    // Call method on actual COM interface
    hr = self->m_pIDocument->get_Accelerators(&ipaccelTable);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDocument->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDocument) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDocument.get_Accelerators() returned %ld", (long)hr);
        goto idocument_get_accelerators_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_accelTable);
    if (ipaccelTable)
    {
        IUnknown* pUnk = NULL;
        ipaccelTable->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_accelTable = IUnknownToPythonIIDObject(pUnk, &IID_IAcceleratorTable);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_accelTable)
    {
        if (py_accelTable)
           Py_DECREF(py_accelTable);
        py_accelTable = Py_None;
        Py_INCREF(py_accelTable);
    }
    if (PyErr_Occurred())
      goto idocument_get_accelerators_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_accelTable);
    goto idocument_get_accelerators_method_cleanup;

    idocument_get_accelerators_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_accelTable);
    if (ipaccelTable)
      ipaccelTable->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDocument.get_Accelerators");
    return return_tuple;
}

static PyObject*
IDocumentMethod_get_ID(PyIDocumentObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IUID* ipID = NULL;
    PyObject* py_ID = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for ID

    // Call method on actual COM interface
    hr = self->m_pIDocument->get_ID(&ipID);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDocument->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDocument) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDocument.get_ID() returned %ld", (long)hr);
        goto idocument_get_id_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_ID);
    if (ipID)
    {
        IUnknown* pUnk = NULL;
        ipID->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_ID = IUnknownToPythonIIDObject(pUnk, &IID_IUID);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_ID)
    {
        if (py_ID)
           Py_DECREF(py_ID);
        py_ID = Py_None;
        Py_INCREF(py_ID);
    }
    if (PyErr_Occurred())
      goto idocument_get_id_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_ID);
    goto idocument_get_id_method_cleanup;

    idocument_get_id_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_ID);
    if (ipID)
      ipID->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDocument.get_ID");
    return return_tuple;
}

static PyObject*
IDocumentMethod_get_Type(PyIDocumentObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriDocumentType eType;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Type

    // Call method on actual COM interface
    hr = self->m_pIDocument->get_Type(&eType);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIDocument->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IDocument) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IDocument.get_Type() returned %ld", (long)hr);
        goto idocument_get_type_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Type

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)eType);
    goto idocument_get_type_method_cleanup;

    idocument_get_type_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Type
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IDocument.get_Type");
    return return_tuple;
}

static PyObject*
IDocumentMethod_get_VBProject(PyIDocumentObject* self, PyObject* args)
{
    /* Param types that are unhandleable: 
       OUTPUT [u'IDispatch', u'*', u'*']
    */
    PyErr_SetString(PyExc_NotImplementedError, "Wrapper for IDocument.get_VBProject not implemented.");
    return NULL;
}


PyMethodDef PyIDocumentMethods[] = {
    {"supports", (PyCFunction)PyIDocument_SupportsInterface, METH_O, ""},
    {"get_Parent", (PyCFunction)IDocumentMethod_get_Parent, METH_VARARGS, ""},
    {"get_Title", (PyCFunction)IDocumentMethod_get_Title, METH_VARARGS, ""},
    {"get_CommandBars", (PyCFunction)IDocumentMethod_get_CommandBars, METH_VARARGS, ""},
    {"get_Accelerators", (PyCFunction)IDocumentMethod_get_Accelerators, METH_VARARGS, ""},
    {"get_ID", (PyCFunction)IDocumentMethod_get_ID, METH_VARARGS, ""},
    {"get_Type", (PyCFunction)IDocumentMethod_get_Type, METH_VARARGS, ""},
    {"get_VBProject", (PyCFunction)IDocumentMethod_get_VBProject, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIDocumentGetSet[] = {
  {"_pUnk", (getter)PyIDocument_GetpUnk, NULL, "Get opaque pointer to an Unknown from IDocument", NULL},
  {"_pointer", (getter)PyIDocument_GetPointer, NULL, "Get memory address for IDocument", NULL},
  {"_IID", (getter)PyIDocument_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIDocument_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIDocument_GetIgnoreFailures, (setter)PyIDocument_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIDocumentObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriFramework.IDocumentObject",                          
                                              /* tp_name */
  sizeof(PyIDocumentObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIDocumentObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIDocumentMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIDocumentGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIDocumentObject_new,                      
                                              /* tp_new */
};

// Interface ICommandBars

typedef struct PyICommandBarsObject {
    PyObject_HEAD
    ICommandBars* m_pICommandBars;
    HRESULT m_HR;
    int m_ignore_failures;
} PyICommandBarsObject;

static PyObject*
PyICommandBarsObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyICommandBarsObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ICommandBars* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ICommandBars, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ICommandBars with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyICommandBarsObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ICommandBars");
            return NULL;
        }
        self->m_pICommandBars = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ICommandBars");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ICommandBars");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ICommandBars* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ICommandBars, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ICommandBars");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyICommandBarsObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ICommandBars");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pICommandBars = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyICommandBarsObject_dealloc(PyICommandBarsObject* self)
{
    if (self->m_pICommandBars)
        self->m_pICommandBars->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyICommandBars_GetpUnk(PyICommandBarsObject* self)
{
    if (!self->m_pICommandBars)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pICommandBars->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ICommandBars to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyICommandBars_GetPointer(PyICommandBarsObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pICommandBars);
}

static PyObject*
PyICommandBars_GetIID(PyICommandBarsObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "289fc451-d249-11d1-91ad-0080c718df97");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyICommandBars_GetHR(PyICommandBarsObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyICommandBars_GetIgnoreFailures(PyICommandBarsObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyICommandBars_SetIgnoreFailures(PyICommandBarsObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyICommandBars_SupportsInterface(PyICommandBarsObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pICommandBars->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ICommandBarsMethod_put_ShowToolTips(PyICommandBarsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_bShow = VARIANT_FALSE;
    PyObject* pyvar_bShow = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_bShow))
      goto icommandbars_put_showtooltips_method_cleanup;

    // Set up initial variable values as needed
    b_bShow = ((PyObject_IsTrue(pyvar_bShow) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto icommandbars_put_showtooltips_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pICommandBars->put_ShowToolTips(b_bShow);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICommandBars->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICommandBars) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICommandBars.put_ShowToolTips() returned %ld", (long)hr);
        goto icommandbars_put_showtooltips_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for bShow

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icommandbars_put_showtooltips_method_cleanup;

    icommandbars_put_showtooltips_method_cleanup:
    self->m_HR = hr;
    // No cleanup for bShow
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICommandBars.put_ShowToolTips");
    return return_tuple;
}

static PyObject*
ICommandBarsMethod_get_ShowToolTips(PyICommandBarsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_bShow = VARIANT_FALSE;
    PyObject* pyvar_bShow = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for bShow

    // Call method on actual COM interface
    hr = self->m_pICommandBars->get_ShowToolTips(&b_bShow);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICommandBars->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICommandBars) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICommandBars.get_ShowToolTips() returned %ld", (long)hr);
        goto icommandbars_get_showtooltips_method_cleanup;
    }

    // Set up return values as needed
    pyvar_bShow = ((b_bShow == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto icommandbars_get_showtooltips_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_bShow);
    goto icommandbars_get_showtooltips_method_cleanup;

    icommandbars_get_showtooltips_method_cleanup:
    self->m_HR = hr;
    // No cleanup for bShow
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICommandBars.get_ShowToolTips");
    return return_tuple;
}

static PyObject*
ICommandBarsMethod_put_LargeIcons(PyICommandBarsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_bLarge = VARIANT_FALSE;
    PyObject* pyvar_bLarge = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_bLarge))
      goto icommandbars_put_largeicons_method_cleanup;

    // Set up initial variable values as needed
    b_bLarge = ((PyObject_IsTrue(pyvar_bLarge) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto icommandbars_put_largeicons_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pICommandBars->put_LargeIcons(b_bLarge);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICommandBars->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICommandBars) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICommandBars.put_LargeIcons() returned %ld", (long)hr);
        goto icommandbars_put_largeicons_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for bLarge

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icommandbars_put_largeicons_method_cleanup;

    icommandbars_put_largeicons_method_cleanup:
    self->m_HR = hr;
    // No cleanup for bLarge
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICommandBars.put_LargeIcons");
    return return_tuple;
}

static PyObject*
ICommandBarsMethod_get_LargeIcons(PyICommandBarsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_bLarge = VARIANT_FALSE;
    PyObject* pyvar_bLarge = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for bLarge

    // Call method on actual COM interface
    hr = self->m_pICommandBars->get_LargeIcons(&b_bLarge);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICommandBars->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICommandBars) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICommandBars.get_LargeIcons() returned %ld", (long)hr);
        goto icommandbars_get_largeicons_method_cleanup;
    }

    // Set up return values as needed
    pyvar_bLarge = ((b_bLarge == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto icommandbars_get_largeicons_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_bLarge);
    goto icommandbars_get_largeicons_method_cleanup;

    icommandbars_get_largeicons_method_cleanup:
    self->m_HR = hr;
    // No cleanup for bLarge
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICommandBars.get_LargeIcons");
    return return_tuple;
}

static PyObject*
ICommandBarsMethod_Create(PyICommandBarsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName = 0;
    PyObject* pyvar_Name;
    PyObject* unicodeName = NULL;
    esriCmdBarType ebarType;
    ICommandBar* ipnewBar = NULL;
    PyObject* py_newBar = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "Oi", &pyvar_Name, (int *)&ebarType))
      goto icommandbars_create_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_Name))
        unicodeName = PyUnicode_FromObject(pyvar_Name);
    else if (PyUnicode_Check(pyvar_Name))
    {
        unicodeName = pyvar_Name;
        Py_INCREF(unicodeName);
    }
    else if (pyvar_Name != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Name at index 0");
    if (unicodeName)
        bsName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeName));
    
    if (PyErr_Occurred())
      goto icommandbars_create_method_cleanup;
    
    // No setup for barType
    // No setup for newBar

    // Call method on actual COM interface
    hr = self->m_pICommandBars->Create(bsName, ebarType, &ipnewBar);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICommandBars->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICommandBars) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICommandBars.Create() returned %ld", (long)hr);
        goto icommandbars_create_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Name
    // No teardown for barType
    Py_XDECREF(py_newBar);
    if (ipnewBar)
    {
        IUnknown* pUnk = NULL;
        ipnewBar->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_newBar = IUnknownToPythonIIDObject(pUnk, &IID_ICommandBar);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_newBar)
    {
        if (py_newBar)
           Py_DECREF(py_newBar);
        py_newBar = Py_None;
        Py_INCREF(py_newBar);
    }
    if (PyErr_Occurred())
      goto icommandbars_create_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_newBar);
    goto icommandbars_create_method_cleanup;

    icommandbars_create_method_cleanup:
    self->m_HR = hr;
    if (bsName)
        ::SysFreeString(bsName);
    
    // No cleanup for barType
    Py_XDECREF(py_newBar);
    if (ipnewBar)
      ipnewBar->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICommandBars.Create");
    return return_tuple;
}

static PyObject*
ICommandBarsMethod_Find(PyICommandBarsObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT videntifier;
    ::VariantInit(&videntifier);
    PyObject* pyvar_identifier = NULL;
    VARIANT_BOOL b_noRecurse = VARIANT_FALSE;
    PyObject* pyvar_noRecurse = NULL;
    VARIANT_BOOL b_noCreate = VARIANT_FALSE;
    PyObject* pyvar_noCreate = NULL;
    ICommandItem* ipItem = NULL;
    PyObject* py_Item = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOO", &pyvar_identifier, &pyvar_noRecurse, &pyvar_noCreate))
      goto icommandbars_find_method_cleanup;

    // Set up initial variable values as needed
    PyObject_AsVariant(pyvar_identifier, &videntifier);
    
    if (PyErr_Occurred())
      goto icommandbars_find_method_cleanup;
    
    b_noRecurse = ((PyObject_IsTrue(pyvar_noRecurse) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto icommandbars_find_method_cleanup;
    
    b_noCreate = ((PyObject_IsTrue(pyvar_noCreate) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto icommandbars_find_method_cleanup;
    
    // No setup for Item

    // Call method on actual COM interface
    hr = self->m_pICommandBars->Find(videntifier, b_noRecurse, b_noCreate, &ipItem);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICommandBars->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICommandBars) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICommandBars.Find() returned %ld", (long)hr);
        goto icommandbars_find_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for identifier
    // No teardown for noRecurse
    // No teardown for noCreate
    Py_XDECREF(py_Item);
    if (ipItem)
    {
        IUnknown* pUnk = NULL;
        ipItem->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_Item = IUnknownToPythonIIDObject(pUnk, &IID_ICommandItem);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_Item)
    {
        if (py_Item)
           Py_DECREF(py_Item);
        py_Item = Py_None;
        Py_INCREF(py_Item);
    }
    if (PyErr_Occurred())
      goto icommandbars_find_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_Item);
    goto icommandbars_find_method_cleanup;

    icommandbars_find_method_cleanup:
    self->m_HR = hr;
    ::VariantClear(&videntifier);
    // No cleanup for noRecurse
    // No cleanup for noCreate
    Py_XDECREF(py_Item);
    if (ipItem)
      ipItem->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICommandBars.Find");
    return return_tuple;
}

static PyObject*
ICommandBarsMethod_HideAllToolbars(PyICommandBarsObject* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pICommandBars->HideAllToolbars();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICommandBars->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICommandBars) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICommandBars.HideAllToolbars() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}


PyMethodDef PyICommandBarsMethods[] = {
    {"supports", (PyCFunction)PyICommandBars_SupportsInterface, METH_O, ""},
    {"put_ShowToolTips", (PyCFunction)ICommandBarsMethod_put_ShowToolTips, METH_VARARGS, ""},
    {"get_ShowToolTips", (PyCFunction)ICommandBarsMethod_get_ShowToolTips, METH_VARARGS, ""},
    {"put_LargeIcons", (PyCFunction)ICommandBarsMethod_put_LargeIcons, METH_VARARGS, ""},
    {"get_LargeIcons", (PyCFunction)ICommandBarsMethod_get_LargeIcons, METH_VARARGS, ""},
    {"Create", (PyCFunction)ICommandBarsMethod_Create, METH_VARARGS, ""},
    {"Find", (PyCFunction)ICommandBarsMethod_Find, METH_VARARGS, ""},
    {"HideAllToolbars", (PyCFunction)ICommandBarsMethod_HideAllToolbars, METH_NOARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyICommandBarsGetSet[] = {
  {"_pUnk", (getter)PyICommandBars_GetpUnk, NULL, "Get opaque pointer to an Unknown from ICommandBars", NULL},
  {"_pointer", (getter)PyICommandBars_GetPointer, NULL, "Get memory address for ICommandBars", NULL},
  {"_IID", (getter)PyICommandBars_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyICommandBars_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyICommandBars_GetIgnoreFailures, (setter)PyICommandBars_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyICommandBarsObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriFramework.ICommandBarsObject",                          
                                              /* tp_name */
  sizeof(PyICommandBarsObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyICommandBarsObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyICommandBarsMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyICommandBarsGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyICommandBarsObject_new,                      
                                              /* tp_new */
};

// Interface ICommandBar

typedef struct PyICommandBarObject {
    PyObject_HEAD
    ICommandBar* m_pICommandBar;
    HRESULT m_HR;
    int m_ignore_failures;
} PyICommandBarObject;

static PyObject*
PyICommandBarObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyICommandBarObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ICommandBar* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ICommandBar, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ICommandBar with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyICommandBarObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ICommandBar");
            return NULL;
        }
        self->m_pICommandBar = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ICommandBar");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ICommandBar");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ICommandBar* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ICommandBar, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ICommandBar");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyICommandBarObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ICommandBar");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pICommandBar = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyICommandBarObject_dealloc(PyICommandBarObject* self)
{
    if (self->m_pICommandBar)
        self->m_pICommandBar->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyICommandBar_GetpUnk(PyICommandBarObject* self)
{
    if (!self->m_pICommandBar)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pICommandBar->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ICommandBar to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyICommandBar_GetPointer(PyICommandBarObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pICommandBar);
}

static PyObject*
PyICommandBar_GetIID(PyICommandBarObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "32e9d003-b867-11d1-947b-080009eebecb");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyICommandBar_GetHR(PyICommandBarObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyICommandBar_GetIgnoreFailures(PyICommandBarObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyICommandBar_SetIgnoreFailures(PyICommandBarObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyICommandBar_SupportsInterface(PyICommandBarObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pICommandBar->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ICommandBarMethod_Add(PyICommandBarObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IUID* ipcmdID = NULL;
    PyObject* py_cmdID;
    VARIANT vIndex;
    ::VariantInit(&vIndex);
    PyObject* pyvar_Index = NULL;
    ICommandItem* ipItem = NULL;
    PyObject* py_Item = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OO", &py_cmdID, &pyvar_Index))
      goto icommandbar_add_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_cmdID, &IID_IUID, (void**)&ipcmdID))
        PyErr_SetString(PyExc_TypeError, "Argument cmdID (position 0) is not IUID");
    
    if (PyErr_Occurred())
      goto icommandbar_add_method_cleanup;
    
    PyObject_AsVariant(pyvar_Index, &vIndex);
    
    if (PyErr_Occurred())
      goto icommandbar_add_method_cleanup;
    
    // No setup for Item

    // Call method on actual COM interface
    hr = self->m_pICommandBar->Add(ipcmdID, &vIndex, &ipItem);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICommandBar->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICommandBar) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICommandBar.Add() returned %ld", (long)hr);
        goto icommandbar_add_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for cmdID
    // No teardown for Index
    Py_XDECREF(py_Item);
    if (ipItem)
    {
        IUnknown* pUnk = NULL;
        ipItem->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_Item = IUnknownToPythonIIDObject(pUnk, &IID_ICommandItem);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_Item)
    {
        if (py_Item)
           Py_DECREF(py_Item);
        py_Item = Py_None;
        Py_INCREF(py_Item);
    }
    if (PyErr_Occurred())
      goto icommandbar_add_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_Item);
    goto icommandbar_add_method_cleanup;

    icommandbar_add_method_cleanup:
    self->m_HR = hr;
    if (ipcmdID)
      ipcmdID->Release();
    ::VariantClear(&vIndex);
    Py_XDECREF(py_Item);
    if (ipItem)
      ipItem->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICommandBar.Add");
    return return_tuple;
}

static PyObject*
ICommandBarMethod_CreateMenu(PyICommandBarObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName = 0;
    PyObject* pyvar_Name;
    PyObject* unicodeName = NULL;
    VARIANT vIndex;
    ::VariantInit(&vIndex);
    PyObject* pyvar_Index = NULL;
    ICommandBar* ipmenu = NULL;
    PyObject* py_menu = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OO", &pyvar_Name, &pyvar_Index))
      goto icommandbar_createmenu_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_Name))
        unicodeName = PyUnicode_FromObject(pyvar_Name);
    else if (PyUnicode_Check(pyvar_Name))
    {
        unicodeName = pyvar_Name;
        Py_INCREF(unicodeName);
    }
    else if (pyvar_Name != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Name at index 0");
    if (unicodeName)
        bsName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeName));
    
    if (PyErr_Occurred())
      goto icommandbar_createmenu_method_cleanup;
    
    PyObject_AsVariant(pyvar_Index, &vIndex);
    
    if (PyErr_Occurred())
      goto icommandbar_createmenu_method_cleanup;
    
    // No setup for menu

    // Call method on actual COM interface
    hr = self->m_pICommandBar->CreateMenu(bsName, &vIndex, &ipmenu);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICommandBar->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICommandBar) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICommandBar.CreateMenu() returned %ld", (long)hr);
        goto icommandbar_createmenu_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Name
    // No teardown for Index
    Py_XDECREF(py_menu);
    if (ipmenu)
    {
        IUnknown* pUnk = NULL;
        ipmenu->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_menu = IUnknownToPythonIIDObject(pUnk, &IID_ICommandBar);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_menu)
    {
        if (py_menu)
           Py_DECREF(py_menu);
        py_menu = Py_None;
        Py_INCREF(py_menu);
    }
    if (PyErr_Occurred())
      goto icommandbar_createmenu_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_menu);
    goto icommandbar_createmenu_method_cleanup;

    icommandbar_createmenu_method_cleanup:
    self->m_HR = hr;
    if (bsName)
        ::SysFreeString(bsName);
    
    ::VariantClear(&vIndex);
    Py_XDECREF(py_menu);
    if (ipmenu)
      ipmenu->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICommandBar.CreateMenu");
    return return_tuple;
}

static PyObject*
ICommandBarMethod_CreateMacroItem(PyICommandBarObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName = 0;
    PyObject* pyvar_Name;
    PyObject* unicodeName = NULL;
    VARIANT vFaceID;
    ::VariantInit(&vFaceID);
    PyObject* pyvar_FaceID = NULL;
    BSTR bsAction = 0;
    PyObject* pyvar_Action;
    PyObject* unicodeAction = NULL;
    VARIANT vIndex;
    ::VariantInit(&vIndex);
    PyObject* pyvar_Index = NULL;
    ICommandItem* ipmacro = NULL;
    PyObject* py_macro = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OOOO", &pyvar_Name, &pyvar_FaceID, &pyvar_Action, &pyvar_Index))
      goto icommandbar_createmacroitem_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_Name))
        unicodeName = PyUnicode_FromObject(pyvar_Name);
    else if (PyUnicode_Check(pyvar_Name))
    {
        unicodeName = pyvar_Name;
        Py_INCREF(unicodeName);
    }
    else if (pyvar_Name != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Name at index 0");
    if (unicodeName)
        bsName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeName));
    
    if (PyErr_Occurred())
      goto icommandbar_createmacroitem_method_cleanup;
    
    PyObject_AsVariant(pyvar_FaceID, &vFaceID);
    
    if (PyErr_Occurred())
      goto icommandbar_createmacroitem_method_cleanup;
    
    if (PyString_Check(pyvar_Action))
        unicodeAction = PyUnicode_FromObject(pyvar_Action);
    else if (PyUnicode_Check(pyvar_Action))
    {
        unicodeAction = pyvar_Action;
        Py_INCREF(unicodeAction);
    }
    else if (pyvar_Action != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Action at index 2");
    if (unicodeAction)
        bsAction = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeAction), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeAction));
    
    if (PyErr_Occurred())
      goto icommandbar_createmacroitem_method_cleanup;
    
    PyObject_AsVariant(pyvar_Index, &vIndex);
    
    if (PyErr_Occurred())
      goto icommandbar_createmacroitem_method_cleanup;
    
    // No setup for macro

    // Call method on actual COM interface
    hr = self->m_pICommandBar->CreateMacroItem(bsName, &vFaceID, bsAction, &vIndex, &ipmacro);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICommandBar->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICommandBar) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICommandBar.CreateMacroItem() returned %ld", (long)hr);
        goto icommandbar_createmacroitem_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Name
    // No teardown for FaceID
    // No teardown for Action
    // No teardown for Index
    Py_XDECREF(py_macro);
    if (ipmacro)
    {
        IUnknown* pUnk = NULL;
        ipmacro->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_macro = IUnknownToPythonIIDObject(pUnk, &IID_ICommandItem);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_macro)
    {
        if (py_macro)
           Py_DECREF(py_macro);
        py_macro = Py_None;
        Py_INCREF(py_macro);
    }
    if (PyErr_Occurred())
      goto icommandbar_createmacroitem_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_macro);
    goto icommandbar_createmacroitem_method_cleanup;

    icommandbar_createmacroitem_method_cleanup:
    self->m_HR = hr;
    if (bsName)
        ::SysFreeString(bsName);
    
    ::VariantClear(&vFaceID);
    if (bsAction)
        ::SysFreeString(bsAction);
    
    ::VariantClear(&vIndex);
    Py_XDECREF(py_macro);
    if (ipmacro)
      ipmacro->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICommandBar.CreateMacroItem");
    return return_tuple;
}

static PyObject*
ICommandBarMethod_get_Count(PyICommandBarObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lCount = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Count

    // Call method on actual COM interface
    hr = self->m_pICommandBar->get_Count(&lCount);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICommandBar->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICommandBar) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICommandBar.get_Count() returned %ld", (long)hr);
        goto icommandbar_get_count_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Count

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lCount);
    goto icommandbar_get_count_method_cleanup;

    icommandbar_get_count_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Count
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICommandBar.get_Count");
    return return_tuple;
}

static PyObject*
ICommandBarMethod_Find(PyICommandBarObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT videntifier;
    ::VariantInit(&videntifier);
    PyObject* pyvar_identifier = NULL;
    VARIANT_BOOL b_noRecurse = VARIANT_FALSE;
    PyObject* pyvar_noRecurse = NULL;
    ICommandItem* ipItem = NULL;
    PyObject* py_Item = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "OO", &pyvar_identifier, &pyvar_noRecurse))
      goto icommandbar_find_method_cleanup;

    // Set up initial variable values as needed
    PyObject_AsVariant(pyvar_identifier, &videntifier);
    
    if (PyErr_Occurred())
      goto icommandbar_find_method_cleanup;
    
    b_noRecurse = ((PyObject_IsTrue(pyvar_noRecurse) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto icommandbar_find_method_cleanup;
    
    // No setup for Item

    // Call method on actual COM interface
    hr = self->m_pICommandBar->Find(videntifier, b_noRecurse, &ipItem);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICommandBar->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICommandBar) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICommandBar.Find() returned %ld", (long)hr);
        goto icommandbar_find_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for identifier
    // No teardown for noRecurse
    Py_XDECREF(py_Item);
    if (ipItem)
    {
        IUnknown* pUnk = NULL;
        ipItem->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_Item = IUnknownToPythonIIDObject(pUnk, &IID_ICommandItem);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_Item)
    {
        if (py_Item)
           Py_DECREF(py_Item);
        py_Item = Py_None;
        Py_INCREF(py_Item);
    }
    if (PyErr_Occurred())
      goto icommandbar_find_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_Item);
    goto icommandbar_find_method_cleanup;

    icommandbar_find_method_cleanup:
    self->m_HR = hr;
    ::VariantClear(&videntifier);
    // No cleanup for noRecurse
    Py_XDECREF(py_Item);
    if (ipItem)
      ipItem->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICommandBar.Find");
    return return_tuple;
}

static PyObject*
ICommandBarMethod_get_Item(PyICommandBarObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lIndex = 0;
    ICommandItem* ipItem = NULL;
    PyObject* py_Item = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lIndex))
      goto icommandbar_get_item_method_cleanup;

    // Set up initial variable values as needed
    // No setup for Index
    // No setup for Item

    // Call method on actual COM interface
    hr = self->m_pICommandBar->get_Item(lIndex, &ipItem);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICommandBar->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICommandBar) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICommandBar.get_Item() returned %ld", (long)hr);
        goto icommandbar_get_item_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Index
    Py_XDECREF(py_Item);
    if (ipItem)
    {
        IUnknown* pUnk = NULL;
        ipItem->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_Item = IUnknownToPythonIIDObject(pUnk, &IID_ICommandItem);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_Item)
    {
        if (py_Item)
           Py_DECREF(py_Item);
        py_Item = Py_None;
        Py_INCREF(py_Item);
    }
    if (PyErr_Occurred())
      goto icommandbar_get_item_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_Item);
    goto icommandbar_get_item_method_cleanup;

    icommandbar_get_item_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Index
    Py_XDECREF(py_Item);
    if (ipItem)
      ipItem->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICommandBar.get_Item");
    return return_tuple;
}

static PyObject*
ICommandBarMethod_Popup(PyICommandBarObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lX = 0;
    long lY = 0;
    ICommandItem* ipChoice = NULL;
    PyObject* py_Choice = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "ll", &lX, &lY))
      goto icommandbar_popup_method_cleanup;

    // Set up initial variable values as needed
    // No setup for X
    // No setup for Y
    // No setup for Choice

    // Call method on actual COM interface
    hr = self->m_pICommandBar->Popup(lX, lY, &ipChoice);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICommandBar->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICommandBar) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICommandBar.Popup() returned %ld", (long)hr);
        goto icommandbar_popup_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for X
    // No teardown for Y
    Py_XDECREF(py_Choice);
    if (ipChoice)
    {
        IUnknown* pUnk = NULL;
        ipChoice->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_Choice = IUnknownToPythonIIDObject(pUnk, &IID_ICommandItem);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_Choice)
    {
        if (py_Choice)
           Py_DECREF(py_Choice);
        py_Choice = Py_None;
        Py_INCREF(py_Choice);
    }
    if (PyErr_Occurred())
      goto icommandbar_popup_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_Choice);
    goto icommandbar_popup_method_cleanup;

    icommandbar_popup_method_cleanup:
    self->m_HR = hr;
    // No cleanup for X
    // No cleanup for Y
    Py_XDECREF(py_Choice);
    if (ipChoice)
      ipChoice->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICommandBar.Popup");
    return return_tuple;
}

static PyObject*
ICommandBarMethod_Dock(PyICommandBarObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriDockFlags edockFlags;
    ICommandBar* ipreferenceBar = NULL;
    PyObject* py_referenceBar;

    // Unpack values
    if (!PyArg_ParseTuple(args, "iO", (int *)&edockFlags, &py_referenceBar))
      goto icommandbar_dock_method_cleanup;

    // Set up initial variable values as needed
    // No setup for dockFlags
    if (!IFaceFromPyObject(py_referenceBar, &IID_ICommandBar, (void**)&ipreferenceBar))
        PyErr_SetString(PyExc_TypeError, "Argument referenceBar (position 1) is not ICommandBar");
    
    if (PyErr_Occurred())
      goto icommandbar_dock_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pICommandBar->Dock(edockFlags, ipreferenceBar);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICommandBar->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICommandBar) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICommandBar.Dock() returned %ld", (long)hr);
        goto icommandbar_dock_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for dockFlags
    // No teardown for referenceBar

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icommandbar_dock_method_cleanup;

    icommandbar_dock_method_cleanup:
    self->m_HR = hr;
    // No cleanup for dockFlags
    if (ipreferenceBar)
      ipreferenceBar->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICommandBar.Dock");
    return return_tuple;
}

static PyObject*
ICommandBarMethod_IsVisible(PyICommandBarObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_bVisible = VARIANT_FALSE;
    PyObject* pyvar_bVisible = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for bVisible

    // Call method on actual COM interface
    hr = self->m_pICommandBar->IsVisible(&b_bVisible);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICommandBar->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICommandBar) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICommandBar.IsVisible() returned %ld", (long)hr);
        goto icommandbar_isvisible_method_cleanup;
    }

    // Set up return values as needed
    pyvar_bVisible = ((b_bVisible == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto icommandbar_isvisible_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_bVisible);
    goto icommandbar_isvisible_method_cleanup;

    icommandbar_isvisible_method_cleanup:
    self->m_HR = hr;
    // No cleanup for bVisible
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICommandBar.IsVisible");
    return return_tuple;
}


PyMethodDef PyICommandBarMethods[] = {
    {"supports", (PyCFunction)PyICommandBar_SupportsInterface, METH_O, ""},
    {"Add", (PyCFunction)ICommandBarMethod_Add, METH_VARARGS, ""},
    {"CreateMenu", (PyCFunction)ICommandBarMethod_CreateMenu, METH_VARARGS, ""},
    {"CreateMacroItem", (PyCFunction)ICommandBarMethod_CreateMacroItem, METH_VARARGS, ""},
    {"get_Count", (PyCFunction)ICommandBarMethod_get_Count, METH_VARARGS, ""},
    {"Find", (PyCFunction)ICommandBarMethod_Find, METH_VARARGS, ""},
    {"get_Item", (PyCFunction)ICommandBarMethod_get_Item, METH_VARARGS, ""},
    {"Popup", (PyCFunction)ICommandBarMethod_Popup, METH_VARARGS, ""},
    {"Dock", (PyCFunction)ICommandBarMethod_Dock, METH_VARARGS, ""},
    {"IsVisible", (PyCFunction)ICommandBarMethod_IsVisible, METH_VARARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyICommandBarGetSet[] = {
  {"_pUnk", (getter)PyICommandBar_GetpUnk, NULL, "Get opaque pointer to an Unknown from ICommandBar", NULL},
  {"_pointer", (getter)PyICommandBar_GetPointer, NULL, "Get memory address for ICommandBar", NULL},
  {"_IID", (getter)PyICommandBar_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyICommandBar_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyICommandBar_GetIgnoreFailures, (setter)PyICommandBar_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyICommandBarObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriFramework.ICommandBarObject",                          
                                              /* tp_name */
  sizeof(PyICommandBarObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyICommandBarObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyICommandBarMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyICommandBarGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyICommandBarObject_new,                      
                                              /* tp_new */
};

// Interface ICommandItem

typedef struct PyICommandItemObject {
    PyObject_HEAD
    ICommandItem* m_pICommandItem;
    HRESULT m_HR;
    int m_ignore_failures;
} PyICommandItemObject;

static PyObject*
PyICommandItemObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyICommandItemObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        ICommandItem* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_ICommandItem, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate ICommandItem with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyICommandItemObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate ICommandItem");
            return NULL;
        }
        self->m_pICommandItem = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for ICommandItem");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to ICommandItem");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    ICommandItem* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_ICommandItem, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to ICommandItem");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyICommandItemObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate ICommandItem");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pICommandItem = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyICommandItemObject_dealloc(PyICommandItemObject* self)
{
    if (self->m_pICommandItem)
        self->m_pICommandItem->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyICommandItem_GetpUnk(PyICommandItemObject* self)
{
    if (!self->m_pICommandItem)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pICommandItem->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI ICommandItem to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyICommandItem_GetPointer(PyICommandItemObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pICommandItem);
}

static PyObject*
PyICommandItem_GetIID(PyICommandItemObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "423b7723-b858-11d1-947b-080009eebecb");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyICommandItem_GetHR(PyICommandItemObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyICommandItem_GetIgnoreFailures(PyICommandItemObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyICommandItem_SetIgnoreFailures(PyICommandItemObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyICommandItem_SupportsInterface(PyICommandItemObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pICommandItem->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
ICommandItemMethod_get_Action(PyICommandItemObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsmacro;
    PyObject* pyvar_macro = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for macro

    // Call method on actual COM interface
    hr = self->m_pICommandItem->get_Action(&bsmacro);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICommandItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICommandItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICommandItem.get_Action() returned %ld", (long)hr);
        goto icommanditem_get_action_method_cleanup;
    }

    // Set up return values as needed
    pyvar_macro = PyUnicode_FromWideChar(bsmacro,::SysStringLen(bsmacro));
    ::SysFreeString(bsmacro);
    
    if (PyErr_Occurred())
      goto icommanditem_get_action_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_macro);
    goto icommanditem_get_action_method_cleanup;

    icommanditem_get_action_method_cleanup:
    self->m_HR = hr;
    if (pyvar_macro != Py_None)
        Py_XDECREF(pyvar_macro);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICommandItem.get_Action");
    return return_tuple;
}

static PyObject*
ICommandItemMethod_put_Action(PyICommandItemObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsmacro = 0;
    PyObject* pyvar_macro;
    PyObject* unicodemacro = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_macro))
      goto icommanditem_put_action_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_macro))
        unicodemacro = PyUnicode_FromObject(pyvar_macro);
    else if (PyUnicode_Check(pyvar_macro))
    {
        unicodemacro = pyvar_macro;
        Py_INCREF(unicodemacro);
    }
    else if (pyvar_macro != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter macro at index 0");
    if (unicodemacro)
        bsmacro = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodemacro), 
                                            (UINT)PyUnicode_GET_SIZE(unicodemacro));
    
    if (PyErr_Occurred())
      goto icommanditem_put_action_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pICommandItem->put_Action(bsmacro);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICommandItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICommandItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICommandItem.put_Action() returned %ld", (long)hr);
        goto icommanditem_put_action_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for macro

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icommanditem_put_action_method_cleanup;

    icommanditem_put_action_method_cleanup:
    self->m_HR = hr;
    if (bsmacro)
        ::SysFreeString(bsmacro);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICommandItem.put_Action");
    return return_tuple;
}

static PyObject*
ICommandItemMethod_get_BuiltIn(PyICommandItemObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_BuiltIn = VARIANT_FALSE;
    PyObject* pyvar_BuiltIn = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for BuiltIn

    // Call method on actual COM interface
    hr = self->m_pICommandItem->get_BuiltIn(&b_BuiltIn);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICommandItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICommandItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICommandItem.get_BuiltIn() returned %ld", (long)hr);
        goto icommanditem_get_builtin_method_cleanup;
    }

    // Set up return values as needed
    pyvar_BuiltIn = ((b_BuiltIn == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto icommanditem_get_builtin_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_BuiltIn);
    goto icommanditem_get_builtin_method_cleanup;

    icommanditem_get_builtin_method_cleanup:
    self->m_HR = hr;
    // No cleanup for BuiltIn
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICommandItem.get_BuiltIn");
    return return_tuple;
}

static PyObject*
ICommandItemMethod_get_Category(PyICommandItemObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsCategory;
    PyObject* pyvar_Category = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Category

    // Call method on actual COM interface
    hr = self->m_pICommandItem->get_Category(&bsCategory);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICommandItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICommandItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICommandItem.get_Category() returned %ld", (long)hr);
        goto icommanditem_get_category_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Category = PyUnicode_FromWideChar(bsCategory,::SysStringLen(bsCategory));
    ::SysFreeString(bsCategory);
    
    if (PyErr_Occurred())
      goto icommanditem_get_category_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Category);
    goto icommanditem_get_category_method_cleanup;

    icommanditem_get_category_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Category != Py_None)
        Py_XDECREF(pyvar_Category);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICommandItem.get_Category");
    return return_tuple;
}

static PyObject*
ICommandItemMethod_get_Command(PyICommandItemObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ICommand* ipCommand = NULL;
    PyObject* py_Command = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Command

    // Call method on actual COM interface
    hr = self->m_pICommandItem->get_Command(&ipCommand);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICommandItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICommandItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICommandItem.get_Command() returned %ld", (long)hr);
        goto icommanditem_get_command_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_Command);
    if (ipCommand)
    {
        IUnknown* pUnk = NULL;
        ipCommand->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_Command = IUnknownToPythonIIDObject(pUnk, &IID_ICommand);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_Command)
    {
        if (py_Command)
           Py_DECREF(py_Command);
        py_Command = Py_None;
        Py_INCREF(py_Command);
    }
    if (PyErr_Occurred())
      goto icommanditem_get_command_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_Command);
    goto icommanditem_get_command_method_cleanup;

    icommanditem_get_command_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_Command);
    if (ipCommand)
      ipCommand->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICommandItem.get_Command");
    return return_tuple;
}

static PyObject*
ICommandItemMethod_Delete(PyICommandItemObject* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pICommandItem->Delete();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICommandItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICommandItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICommandItem.Delete() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}

static PyObject*
ICommandItemMethod_put_FaceID(PyICommandItemObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT vFaceID;
    ::VariantInit(&vFaceID);
    PyObject* pyvar_FaceID = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_FaceID))
      goto icommanditem_put_faceid_method_cleanup;

    // Set up initial variable values as needed
    PyObject_AsVariant(pyvar_FaceID, &vFaceID);
    
    if (PyErr_Occurred())
      goto icommanditem_put_faceid_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pICommandItem->put_FaceID(vFaceID);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICommandItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICommandItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICommandItem.put_FaceID() returned %ld", (long)hr);
        goto icommanditem_put_faceid_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for FaceID

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icommanditem_put_faceid_method_cleanup;

    icommanditem_put_faceid_method_cleanup:
    self->m_HR = hr;
    ::VariantClear(&vFaceID);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICommandItem.put_FaceID");
    return return_tuple;
}

static PyObject*
ICommandItemMethod_get_FaceID(PyICommandItemObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT vFaceID;
    ::VariantInit(&vFaceID);
    PyObject* pyvar_FaceID = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for FaceID

    // Call method on actual COM interface
    hr = self->m_pICommandItem->get_FaceID(&vFaceID);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICommandItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICommandItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICommandItem.get_FaceID() returned %ld", (long)hr);
        goto icommanditem_get_faceid_method_cleanup;
    }

    // Set up return values as needed
    pyvar_FaceID = Variant_AsPyObject(&vFaceID);
    if (PyErr_Occurred())
      goto icommanditem_get_faceid_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_FaceID);
    goto icommanditem_get_faceid_method_cleanup;

    icommanditem_get_faceid_method_cleanup:
    self->m_HR = hr;
    ::VariantClear(&vFaceID);
    Py_XDECREF(pyvar_FaceID);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICommandItem.get_FaceID");
    return return_tuple;
}

static PyObject*
ICommandItemMethod_put_Group(PyICommandItemObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_Group = VARIANT_FALSE;
    PyObject* pyvar_Group = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_Group))
      goto icommanditem_put_group_method_cleanup;

    // Set up initial variable values as needed
    b_Group = ((PyObject_IsTrue(pyvar_Group) == 1)?VARIANT_TRUE:VARIANT_FALSE);
    
    if (PyErr_Occurred())
      goto icommanditem_put_group_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pICommandItem->put_Group(b_Group);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICommandItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICommandItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICommandItem.put_Group() returned %ld", (long)hr);
        goto icommanditem_put_group_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Group

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icommanditem_put_group_method_cleanup;

    icommanditem_put_group_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Group
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICommandItem.put_Group");
    return return_tuple;
}

static PyObject*
ICommandItemMethod_get_Group(PyICommandItemObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    VARIANT_BOOL b_Group = VARIANT_FALSE;
    PyObject* pyvar_Group = Py_False;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Group

    // Call method on actual COM interface
    hr = self->m_pICommandItem->get_Group(&b_Group);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICommandItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICommandItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICommandItem.get_Group() returned %ld", (long)hr);
        goto icommanditem_get_group_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Group = ((b_Group == VARIANT_TRUE)?Py_True:Py_False);
    if (PyErr_Occurred())
      goto icommanditem_get_group_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Group);
    goto icommanditem_get_group_method_cleanup;

    icommanditem_get_group_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Group
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICommandItem.get_Group");
    return return_tuple;
}

static PyObject*
ICommandItemMethod_get_HelpFile(PyICommandItemObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsHelpFile;
    PyObject* pyvar_HelpFile = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for HelpFile

    // Call method on actual COM interface
    hr = self->m_pICommandItem->get_HelpFile(&bsHelpFile);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICommandItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICommandItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICommandItem.get_HelpFile() returned %ld", (long)hr);
        goto icommanditem_get_helpfile_method_cleanup;
    }

    // Set up return values as needed
    pyvar_HelpFile = PyUnicode_FromWideChar(bsHelpFile,::SysStringLen(bsHelpFile));
    ::SysFreeString(bsHelpFile);
    
    if (PyErr_Occurred())
      goto icommanditem_get_helpfile_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_HelpFile);
    goto icommanditem_get_helpfile_method_cleanup;

    icommanditem_get_helpfile_method_cleanup:
    self->m_HR = hr;
    if (pyvar_HelpFile != Py_None)
        Py_XDECREF(pyvar_HelpFile);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICommandItem.get_HelpFile");
    return return_tuple;
}

static PyObject*
ICommandItemMethod_put_HelpFile(PyICommandItemObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsHelpFile = 0;
    PyObject* pyvar_HelpFile;
    PyObject* unicodeHelpFile = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_HelpFile))
      goto icommanditem_put_helpfile_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_HelpFile))
        unicodeHelpFile = PyUnicode_FromObject(pyvar_HelpFile);
    else if (PyUnicode_Check(pyvar_HelpFile))
    {
        unicodeHelpFile = pyvar_HelpFile;
        Py_INCREF(unicodeHelpFile);
    }
    else if (pyvar_HelpFile != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter HelpFile at index 0");
    if (unicodeHelpFile)
        bsHelpFile = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeHelpFile), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeHelpFile));
    
    if (PyErr_Occurred())
      goto icommanditem_put_helpfile_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pICommandItem->put_HelpFile(bsHelpFile);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICommandItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICommandItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICommandItem.put_HelpFile() returned %ld", (long)hr);
        goto icommanditem_put_helpfile_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for HelpFile

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icommanditem_put_helpfile_method_cleanup;

    icommanditem_put_helpfile_method_cleanup:
    self->m_HR = hr;
    if (bsHelpFile)
        ::SysFreeString(bsHelpFile);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICommandItem.put_HelpFile");
    return return_tuple;
}

static PyObject*
ICommandItemMethod_get_HelpContextID(PyICommandItemObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lcontextID = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for contextID

    // Call method on actual COM interface
    hr = self->m_pICommandItem->get_HelpContextID(&lcontextID);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICommandItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICommandItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICommandItem.get_HelpContextID() returned %ld", (long)hr);
        goto icommanditem_get_helpcontextid_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for contextID

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lcontextID);
    goto icommanditem_get_helpcontextid_method_cleanup;

    icommanditem_get_helpcontextid_method_cleanup:
    self->m_HR = hr;
    // No cleanup for contextID
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICommandItem.get_HelpContextID");
    return return_tuple;
}

static PyObject*
ICommandItemMethod_put_HelpContextID(PyICommandItemObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lcontextID = 0;

    // Unpack values
    if (!PyArg_ParseTuple(args, "l", &lcontextID))
      goto icommanditem_put_helpcontextid_method_cleanup;

    // Set up initial variable values as needed
    // No setup for contextID

    // Call method on actual COM interface
    hr = self->m_pICommandItem->put_HelpContextID(lcontextID);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICommandItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICommandItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICommandItem.put_HelpContextID() returned %ld", (long)hr);
        goto icommanditem_put_helpcontextid_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for contextID

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icommanditem_put_helpcontextid_method_cleanup;

    icommanditem_put_helpcontextid_method_cleanup:
    self->m_HR = hr;
    // No cleanup for contextID
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICommandItem.put_HelpContextID");
    return return_tuple;
}

static PyObject*
ICommandItemMethod_get_ID(PyICommandItemObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    IUID* ipidentity = NULL;
    PyObject* py_identity = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for identity

    // Call method on actual COM interface
    hr = self->m_pICommandItem->get_ID(&ipidentity);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICommandItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICommandItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICommandItem.get_ID() returned %ld", (long)hr);
        goto icommanditem_get_id_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_identity);
    if (ipidentity)
    {
        IUnknown* pUnk = NULL;
        ipidentity->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_identity = IUnknownToPythonIIDObject(pUnk, &IID_IUID);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_identity)
    {
        if (py_identity)
           Py_DECREF(py_identity);
        py_identity = Py_None;
        Py_INCREF(py_identity);
    }
    if (PyErr_Occurred())
      goto icommanditem_get_id_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_identity);
    goto icommanditem_get_id_method_cleanup;

    icommanditem_get_id_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_identity);
    if (ipidentity)
      ipidentity->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICommandItem.get_ID");
    return return_tuple;
}

static PyObject*
ICommandItemMethod_get_Index(PyICommandItemObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    long lIndex = 0;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Index

    // Call method on actual COM interface
    hr = self->m_pICommandItem->get_Index(&lIndex);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICommandItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICommandItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICommandItem.get_Index() returned %ld", (long)hr);
        goto icommanditem_get_index_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Index

    // Initialize output tuple
    return_tuple = Py_BuildValue("l",
                                            lIndex);
    goto icommanditem_get_index_method_cleanup;

    icommanditem_get_index_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Index
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICommandItem.get_Index");
    return return_tuple;
}

static PyObject*
ICommandItemMethod_get_Name(PyICommandItemObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName;
    PyObject* pyvar_Name = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Name

    // Call method on actual COM interface
    hr = self->m_pICommandItem->get_Name(&bsName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICommandItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICommandItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICommandItem.get_Name() returned %ld", (long)hr);
        goto icommanditem_get_name_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Name = PyUnicode_FromWideChar(bsName,::SysStringLen(bsName));
    ::SysFreeString(bsName);
    
    if (PyErr_Occurred())
      goto icommanditem_get_name_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Name);
    goto icommanditem_get_name_method_cleanup;

    icommanditem_get_name_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Name != Py_None)
        Py_XDECREF(pyvar_Name);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICommandItem.get_Name");
    return return_tuple;
}

static PyObject*
ICommandItemMethod_put_Name(PyICommandItemObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName = 0;
    PyObject* pyvar_Name;
    PyObject* unicodeName = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_Name))
      goto icommanditem_put_name_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_Name))
        unicodeName = PyUnicode_FromObject(pyvar_Name);
    else if (PyUnicode_Check(pyvar_Name))
    {
        unicodeName = pyvar_Name;
        Py_INCREF(unicodeName);
    }
    else if (pyvar_Name != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Name at index 0");
    if (unicodeName)
        bsName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeName));
    
    if (PyErr_Occurred())
      goto icommanditem_put_name_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pICommandItem->put_Name(bsName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICommandItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICommandItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICommandItem.put_Name() returned %ld", (long)hr);
        goto icommanditem_put_name_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Name

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icommanditem_put_name_method_cleanup;

    icommanditem_put_name_method_cleanup:
    self->m_HR = hr;
    if (bsName)
        ::SysFreeString(bsName);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICommandItem.put_Name");
    return return_tuple;
}

static PyObject*
ICommandItemMethod_put_Caption(PyICommandItemObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName = 0;
    PyObject* pyvar_Name;
    PyObject* unicodeName = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_Name))
      goto icommanditem_put_caption_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_Name))
        unicodeName = PyUnicode_FromObject(pyvar_Name);
    else if (PyUnicode_Check(pyvar_Name))
    {
        unicodeName = pyvar_Name;
        Py_INCREF(unicodeName);
    }
    else if (pyvar_Name != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Name at index 0");
    if (unicodeName)
        bsName = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeName), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeName));
    
    if (PyErr_Occurred())
      goto icommanditem_put_caption_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pICommandItem->put_Caption(bsName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICommandItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICommandItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICommandItem.put_Caption() returned %ld", (long)hr);
        goto icommanditem_put_caption_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Name

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icommanditem_put_caption_method_cleanup;

    icommanditem_put_caption_method_cleanup:
    self->m_HR = hr;
    if (bsName)
        ::SysFreeString(bsName);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICommandItem.put_Caption");
    return return_tuple;
}

static PyObject*
ICommandItemMethod_get_Caption(PyICommandItemObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsName;
    PyObject* pyvar_Name = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Name

    // Call method on actual COM interface
    hr = self->m_pICommandItem->get_Caption(&bsName);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICommandItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICommandItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICommandItem.get_Caption() returned %ld", (long)hr);
        goto icommanditem_get_caption_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Name = PyUnicode_FromWideChar(bsName,::SysStringLen(bsName));
    ::SysFreeString(bsName);
    
    if (PyErr_Occurred())
      goto icommanditem_get_caption_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Name);
    goto icommanditem_get_caption_method_cleanup;

    icommanditem_get_caption_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Name != Py_None)
        Py_XDECREF(pyvar_Name);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICommandItem.get_Caption");
    return return_tuple;
}

static PyObject*
ICommandItemMethod_get_Parent(PyICommandItemObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ICommandBar* ipbar = NULL;
    PyObject* py_bar = NULL;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for bar

    // Call method on actual COM interface
    hr = self->m_pICommandItem->get_Parent(&ipbar);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICommandItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICommandItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICommandItem.get_Parent() returned %ld", (long)hr);
        goto icommanditem_get_parent_method_cleanup;
    }

    // Set up return values as needed
    Py_XDECREF(py_bar);
    if (ipbar)
    {
        IUnknown* pUnk = NULL;
        ipbar->QueryInterface(IID_IUnknown, (void **)&pUnk);
        py_bar = IUnknownToPythonIIDObject(pUnk, &IID_ICommandBar);
        if (pUnk)
           pUnk->Release();}
    if (PyErr_Occurred() || !py_bar)
    {
        if (py_bar)
           Py_DECREF(py_bar);
        py_bar = Py_None;
        Py_INCREF(py_bar);
    }
    if (PyErr_Occurred())
      goto icommanditem_get_parent_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            py_bar);
    goto icommanditem_get_parent_method_cleanup;

    icommanditem_get_parent_method_cleanup:
    self->m_HR = hr;
    Py_XDECREF(py_bar);
    if (ipbar)
      ipbar->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICommandItem.get_Parent");
    return return_tuple;
}

static PyObject*
ICommandItemMethod_Reset(PyICommandItemObject* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pICommandItem->Reset();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICommandItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICommandItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICommandItem.Reset() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}

static PyObject*
ICommandItemMethod_get_Style(PyICommandItemObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriCommandStyles eStyle;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Style

    // Call method on actual COM interface
    hr = self->m_pICommandItem->get_Style(&eStyle);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICommandItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICommandItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICommandItem.get_Style() returned %ld", (long)hr);
        goto icommanditem_get_style_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Style

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)eStyle);
    goto icommanditem_get_style_method_cleanup;

    icommanditem_get_style_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Style
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICommandItem.get_Style");
    return return_tuple;
}

static PyObject*
ICommandItemMethod_put_Style(PyICommandItemObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriCommandStyles eStyle;

    // Unpack values
    if (!PyArg_ParseTuple(args, "i", (int *)&eStyle))
      goto icommanditem_put_style_method_cleanup;

    // Set up initial variable values as needed
    // No setup for Style

    // Call method on actual COM interface
    hr = self->m_pICommandItem->put_Style(eStyle);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICommandItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICommandItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICommandItem.put_Style() returned %ld", (long)hr);
        goto icommanditem_put_style_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Style

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icommanditem_put_style_method_cleanup;

    icommanditem_put_style_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Style
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICommandItem.put_Style");
    return return_tuple;
}

static PyObject*
ICommandItemMethod_get_Tag(PyICommandItemObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsTag;
    PyObject* pyvar_Tag = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Tag

    // Call method on actual COM interface
    hr = self->m_pICommandItem->get_Tag(&bsTag);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICommandItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICommandItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICommandItem.get_Tag() returned %ld", (long)hr);
        goto icommanditem_get_tag_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Tag = PyUnicode_FromWideChar(bsTag,::SysStringLen(bsTag));
    ::SysFreeString(bsTag);
    
    if (PyErr_Occurred())
      goto icommanditem_get_tag_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Tag);
    goto icommanditem_get_tag_method_cleanup;

    icommanditem_get_tag_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Tag != Py_None)
        Py_XDECREF(pyvar_Tag);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICommandItem.get_Tag");
    return return_tuple;
}

static PyObject*
ICommandItemMethod_put_Tag(PyICommandItemObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsTag = 0;
    PyObject* pyvar_Tag;
    PyObject* unicodeTag = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_Tag))
      goto icommanditem_put_tag_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_Tag))
        unicodeTag = PyUnicode_FromObject(pyvar_Tag);
    else if (PyUnicode_Check(pyvar_Tag))
    {
        unicodeTag = pyvar_Tag;
        Py_INCREF(unicodeTag);
    }
    else if (pyvar_Tag != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Tag at index 0");
    if (unicodeTag)
        bsTag = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeTag), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeTag));
    
    if (PyErr_Occurred())
      goto icommanditem_put_tag_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pICommandItem->put_Tag(bsTag);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICommandItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICommandItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICommandItem.put_Tag() returned %ld", (long)hr);
        goto icommanditem_put_tag_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Tag

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icommanditem_put_tag_method_cleanup;

    icommanditem_put_tag_method_cleanup:
    self->m_HR = hr;
    if (bsTag)
        ::SysFreeString(bsTag);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICommandItem.put_Tag");
    return return_tuple;
}

static PyObject*
ICommandItemMethod_get_Tooltip(PyICommandItemObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsTooltip;
    PyObject* pyvar_Tooltip = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Tooltip

    // Call method on actual COM interface
    hr = self->m_pICommandItem->get_Tooltip(&bsTooltip);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICommandItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICommandItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICommandItem.get_Tooltip() returned %ld", (long)hr);
        goto icommanditem_get_tooltip_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Tooltip = PyUnicode_FromWideChar(bsTooltip,::SysStringLen(bsTooltip));
    ::SysFreeString(bsTooltip);
    
    if (PyErr_Occurred())
      goto icommanditem_get_tooltip_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Tooltip);
    goto icommanditem_get_tooltip_method_cleanup;

    icommanditem_get_tooltip_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Tooltip != Py_None)
        Py_XDECREF(pyvar_Tooltip);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICommandItem.get_Tooltip");
    return return_tuple;
}

static PyObject*
ICommandItemMethod_put_Tooltip(PyICommandItemObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsTooltip = 0;
    PyObject* pyvar_Tooltip;
    PyObject* unicodeTooltip = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_Tooltip))
      goto icommanditem_put_tooltip_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_Tooltip))
        unicodeTooltip = PyUnicode_FromObject(pyvar_Tooltip);
    else if (PyUnicode_Check(pyvar_Tooltip))
    {
        unicodeTooltip = pyvar_Tooltip;
        Py_INCREF(unicodeTooltip);
    }
    else if (pyvar_Tooltip != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Tooltip at index 0");
    if (unicodeTooltip)
        bsTooltip = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeTooltip), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeTooltip));
    
    if (PyErr_Occurred())
      goto icommanditem_put_tooltip_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pICommandItem->put_Tooltip(bsTooltip);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICommandItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICommandItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICommandItem.put_Tooltip() returned %ld", (long)hr);
        goto icommanditem_put_tooltip_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Tooltip

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icommanditem_put_tooltip_method_cleanup;

    icommanditem_put_tooltip_method_cleanup:
    self->m_HR = hr;
    if (bsTooltip)
        ::SysFreeString(bsTooltip);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICommandItem.put_Tooltip");
    return return_tuple;
}

static PyObject*
ICommandItemMethod_get_Type(PyICommandItemObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    esriCommandTypes eType;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Type

    // Call method on actual COM interface
    hr = self->m_pICommandItem->get_Type(&eType);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICommandItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICommandItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICommandItem.get_Type() returned %ld", (long)hr);
        goto icommanditem_get_type_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Type

    // Initialize output tuple
    return_tuple = Py_BuildValue("i",
                                            (int)eType);
    goto icommanditem_get_type_method_cleanup;

    icommanditem_get_type_method_cleanup:
    self->m_HR = hr;
    // No cleanup for Type
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICommandItem.get_Type");
    return return_tuple;
}

static PyObject*
ICommandItemMethod_get_Message(PyICommandItemObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsMessage;
    PyObject* pyvar_Message = Py_None;

    // Unpack values
    // No inputs to unpack

    // Set up initial variable values as needed
    // No setup for Message

    // Call method on actual COM interface
    hr = self->m_pICommandItem->get_Message(&bsMessage);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICommandItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICommandItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICommandItem.get_Message() returned %ld", (long)hr);
        goto icommanditem_get_message_method_cleanup;
    }

    // Set up return values as needed
    pyvar_Message = PyUnicode_FromWideChar(bsMessage,::SysStringLen(bsMessage));
    ::SysFreeString(bsMessage);
    
    if (PyErr_Occurred())
      goto icommanditem_get_message_method_cleanup;
    

    // Initialize output tuple
    return_tuple = Py_BuildValue("O",
                                            pyvar_Message);
    goto icommanditem_get_message_method_cleanup;

    icommanditem_get_message_method_cleanup:
    self->m_HR = hr;
    if (pyvar_Message != Py_None)
        Py_XDECREF(pyvar_Message);
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICommandItem.get_Message");
    return return_tuple;
}

static PyObject*
ICommandItemMethod_put_Message(PyICommandItemObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    BSTR bsMessage = 0;
    PyObject* pyvar_Message;
    PyObject* unicodeMessage = NULL;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &pyvar_Message))
      goto icommanditem_put_message_method_cleanup;

    // Set up initial variable values as needed
    if (PyString_Check(pyvar_Message))
        unicodeMessage = PyUnicode_FromObject(pyvar_Message);
    else if (PyUnicode_Check(pyvar_Message))
    {
        unicodeMessage = pyvar_Message;
        Py_INCREF(unicodeMessage);
    }
    else if (pyvar_Message != Py_None)
        PyErr_SetString(PyExc_ValueError, "Invalid value for parameter Message at index 0");
    if (unicodeMessage)
        bsMessage = ::SysAllocStringLen(PyUnicode_AS_UNICODE(unicodeMessage), 
                                            (UINT)PyUnicode_GET_SIZE(unicodeMessage));
    
    if (PyErr_Occurred())
      goto icommanditem_put_message_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pICommandItem->put_Message(bsMessage);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICommandItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICommandItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICommandItem.put_Message() returned %ld", (long)hr);
        goto icommanditem_put_message_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for Message

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto icommanditem_put_message_method_cleanup;

    icommanditem_put_message_method_cleanup:
    self->m_HR = hr;
    if (bsMessage)
        ::SysFreeString(bsMessage);
    
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in ICommandItem.put_Message");
    return return_tuple;
}

static PyObject*
ICommandItemMethod_Execute(PyICommandItemObject* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pICommandItem->Execute();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICommandItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICommandItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICommandItem.Execute() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}

static PyObject*
ICommandItemMethod_Refresh(PyICommandItemObject* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pICommandItem->Refresh();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pICommandItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_ICommandItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: ICommandItem.Refresh() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}


PyMethodDef PyICommandItemMethods[] = {
    {"supports", (PyCFunction)PyICommandItem_SupportsInterface, METH_O, ""},
    {"get_Action", (PyCFunction)ICommandItemMethod_get_Action, METH_VARARGS, ""},
    {"put_Action", (PyCFunction)ICommandItemMethod_put_Action, METH_VARARGS, ""},
    {"get_BuiltIn", (PyCFunction)ICommandItemMethod_get_BuiltIn, METH_VARARGS, ""},
    {"get_Category", (PyCFunction)ICommandItemMethod_get_Category, METH_VARARGS, ""},
    {"get_Command", (PyCFunction)ICommandItemMethod_get_Command, METH_VARARGS, ""},
    {"Delete", (PyCFunction)ICommandItemMethod_Delete, METH_NOARGS, ""},
    {"put_FaceID", (PyCFunction)ICommandItemMethod_put_FaceID, METH_VARARGS, ""},
    {"get_FaceID", (PyCFunction)ICommandItemMethod_get_FaceID, METH_VARARGS, ""},
    {"put_Group", (PyCFunction)ICommandItemMethod_put_Group, METH_VARARGS, ""},
    {"get_Group", (PyCFunction)ICommandItemMethod_get_Group, METH_VARARGS, ""},
    {"get_HelpFile", (PyCFunction)ICommandItemMethod_get_HelpFile, METH_VARARGS, ""},
    {"put_HelpFile", (PyCFunction)ICommandItemMethod_put_HelpFile, METH_VARARGS, ""},
    {"get_HelpContextID", (PyCFunction)ICommandItemMethod_get_HelpContextID, METH_VARARGS, ""},
    {"put_HelpContextID", (PyCFunction)ICommandItemMethod_put_HelpContextID, METH_VARARGS, ""},
    {"get_ID", (PyCFunction)ICommandItemMethod_get_ID, METH_VARARGS, ""},
    {"get_Index", (PyCFunction)ICommandItemMethod_get_Index, METH_VARARGS, ""},
    {"get_Name", (PyCFunction)ICommandItemMethod_get_Name, METH_VARARGS, ""},
    {"put_Name", (PyCFunction)ICommandItemMethod_put_Name, METH_VARARGS, ""},
    {"put_Caption", (PyCFunction)ICommandItemMethod_put_Caption, METH_VARARGS, ""},
    {"get_Caption", (PyCFunction)ICommandItemMethod_get_Caption, METH_VARARGS, ""},
    {"get_Parent", (PyCFunction)ICommandItemMethod_get_Parent, METH_VARARGS, ""},
    {"Reset", (PyCFunction)ICommandItemMethod_Reset, METH_NOARGS, ""},
    {"get_Style", (PyCFunction)ICommandItemMethod_get_Style, METH_VARARGS, ""},
    {"put_Style", (PyCFunction)ICommandItemMethod_put_Style, METH_VARARGS, ""},
    {"get_Tag", (PyCFunction)ICommandItemMethod_get_Tag, METH_VARARGS, ""},
    {"put_Tag", (PyCFunction)ICommandItemMethod_put_Tag, METH_VARARGS, ""},
    {"get_Tooltip", (PyCFunction)ICommandItemMethod_get_Tooltip, METH_VARARGS, ""},
    {"put_Tooltip", (PyCFunction)ICommandItemMethod_put_Tooltip, METH_VARARGS, ""},
    {"get_Type", (PyCFunction)ICommandItemMethod_get_Type, METH_VARARGS, ""},
    {"get_Message", (PyCFunction)ICommandItemMethod_get_Message, METH_VARARGS, ""},
    {"put_Message", (PyCFunction)ICommandItemMethod_put_Message, METH_VARARGS, ""},
    {"Execute", (PyCFunction)ICommandItemMethod_Execute, METH_NOARGS, ""},
    {"Refresh", (PyCFunction)ICommandItemMethod_Refresh, METH_NOARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyICommandItemGetSet[] = {
  {"_pUnk", (getter)PyICommandItem_GetpUnk, NULL, "Get opaque pointer to an Unknown from ICommandItem", NULL},
  {"_pointer", (getter)PyICommandItem_GetPointer, NULL, "Get memory address for ICommandItem", NULL},
  {"_IID", (getter)PyICommandItem_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyICommandItem_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyICommandItem_GetIgnoreFailures, (setter)PyICommandItem_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyICommandItemObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriFramework.ICommandItemObject",                          
                                              /* tp_name */
  sizeof(PyICommandItemObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyICommandItemObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyICommandItemMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyICommandItemGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyICommandItemObject_new,                      
                                              /* tp_new */
};

// Interface IMenuItem

typedef struct PyIMenuItemObject {
    PyObject_HEAD
    IMenuItem* m_pIMenuItem;
    HRESULT m_HR;
    int m_ignore_failures;
} PyIMenuItemObject;

static PyObject*
PyIMenuItemObject_new(PyTypeObject* type, PyObject* args, PyObject* keywds)
{
    PyIMenuItemObject* self = NULL;
    IUnknown* pUnk = NULL;
    GUID pCLSID;

    PyObject* argument;
    if (!PyArg_ParseTuple(args, "O", &argument))
        return NULL;

    // Are we passed a UUID instance?
    if (GuidFromPyObject(argument, &pCLSID))
    {
        IMenuItem* pIFace;
        HRESULT hr = ::CoCreateInstance(pCLSID, 0, CLSCTX_ALL, IID_IMenuItem, (void**)&pIFace);
        if (FAILED(hr))
        {
            PyErr_SetString(PyExc_RuntimeError, "Could not CoCreate IMenuItem with provided CLSID");
            return NULL;
        }
        if (!(self = ((PyIMenuItemObject *)type->tp_alloc(type, 0))))
        {
            PyErr_SetString(PyExc_MemoryError, "Could not allocate IMenuItem");
            return NULL;
        }
        self->m_pIMenuItem = pIFace;
        self->m_HR = hr;
        self->m_ignore_failures = 0;
        return (PyObject *)self;
    }
    // Are we passed an opaque pointer?
    else if (PyCObject_Check(argument))
    {
        pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
    }
    // No? See if there's an object._pUnk attribute that is one!
    else
    {
        argument = PyObject_GetAttrString(argument, "_pUnk");
        if (!argument)
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, "Not an acceptable value for IMenuItem");
            Py_XDECREF(argument);
            return NULL;
        }
        else if (PyCObject_Check(argument))
        {
            pUnk = (IUnknown *)PyCObject_AsVoidPtr(argument);
        }
        else
        {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError, "Not an acceptable pointer type to IMenuItem");
            Py_XDECREF(argument);
            return NULL;
        }
        Py_XDECREF(argument);
    }

    // Null pointers!
    if (pUnk == NULL)
        Py_RETURN_NONE;

    IMenuItem* pmVar = NULL;
    if (FAILED(pUnk->QueryInterface(IID_IMenuItem, (void**)&pmVar)))
    {
        PyErr_SetString(PyExc_TypeError, "Could not convert to IMenuItem");
        return NULL;
    }

    if (pmVar == NULL)
        Py_RETURN_NONE;

    if (!(self = ((PyIMenuItemObject *)type->tp_alloc(type, 0))))
    {
        PyErr_SetString(PyExc_MemoryError, "Could not allocate IMenuItem");
        return NULL;
    }

    //pmVar->AddRef();
    self->m_pIMenuItem = pmVar;
    self->m_HR = S_OK;
    self->m_ignore_failures = 0;
    return (PyObject *)self;
}

static void
PyIMenuItemObject_dealloc(PyIMenuItemObject* self)
{
    if (self->m_pIMenuItem)
        self->m_pIMenuItem->Release();
    self->ob_type->tp_free(self);    
}

static PyObject*
PyIMenuItem_GetpUnk(PyIMenuItemObject* self)
{
    if (!self->m_pIMenuItem)
        Py_RETURN_NONE;
    IUnknown* pu = NULL;
    
    HRESULT hr;
    if (FAILED(hr = self->m_pIMenuItem->QueryInterface(IID_IUnknown, (void **)&pu)))
    {
        PyErr_SetString(PyExc_TypeError, "Cannot QI IMenuItem to Unknown?");
        return NULL;
    }

    self->m_HR = hr;

    if (!pu)
        Py_RETURN_NONE;

    return PyCObject_FromVoidPtr((void*)pu, destr_unknown);
}

static PyObject*
PyIMenuItem_GetPointer(PyIMenuItemObject* self)
{
    return PyLong_FromVoidPtr((void*)self->m_pIMenuItem);
}

static PyObject*
PyIMenuItem_GetIID(PyIMenuItemObject* self)
{
    if (g_pUUID_type)
        return PyObject_CallFunction(g_pUUID_type, "s", "2b718169-1b85-11d2-94b6-080009eebecb");
    PyErr_SetString(PyExc_ImportError, "No UUID module loaded!");
    return NULL;
}

static PyObject*
PyIMenuItem_GetHR(PyIMenuItemObject* self)
{
    return PyLong_FromUnsignedLong((unsigned long)self->m_HR);
}

static PyObject*
PyIMenuItem_GetIgnoreFailures(PyIMenuItemObject* self)
{
    if (self->m_ignore_failures)
        Py_RETURN_TRUE;
    Py_RETURN_FALSE;
}

static int
PyIMenuItem_SetIgnoreFailures(PyIMenuItemObject* self, PyObject* val)
{
    self->m_ignore_failures = PyObject_IsTrue(val);
    return 0;
}

static PyObject*
PyIMenuItem_SupportsInterface(PyIMenuItemObject* self, PyObject* iface)
{
    GUID iid;
    if (GuidFromPyObject(iface, &iid))
    {
        IUnknown* ipUnk;
        if (SUCCEEDED(self->m_pIMenuItem->QueryInterface(iid, (void**)&ipUnk)) && ipUnk)
        {
            ipUnk->Release();
            Py_RETURN_TRUE;
        }
        Py_RETURN_FALSE;
    }
    PyErr_SetString(PyExc_ValueError, "Bad interface ID.");
    return NULL;
}


static PyObject*
IMenuItemMethod_OnPopup(PyIMenuItemObject* self, PyObject* args)
{
    PyObject* return_tuple = NULL;
    HRESULT hr = 0;

    // Initialize variables
    ICommandBar* ippParentMenu = NULL;
    PyObject* py_pParentMenu;

    // Unpack values
    if (!PyArg_ParseTuple(args, "O", &py_pParentMenu))
      goto imenuitem_onpopup_method_cleanup;

    // Set up initial variable values as needed
    if (!IFaceFromPyObject(py_pParentMenu, &IID_ICommandBar, (void**)&ippParentMenu))
        PyErr_SetString(PyExc_TypeError, "Argument pParentMenu (position 0) is not ICommandBar");
    
    if (PyErr_Occurred())
      goto imenuitem_onpopup_method_cleanup;
    

    // Call method on actual COM interface
    hr = self->m_pIMenuItem->OnPopup(ippParentMenu);
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIMenuItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IMenuItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IMenuItem.OnPopup() returned %ld", (long)hr);
        goto imenuitem_onpopup_method_cleanup;
    }

    // Set up return values as needed
    // No teardown for pParentMenu

    // Initialize output tuple
    // No outputs
    return_tuple = Py_None;
    Py_INCREF(return_tuple);
    goto imenuitem_onpopup_method_cleanup;

    imenuitem_onpopup_method_cleanup:
    self->m_HR = hr;
    if (ippParentMenu)
      ippParentMenu->Release();
    if (!return_tuple && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "Unspecified error in IMenuItem.OnPopup");
    return return_tuple;
}

static PyObject*
IMenuItemMethod_OnClose(PyIMenuItemObject* self, PyObject* args)
{
    HRESULT hr = 0;
    Py_BEGIN_ALLOW_THREADS
    hr = self->m_pIMenuItem->OnClose();
    Py_END_ALLOW_THREADS
    if (FAILED(hr) && !(self->m_ignore_failures))
    {
        ISupportErrorInfo* pSuppErrInfo;
        if (SUCCEEDED(self->m_pIMenuItem->QueryInterface(IID_ISupportErrorInfo, (void**)&pSuppErrInfo)) 
            && pSuppErrInfo
            && pSuppErrInfo->InterfaceSupportsErrorInfo(IID_IMenuItem) == S_OK)
        {
            IErrorInfo* pErrInfo = 0; 
            if (::GetErrorInfo(0, &pErrInfo) == S_OK 
                && pErrInfo)
            {
                BSTR errstring;
                pErrInfo->GetDescription(&errstring);
                PyObject* pyErrMsg = PyUnicode_FromWideChar(errstring,::SysStringLen(errstring));
                ::SysFreeString(errstring);
                PyErr_SetObject(PyExc_RuntimeError, pyErrMsg);
                Py_XDECREF(pyErrMsg);
                pErrInfo->Release();
            }
        }
        if (pSuppErrInfo)
            pSuppErrInfo->Release();
        if (!PyErr_Occurred())
            PyErr_Format(PyExc_RuntimeError, "Failure: IMenuItem.OnClose() returned %ld", (long)hr);
        self->m_HR = hr;
        return NULL;
    }
    self->m_HR = hr;
    Py_RETURN_NONE;
}


PyMethodDef PyIMenuItemMethods[] = {
    {"supports", (PyCFunction)PyIMenuItem_SupportsInterface, METH_O, ""},
    {"OnPopup", (PyCFunction)IMenuItemMethod_OnPopup, METH_VARARGS, ""},
    {"OnClose", (PyCFunction)IMenuItemMethod_OnClose, METH_NOARGS, ""},
    {NULL, NULL, NULL, NULL}
};

PyGetSetDef PyIMenuItemGetSet[] = {
  {"_pUnk", (getter)PyIMenuItem_GetpUnk, NULL, "Get opaque pointer to an Unknown from IMenuItem", NULL},
  {"_pointer", (getter)PyIMenuItem_GetPointer, NULL, "Get memory address for IMenuItem", NULL},
  {"_IID", (getter)PyIMenuItem_GetIID, NULL, "Get reference to the GUID for this interface", NULL},
  {"_HR", (getter)PyIMenuItem_GetHR, NULL, "Get the HRESULT from the last function call on this object", NULL},
  {"_ignore_failures", (getter)PyIMenuItem_GetIgnoreFailures, (setter)PyIMenuItem_SetIgnoreFailures, "Whether to raise if the HR is a failure", NULL},
  {NULL, NULL, NULL, NULL, NULL}
};

static PyTypeObject PyIMenuItemObject_Type = {
  PyObject_HEAD_INIT(NULL)
  0,                                          /* ob_size */
  "_esriFramework.IMenuItemObject",                          
                                              /* tp_name */
  sizeof(PyIMenuItemObject),                  
                                              /* tp_basicsize */
  0,                                          /* tp_itemsize */
  (destructor)PyIMenuItemObject_dealloc,      
                                              /* tp_dealloc */
  0,                                          /* tp_print */
  0,                                          /* tp_getattr */
  0,                                          /* tp_setattr */
  0,                                          /* tp_compare */
  0,                                          /* tp_repr */
  0,                                          /* tp_as_number */
  0,                                          /* tp_as_sequence */
  0,                                          /* tp_as_mapping */
  0,                                          /* tp_hash  */
  0,                                          /* tp_call */
  0,                                          /* tp_str */
  0,                                          /* tp_getattro */
  0,                                          /* tp_setattro */
  0,                                          /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
  "",                                  
                                              /* tp_doc */
  0,                                          /* tp_traverse */
  0,                                          /* tp_clear */
  0,                                          /* tp_richcompare */
  0,                                          /* tp_weaklistoffset */
  0,                                          /* tp_iter */
  0,                                          /* tp_iternext */
  PyIMenuItemMethods,
                                              /* tp_methods */
  0,                                          /* tp_members */
  PyIMenuItemGetSet,
                                              /* tp_getset */
  0,                                          /* tp_base */
  0,                                          /* tp_dict */
  0,                                          /* tp_descr_get */
  0,                                          /* tp_descr_set */
  0,                                          /* tp_dictoffset */
  0,                                          /* tp_init */
  0,                                          /* tp_alloc */
  PyIMenuItemObject_new,                      
                                              /* tp_new */
};





static PyObject*
CoCreateMouseCursor(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_MouseCursor, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of MouseCursor");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("dcab4344-69d0-492a-9468-9a89a8e9b571")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "dcab4344-69d0-492a-9468-9a89a8e9b571");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateApplicationStatusEvents(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_ApplicationStatusEvents, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of ApplicationStatusEvents");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("abc37653-e992-48e1-a35b-c2f3e1bcdb45")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "abc37653-e992-48e1-a35b-c2f3e1bcdb45");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateAppRef(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_AppRef, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of AppRef");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("e1740ec5-9513-11d2-a2df-0000f8774fb5")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "e1740ec5-9513-11d2-a2df-0000f8774fb5");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateAppROT(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_AppROT, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of AppROT");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("fabc30fb-d273-11d2-9f36-00c04f6bc61a")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "fabc30fb-d273-11d2-9f36-00c04f6bc61a");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateAccelerator(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_Accelerator, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of Accelerator");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("8a85d730-2949-49da-8995-cec77f68bdfa")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "8a85d730-2949-49da-8995-cec77f68bdfa");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateTemplates(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_Templates, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of Templates");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("c32ff69d-cf6a-4fe5-b62f-a38feaead0d8")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "c32ff69d-cf6a-4fe5-b62f-a38feaead0d8");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateCommandBars(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_CommandBars, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of CommandBars");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("5c396018-9b88-493c-b47d-8c6332aedbdd")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "5c396018-9b88-493c-b47d-8c6332aedbdd");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateCommandBar(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_CommandBar, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of CommandBar");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("a37ef60a-59b9-4599-8621-ac81112df947")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "a37ef60a-59b9-4599-8621-ac81112df947");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateAcceleratorTable(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_AcceleratorTable, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of AcceleratorTable");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("ce259b71-280c-11d2-aa2f-000000000000")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "ce259b71-280c-11d2-aa2f-000000000000");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateCommandItem(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_CommandItem, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of CommandItem");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("fa73ef95-b87c-11d1-947b-080009eebecb")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "fa73ef95-b87c-11d1-947b-080009eebecb");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateDockableWindow(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_DockableWindow, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of DockableWindow");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("d91ed352-e414-11d3-a679-0008c7df97b9")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "d91ed352-e414-11d3-a679-0008c7df97b9");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateDllThreadManager(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_DllThreadManager, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of DllThreadManager");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("057c74e0-faf0-45cb-89e3-af132be1a2a7")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "057c74e0-faf0-45cb-89e3-af132be1a2a7");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateButton(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_Button, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of Button");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("d13cbe84-71b0-4eef-8bd6-60d358b431f6")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "d13cbe84-71b0-4eef-8bd6-60d358b431f6");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateTool(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_Tool, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of Tool");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("da53dc37-e97c-4997-bbde-93f2be061ec0")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "da53dc37-e97c-4997-bbde-93f2be061ec0");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateToolControl(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_ToolControl, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of ToolControl");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("b6bff46f-6dcf-4db7-9985-5f41a41f17fc")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "b6bff46f-6dcf-4db7-9985-5f41a41f17fc");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateMultiItem(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_MultiItem, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of MultiItem");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("bf3dd473-a408-4014-b913-69a31af6115d")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "bf3dd473-a408-4014-b913-69a31af6115d");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateStyleGalleryItem(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_StyleGalleryItem, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of StyleGalleryItem");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("ac0e9829-91cb-11d1-8813-080009ec732a")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "ac0e9829-91cb-11d1-8813-080009ec732a");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateEnumStyleGalleryItem(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_EnumStyleGalleryItem, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of EnumStyleGalleryItem");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("ac0e982a-91cb-11d1-8813-080009ec732a")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "ac0e982a-91cb-11d1-8813-080009ec732a");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateStyleGallery(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_StyleGallery, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of StyleGallery");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("ac0e9827-91cb-11d1-8813-080009ec732a")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "ac0e9827-91cb-11d1-8813-080009ec732a");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateColorSelector(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_ColorSelector, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of ColorSelector");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("93051635-f841-11d2-9f36-00c04f6bc709")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "93051635-f841-11d2-9f36-00c04f6bc709");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateColorPalette(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_ColorPalette, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of ColorPalette");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("14746474-1534-11d3-9f49-00c04f6bc709")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "14746474-1534-11d3-9f49-00c04f6bc709");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateColorBrowser(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_ColorBrowser, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of ColorBrowser");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("20cd4001-8f3d-11d0-8590-0800091a2a72")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "20cd4001-8f3d-11d0-8590-0800091a2a72");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateColorPageSite(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_ColorPageSite, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of ColorPageSite");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("20cd4002-8f3d-11d0-8590-0800091a2a72")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "20cd4002-8f3d-11d0-8590-0800091a2a72");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateRgbPropertyPage(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_RgbPropertyPage, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of RgbPropertyPage");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("20cd4003-8f3d-11d0-8590-0800091a2a72")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "20cd4003-8f3d-11d0-8590-0800091a2a72");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateCmykPropertyPage(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_CmykPropertyPage, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of CmykPropertyPage");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("20cd4004-8f3d-11d0-8590-0800091a2a72")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "20cd4004-8f3d-11d0-8590-0800091a2a72");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateHsvPropertyPage(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_HsvPropertyPage, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of HsvPropertyPage");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("20cd4005-8f3d-11d0-8590-0800091a2a72")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "20cd4005-8f3d-11d0-8590-0800091a2a72");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateGrayPropertyPage(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_GrayPropertyPage, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of GrayPropertyPage");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("20cd4006-8f3d-11d0-8590-0800091a2a72")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "20cd4006-8f3d-11d0-8590-0800091a2a72");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateColorNamePropertyPage(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_ColorNamePropertyPage, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of ColorNamePropertyPage");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("20cd4007-8f3d-11d0-8590-0800091a2a72")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "20cd4007-8f3d-11d0-8590-0800091a2a72");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateModelessFrame(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_ModelessFrame, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of ModelessFrame");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("9f79baae-e23a-4e3e-83f9-6d85b3d1094f")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "9f79baae-e23a-4e3e-83f9-6d85b3d1094f");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateSymbolPickerDialog(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_SymbolPickerDialog, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of SymbolPickerDialog");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("14b6e652-3962-4a79-a8b2-f7d7f8b00b59")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "14b6e652-3962-4a79-a8b2-f7d7f8b00b59");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateComPropertySheet(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_ComPropertySheet, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of ComPropertySheet");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("01964af3-7f1a-11d2-a2de-080009b6f22b")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "01964af3-7f1a-11d2-a2de-080009b6f22b");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateComPropertyPageSite(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_ComPropertyPageSite, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of ComPropertyPageSite");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("de803db1-bc9a-44b2-b735-3c0912239587")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "de803db1-bc9a-44b2-b735-3c0912239587");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateNumberDialog(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_NumberDialog, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of NumberDialog");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("759f7b99-e07d-11d1-aa87-00c04fa374bd")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "759f7b99-e07d-11d1-aa87-00c04fa374bd");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateMessageDialog(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_MessageDialog, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of MessageDialog");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("48f2c007-25c4-11d3-9fba-00c04f6bc8dd")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "48f2c007-25c4-11d3-9fba-00c04f6bc8dd");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateCoordinateDialog(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_CoordinateDialog, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of CoordinateDialog");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("759f7b9c-e07d-11d1-aa87-00c04fa374bd")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "759f7b9c-e07d-11d1-aa87-00c04fa374bd");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateProgressDialogFactory(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_ProgressDialogFactory, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of ProgressDialogFactory");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("31a6aeb2-f644-11d1-a248-080009b6f22b")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "31a6aeb2-f644-11d1-a248-080009b6f22b");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateListDialog(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_ListDialog, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of ListDialog");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("5f399a17-0b7d-11d2-8c1e-0000f8774f55")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "5f399a17-0b7d-11d2-8c1e-0000f8774f55");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateNumberFormatDialog(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_NumberFormatDialog, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of NumberFormatDialog");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("88002c0a-939a-11d2-ae73-080009ec732a")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "88002c0a-939a-11d2-ae73-080009ec732a");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateNumericPropertyPage(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_NumericPropertyPage, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of NumericPropertyPage");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("9388d95b-9460-11d2-ae74-080009ec732a")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "9388d95b-9460-11d2-ae74-080009ec732a");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateCurrencyPropertyPage(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_CurrencyPropertyPage, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of CurrencyPropertyPage");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("6f560571-960f-11d2-ae77-080009ec732a")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "6f560571-960f-11d2-ae77-080009ec732a");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateScientificPropertyPage(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_ScientificPropertyPage, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of ScientificPropertyPage");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("fecb8199-c694-11d2-9f34-00c04f6bc78e")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "fecb8199-c694-11d2-9f34-00c04f6bc78e");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateAnglePropertyPage(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_AnglePropertyPage, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of AnglePropertyPage");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("fecb819a-c694-11d2-9f34-00c04f6bc78e")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "fecb819a-c694-11d2-9f34-00c04f6bc78e");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateDirectionPropertyPage(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_DirectionPropertyPage, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of DirectionPropertyPage");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("ecb196fe-47dc-4f3a-ae2a-1ce2ebfb6dc2")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "ecb196fe-47dc-4f3a-ae2a-1ce2ebfb6dc2");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreatePercentagePropertyPage(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_PercentagePropertyPage, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of PercentagePropertyPage");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("fcf40d6d-c91f-11d2-aaf8-000000000000")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "fcf40d6d-c91f-11d2-aaf8-000000000000");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateCustomPropertyPage(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_CustomPropertyPage, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of CustomPropertyPage");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("fcf40d6e-c91f-11d2-aaf8-000000000000")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "fcf40d6e-c91f-11d2-aaf8-000000000000");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateRatePropertyPage(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_RatePropertyPage, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of RatePropertyPage");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("fcf40d6f-c91f-11d2-aaf8-000000000000")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "fcf40d6f-c91f-11d2-aaf8-000000000000");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateFractionPropertyPage(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_FractionPropertyPage, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of FractionPropertyPage");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("fcf40d70-c91f-11d2-aaf8-000000000000")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "fcf40d70-c91f-11d2-aaf8-000000000000");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateGetStringDialog(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_GetStringDialog, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of GetStringDialog");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("a7b8ec90-ac12-11d2-ab27-00c04fa334b3")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "a7b8ec90-ac12-11d2-ab27-00c04fa334b3");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyObject*
CoCreateGetUserAndPasswordDialog(PyObject* self)
{
    IUnknown* pUnk;

    HRESULT hr = ::CoCreateInstance(CLSID_GetUserAndPasswordDialog, 0, CLSCTX_ALL, IID_IUnknown, (void**)&pUnk);

    if (FAILED(hr))
    {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize instance of GetUserAndPasswordDialog");
        return NULL;
    }

    PyObject* retval = PyCObject_FromVoidPtr((void*)pUnk, destr_unknown);

    if (g_pUnk_type)
    {
        // new_retval = IUnknown(pointer_to_unknown)
        PyObject* new_retval = PyObject_CallFunction(g_pUnk_type, "O", retval);
        PyObject* clsid_key_lookup = NULL;
        PyObject* pIID = NULL;
        if (g_pUUID_type)
        {
            // Look up clsid in CLSID map
            // clsid_key_lookup = uuid.UUID("f4deb91a-378f-4aca-9971-12c494d94e58")
            clsid_key_lookup = PyObject_CallFunction(g_pUUID_type, "s", "f4deb91a-378f-4aca-9971-12c494d94e58");
            // If the key is there we can fetch the default interface
            // if clsid_key_lookup in _CLSID_Map:
            if (g_pCLSIDMap && 
                g_pIIDMap &&
                clsid_key_lookup &&
                (PyDict_Contains(g_pCLSIDMap, clsid_key_lookup) == 1))
            {
                // pIID = _CLSID_Map[clsid]
                pIID = PyDict_GetItem(g_pCLSIDMap, clsid_key_lookup);

                // pCall = _IID_Map[pIID]
                PyObject* pCall = NULL;
                if (PyDict_Contains(g_pIIDMap, pIID) == 1)
                    pCall = PyDict_GetItem(g_pIIDMap, pIID);

                // new_item = pCall(new_retval)
                PyObject* new_item = NULL;
                if (pCall)
                    new_item = PyObject_CallFunction(pCall, "O", new_retval);

                if (new_item)
                {
                    // Replace with new object
                    Py_DECREF(new_retval);
                    new_retval = new_item;
                }
            }
            PyErr_Clear();
        }
        Py_XDECREF(clsid_key_lookup);
        Py_XDECREF(pIID);
        Py_DECREF(retval);
        return new_retval;
    }

    return retval;
}



static PyMethodDef _esriFrameworkMethods[] = {
    {"MouseCursor", (PyCFunction)CoCreateMouseCursor, METH_NOARGS,
     "Create instance of MouseCursor\n"},
    {"ApplicationStatusEvents", (PyCFunction)CoCreateApplicationStatusEvents, METH_NOARGS,
     "Create instance of ApplicationStatusEvents\n"},
    {"AppRef", (PyCFunction)CoCreateAppRef, METH_NOARGS,
     "Create instance of AppRef\n"},
    {"AppROT", (PyCFunction)CoCreateAppROT, METH_NOARGS,
     "Create instance of AppROT\n"},
    {"Accelerator", (PyCFunction)CoCreateAccelerator, METH_NOARGS,
     "Create instance of Accelerator\n"},
    {"Templates", (PyCFunction)CoCreateTemplates, METH_NOARGS,
     "Create instance of Templates\n"},
    {"CommandBars", (PyCFunction)CoCreateCommandBars, METH_NOARGS,
     "Create instance of CommandBars\n"},
    {"CommandBar", (PyCFunction)CoCreateCommandBar, METH_NOARGS,
     "Create instance of CommandBar\n"},
    {"AcceleratorTable", (PyCFunction)CoCreateAcceleratorTable, METH_NOARGS,
     "Create instance of AcceleratorTable\n"},
    {"CommandItem", (PyCFunction)CoCreateCommandItem, METH_NOARGS,
     "Create instance of CommandItem\n"},
    {"DockableWindow", (PyCFunction)CoCreateDockableWindow, METH_NOARGS,
     "Create instance of DockableWindow\n"},
    {"DllThreadManager", (PyCFunction)CoCreateDllThreadManager, METH_NOARGS,
     "Create instance of DllThreadManager\n"},
    {"Button", (PyCFunction)CoCreateButton, METH_NOARGS,
     "Create instance of Button\n"},
    {"Tool", (PyCFunction)CoCreateTool, METH_NOARGS,
     "Create instance of Tool\n"},
    {"ToolControl", (PyCFunction)CoCreateToolControl, METH_NOARGS,
     "Create instance of ToolControl\n"},
    {"MultiItem", (PyCFunction)CoCreateMultiItem, METH_NOARGS,
     "Create instance of MultiItem\n"},
    {"StyleGalleryItem", (PyCFunction)CoCreateStyleGalleryItem, METH_NOARGS,
     "Create instance of StyleGalleryItem\n"},
    {"EnumStyleGalleryItem", (PyCFunction)CoCreateEnumStyleGalleryItem, METH_NOARGS,
     "Create instance of EnumStyleGalleryItem\n"},
    {"StyleGallery", (PyCFunction)CoCreateStyleGallery, METH_NOARGS,
     "Create instance of StyleGallery\n"},
    {"ColorSelector", (PyCFunction)CoCreateColorSelector, METH_NOARGS,
     "Create instance of ColorSelector\n"},
    {"ColorPalette", (PyCFunction)CoCreateColorPalette, METH_NOARGS,
     "Create instance of ColorPalette\n"},
    {"ColorBrowser", (PyCFunction)CoCreateColorBrowser, METH_NOARGS,
     "Create instance of ColorBrowser\n"},
    {"ColorPageSite", (PyCFunction)CoCreateColorPageSite, METH_NOARGS,
     "Create instance of ColorPageSite\n"},
    {"RgbPropertyPage", (PyCFunction)CoCreateRgbPropertyPage, METH_NOARGS,
     "Create instance of RgbPropertyPage\n"},
    {"CmykPropertyPage", (PyCFunction)CoCreateCmykPropertyPage, METH_NOARGS,
     "Create instance of CmykPropertyPage\n"},
    {"HsvPropertyPage", (PyCFunction)CoCreateHsvPropertyPage, METH_NOARGS,
     "Create instance of HsvPropertyPage\n"},
    {"GrayPropertyPage", (PyCFunction)CoCreateGrayPropertyPage, METH_NOARGS,
     "Create instance of GrayPropertyPage\n"},
    {"ColorNamePropertyPage", (PyCFunction)CoCreateColorNamePropertyPage, METH_NOARGS,
     "Create instance of ColorNamePropertyPage\n"},
    {"ModelessFrame", (PyCFunction)CoCreateModelessFrame, METH_NOARGS,
     "Create instance of ModelessFrame\n"},
    {"SymbolPickerDialog", (PyCFunction)CoCreateSymbolPickerDialog, METH_NOARGS,
     "Create instance of SymbolPickerDialog\n"},
    {"ComPropertySheet", (PyCFunction)CoCreateComPropertySheet, METH_NOARGS,
     "Create instance of ComPropertySheet\n"},
    {"ComPropertyPageSite", (PyCFunction)CoCreateComPropertyPageSite, METH_NOARGS,
     "Create instance of ComPropertyPageSite\n"},
    {"NumberDialog", (PyCFunction)CoCreateNumberDialog, METH_NOARGS,
     "Create instance of NumberDialog\n"},
    {"MessageDialog", (PyCFunction)CoCreateMessageDialog, METH_NOARGS,
     "Create instance of MessageDialog\n"},
    {"CoordinateDialog", (PyCFunction)CoCreateCoordinateDialog, METH_NOARGS,
     "Create instance of CoordinateDialog\n"},
    {"ProgressDialogFactory", (PyCFunction)CoCreateProgressDialogFactory, METH_NOARGS,
     "Create instance of ProgressDialogFactory\n"},
    {"ListDialog", (PyCFunction)CoCreateListDialog, METH_NOARGS,
     "Create instance of ListDialog\n"},
    {"NumberFormatDialog", (PyCFunction)CoCreateNumberFormatDialog, METH_NOARGS,
     "Create instance of NumberFormatDialog\n"},
    {"NumericPropertyPage", (PyCFunction)CoCreateNumericPropertyPage, METH_NOARGS,
     "Create instance of NumericPropertyPage\n"},
    {"CurrencyPropertyPage", (PyCFunction)CoCreateCurrencyPropertyPage, METH_NOARGS,
     "Create instance of CurrencyPropertyPage\n"},
    {"ScientificPropertyPage", (PyCFunction)CoCreateScientificPropertyPage, METH_NOARGS,
     "Create instance of ScientificPropertyPage\n"},
    {"AnglePropertyPage", (PyCFunction)CoCreateAnglePropertyPage, METH_NOARGS,
     "Create instance of AnglePropertyPage\n"},
    {"DirectionPropertyPage", (PyCFunction)CoCreateDirectionPropertyPage, METH_NOARGS,
     "Create instance of DirectionPropertyPage\n"},
    {"PercentagePropertyPage", (PyCFunction)CoCreatePercentagePropertyPage, METH_NOARGS,
     "Create instance of PercentagePropertyPage\n"},
    {"CustomPropertyPage", (PyCFunction)CoCreateCustomPropertyPage, METH_NOARGS,
     "Create instance of CustomPropertyPage\n"},
    {"RatePropertyPage", (PyCFunction)CoCreateRatePropertyPage, METH_NOARGS,
     "Create instance of RatePropertyPage\n"},
    {"FractionPropertyPage", (PyCFunction)CoCreateFractionPropertyPage, METH_NOARGS,
     "Create instance of FractionPropertyPage\n"},
    {"GetStringDialog", (PyCFunction)CoCreateGetStringDialog, METH_NOARGS,
     "Create instance of GetStringDialog\n"},
    {"GetUserAndPasswordDialog", (PyCFunction)CoCreateGetUserAndPasswordDialog, METH_NOARGS,
     "Create instance of GetUserAndPasswordDialog\n"},
    {NULL, NULL, 0, NULL}
};

extern "C" {

    PyMODINIT_FUNC
    init_esriFramework(void)
    {
        // Import UUID module and keep a global pointer to the UUID object
        PyObject* uuid_module = PyImport_ImportModuleNoBlock("uuid");
        if (!uuid_module)
        {
            PyErr_SetString(PyExc_ImportError, "Could not import UUID module");
            return;
        }
        if (g_pUUID_type)
            Py_DECREF(g_pUUID_type);
        g_pUUID_type = PyObject_GetAttrString(uuid_module, "UUID");

        // Initialize module, make it show up in the right place
        PyObject* module;
        module = Py_InitModule3("cartocomutils._esriFramework",
                                 _esriFrameworkMethods,
                                "Type library");
        Py_INCREF(module);

        // Add IUnknown base type to parent module so every typelib is using the same
        // Py_Type pointer when typechecking.
        PyObject* parent = PyImport_ImportModuleNoBlock("cartocomutils");
        if (parent)
        {
            if (!PyObject_HasAttrString(parent, "IUnknown"))
            {
                // Bootstrapping
                PyType_Ready(&IUnknownObject_Type);
                PyModule_AddObject(parent, "IUnknown", (PyObject*)(&IUnknownObject_Type));
                // Also probably means we need to coinitialize
                ::CoInitialize(NULL);
            }
            g_pUnk_type = PyObject_GetAttrString(parent, "IUnknown");
            if (!PyObject_HasAttrString(parent, "_IIDMap"))
                PyModule_AddObject(parent, "_IIDMap", PyDict_New());
            if (!PyObject_HasAttrString(parent, "_CLSIDMap"))
                PyModule_AddObject(parent, "_CLSIDMap", PyDict_New());
            g_pIIDMap = PyObject_GetAttrString(parent, "_IIDMap");
            Py_XINCREF(g_pIIDMap);
            // Set global unknown object
            if (g_pUnk_type && g_pIIDMap)
                PyDict_SetItem(g_pIIDMap, PyObject_CallFunction(g_pUUID_type, "s", "{00000000-0000-0000-C000-000000000046}"), g_pUnk_type);
            g_pCLSIDMap = PyObject_GetAttrString(parent, "_CLSIDMap");
            Py_XINCREF(g_pCLSIDMap);
            g_pRecordMap = PyObject_GetAttrString(parent, "_RecordMap");
            Py_XINCREF(g_pRecordMap);
            PyErr_Clear();
        }

        // Bulk add all interfaces as objects
        // IProtectNameFramework
        PyType_Ready(&PyIProtectNameFrameworkObject_Type);
        Py_INCREF((PyObject* )&PyIProtectNameFrameworkObject_Type);
        PyModule_AddObject(module, "IProtectNameFramework", 
                           (PyObject *)&PyIProtectNameFrameworkObject_Type);

        // IAccelerator
        PyType_Ready(&PyIAcceleratorObject_Type);
        Py_INCREF((PyObject* )&PyIAcceleratorObject_Type);
        PyModule_AddObject(module, "IAccelerator", 
                           (PyObject *)&PyIAcceleratorObject_Type);

        // IAcceleratorTable
        PyType_Ready(&PyIAcceleratorTableObject_Type);
        Py_INCREF((PyObject* )&PyIAcceleratorTableObject_Type);
        PyModule_AddObject(module, "IAcceleratorTable", 
                           (PyObject *)&PyIAcceleratorTableObject_Type);

        // ICustomizationFilter
        PyType_Ready(&PyICustomizationFilterObject_Type);
        Py_INCREF((PyObject* )&PyICustomizationFilterObject_Type);
        PyModule_AddObject(module, "ICustomizationFilter", 
                           (PyObject *)&PyICustomizationFilterObject_Type);

        // ITemplates
        PyType_Ready(&PyITemplatesObject_Type);
        Py_INCREF((PyObject* )&PyITemplatesObject_Type);
        PyModule_AddObject(module, "ITemplates", 
                           (PyObject *)&PyITemplatesObject_Type);

        // IAcceleratorHook
        PyType_Ready(&PyIAcceleratorHookObject_Type);
        Py_INCREF((PyObject* )&PyIAcceleratorHookObject_Type);
        PyModule_AddObject(module, "IAcceleratorHook", 
                           (PyObject *)&PyIAcceleratorHookObject_Type);

        // IPaletteEvents
        PyType_Ready(&PyIPaletteEventsObject_Type);
        Py_INCREF((PyObject* )&PyIPaletteEventsObject_Type);
        PyModule_AddObject(module, "IPaletteEvents", 
                           (PyObject *)&PyIPaletteEventsObject_Type);

        // ISelectionPalette
        PyType_Ready(&PyISelectionPaletteObject_Type);
        Py_INCREF((PyObject* )&PyISelectionPaletteObject_Type);
        PyModule_AddObject(module, "ISelectionPalette", 
                           (PyObject *)&PyISelectionPaletteObject_Type);

        // IApplicationStatus
        PyType_Ready(&PyIApplicationStatusObject_Type);
        Py_INCREF((PyObject* )&PyIApplicationStatusObject_Type);
        PyModule_AddObject(module, "IApplicationStatus", 
                           (PyObject *)&PyIApplicationStatusObject_Type);

        // IWindowPosition
        PyType_Ready(&PyIWindowPositionObject_Type);
        Py_INCREF((PyObject* )&PyIWindowPositionObject_Type);
        PyModule_AddObject(module, "IWindowPosition", 
                           (PyObject *)&PyIWindowPositionObject_Type);

        // IMouseCursor
        PyType_Ready(&PyIMouseCursorObject_Type);
        Py_INCREF((PyObject* )&PyIMouseCursorObject_Type);
        PyModule_AddObject(module, "IMouseCursor", 
                           (PyObject *)&PyIMouseCursorObject_Type);

        // IObjectFactory
        PyType_Ready(&PyIObjectFactoryObject_Type);
        Py_INCREF((PyObject* )&PyIObjectFactoryObject_Type);
        PyModule_AddObject(module, "IObjectFactory", 
                           (PyObject *)&PyIObjectFactoryObject_Type);

        // IVbaApplication
        PyType_Ready(&PyIVbaApplicationObject_Type);
        Py_INCREF((PyObject* )&PyIVbaApplicationObject_Type);
        PyModule_AddObject(module, "IVbaApplication", 
                           (PyObject *)&PyIVbaApplicationObject_Type);

        // ISmallBitmapProvider
        PyType_Ready(&PyISmallBitmapProviderObject_Type);
        Py_INCREF((PyObject* )&PyISmallBitmapProviderObject_Type);
        PyModule_AddObject(module, "ISmallBitmapProvider", 
                           (PyObject *)&PyISmallBitmapProviderObject_Type);

        // IDockableWindowHelpNotify
        PyType_Ready(&PyIDockableWindowHelpNotifyObject_Type);
        Py_INCREF((PyObject* )&PyIDockableWindowHelpNotifyObject_Type);
        PyModule_AddObject(module, "IDockableWindowHelpNotify", 
                           (PyObject *)&PyIDockableWindowHelpNotifyObject_Type);

        // IDockableWindow
        PyType_Ready(&PyIDockableWindowObject_Type);
        Py_INCREF((PyObject* )&PyIDockableWindowObject_Type);
        PyModule_AddObject(module, "IDockableWindow", 
                           (PyObject *)&PyIDockableWindowObject_Type);

        // IDockableWindowImageDef
        PyType_Ready(&PyIDockableWindowImageDefObject_Type);
        Py_INCREF((PyObject* )&PyIDockableWindowImageDefObject_Type);
        PyModule_AddObject(module, "IDockableWindowImageDef", 
                           (PyObject *)&PyIDockableWindowImageDefObject_Type);

        // IDockableWindowDef
        PyType_Ready(&PyIDockableWindowDefObject_Type);
        Py_INCREF((PyObject* )&PyIDockableWindowDefObject_Type);
        PyModule_AddObject(module, "IDockableWindowDef", 
                           (PyObject *)&PyIDockableWindowDefObject_Type);

        // IDockableWindowInitialPlacement
        PyType_Ready(&PyIDockableWindowInitialPlacementObject_Type);
        Py_INCREF((PyObject* )&PyIDockableWindowInitialPlacementObject_Type);
        PyModule_AddObject(module, "IDockableWindowInitialPlacement", 
                           (PyObject *)&PyIDockableWindowInitialPlacementObject_Type);

        // IDockableWindowInitialPlacementNeighbors
        PyType_Ready(&PyIDockableWindowInitialPlacementNeighborsObject_Type);
        Py_INCREF((PyObject* )&PyIDockableWindowInitialPlacementNeighborsObject_Type);
        PyModule_AddObject(module, "IDockableWindowInitialPlacementNeighbors", 
                           (PyObject *)&PyIDockableWindowInitialPlacementNeighborsObject_Type);

        // IDockableWindowManager
        PyType_Ready(&PyIDockableWindowManagerObject_Type);
        Py_INCREF((PyObject* )&PyIDockableWindowManagerObject_Type);
        PyModule_AddObject(module, "IDockableWindowManager", 
                           (PyObject *)&PyIDockableWindowManagerObject_Type);

        // IDllThreadManager
        PyType_Ready(&PyIDllThreadManagerObject_Type);
        Py_INCREF((PyObject* )&PyIDllThreadManagerObject_Type);
        PyModule_AddObject(module, "IDllThreadManager", 
                           (PyObject *)&PyIDllThreadManagerObject_Type);

        // IMultiThreadedApplication
        PyType_Ready(&PyIMultiThreadedApplicationObject_Type);
        Py_INCREF((PyObject* )&PyIMultiThreadedApplicationObject_Type);
        PyModule_AddObject(module, "IMultiThreadedApplication", 
                           (PyObject *)&PyIMultiThreadedApplicationObject_Type);

        // IDocumentDirty
        PyType_Ready(&PyIDocumentDirtyObject_Type);
        Py_INCREF((PyObject* )&PyIDocumentDirtyObject_Type);
        PyModule_AddObject(module, "IDocumentDirty", 
                           (PyObject *)&PyIDocumentDirtyObject_Type);

        // IDocumentDirty2
        PyType_Ready(&PyIDocumentDirty2Object_Type);
        Py_INCREF((PyObject* )&PyIDocumentDirty2Object_Type);
        PyModule_AddObject(module, "IDocumentDirty2", 
                           (PyObject *)&PyIDocumentDirty2Object_Type);

        // IDDECommandHandler
        PyType_Ready(&PyIDDECommandHandlerObject_Type);
        Py_INCREF((PyObject* )&PyIDDECommandHandlerObject_Type);
        PyModule_AddObject(module, "IDDECommandHandler", 
                           (PyObject *)&PyIDDECommandHandlerObject_Type);

        // IPropertyPageContext
        PyType_Ready(&PyIPropertyPageContextObject_Type);
        Py_INCREF((PyObject* )&PyIPropertyPageContextObject_Type);
        PyModule_AddObject(module, "IPropertyPageContext", 
                           (PyObject *)&PyIPropertyPageContextObject_Type);

        // IColorPalette
        PyType_Ready(&PyIColorPaletteObject_Type);
        Py_INCREF((PyObject* )&PyIColorPaletteObject_Type);
        PyModule_AddObject(module, "IColorPalette", 
                           (PyObject *)&PyIColorPaletteObject_Type);

        // IArcToolboxTool
        PyType_Ready(&PyIArcToolboxToolObject_Type);
        Py_INCREF((PyObject* )&PyIArcToolboxToolObject_Type);
        PyModule_AddObject(module, "IArcToolboxTool", 
                           (PyObject *)&PyIArcToolboxToolObject_Type);

        // IFileOpenHandler
        PyType_Ready(&PyIFileOpenHandlerObject_Type);
        Py_INCREF((PyObject* )&PyIFileOpenHandlerObject_Type);
        PyModule_AddObject(module, "IFileOpenHandler", 
                           (PyObject *)&PyIFileOpenHandlerObject_Type);

        // IAtbApplication
        PyType_Ready(&PyIAtbApplicationObject_Type);
        Py_INCREF((PyObject* )&PyIAtbApplicationObject_Type);
        PyModule_AddObject(module, "IAtbApplication", 
                           (PyObject *)&PyIAtbApplicationObject_Type);

        // IArcToolboxFind
        PyType_Ready(&PyIArcToolboxFindObject_Type);
        Py_INCREF((PyObject* )&PyIArcToolboxFindObject_Type);
        PyModule_AddObject(module, "IArcToolboxFind", 
                           (PyObject *)&PyIArcToolboxFindObject_Type);

        // IApplicationStatusEvents
        PyType_Ready(&PyIApplicationStatusEventsObject_Type);
        Py_INCREF((PyObject* )&PyIApplicationStatusEventsObject_Type);
        PyModule_AddObject(module, "IApplicationStatusEvents", 
                           (PyObject *)&PyIApplicationStatusEventsObject_Type);

        // IApplicationRefreshBitmap
        PyType_Ready(&PyIApplicationRefreshBitmapObject_Type);
        Py_INCREF((PyObject* )&PyIApplicationRefreshBitmapObject_Type);
        PyModule_AddObject(module, "IApplicationRefreshBitmap", 
                           (PyObject *)&PyIApplicationRefreshBitmapObject_Type);

        // IComPropertySheet2
        PyType_Ready(&PyIComPropertySheet2Object_Type);
        Py_INCREF((PyObject* )&PyIComPropertySheet2Object_Type);
        PyModule_AddObject(module, "IComPropertySheet2", 
                           (PyObject *)&PyIComPropertySheet2Object_Type);

        // IApplicationIdentifyDialog
        PyType_Ready(&PyIApplicationIdentifyDialogObject_Type);
        Py_INCREF((PyObject* )&PyIApplicationIdentifyDialogObject_Type);
        PyModule_AddObject(module, "IApplicationIdentifyDialog", 
                           (PyObject *)&PyIApplicationIdentifyDialogObject_Type);

        // IColorBrowser
        PyType_Ready(&PyIColorBrowserObject_Type);
        Py_INCREF((PyObject* )&PyIColorBrowserObject_Type);
        PyModule_AddObject(module, "IColorBrowser", 
                           (PyObject *)&PyIColorBrowserObject_Type);

        // IColorSelector
        PyType_Ready(&PyIColorSelectorObject_Type);
        Py_INCREF((PyObject* )&PyIColorSelectorObject_Type);
        PyModule_AddObject(module, "IColorSelector", 
                           (PyObject *)&PyIColorSelectorObject_Type);

        // ICustomColorPalette
        PyType_Ready(&PyICustomColorPaletteObject_Type);
        Py_INCREF((PyObject* )&PyICustomColorPaletteObject_Type);
        PyModule_AddObject(module, "ICustomColorPalette", 
                           (PyObject *)&PyICustomColorPaletteObject_Type);

        // IComPropertyPageSite
        PyType_Ready(&PyIComPropertyPageSiteObject_Type);
        Py_INCREF((PyObject* )&PyIComPropertyPageSiteObject_Type);
        PyModule_AddObject(module, "IComPropertyPageSite", 
                           (PyObject *)&PyIComPropertyPageSiteObject_Type);

        // IComPropertyPage
        PyType_Ready(&PyIComPropertyPageObject_Type);
        Py_INCREF((PyObject* )&PyIComPropertyPageObject_Type);
        PyModule_AddObject(module, "IComPropertyPage", 
                           (PyObject *)&PyIComPropertyPageObject_Type);

        // IComPropertyPage2
        PyType_Ready(&PyIComPropertyPage2Object_Type);
        Py_INCREF((PyObject* )&PyIComPropertyPage2Object_Type);
        PyModule_AddObject(module, "IComPropertyPage2", 
                           (PyObject *)&PyIComPropertyPage2Object_Type);

        // IModelessFrame
        PyType_Ready(&PyIModelessFrameObject_Type);
        Py_INCREF((PyObject* )&PyIModelessFrameObject_Type);
        PyModule_AddObject(module, "IModelessFrame", 
                           (PyObject *)&PyIModelessFrameObject_Type);

        // IGetStringDialog
        PyType_Ready(&PyIGetStringDialogObject_Type);
        Py_INCREF((PyObject* )&PyIGetStringDialogObject_Type);
        PyModule_AddObject(module, "IGetStringDialog", 
                           (PyObject *)&PyIGetStringDialogObject_Type);

        // IGetUserAndPasswordDialog
        PyType_Ready(&PyIGetUserAndPasswordDialogObject_Type);
        Py_INCREF((PyObject* )&PyIGetUserAndPasswordDialogObject_Type);
        PyModule_AddObject(module, "IGetUserAndPasswordDialog", 
                           (PyObject *)&PyIGetUserAndPasswordDialogObject_Type);

        // INumberDialog
        PyType_Ready(&PyINumberDialogObject_Type);
        Py_INCREF((PyObject* )&PyINumberDialogObject_Type);
        PyModule_AddObject(module, "INumberDialog", 
                           (PyObject *)&PyINumberDialogObject_Type);

        // IMessageDialog
        PyType_Ready(&PyIMessageDialogObject_Type);
        Py_INCREF((PyObject* )&PyIMessageDialogObject_Type);
        PyModule_AddObject(module, "IMessageDialog", 
                           (PyObject *)&PyIMessageDialogObject_Type);

        // ICoordinateDialog
        PyType_Ready(&PyICoordinateDialogObject_Type);
        Py_INCREF((PyObject* )&PyICoordinateDialogObject_Type);
        PyModule_AddObject(module, "ICoordinateDialog", 
                           (PyObject *)&PyICoordinateDialogObject_Type);

        // IProgressDialog2
        PyType_Ready(&PyIProgressDialog2Object_Type);
        Py_INCREF((PyObject* )&PyIProgressDialog2Object_Type);
        PyModule_AddObject(module, "IProgressDialog2", 
                           (PyObject *)&PyIProgressDialog2Object_Type);

        // IProgressDialogFactory
        PyType_Ready(&PyIProgressDialogFactoryObject_Type);
        Py_INCREF((PyObject* )&PyIProgressDialogFactoryObject_Type);
        PyModule_AddObject(module, "IProgressDialogFactory", 
                           (PyObject *)&PyIProgressDialogFactoryObject_Type);

        // IListDialog
        PyType_Ready(&PyIListDialogObject_Type);
        Py_INCREF((PyObject* )&PyIListDialogObject_Type);
        PyModule_AddObject(module, "IListDialog", 
                           (PyObject *)&PyIListDialogObject_Type);

        // IStyleSelector
        PyType_Ready(&PyIStyleSelectorObject_Type);
        Py_INCREF((PyObject* )&PyIStyleSelectorObject_Type);
        PyModule_AddObject(module, "IStyleSelector", 
                           (PyObject *)&PyIStyleSelectorObject_Type);

        // IComEmbeddedPropertyPage
        PyType_Ready(&PyIComEmbeddedPropertyPageObject_Type);
        Py_INCREF((PyObject* )&PyIComEmbeddedPropertyPageObject_Type);
        PyModule_AddObject(module, "IComEmbeddedPropertyPage", 
                           (PyObject *)&PyIComEmbeddedPropertyPageObject_Type);

        // IComPropertyPageObjectFactory
        PyType_Ready(&PyIComPropertyPageObjectFactoryObject_Type);
        Py_INCREF((PyObject* )&PyIComPropertyPageObjectFactoryObject_Type);
        PyModule_AddObject(module, "IComPropertyPageObjectFactory", 
                           (PyObject *)&PyIComPropertyPageObjectFactoryObject_Type);

        // IComPropertySheet
        PyType_Ready(&PyIComPropertySheetObject_Type);
        Py_INCREF((PyObject* )&PyIComPropertySheetObject_Type);
        PyModule_AddObject(module, "IComPropertySheet", 
                           (PyObject *)&PyIComPropertySheetObject_Type);

        // IComPropertySheetID
        PyType_Ready(&PyIComPropertySheetIDObject_Type);
        Py_INCREF((PyObject* )&PyIComPropertySheetIDObject_Type);
        PyModule_AddObject(module, "IComPropertySheetID", 
                           (PyObject *)&PyIComPropertySheetIDObject_Type);

        // IPropertyPageSiteConfig
        PyType_Ready(&PyIPropertyPageSiteConfigObject_Type);
        Py_INCREF((PyObject* )&PyIPropertyPageSiteConfigObject_Type);
        PyModule_AddObject(module, "IPropertyPageSiteConfig", 
                           (PyObject *)&PyIPropertyPageSiteConfigObject_Type);

        // INumberFormatDialog
        PyType_Ready(&PyINumberFormatDialogObject_Type);
        Py_INCREF((PyObject* )&PyINumberFormatDialogObject_Type);
        PyModule_AddObject(module, "INumberFormatDialog", 
                           (PyObject *)&PyINumberFormatDialogObject_Type);

        // ISymbolPickerDialog
        PyType_Ready(&PyISymbolPickerDialogObject_Type);
        Py_INCREF((PyObject* )&PyISymbolPickerDialogObject_Type);
        PyModule_AddObject(module, "ISymbolPickerDialog", 
                           (PyObject *)&PyISymbolPickerDialogObject_Type);

        // IApplication
        PyType_Ready(&PyIApplicationObject_Type);
        Py_INCREF((PyObject* )&PyIApplicationObject_Type);
        PyModule_AddObject(module, "IApplication", 
                           (PyObject *)&PyIApplicationObject_Type);

        // IAppROT
        PyType_Ready(&PyIAppROTObject_Type);
        Py_INCREF((PyObject* )&PyIAppROTObject_Type);
        PyModule_AddObject(module, "IAppROT", 
                           (PyObject *)&PyIAppROTObject_Type);

        // IAppROTEvents
        PyType_Ready(&PyIAppROTEventsObject_Type);
        Py_INCREF((PyObject* )&PyIAppROTEventsObject_Type);
        PyModule_AddObject(module, "IAppROTEvents", 
                           (PyObject *)&PyIAppROTEventsObject_Type);

        // IDocument
        PyType_Ready(&PyIDocumentObject_Type);
        Py_INCREF((PyObject* )&PyIDocumentObject_Type);
        PyModule_AddObject(module, "IDocument", 
                           (PyObject *)&PyIDocumentObject_Type);

        // ICommandBars
        PyType_Ready(&PyICommandBarsObject_Type);
        Py_INCREF((PyObject* )&PyICommandBarsObject_Type);
        PyModule_AddObject(module, "ICommandBars", 
                           (PyObject *)&PyICommandBarsObject_Type);

        // ICommandBar
        PyType_Ready(&PyICommandBarObject_Type);
        Py_INCREF((PyObject* )&PyICommandBarObject_Type);
        PyModule_AddObject(module, "ICommandBar", 
                           (PyObject *)&PyICommandBarObject_Type);

        // ICommandItem
        PyType_Ready(&PyICommandItemObject_Type);
        Py_INCREF((PyObject* )&PyICommandItemObject_Type);
        PyModule_AddObject(module, "ICommandItem", 
                           (PyObject *)&PyICommandItemObject_Type);

        // IMenuItem
        PyType_Ready(&PyIMenuItemObject_Type);
        Py_INCREF((PyObject* )&PyIMenuItemObject_Type);
        PyModule_AddObject(module, "IMenuItem", 
                           (PyObject *)&PyIMenuItemObject_Type);


        // Bulk add all the IID_* CLSID_* from this type lib
        if (g_pUUID_type)
        {
            // guids registration for interfaces
            if (g_pIIDMap)
            {
// Disabled for now, done in the .py file
            }

            // clsids registration for known coclasses
            if (g_pCLSIDMap)
            {
// Disabled for now, done in the .py file
            }
        }
        Py_XDECREF(g_pIIDMap);
        Py_XDECREF(g_pCLSIDMap);
    }

}
